Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The method has 511 lines of code.
Complex Method,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,ParseProfilerOptions,Cyclomatic complexity of the method is 14
Complex Method,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,Cyclomatic complexity of the method is 80
Long Parameter List,UserInterfaceTests,TestService,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\TestService.cs,StartSession,The method has 5 parameters. Parameters: file' profilePath' logFile' args' useNewEditor
Long Parameter List,Mono.Profiler.Log,LogEvent,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogEvent.cs,ToString,The method has 5 parameters. Parameters: source' result' indent' header' level
Long Identifier,MonoDevelop.StressTest,GraphExtensions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Profiler\GraphExtensions.cs,GetPredecessors,The length of the parameter vertexPredecessorRecorderObserver is 33.
Long Statement,MonoDevelop.StressTest,StressTestApp,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestApp.cs,StartWithProfiler,The length of the statement  "			TestService.StartSession (monoPath' profilePath' logFile' $"{profilerProcessor.GetMonoArguments ()} \"{MonoDevelopBinPath}\""' useNewEditor: Properties.UseNewEditor);" is 166.
Long Statement,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The length of the statement  "			Console.WriteLine ("                            'heaponly' is default value' and logs minimal needed to get number of objects after each iteration");" is 149.
Long Statement,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The length of the statement  "			Console.WriteLine ("                            'all' tracks also allocations which can later be used in UI profiler to further analyse leak reasons");" is 151.
Long Statement,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The length of the statement  "			Console.WriteLine ("                            'custom' is for advanced usages where user supplies mono profiler parameters to fine tune logging");" is 148.
Long Statement,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The length of the statement  "			Console.WriteLine ("  printreport=<name>      Defines what to print between interations. Can be used multiple times. Possible options:");" is 137.
Long Statement,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The length of the statement  "			Console.WriteLine ("                            'objectsdiff' prints object count difference between iterations for each class");" is 129.
Long Statement,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The length of the statement  "			Console.WriteLine ("                            'objectstotal' prints object count difference between iterations for each class");" is 130.
Long Statement,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The length of the statement  "			Console.WriteLine ("  maxframes=<maxframes>   How many stackframes should be logged on each allocation' used only with 'all'");" is 127.
Long Statement,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The length of the statement  "			Console.WriteLine ("  custom=<custom>         This value will be passed directly to mono --profiler=<custom>' used only with 'custom'");" is 136.
Long Statement,MonoDevelop.StressTest,DefaultScenarioProvider,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Scenarios\DefaultScenarioProvider.cs,GetTestScenario,The length of the statement  "            string testProjectPath = Path.Combine(Path.GetDirectoryName(typeof(DefaultScenarioProvider).Assembly.Location)' "TestProject");" is 127.
Long Statement,MonoDevelop.StressTest,ProfilerProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Profiler\ProfilerProcessor.cs,GetMonoArguments,The length of the statement  "					return $"--profile=log:nodefaults'heapshot-on-shutdown'heapshot=ondemand'gcalloc'gcmove'gcroot'counter'maxframes={Options.MaxFrames}'output=\"{Options.MlpdOutputPath}\"";" is 170.
Long Statement,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,OpenFile,The length of the statement  "			Session.RunAndWaitForTimer (() => Session.GlobalInvoke ("MonoDevelop.Ide.IdeApp.Workbench.OpenDocument"' (string)file' true)' "Ide.Shell.DocumentOpened");" is 154.
Long Statement,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,BuildSolution,The length of the statement  "			Session.RunAndWaitForTimer (() => Session.ExecuteCommand (ProjectCommands.BuildSolution)' "Ide.Shell.ProjectBuilt"' timeoutInSecs * 1000);" is 138.
Long Statement,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,ClickButtonAlertDialog,The length of the statement  "				return Session.ClickElement (c => c.Window ().Marked ("MonoDevelop.Ide.Gui.Dialogs.GtkAlertDialog").Children ().Button ().Text (buttonText));" is 141.
Long Statement,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,WaitForIdeIdle,The length of the statement  "				var isIdle = string.Equals (initialStatusMessage' finalStatusMessage) && !ignoreStatusMessages.Contains (finalStatusMessage);" is 125.
Long Statement,UserInterfaceTests,Workbench,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Workbench.cs,GetStatusMessage,The length of the statement  "					() => (text = Session.GetGlobalValue<string> ("MonoDevelop.Ide.IdeApp.Workbench.statusBar.CurrentText")) != string.Empty'" is 121.
Long Statement,UserInterfaceTests,ProjectDetails,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\TemplateTestOptions.cs,ToString,The length of the statement  "			return string.Format ("ProjectName={0}' SolutionName={1}' SolutionLocation={2}' ProjectInSolution={3}' AddProjectToExistingSolution={4}"'" is 137.
Long Statement,UserInterfaceTests,NewFileOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\TemplateTestOptions.cs,ToString,The length of the statement  "			return string.Format ("FileName={0}' FileType={1}' FileTypeCategory={2}' FileTypeCategoryRoot={3}' AddToProjectName={4}"'" is 121.
Long Statement,UserInterfaceTests,WorkbenchExtensions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\UserInterfaceTests\WorkbenchExtensions.cs,RebuildSolution,The length of the statement  "			Session.RunAndWaitForTimer (() => Session.ExecuteCommand (ProjectCommands.RebuildSolution)' "Ide.Shell.ProjectBuilt"' timeoutInSecs * 1000);" is 140.
Long Statement,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The length of the statement  "							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()'" is 120.
Long Statement,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The length of the statement  "							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()'" is 120.
Long Statement,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The length of the statement  "							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()'" is 132.
Long Statement,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The length of the statement  "						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();" is 131.
Empty Catch Block,MonoDevelop.StressTest,ProfilerProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Profiler\ProfilerProcessor.cs,ProcessFile,The method has an empty catch block.
Magic Number,MonoDevelop.StressTest,StressTestApp,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestApp.cs,Start,The following statement contains a magic number: TestService.Session.WaitForElement (IdeQuery.DefaultWorkbench' 10000);
Magic Number,MonoDevelop.StressTest,StressTestOptions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestOptions.cs,PrintProfilerHelpAndExit,The following statement contains a magic number: System.Environment.Exit (33);
Magic Number,MonoDevelop.StressTest,DefaultScenario,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Scenarios\DefaultScenario.cs,RunTypingTest,The following statement contains a magic number: var area = TestService.Session.WaitForElement (IdeQuery.TextAreaForFile (openFile)' 30000);
Magic Number,MonoDevelop.StressTest,ProfilerProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Profiler\ProfilerProcessor.cs,ProcessFile,The following statement contains a magic number: Thread.Sleep (100);
Magic Number,MonoDevelop.StressTest,ProfilerProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Profiler\ProfilerProcessor.cs,ProcessFile,The following statement contains a magic number: i < 100
Magic Number,MonoDevelop.StressTest,NeverEndingLogStream,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Profiler\ProfilerProcessor.cs,ReadByte,The following statement contains a magic number: Thread.Sleep (100);
Magic Number,MonoDevelop.StressTest,NeverEndingLogStream,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\Profiler\ProfilerProcessor.cs,Read,The following statement contains a magic number: Thread.Sleep (100);
Magic Number,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,BuildSolution,The following statement contains a magic number: Session.RunAndWaitForTimer (() => Session.ExecuteCommand (ProjectCommands.BuildSolution)' "Ide.Shell.ProjectBuilt"' timeoutInSecs * 1000);
Magic Number,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,WaitForPackageUpdateExtra,The following statement contains a magic number: WaitForStatusMessage (otherMessages.ToArray ()' timeoutInSecs: 180' pollStepInSecs: 1);
Magic Number,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,PollStatusMessage,The following statement contains a magic number: Ide.WaitUntil (() => { 				string actualStatusMessage = string.Empty; 				try { 					actualStatusMessage = Workbench.GetStatusMessage (); 					return waitForMessage == (statusMessage.Contains (actualStatusMessage' StringComparer.OrdinalIgnoreCase)); 				} catch (TimeoutException e) { 					throw new TimeoutException ( 						string.Format ("Timed out. Found status message '{0}'\nand expected one of these:\n\t {1}"' 							actualStatusMessage' string.Join ("\n\t"' statusMessage))' e); 				} 			}' 			pollStep: pollStepInSecs * 1000' 			timeout: timeoutInSecs * 1000' 			timeoutMessage: () => "GetStatusMessage=" + Workbench.GetStatusMessage ());
Magic Number,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,PollStatusMessage,The following statement contains a magic number: Ide.WaitUntil (() => { 				string actualStatusMessage = string.Empty; 				try { 					actualStatusMessage = Workbench.GetStatusMessage (); 					return waitForMessage == (statusMessage.Contains (actualStatusMessage' StringComparer.OrdinalIgnoreCase)); 				} catch (TimeoutException e) { 					throw new TimeoutException ( 						string.Format ("Timed out. Found status message '{0}'\nand expected one of these:\n\t {1}"' 							actualStatusMessage' string.Join ("\n\t"' statusMessage))' e); 				} 			}' 			pollStep: pollStepInSecs * 1000' 			timeout: timeoutInSecs * 1000' 			timeoutMessage: () => "GetStatusMessage=" + Workbench.GetStatusMessage ());
Magic Number,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,WaitForIdeIdle,The following statement contains a magic number: PollTimer ((int)totalTimeoutInSecs * 1000' (int)idlePeriodInSecs * 1000' () => { 				var finalStatusMessage = Workbench.GetStatusMessage (waitForNonEmpty: false); 				var isIdle = string.Equals (initialStatusMessage' finalStatusMessage) && !ignoreStatusMessages.Contains (finalStatusMessage);  				if (!isIdle) 					initialStatusMessage = finalStatusMessage; 				return isIdle; 			});
Magic Number,UserInterfaceTests,Ide,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Ide.cs,WaitForIdeIdle,The following statement contains a magic number: PollTimer ((int)totalTimeoutInSecs * 1000' (int)idlePeriodInSecs * 1000' () => { 				var finalStatusMessage = Workbench.GetStatusMessage (waitForNonEmpty: false); 				var isIdle = string.Equals (initialStatusMessage' finalStatusMessage) && !ignoreStatusMessages.Contains (finalStatusMessage);  				if (!isIdle) 					initialStatusMessage = finalStatusMessage; 				return isIdle; 			});
Magic Number,UserInterfaceTests,Workbench,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Workbench.cs,IsBuildSuccessful,The following statement contains a magic number: Ide.WaitUntil (() => { 				var actualStatusMessage = Workbench.GetStatusMessage (); 				if (actualStatusMessage == "Build successful.") { 					isBuildSuccessful = true; 					return true; 				} 				if (actualStatusMessage == "Build failed.") { 					isBuildSuccessful = false; 					return true; 				} 				var match = buildRegex.Match (actualStatusMessage); 				if (match != null && match.Success) { 					isBuildSuccessful = string.Equals (match.Groups ["errors"].ToString ()' "0"); 					return true; 				} 				return false; 			}' 			pollStep: 5 * 1000' 			timeout: timeoutInSecs * 1000' 			timeoutMessage: () => "GetStatusMessage=" + Workbench.GetStatusMessage ());
Magic Number,UserInterfaceTests,Workbench,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Workbench.cs,IsBuildSuccessful,The following statement contains a magic number: Ide.WaitUntil (() => { 				var actualStatusMessage = Workbench.GetStatusMessage (); 				if (actualStatusMessage == "Build successful.") { 					isBuildSuccessful = true; 					return true; 				} 				if (actualStatusMessage == "Build failed.") { 					isBuildSuccessful = false; 					return true; 				} 				var match = buildRegex.Match (actualStatusMessage); 				if (match != null && match.Success) { 					isBuildSuccessful = string.Equals (match.Groups ["errors"].ToString ()' "0"); 					return true; 				} 				return false; 			}' 			pollStep: 5 * 1000' 			timeout: timeoutInSecs * 1000' 			timeoutMessage: () => "GetStatusMessage=" + Workbench.GetStatusMessage ());
Magic Number,UserInterfaceTests,Workbench,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Workbench.cs,IsBuildSuccessful,The following statement contains a magic number: Ide.WaitUntil (() => { 				var actualStatusMessage = Workbench.GetStatusMessage (); 				if (actualStatusMessage == "Build successful.") { 					isBuildSuccessful = true; 					return true; 				} 				if (actualStatusMessage == "Build failed.") { 					isBuildSuccessful = false; 					return true; 				} 				var match = buildRegex.Match (actualStatusMessage); 				if (match != null && match.Success) { 					isBuildSuccessful = string.Equals (match.Groups ["errors"].ToString ()' "0"); 					return true; 				} 				return false; 			}' 			pollStep: 5 * 1000' 			timeout: timeoutInSecs * 1000' 			timeoutMessage: () => "GetStatusMessage=" + Workbench.GetStatusMessage ());
Magic Number,UserInterfaceTests,Workbench,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Workbench.cs,Run,The following statement contains a magic number: Ide.WaitUntil ( 					() => !Session.Query (c => IdeQuery.RunButton (c).Property ("Icon"' "Stop")).Any ()' 					timeout: timeoutSeconds * 1000' pollStep: pollStepSecs * 1000);
Magic Number,UserInterfaceTests,Workbench,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\Workbench.cs,Run,The following statement contains a magic number: Ide.WaitUntil ( 					() => !Session.Query (c => IdeQuery.RunButton (c).Property ("Icon"' "Stop")).Any ()' 					timeout: timeoutSeconds * 1000' pollStep: pollStepSecs * 1000);
Magic Number,UserInterfaceTests,ProjectDetails,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\UserInterfaceTests\TemplateTestOptions.cs,ProjectDetails,The following statement contains a magic number: BuildTimeout = TimeSpan.FromSeconds (180);
Magic Number,UserInterfaceTests,WorkbenchExtensions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\UserInterfaceTests\WorkbenchExtensions.cs,RebuildSolution,The following statement contains a magic number: Session.RunAndWaitForTimer (() => Session.ExecuteCommand (ProjectCommands.RebuildSolution)' "Ide.Shell.ProjectBuilt"' timeoutInSecs * 1000);
Magic Number,UserInterfaceTests,WorkbenchExtensions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\UserInterfaceTests\WorkbenchExtensions.cs,Debug,The following statement contains a magic number: Ide.WaitUntil ( 					() => !Session.Query (c => IdeQuery.RunButton (c).Property ("Icon"' "Stop")).Any ()' 					timeout: timeoutSeconds * 1000' pollStep: pollStepSecs * 1000);
Magic Number,UserInterfaceTests,WorkbenchExtensions,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\UserInterfaceTests\WorkbenchExtensions.cs,Debug,The following statement contains a magic number: Ide.WaitUntil ( 					() => !Session.Query (c => IdeQuery.RunButton (c).Property ("Icon"' "Stop")).Any ()' 					timeout: timeoutSeconds * 1000' pollStep: pollStepSecs * 1000);
Magic Number,Mono.Profiler.Log,LogStreamHeader,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogStreamHeader.cs,LogStreamHeader,The following statement contains a magic number: Version.Major >= 3
Magic Number,Mono.Profiler.Log,LogReader,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogReader.cs,ReadCString,The following statement contains a magic number: Array.Resize (ref _stringBuffer' System.Math.Max (_stringBuffer.Length * 2' pos + 1));
Magic Number,Mono.Profiler.Log,LogReader,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogReader.cs,ReadSLeb128,The following statement contains a magic number: shift += 7;
Magic Number,Mono.Profiler.Log,LogReader,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogReader.cs,ReadSLeb128,The following statement contains a magic number: shift < sizeof (long) * 8 && (b & 0x40) == 0x40
Magic Number,Mono.Profiler.Log,LogReader,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogReader.cs,ReadULeb128,The following statement contains a magic number: shift += 7;
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,Process,The following statement contains a magic number: var events = new List<LogEvent> (Environment.ProcessorCount * 1000);
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadEvent,The following statement contains a magic number: switch (basicType) { 			case LogEventType.Allocation: 				switch (extType) { 				case LogEventType.AllocationBacktrace: 				case LogEventType.AllocationNoBacktrace: 					ev = new AllocationEvent { 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectPointer = ReadObject ()' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.AllocationBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.GC: 				switch (extType) { 				case LogEventType.GCEvent: 					ev = new GCEvent { 						Type = (LogGCEvent) _reader.ReadByte ()' 						Generation = _reader.ReadByte ()' 					}; 					break; 				case LogEventType.GCResize: 					ev = new GCResizeEvent { 						NewSize = (long) _reader.ReadULeb128 ()' 					}; 					break; 				case LogEventType.GCMove: { 					var list = new long [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) 						list [i] = ReadObject ();  					ev = new GCMoveEvent { 						OldObjectPointers = list.Where ((_' i) => i % 2 == 0).ToArray ()' 						NewObjectPointers = list.Where ((_' i) => i % 2 != 0).ToArray ()' 					}; 					break; 				} 				case LogEventType.GCHandleCreationNoBacktrace: 				case LogEventType.GCHandleCreationBacktrace: 					ev = new GCHandleCreationEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleCreationBacktrace)' 					}; 					break; 				case LogEventType.GCHandleDeletionNoBacktrace: 				case LogEventType.GCHandleDeletionBacktrace: 					ev = new GCHandleDeletionEvent { 						Type = (LogGCHandleType) _reader.ReadULeb128 ()' 						Handle = (long) _reader.ReadULeb128 ()' 						Backtrace = ReadBacktrace (extType == LogEventType.GCHandleDeletionBacktrace)' 					}; 					break; 				case LogEventType.GCFinalizeBegin: 					ev = new GCFinalizeBeginEvent (); 					break; 				case LogEventType.GCFinalizeEnd: 					ev = new GCFinalizeEndEvent (); 					break; 				case LogEventType.GCFinalizeObjectBegin: 					ev = new GCFinalizeObjectBeginEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				case LogEventType.GCFinalizeObjectEnd: 					ev = new GCFinalizeObjectEndEvent { 						ObjectPointer = ReadObject ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Metadata: { 				var load = false; 				var unload = false;  				switch (extType) { 				case LogEventType.MetadataExtra: 					break; 				case LogEventType.MetadataEndLoad: 					load = true; 					break; 				case LogEventType.MetadataEndUnload: 					unload = true; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				}  				var metadataType = (LogMetadataType) _reader.ReadByte ();  				switch (metadataType) { 				case LogMetadataType.Class: 					if (load) { 						ev = new ClassLoadEvent { 							ClassPointer = ReadPointer ()' 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid class metadata event."); 					break; 				case LogMetadataType.Image: 					if (load) { 						var ile = new ImageLoadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						};  						if (StreamHeader.FormatVersion >= 16) { 							var guid = _reader.ReadCString ();  							ile.ModuleVersionId = guid == string.Empty ? Guid.Empty : Guid.Parse (guid); 						}  						ev = ile; 					} else if (unload) { 						ev = new ImageUnloadEvent { 							ImagePointer = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid image metadata event."); 					break; 				case LogMetadataType.Assembly: 					if (load) { 						ev = new AssemblyLoadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else if (unload) { 						ev = new AssemblyUnloadEvent { 							AssemblyPointer = ReadPointer ()' 							ImagePointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : 0' 							Name = _reader.ReadCString ()' 						}; 					} else 						throw new LogException ("Invalid assembly metadata event."); 					break; 				case LogMetadataType.AppDomain: 					if (load) { 						ev = new AppDomainLoadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new AppDomainUnloadEvent { 							AppDomainId = ReadPointer ()' 						}; 					} else { 						ev = new AppDomainNameEvent { 							AppDomainId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Thread: 					if (load) { 						ev = new ThreadStartEvent { 							ThreadId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ThreadEndEvent { 							ThreadId = ReadPointer ()' 						}; 					} else { 						ev = new ThreadNameEvent { 							ThreadId = ReadPointer ()' 							Name = _reader.ReadCString ()' 						}; 					} 					break; 				case LogMetadataType.Context: 					if (load) { 						ev = new ContextLoadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else if (unload) { 						ev = new ContextUnloadEvent { 							ContextId = ReadPointer ()' 							AppDomainId = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid context metadata event."); 					break; 				case LogMetadataType.VTable: 					if (load) { 						ev = new VTableLoadEvent { 							VTablePointer = ReadPointer ()' 							AppDomainId = ReadPointer ()' 							ClassPointer = ReadPointer ()' 						}; 					} else 						throw new LogException ("Invalid VTable metadata event."); 					break; 				default: 					throw new LogException ($"Invalid metadata type ({metadataType})."); 				} 				break; 			} 			case LogEventType.Method: 				switch (extType) { 				case LogEventType.MethodLeave: 					ev = new LeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodEnter: 					ev = new EnterEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodLeaveExceptional: 					ev = new ExceptionalLeaveEvent { 						MethodPointer = ReadMethod ()' 					}; 					break; 				case LogEventType.MethodJit: 					ev = new JitEvent { 						MethodPointer = ReadMethod ()' 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Exception: 				switch (extType) { 				case LogEventType.ExceptionThrowNoBacktrace: 				case LogEventType.ExceptionThrowBacktrace: 					ev = new ThrowEvent { 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.ExceptionThrowBacktrace)' 					}; 					break; 				case LogEventType.ExceptionClause: 					ev = new ExceptionClauseEvent { 						Type = (LogExceptionClause) _reader.ReadByte ()' 						Index = (long) _reader.ReadULeb128 ()' 						MethodPointer = ReadMethod ()' 						ObjectPointer = StreamHeader.FormatVersion >= 14 ? ReadObject () : 0' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Monitor: 				if (StreamHeader.FormatVersion < 14) { 					if (extType.HasFlag (LogEventType.MonitorBacktrace)) { 						extType = LogEventType.MonitorBacktrace; 					} else { 						extType = LogEventType.MonitorNoBacktrace; 					} 				} 				switch (extType) { 				case LogEventType.MonitorNoBacktrace: 				case LogEventType.MonitorBacktrace: 					ev = new MonitorEvent { 						Event = StreamHeader.FormatVersion >= 14 ? 						        (LogMonitorEvent) _reader.ReadByte () : 						        (LogMonitorEvent) ((((byte) type & 0xf0) >> 4) & 0x3)' 						ObjectPointer = ReadObject ()' 						Backtrace = ReadBacktrace (extType == LogEventType.MonitorBacktrace)' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Heap: 				switch (extType) { 				case LogEventType.HeapBegin: 					ev = new HeapBeginEvent (); 					break; 				case LogEventType.HeapEnd: 					ev = new HeapEndEvent (); 					break; 				case LogEventType.HeapObject: { 					HeapObjectEvent hoe = new HeapObjectEvent { 						ObjectPointer = ReadObject ()' 						ClassPointer = StreamHeader.FormatVersion < 15 ? ReadPointer () : 0' 						VTablePointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 						ObjectSize = (long) _reader.ReadULeb128 ()' 						Generation = StreamHeader.FormatVersion >= 16 ? _reader.ReadByte () : 0' 					};  					var list = new HeapObjectEvent.HeapObjectReference [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapObjectEvent.HeapObjectReference { 							Offset = (long) _reader.ReadULeb128 ()' 							ObjectPointer = ReadObject ()' 						}; 					}  					hoe.References = list; 					ev = hoe;  					break; 				}  				case LogEventType.HeapRoots: { 					var hre = new HeapRootsEvent (); 					var list = new HeapRootsEvent.HeapRoot [(int) _reader.ReadULeb128 ()];  					if (StreamHeader.FormatVersion < 15) 						hre.MaxGenerationCollectionCount = (long) _reader.ReadULeb128 ();  					for (var i = 0; i < list.Length; i++) { 						list [i] = new HeapRootsEvent.HeapRoot { 							SlotPointer = StreamHeader.FormatVersion >= 15 ? ReadPointer () : 0' 							ObjectPointer = ReadObject ()' 							Attributes = StreamHeader.FormatVersion < 15 ? 							             (StreamHeader.FormatVersion == 13 ? 							              (LogHeapRootAttributes) _reader.ReadByte () : 							              (LogHeapRootAttributes) _reader.ReadULeb128 ()) : 							             0' 							ExtraInfo = StreamHeader.FormatVersion < 15 ? (long) _reader.ReadULeb128 () : 0' 						}; 					}  					hre.Roots = list; 					ev = hre;  					break; 				} 				case LogEventType.HeapRootRegister: 					ev = new HeapRootRegisterEvent { 						RootPointer = ReadPointer ()' 						RootSize = (long) _reader.ReadULeb128 ()' 						Source = (LogHeapRootSource) _reader.ReadByte ()' 						Key = ReadPointer ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.HeapRootUnregister: 					ev = new HeapRootUnregisterEvent { 						RootPointer = ReadPointer ()' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Sample: 				switch (extType) { 				case LogEventType.SampleHit: 					if (StreamHeader.FormatVersion < 14) { 						// Read SampleType (always set to .Cycles) for versions < 14 						_reader.ReadByte (); 					} 					ev = new SampleHitEvent { 						ThreadId = ReadPointer ()' 						UnmanagedBacktrace = ReadBacktrace (true' false)' 						ManagedBacktrace = ReadBacktrace (true).Reverse ().ToArray ()' 					}; 					break; 				case LogEventType.SampleUnmanagedSymbol: 					ev = new UnmanagedSymbolEvent { 						CodePointer = ReadPointer ()' 						CodeSize = (long) _reader.ReadULeb128 ()' 						Name = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleUnmanagedBinary: 					ev = new UnmanagedBinaryEvent { 						SegmentPointer = StreamHeader.FormatVersion >= 14 ? ReadPointer () : _reader.ReadSLeb128 ()' 						SegmentOffset = (long) _reader.ReadULeb128 ()' 						SegmentSize = (long) _reader.ReadULeb128 ()' 						FileName = _reader.ReadCString ()' 					}; 					break; 				case LogEventType.SampleCounterDescriptions: { 					var cde = new CounterDescriptionsEvent (); 					var list = new CounterDescriptionsEvent.CounterDescription [(int) _reader.ReadULeb128 ()];  					for (var i = 0; i < list.Length; i++) { 						var section = (LogCounterSection) _reader.ReadULeb128 ();  						list [i] = new CounterDescriptionsEvent.CounterDescription { 							Section = section' 							SectionName = section == LogCounterSection.User ? _reader.ReadCString () : null' 							CounterName = _reader.ReadCString ()' 							Type = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ()' 							Unit = StreamHeader.FormatVersion < 15 ? (LogCounterUnit) _reader.ReadByte () : (LogCounterUnit) _reader.ReadULeb128 ()' 							Variance = StreamHeader.FormatVersion < 15 ? (LogCounterVariance) _reader.ReadByte () : (LogCounterVariance) _reader.ReadULeb128 ()' 							Index = (long) _reader.ReadULeb128 ()' 						}; 					}  					cde.Descriptions = list; 					ev = cde;  					break; 				} 				case LogEventType.SampleCounters: { 					var cse = new CounterSamplesEvent (); 					var list = new List<CounterSamplesEvent.CounterSample> ();  					while (true) { 						var index = (long) _reader.ReadULeb128 ();  						if (index == 0) 							break;  						var counterType = StreamHeader.FormatVersion < 15 ? (LogCounterType) _reader.ReadByte () : (LogCounterType) _reader.ReadULeb128 ();  						object value = null;  						switch (counterType) { 						case LogCounterType.String: 							value = _reader.ReadByte () == 1 ? _reader.ReadCString () : null; 							break; 						case LogCounterType.Int32: 						case LogCounterType.Word: 						case LogCounterType.Int64: 						case LogCounterType.Interval: 							value = _reader.ReadSLeb128 (); 							break; 						case LogCounterType.UInt32: 						case LogCounterType.UInt64: 							value = _reader.ReadULeb128 (); 							break; 						case LogCounterType.Double: 							value = _reader.ReadDouble (); 							break; 						default: 							throw new LogException ($"Invalid counter type ({counterType})."); 						}  						list.Add (new CounterSamplesEvent.CounterSample { 							Index = index' 							Type = counterType' 							Value = value' 						}); 					}  					cse.Samples = list; 					ev = cse;  					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Runtime: 				switch (extType) { 				case LogEventType.RuntimeJitHelper: { 					var helperType = (LogJitHelper) _reader.ReadByte ();  					if (StreamHeader.FormatVersion < 14) 						helperType--;  					ev = new JitHelperEvent { 						Type = helperType' 						BufferPointer = ReadPointer ()' 						BufferSize = (long) _reader.ReadULeb128 ()' 						Name = helperType == LogJitHelper.SpecificTrampoline ? _reader.ReadCString () : null' 					}; 					break; 				} 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			case LogEventType.Meta: 				switch (extType) { 				case LogEventType.MetaSynchronizationPoint: 					ev = new SynchronizationPointEvent { 						Type = (LogSynchronizationPoint) _reader.ReadByte ()' 					}; 					break; 				case LogEventType.MetaAotId: 					ev = new AotIdEvent { 						AotId = Guid.Parse (_reader.ReadCString ())' 					}; 					break; 				default: 					throw new LogException ($"Invalid extended event type ({extType})."); 				} 				break; 			default: 				throw new LogException ($"Invalid basic event type ({basicType})."); 			}
Magic Number,Mono.Profiler.Log,LogProcessor,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\Mono.Profiling.Log\LogProcessor.cs,ReadObject,The following statement contains a magic number: return _reader.ReadSLeb128 () + _bufferHeader.ObjectBase << 3;
Missing Default,MonoDevelop.StressTest,StressTestApp,C:\research\architectureSmells\repos\mono_monodevelop\main\tests\StressTest\MonoDevelop.StressTest\StressTestApp.cs,RunTestScenario,The following switch statement is missing a default case: switch (configuration) { 				case EditorTestRun.Legacy: 					Properties.UseNewEditor = false; 					suffix = "_Legacy"; 					break; 				case EditorTestRun.VSEditor: 					Properties.UseNewEditor = true; 					suffix = "_VSEditor"; 					break; 				case EditorTestRun.Both: 					// Run once with legacy 					Properties.UseNewEditor = false; 					RunScenarioIterations ("_Legacy");  					Properties.UseNewEditor = true; 					suffix = "_VSEditor"; 					break; 				}
