Implementation smell,Namespace,Class,File,Method,Description
Long Method,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The method has 188 lines of code.
Complex Method,SafeILGenerator.Ast,AstUtils,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\AstUtils.cs,GetTypeSize,Cyclomatic complexity of the method is 9
Complex Method,SafeILGenerator.Ast,AstUtils,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\AstUtils.cs,CastType,Cyclomatic complexity of the method is 12
Complex Method,SafeILGenerator.Ast.Generators,GeneratorCSharp,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorCSharp.cs,ValueAsString,Cyclomatic complexity of the method is 8
Complex Method,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,Cyclomatic complexity of the method is 10
Complex Method,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,Cyclomatic complexity of the method is 12
Complex Method,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,Cyclomatic complexity of the method is 11
Long Statement,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The length of the statement  "                //IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle) " is 130.
Long Statement,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The length of the statement  "            //if (LeftType != RightType) throw(new Exception(String.Format("BinaryOp Type mismatch ({0}) != ({1})"' LeftType' RightType))); " is 127.
Long Statement,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The length of the statement  "            //			throw(new InvalidOperationException(String.Format("Operator '{0}' requires boolean types but found {1}' {2}"' Item.Operator' LeftType' RightType))); " is 153.
Long Statement,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The length of the statement  "                        //Generate(new AstNodeStmAssign(new AstNodeExprLocal(SwitchVarLocal)' Switch.SwitchValue - new AstNodeExprCast(CommonType' CommonMin))); " is 136.
Long Statement,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The length of the statement  "                        //Generate(new AstNodeStmIfElse(new AstNodeExprBinop(new AstNodeExprLocal(SwitchVarLocal)' "<"' 0)' new AstNodeStmGotoAlways(DefaultLabel))); " is 141.
Long Statement,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The length of the statement  "                        //Generate(new AstNodeStmIfElse(new AstNodeExprBinop(new AstNodeExprLocal(SwitchVarLocal)' ">="' CasesLength)' new AstNodeStmGotoAlways(DefaultLabel))); " is 152.
Complex Conditional,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The conditional expression  "itemType == typeof(int)                  || itemType == typeof(sbyte)                  || itemType == typeof(short)                  || itemType == typeof(bool)"  is complex.
Complex Conditional,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The conditional expression  "(leftType == typeof(uint) || leftType == typeof(int)) && rightType == typeof(int) && rightImm != null"  is complex.
Magic Number,SafeILGenerator.Ast.Generators,GeneratorCSharp,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorCSharp.cs,ValueAsString,The following statement contains a magic number: if (Convert.ToInt64(value) > 9) return $"0x{value:X}";
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: if (                  itemType == typeof(int)                  || itemType == typeof(sbyte)                  || itemType == typeof(short)                  || itemType == typeof(bool)              )              {                  var value = (int) Convert.ToInt64(itemValue);                  switch (value)                  {                      case -1:                          Emit(OpCodes.Ldc_I4_M1);                          break;                      case 0:                          Emit(OpCodes.Ldc_I4_0);                          break;                      case 1:                          Emit(OpCodes.Ldc_I4_1);                          break;                      case 2:                          Emit(OpCodes.Ldc_I4_2);                          break;                      case 3:                          Emit(OpCodes.Ldc_I4_3);                          break;                      case 4:                          Emit(OpCodes.Ldc_I4_4);                          break;                      case 5:                          Emit(OpCodes.Ldc_I4_5);                          break;                      case 6:                          Emit(OpCodes.Ldc_I4_6);                          break;                      case 7:                          Emit(OpCodes.Ldc_I4_7);                          break;                      case 8:                          Emit(OpCodes.Ldc_I4_8);                          break;                      default:                          Emit(OpCodes.Ldc_I4' value);                          break;                  }              }              else if (itemType == typeof(long) || itemType == typeof(ulong))              {                  Emit(OpCodes.Ldc_I8' Convert.ToInt64(itemValue));              }              else if (itemType == typeof(IntPtr))              {  #if false  				Emit(OpCodes.Ldc_I8' ((IntPtr)Item.Value).ToInt64());  				Emit(OpCodes.Conv_I);  #else                  if (Environment.Is64BitProcess)                  {                      Emit(OpCodes.Ldc_I8' ((IntPtr) item.Value).ToInt64());                      Emit(OpCodes.Conv_I);                  }                  else                  {                      Emit(OpCodes.Ldc_I4' ((IntPtr) item.Value).ToInt32());                      Emit(OpCodes.Conv_I);                  }  #endif              }              else if (itemType == typeof(float))              {                  Emit(OpCodes.Ldc_R4' (float) item.Value);              }              else if (item.Value == null)              {                  Emit(OpCodes.Ldnull);              }              else if (itemType == typeof(string))              {                  Emit(OpCodes.Ldstr' (string) item.Value);              }              else if (itemType == typeof(Type))              {                  Emit(OpCodes.Ldtoken' (Type) item.Value);                  Emit(OpCodes.Call' ((Func<RuntimeTypeHandle' Type>) Type.GetTypeFromHandle).Method);                  //IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)              }              else              {                  throw new NotImplementedException($"Can't handle immediate type {itemType}");              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: if (                  itemType == typeof(int)                  || itemType == typeof(sbyte)                  || itemType == typeof(short)                  || itemType == typeof(bool)              )              {                  var value = (int) Convert.ToInt64(itemValue);                  switch (value)                  {                      case -1:                          Emit(OpCodes.Ldc_I4_M1);                          break;                      case 0:                          Emit(OpCodes.Ldc_I4_0);                          break;                      case 1:                          Emit(OpCodes.Ldc_I4_1);                          break;                      case 2:                          Emit(OpCodes.Ldc_I4_2);                          break;                      case 3:                          Emit(OpCodes.Ldc_I4_3);                          break;                      case 4:                          Emit(OpCodes.Ldc_I4_4);                          break;                      case 5:                          Emit(OpCodes.Ldc_I4_5);                          break;                      case 6:                          Emit(OpCodes.Ldc_I4_6);                          break;                      case 7:                          Emit(OpCodes.Ldc_I4_7);                          break;                      case 8:                          Emit(OpCodes.Ldc_I4_8);                          break;                      default:                          Emit(OpCodes.Ldc_I4' value);                          break;                  }              }              else if (itemType == typeof(long) || itemType == typeof(ulong))              {                  Emit(OpCodes.Ldc_I8' Convert.ToInt64(itemValue));              }              else if (itemType == typeof(IntPtr))              {  #if false  				Emit(OpCodes.Ldc_I8' ((IntPtr)Item.Value).ToInt64());  				Emit(OpCodes.Conv_I);  #else                  if (Environment.Is64BitProcess)                  {                      Emit(OpCodes.Ldc_I8' ((IntPtr) item.Value).ToInt64());                      Emit(OpCodes.Conv_I);                  }                  else                  {                      Emit(OpCodes.Ldc_I4' ((IntPtr) item.Value).ToInt32());                      Emit(OpCodes.Conv_I);                  }  #endif              }              else if (itemType == typeof(float))              {                  Emit(OpCodes.Ldc_R4' (float) item.Value);              }              else if (item.Value == null)              {                  Emit(OpCodes.Ldnull);              }              else if (itemType == typeof(string))              {                  Emit(OpCodes.Ldstr' (string) item.Value);              }              else if (itemType == typeof(Type))              {                  Emit(OpCodes.Ldtoken' (Type) item.Value);                  Emit(OpCodes.Call' ((Func<RuntimeTypeHandle' Type>) Type.GetTypeFromHandle).Method);                  //IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)              }              else              {                  throw new NotImplementedException($"Can't handle immediate type {itemType}");              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: if (                  itemType == typeof(int)                  || itemType == typeof(sbyte)                  || itemType == typeof(short)                  || itemType == typeof(bool)              )              {                  var value = (int) Convert.ToInt64(itemValue);                  switch (value)                  {                      case -1:                          Emit(OpCodes.Ldc_I4_M1);                          break;                      case 0:                          Emit(OpCodes.Ldc_I4_0);                          break;                      case 1:                          Emit(OpCodes.Ldc_I4_1);                          break;                      case 2:                          Emit(OpCodes.Ldc_I4_2);                          break;                      case 3:                          Emit(OpCodes.Ldc_I4_3);                          break;                      case 4:                          Emit(OpCodes.Ldc_I4_4);                          break;                      case 5:                          Emit(OpCodes.Ldc_I4_5);                          break;                      case 6:                          Emit(OpCodes.Ldc_I4_6);                          break;                      case 7:                          Emit(OpCodes.Ldc_I4_7);                          break;                      case 8:                          Emit(OpCodes.Ldc_I4_8);                          break;                      default:                          Emit(OpCodes.Ldc_I4' value);                          break;                  }              }              else if (itemType == typeof(long) || itemType == typeof(ulong))              {                  Emit(OpCodes.Ldc_I8' Convert.ToInt64(itemValue));              }              else if (itemType == typeof(IntPtr))              {  #if false  				Emit(OpCodes.Ldc_I8' ((IntPtr)Item.Value).ToInt64());  				Emit(OpCodes.Conv_I);  #else                  if (Environment.Is64BitProcess)                  {                      Emit(OpCodes.Ldc_I8' ((IntPtr) item.Value).ToInt64());                      Emit(OpCodes.Conv_I);                  }                  else                  {                      Emit(OpCodes.Ldc_I4' ((IntPtr) item.Value).ToInt32());                      Emit(OpCodes.Conv_I);                  }  #endif              }              else if (itemType == typeof(float))              {                  Emit(OpCodes.Ldc_R4' (float) item.Value);              }              else if (item.Value == null)              {                  Emit(OpCodes.Ldnull);              }              else if (itemType == typeof(string))              {                  Emit(OpCodes.Ldstr' (string) item.Value);              }              else if (itemType == typeof(Type))              {                  Emit(OpCodes.Ldtoken' (Type) item.Value);                  Emit(OpCodes.Call' ((Func<RuntimeTypeHandle' Type>) Type.GetTypeFromHandle).Method);                  //IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)              }              else              {                  throw new NotImplementedException($"Can't handle immediate type {itemType}");              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: if (                  itemType == typeof(int)                  || itemType == typeof(sbyte)                  || itemType == typeof(short)                  || itemType == typeof(bool)              )              {                  var value = (int) Convert.ToInt64(itemValue);                  switch (value)                  {                      case -1:                          Emit(OpCodes.Ldc_I4_M1);                          break;                      case 0:                          Emit(OpCodes.Ldc_I4_0);                          break;                      case 1:                          Emit(OpCodes.Ldc_I4_1);                          break;                      case 2:                          Emit(OpCodes.Ldc_I4_2);                          break;                      case 3:                          Emit(OpCodes.Ldc_I4_3);                          break;                      case 4:                          Emit(OpCodes.Ldc_I4_4);                          break;                      case 5:                          Emit(OpCodes.Ldc_I4_5);                          break;                      case 6:                          Emit(OpCodes.Ldc_I4_6);                          break;                      case 7:                          Emit(OpCodes.Ldc_I4_7);                          break;                      case 8:                          Emit(OpCodes.Ldc_I4_8);                          break;                      default:                          Emit(OpCodes.Ldc_I4' value);                          break;                  }              }              else if (itemType == typeof(long) || itemType == typeof(ulong))              {                  Emit(OpCodes.Ldc_I8' Convert.ToInt64(itemValue));              }              else if (itemType == typeof(IntPtr))              {  #if false  				Emit(OpCodes.Ldc_I8' ((IntPtr)Item.Value).ToInt64());  				Emit(OpCodes.Conv_I);  #else                  if (Environment.Is64BitProcess)                  {                      Emit(OpCodes.Ldc_I8' ((IntPtr) item.Value).ToInt64());                      Emit(OpCodes.Conv_I);                  }                  else                  {                      Emit(OpCodes.Ldc_I4' ((IntPtr) item.Value).ToInt32());                      Emit(OpCodes.Conv_I);                  }  #endif              }              else if (itemType == typeof(float))              {                  Emit(OpCodes.Ldc_R4' (float) item.Value);              }              else if (item.Value == null)              {                  Emit(OpCodes.Ldnull);              }              else if (itemType == typeof(string))              {                  Emit(OpCodes.Ldstr' (string) item.Value);              }              else if (itemType == typeof(Type))              {                  Emit(OpCodes.Ldtoken' (Type) item.Value);                  Emit(OpCodes.Call' ((Func<RuntimeTypeHandle' Type>) Type.GetTypeFromHandle).Method);                  //IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)              }              else              {                  throw new NotImplementedException($"Can't handle immediate type {itemType}");              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: if (                  itemType == typeof(int)                  || itemType == typeof(sbyte)                  || itemType == typeof(short)                  || itemType == typeof(bool)              )              {                  var value = (int) Convert.ToInt64(itemValue);                  switch (value)                  {                      case -1:                          Emit(OpCodes.Ldc_I4_M1);                          break;                      case 0:                          Emit(OpCodes.Ldc_I4_0);                          break;                      case 1:                          Emit(OpCodes.Ldc_I4_1);                          break;                      case 2:                          Emit(OpCodes.Ldc_I4_2);                          break;                      case 3:                          Emit(OpCodes.Ldc_I4_3);                          break;                      case 4:                          Emit(OpCodes.Ldc_I4_4);                          break;                      case 5:                          Emit(OpCodes.Ldc_I4_5);                          break;                      case 6:                          Emit(OpCodes.Ldc_I4_6);                          break;                      case 7:                          Emit(OpCodes.Ldc_I4_7);                          break;                      case 8:                          Emit(OpCodes.Ldc_I4_8);                          break;                      default:                          Emit(OpCodes.Ldc_I4' value);                          break;                  }              }              else if (itemType == typeof(long) || itemType == typeof(ulong))              {                  Emit(OpCodes.Ldc_I8' Convert.ToInt64(itemValue));              }              else if (itemType == typeof(IntPtr))              {  #if false  				Emit(OpCodes.Ldc_I8' ((IntPtr)Item.Value).ToInt64());  				Emit(OpCodes.Conv_I);  #else                  if (Environment.Is64BitProcess)                  {                      Emit(OpCodes.Ldc_I8' ((IntPtr) item.Value).ToInt64());                      Emit(OpCodes.Conv_I);                  }                  else                  {                      Emit(OpCodes.Ldc_I4' ((IntPtr) item.Value).ToInt32());                      Emit(OpCodes.Conv_I);                  }  #endif              }              else if (itemType == typeof(float))              {                  Emit(OpCodes.Ldc_R4' (float) item.Value);              }              else if (item.Value == null)              {                  Emit(OpCodes.Ldnull);              }              else if (itemType == typeof(string))              {                  Emit(OpCodes.Ldstr' (string) item.Value);              }              else if (itemType == typeof(Type))              {                  Emit(OpCodes.Ldtoken' (Type) item.Value);                  Emit(OpCodes.Call' ((Func<RuntimeTypeHandle' Type>) Type.GetTypeFromHandle).Method);                  //IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)              }              else              {                  throw new NotImplementedException($"Can't handle immediate type {itemType}");              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: if (                  itemType == typeof(int)                  || itemType == typeof(sbyte)                  || itemType == typeof(short)                  || itemType == typeof(bool)              )              {                  var value = (int) Convert.ToInt64(itemValue);                  switch (value)                  {                      case -1:                          Emit(OpCodes.Ldc_I4_M1);                          break;                      case 0:                          Emit(OpCodes.Ldc_I4_0);                          break;                      case 1:                          Emit(OpCodes.Ldc_I4_1);                          break;                      case 2:                          Emit(OpCodes.Ldc_I4_2);                          break;                      case 3:                          Emit(OpCodes.Ldc_I4_3);                          break;                      case 4:                          Emit(OpCodes.Ldc_I4_4);                          break;                      case 5:                          Emit(OpCodes.Ldc_I4_5);                          break;                      case 6:                          Emit(OpCodes.Ldc_I4_6);                          break;                      case 7:                          Emit(OpCodes.Ldc_I4_7);                          break;                      case 8:                          Emit(OpCodes.Ldc_I4_8);                          break;                      default:                          Emit(OpCodes.Ldc_I4' value);                          break;                  }              }              else if (itemType == typeof(long) || itemType == typeof(ulong))              {                  Emit(OpCodes.Ldc_I8' Convert.ToInt64(itemValue));              }              else if (itemType == typeof(IntPtr))              {  #if false  				Emit(OpCodes.Ldc_I8' ((IntPtr)Item.Value).ToInt64());  				Emit(OpCodes.Conv_I);  #else                  if (Environment.Is64BitProcess)                  {                      Emit(OpCodes.Ldc_I8' ((IntPtr) item.Value).ToInt64());                      Emit(OpCodes.Conv_I);                  }                  else                  {                      Emit(OpCodes.Ldc_I4' ((IntPtr) item.Value).ToInt32());                      Emit(OpCodes.Conv_I);                  }  #endif              }              else if (itemType == typeof(float))              {                  Emit(OpCodes.Ldc_R4' (float) item.Value);              }              else if (item.Value == null)              {                  Emit(OpCodes.Ldnull);              }              else if (itemType == typeof(string))              {                  Emit(OpCodes.Ldstr' (string) item.Value);              }              else if (itemType == typeof(Type))              {                  Emit(OpCodes.Ldtoken' (Type) item.Value);                  Emit(OpCodes.Call' ((Func<RuntimeTypeHandle' Type>) Type.GetTypeFromHandle).Method);                  //IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)              }              else              {                  throw new NotImplementedException($"Can't handle immediate type {itemType}");              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: if (                  itemType == typeof(int)                  || itemType == typeof(sbyte)                  || itemType == typeof(short)                  || itemType == typeof(bool)              )              {                  var value = (int) Convert.ToInt64(itemValue);                  switch (value)                  {                      case -1:                          Emit(OpCodes.Ldc_I4_M1);                          break;                      case 0:                          Emit(OpCodes.Ldc_I4_0);                          break;                      case 1:                          Emit(OpCodes.Ldc_I4_1);                          break;                      case 2:                          Emit(OpCodes.Ldc_I4_2);                          break;                      case 3:                          Emit(OpCodes.Ldc_I4_3);                          break;                      case 4:                          Emit(OpCodes.Ldc_I4_4);                          break;                      case 5:                          Emit(OpCodes.Ldc_I4_5);                          break;                      case 6:                          Emit(OpCodes.Ldc_I4_6);                          break;                      case 7:                          Emit(OpCodes.Ldc_I4_7);                          break;                      case 8:                          Emit(OpCodes.Ldc_I4_8);                          break;                      default:                          Emit(OpCodes.Ldc_I4' value);                          break;                  }              }              else if (itemType == typeof(long) || itemType == typeof(ulong))              {                  Emit(OpCodes.Ldc_I8' Convert.ToInt64(itemValue));              }              else if (itemType == typeof(IntPtr))              {  #if false  				Emit(OpCodes.Ldc_I8' ((IntPtr)Item.Value).ToInt64());  				Emit(OpCodes.Conv_I);  #else                  if (Environment.Is64BitProcess)                  {                      Emit(OpCodes.Ldc_I8' ((IntPtr) item.Value).ToInt64());                      Emit(OpCodes.Conv_I);                  }                  else                  {                      Emit(OpCodes.Ldc_I4' ((IntPtr) item.Value).ToInt32());                      Emit(OpCodes.Conv_I);                  }  #endif              }              else if (itemType == typeof(float))              {                  Emit(OpCodes.Ldc_R4' (float) item.Value);              }              else if (item.Value == null)              {                  Emit(OpCodes.Ldnull);              }              else if (itemType == typeof(string))              {                  Emit(OpCodes.Ldstr' (string) item.Value);              }              else if (itemType == typeof(Type))              {                  Emit(OpCodes.Ldtoken' (Type) item.Value);                  Emit(OpCodes.Call' ((Func<RuntimeTypeHandle' Type>) Type.GetTypeFromHandle).Method);                  //IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)              }              else              {                  throw new NotImplementedException($"Can't handle immediate type {itemType}");              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: switch (argumentIndex)              {                  case 0:                      Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      Emit(OpCodes.Ldarg_3);                      break;                  default:                      Emit(OpCodes.Ldarg' argumentIndex);                      break;              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: switch (argumentIndex)              {                  case 0:                      Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      Emit(OpCodes.Ldarg_3);                      break;                  default:                      Emit(OpCodes.Ldarg' argumentIndex);                      break;              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: switch (localBuilder.LocalIndex)              {                  case 0:                      Emit(OpCodes.Ldloc_0);                      break;                  case 1:                      Emit(OpCodes.Ldloc_1);                      break;                  case 2:                      Emit(OpCodes.Ldloc_2);                      break;                  case 3:                      Emit(OpCodes.Ldloc_3);                      break;                  default:                      Emit(OpCodes.Ldloc' localBuilder);                      break;              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: switch (localBuilder.LocalIndex)              {                  case 0:                      Emit(OpCodes.Ldloc_0);                      break;                  case 1:                      Emit(OpCodes.Ldloc_1);                      break;                  case 2:                      Emit(OpCodes.Ldloc_2);                      break;                  case 3:                      Emit(OpCodes.Ldloc_3);                      break;                  default:                      Emit(OpCodes.Ldloc' localBuilder);                      break;              }
Magic Number,SafeILGenerator.Ast.Generators,GeneratorIl,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Generators\GeneratorIL.cs,_Generate,The following statement contains a magic number: if (Switch.Cases.Length > 0)              {                  var commonType = Switch.Cases.First().CaseValue.GetType();                  if (Switch.Cases.Any(Case => Case.CaseValue.GetType() != commonType))                  {                      throw new Exception("All cases should have the same type");                  }                    var doneSpecialized = false;                    // Specialized constant-time integer switch (if possible)                  if (AstUtils.IsIntegerType(commonType))                  {                      var commonMin = Switch.Cases.Min(Case => AstUtils.CastType<long>(Case.CaseValue));                      var commonMax = Switch.Cases.Max(Case => AstUtils.CastType<long>(Case.CaseValue));                      var casesLength = commonMax - commonMin + 1;                        // No processing tables greater than 4096 elements.                      if (casesLength <= 4096)                      {                          var labels = new AstLabel[casesLength];                          for (var n = 0; n < casesLength; n++) labels[n] = defaultLabel;                            foreach (var Case in Switch.Cases)                          {                              var realValue = AstUtils.CastType<long>(Case.CaseValue);                              var offset = realValue - commonMin;                              labels[offset] = AstLabel.CreateLabel("Case_" + realValue);                          }                            /*                          //var SwitchVarLocal = AstLocal.Create(AllCaseValues.First().GetType()' "SwitchVarLocal" + SwitchVarCount++);                          //Generate(new AstNodeStmAssign(new AstNodeExprLocal(SwitchVarLocal)' Switch.SwitchValue - new AstNodeExprCast(CommonType' CommonMin)));                          //Generate(new AstNodeStmIfElse(new AstNodeExprBinop(new AstNodeExprLocal(SwitchVarLocal)' "<"' 0)' new AstNodeStmGotoAlways(DefaultLabel)));                          //Generate(new AstNodeStmIfElse(new AstNodeExprBinop(new AstNodeExprLocal(SwitchVarLocal)' ">="' CasesLength)' new AstNodeStmGotoAlways(DefaultLabel)));                          //Generate(new AstNodeExprLocal(SwitchVarLocal));                          */                            Generate(Switch.SwitchValue - new AstNodeExprCast(commonType' commonMin));                          Emit(OpCodes.Switch' labels);                          Generate(new AstNodeStmGotoAlways(defaultLabel));                          foreach (var Case in Switch.Cases)                          {                              var realValue = AstUtils.CastType<long>(Case.CaseValue);                              var offset = realValue - commonMin;                              Generate(new AstNodeStmLabel(labels[offset]));                              {                                  Generate(Case.Code);                              }                              Generate(new AstNodeStmGotoAlways(endCasesLabel));                          }                            doneSpecialized = true;                      }                      else                      {                          // TODO: find a common shift and masks for all the values to reduce CasesLength.                          // TODO: On too large test cases' split them recursively in:                          // if (Var < Half) { switch(Var - LowerPartMin) { ... } } else { switch(Var - Half - UpperPartMin) { ... } }                      }                  }                  // Specialized switch for strings (checking length' then hash' then contents)                  else if (commonType == typeof(string))                  {                      // TODO!                  }                    // Generic if/else                  if (!doneSpecialized)                  {                      var switchVarLocal =                          AstLocal.Create(caseValues.First().GetType()' "SwitchVarLocal" + _switchVarCount++);                      Generate(new AstNodeStmAssign(new AstNodeExprLocal(switchVarLocal)' Switch.SwitchValue));                      //Switch.Cases                      foreach (var Case in Switch.Cases)                      {                          var labelSkipThisCase = AstLabel.CreateLabel("LabelCase" + Case.CaseValue);                          Generate(new AstNodeStmGotoIfFalse(labelSkipThisCase'                              new AstNodeExprBinop(new AstNodeExprLocal(switchVarLocal)' "=="'                                  new AstNodeExprImm(Case.CaseValue))));                          Generate(Case.Code);                          Generate(new AstNodeStmGotoAlways(endCasesLabel));                          Generate(new AstNodeStmLabel(labelSkipThisCase));                      }                  }              }
Magic Number,SafeILGenerator.Utils,IlInstanceHolder,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Utils\ILInstanceHolder.cs,Alloc,The following statement contains a magic number: lock (TypePools)              {                  if (!TypePools.ContainsKey(type))                  {                      TypePools[type] = new List<IlInstanceHolderPool>();                  }                  var poolsType = TypePools[type];                  var freePool = poolsType.FirstOrDefault(pool => pool.HasAvailable);                  if (freePool == null)                  {                      var nextPoolSize = 1 << (poolsType.Count + 2);                      //if (NextPoolSize < 2048) NextPoolSize = 2048;    #if DEBUG_ILINSTANCEHOLDERPOOL_TIME  					Console.BackgroundColor = ConsoleColor.DarkRed;  					Console.Error.Write("Create ILInstanceHolderPool({0})[{1}]..."' Type' NextPoolSize);  					var Start = DateTime.UtcNow;  #endif                      poolsType.Add(freePool = new IlInstanceHolderPool(type' nextPoolSize));  #if DEBUG_ILINSTANCEHOLDERPOOL_TIME  					var End = DateTime.UtcNow;  					Console.Error.WriteLine("Ok({0})"' End - Start);  					Console.ResetColor();  #endif                  }                  var item = freePool.Alloc();                  item.Value = value;                  return item;              }
Duplicate Code,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The method contains a code clone-set at the following line numbers (starting from the method definition): ((33' 55)' (138' 160))
Missing Default,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The following switch statement is missing a default case: switch (Operator)                          {                              case "+": return new AstNodeExprImm(AstUtils.CastType(leftValue + rightValue' type));                              case "-": return new AstNodeExprImm(AstUtils.CastType(leftValue - rightValue' type));                              case "*": return new AstNodeExprImm(AstUtils.CastType(leftValue * rightValue' type));                              case "/": return new AstNodeExprImm(AstUtils.CastType(leftValue / rightValue' type));                          }
Missing Default,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The following switch statement is missing a default case: switch (Operator)                          {                              case "|":                                  if (leftValue == 0) return binary.RightNode;                                  break;                              case "+":                                  if (leftValue == 0) return binary.RightNode;                                  break;                              case "-":                                  if (leftValue == 0) return new AstNodeExprUnop("-"' binary.RightNode);                                  break;                              case "*":                                  //if (LeftValue == 0) return new AstNodeExprImm(AstUtils.CastType(0' Type));                                  if (leftValue == 1) return binary.RightNode;                                  break;                              case "/":                                  //if (LeftValue == 0) return new AstNodeExprImm(AstUtils.CastType(0' Type));                                  break;                          }
Missing Default,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The following switch statement is missing a default case: switch (Operator)                          {                              case "|":                                  if (rightValue == 0) return binary.LeftNode;                                  break;                              case "+":                                  if (rightValue == 0) return binary.LeftNode;                                  break;                              case "-":                                  if (rightValue == 0) return binary.LeftNode;                                  break;                              case "*":                                  if (rightValue == 1) return binary.LeftNode;                                  break;                              case "/":                                  //if (LeftValue == 0) return new AstNodeExprImm(AstUtils.CastType(0' Type));                                  break;                          }
Missing Default,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The following switch statement is missing a default case: switch (Operator)                              {                                  case "+": return new AstNodeExprImm(AstUtils.CastType(leftValue + rightValue' type));                                  case "-": return new AstNodeExprImm(AstUtils.CastType(leftValue - rightValue' type));                                  case "*": return new AstNodeExprImm(AstUtils.CastType(leftValue * rightValue' type));                                  case "/": return new AstNodeExprImm(AstUtils.CastType(leftValue / rightValue' type));                                  case "<<":                                      return new AstNodeExprImm(AstUtils.CastType(leftValue << (int) rightValue' type));                                  case ">>":                                      return new AstNodeExprImm(AstUtils.CastType(leftValue >> (int) rightValue' type));                              }
Missing Default,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The following switch statement is missing a default case: switch (Operator)                              {                                  case "+": return new AstNodeExprImm(AstUtils.CastType(leftValue + rightValue' type));                                  case "-": return new AstNodeExprImm(AstUtils.CastType(leftValue - rightValue' type));                                  case "*": return new AstNodeExprImm(AstUtils.CastType(leftValue * rightValue' type));                                  case "/": return new AstNodeExprImm(AstUtils.CastType(leftValue / rightValue' type));                                  case "<<":                                      return new AstNodeExprImm(AstUtils.CastType(leftValue << (int) rightValue' type));                                  case ">>":                                      return new AstNodeExprImm(AstUtils.CastType(leftValue >> (int) rightValue' type));                              }
Missing Default,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The following switch statement is missing a default case: switch (Operator)                          {                              case "&":                                  if (leftValue == 0) return new AstNodeExprImm(0);                                  break;                              case "|":                                  if (leftValue == 0) return binary.RightNode;                                  break;                              case "+":                                  if (leftValue == 0) return binary.RightNode;                                  break;                              case "-":                                  if (leftValue == 0) return new AstNodeExprUnop("-"' binary.RightNode);                                  break;                              case "*":                                  //if (LeftValue == 0) return new AstNodeExprImm(AstUtils.CastType(0' Type));                                  if (leftValue == 1) return binary.RightNode;                                  break;                              case "/":                                  //if (LeftValue == 0) return new AstNodeExprImm(AstUtils.CastType(0' Type));                                  break;                          }
Missing Default,SafeILGenerator.Ast.Optimizers,AstOptimizer,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Ast\Optimizers\AstOptimizer.cs,_Optimize,The following switch statement is missing a default case: switch (Operator)                          {                              case "0":                                  if (rightValue == 0) return new AstNodeExprImm(0);                                  break;                              case "|":                                  if (rightValue == 0) return binary.LeftNode;                                  break;                              case "+":                                  if (rightValue == 0) return binary.LeftNode;                                  if (rightValue < 0)                                      return new AstNodeExprBinop(binary.LeftNode' "-"'                                          new AstNodeExprImm(AstUtils.Negate(rightImm.Value)));                                  break;                              case "-":                                  if (rightValue == 0) return binary.LeftNode;                                  break;                              case "*":                                  if (rightValue == 1) return binary.LeftNode;                                  break;                              case "/":                                  //if (RightValue == 0) throw(new Exception("Can't divide by 0"));                                  if (rightValue == 1) return binary.LeftNode;                                  break;                          }
Missing Default,SafeILGenerator.Utils,IlFieldInfo,C:\repos\soywiz_cspspemu\Libraries\SafeILGenerator\SafeILGenerator\Utils\ILFieldInfo.cs,GetFieldInfo,The following switch statement is missing a default case: switch (expression)                  {                      case LambdaExpression expr:                          expression = expr.Body;                          continue;                      case MemberExpression expr:                          return (FieldInfo) expr.Member;                  }
