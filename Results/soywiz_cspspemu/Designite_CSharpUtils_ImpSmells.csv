Implementation smell,Namespace,Class,File,Method,Description
Long Method,CSharpUtils.Containers.RedBlackTree,Node,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStatsNode.cs,NonSynchronizedRemove,The method has 185 lines of code.
Complex Method,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,Sms,Cyclomatic complexity of the method is 14
Complex Method,CSharpUtils.Containers.RedBlackTree,Node,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStatsNode.cs,SetColor,Cyclomatic complexity of the method is 8
Complex Method,CSharpUtils.Containers.RedBlackTree,Node,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStatsNode.cs,NonSynchronizedRemove,Cyclomatic complexity of the method is 10
Complex Method,CSharpUtils.Extensions,StructExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StructExtensions.cs,ToStringDefault,Cyclomatic complexity of the method is 16
Complex Method,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,CountStringzBytes,Cyclomatic complexity of the method is 9
Complex Method,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,ReadStringz,Cyclomatic complexity of the method is 8
Complex Method,CSharpUtils.Json,Json,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Json\JSON.cs,Stringify,Cyclomatic complexity of the method is 11
Long Parameter List,CSharpUtils,BitUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitUtils.cs,InsertScaled,The method has 5 parameters. Parameters: initialValue' offset' count' valueToInsert' maxValue
Long Parameter List,CSharpUtils,BitUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitUtils.cs,InsertScaled,The method has 5 parameters. Parameters: initialValue' offset' count' valueToInsert' maxValue
Long Parameter List,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffText,The method has 5 parameters. Parameters: textA' textB' trimSpace' ignoreSpace' ignoreCase
Long Parameter List,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffCodes,The method has 5 parameters. Parameters: lines' h' trimSpace' ignoreSpace' ignoreCase
Long Parameter List,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,Sms,The method has 8 parameters. Parameters: dataA' lowerA' upperA' dataB' lowerB' upperB' downVector' upVector
Long Parameter List,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,Lcs,The method has 8 parameters. Parameters: dataA' lowerA' upperA' dataB' lowerB' upperB' downVector' upVector
Long Parameter List,CSharpUtils.Containers.RedBlackTree,Range,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStatsRange.cs,Range,The method has 5 parameters. Parameters: parentTree' rangeStartNode' rangeEndNode' rangeStartPosition' rangeEndPosition
Long Parameter List,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,CountStringzBytes,The method has 5 parameters. Parameters: stream' toRead' alignTo4' alignPosition' keepStreamPosition
Long Parameter List,CSharpUtils.Streams,SliceStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\SliceStream.cs,SliceStream,The method has 5 parameters. Parameters: baseStream' thisStart' thisLength' canWrite' allowSliceOutsideHigh
Long Statement,CSharpUtils.Containers.RedBlackTree,RedBlackTreeWithStats<TElement>,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStats.cs,LocateNodeAtPosition,The length of the statement  "                    //writefln("Left(%s/%s) ::: %d-%d"' current.childCountLeft' current.childCountRight' currentPosition' current.childCountRight); " is 127.
Long Statement,CSharpUtils.Containers.RedBlackTree,RedBlackTreeWithStats<TElement>,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStats.cs,LocateNodeAtPosition,The length of the statement  "                    //writefln("Right(%s/%s) ::: %d+%d"' current.childCountLeft' current.childCountRight' currentPosition' current.childCountLeft); " is 127.
Long Statement,CSharpUtils.Containers.RedBlackTree,Node,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStatsNode.cs,ToString,The length of the statement  "                    $"RedBlackTreeWithStats.Node(Value={Value}' Color={Enum.GetName(typeof(Color)' Color)}' ChildCountLeft={ChildCountLeft}' ChildCountRight={ChildCountRight})"; " is 157.
Complex Conditional,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,CreateDiffs,The conditional expression  "(lineA < dataA.Length) && (!dataA.Modified[lineA])                      && (lineB < dataB.Length) && (!dataB.Modified[lineB])"  is complex.
Complex Conditional,CSharpUtils.Containers.RedBlackTree,Node,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStatsNode.cs,NonSynchronizedRemove,The conditional expression  "(wl == null || wl.Color == Color.Black) &&                                  (wr == null || wr.Color == Color.Black)"  is complex.
Complex Conditional,CSharpUtils.Containers.RedBlackTree,Node,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStatsNode.cs,NonSynchronizedRemove,The conditional expression  "(wl == null || wl.Color == Color.Black) &&                                  (wr == null || wr.Color == Color.Black)"  is complex.
Complex Conditional,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,ReadAllContentsAsString,The conditional expression  "data.Length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF"  is complex.
Complex Conditional,CSharpUtils.Streams,SliceStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\SliceStream.cs,SliceStream,The conditional expression  "(SliceHigh < SliceLow) || (SliceLow < 0) || (SliceHigh < 0) || !allowSliceOutsideHigh &&                  ((SliceLow > baseStream.Length) || (SliceHigh > baseStream.Length))"  is complex.
Empty Catch Block,CSharpUtils.Threading,Coroutine,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Threading\Coroutines.cs,Coroutine,The method has an empty catch block.
Empty Catch Block,CSharpUtils.Threading,GreenThread,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Threading\GreenThread.cs,InitAndStartStopped,The method has an empty catch block.
Empty Catch Block,CSharpUtils.Threading,GreenThread,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Threading\GreenThread.cs,InitAndStartStopped,The method has an empty catch block.
Magic Number,CSharpUtils,BitWriter2,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitWriter2.cs,WriteBits,The following statement contains a magic number: switch (_byteCapacity)              {                  case 1:                      Stream.WriteByte((byte) _currentValue);                      break;                  case 2:                      Stream.WriteStruct((ushort) _currentValue);                      break;                  case 4:                      // ReSharper disable once RedundantCast                      Stream.WriteStruct((uint) _currentValue);                      break;                  default:                      throw(new InvalidOperationException());              }
Magic Number,CSharpUtils,BitWriter2,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitWriter2.cs,WriteBits,The following statement contains a magic number: switch (_byteCapacity)              {                  case 1:                      Stream.WriteByte((byte) _currentValue);                      break;                  case 2:                      Stream.WriteStruct((ushort) _currentValue);                      break;                  case 4:                      // ReSharper disable once RedundantCast                      Stream.WriteStruct((uint) _currentValue);                      break;                  default:                      throw(new InvalidOperationException());              }
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffText,The following statement contains a magic number: var downVector = new int[2 * max + 2];
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffText,The following statement contains a magic number: var downVector = new int[2 * max + 2];
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffText,The following statement contains a magic number: var upVector = new int[2 * max + 2];
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffText,The following statement contains a magic number: var upVector = new int[2 * max + 2];
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffInt,The following statement contains a magic number: var downVector = new int[2 * max + 2];
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffInt,The following statement contains a magic number: var downVector = new int[2 * max + 2];
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffInt,The following statement contains a magic number: var upVector = new int[2 * max + 2];
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffInt,The following statement contains a magic number: var upVector = new int[2 * max + 2];
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,Sms,The following statement contains a magic number: var maxD = ((upperA - lowerA + upperB - lowerB) / 2) + 1;
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,Sms,The following statement contains a magic number: for (var d = 0; d <= maxD; d++)              {                  // Extend the forward path.                  Smsrd ret;                  for (var k = downK - d; k <= downK + d; k += 2)                  {                      // Debug.Write(0' "SMS"' "extend forward path " + k.ToString());                        // find the only or better starting point                      int x;                      if (k == downK - d)                      {                          x = downVector[downOffset + k + 1]; // down                      }                      else                      {                          x = downVector[downOffset + k - 1] + 1; // a step to the right                          if ((k < downK + d) && (downVector[downOffset + k + 1] >= x))                              x = downVector[downOffset + k + 1]; // down                      }                      var y = x - k;                        // find the end of the furthest reaching forward D-path in diagonal k.                      while ((x < upperA) && (y < upperB) && (dataA.Data[x] == dataB.Data[y]))                      {                          x++;                          y++;                      }                      downVector[downOffset + k] = x;                        // overlap ?                      if (oddDelta && (upK - d < k) && (k < upK + d))                      {                          if (upVector[upOffset + k] <= downVector[downOffset + k])                          {                              ret.X = downVector[downOffset + k];                              ret.Y = downVector[downOffset + k] - k;                              // ret.u = UpVector[UpOffset + k];      // 2002.09.20: no need for 2 points                               // ret.v = UpVector[UpOffset + k] - k;                              return (ret);                          } // if                      } // if                  } // for k                    // Extend the reverse path.                  for (var k = upK - d; k <= upK + d; k += 2)                  {                      // Debug.Write(0' "SMS"' "extend reverse path " + k.ToString());                        // find the only or better starting point                      int x;                      if (k == upK + d)                      {                          x = upVector[upOffset + k - 1]; // up                      }                      else                      {                          x = upVector[upOffset + k + 1] - 1; // left                          if ((k > upK - d) && (upVector[upOffset + k - 1] < x))                              x = upVector[upOffset + k - 1]; // up                      } // if                      var y = x - k;                        while ((x > lowerA) && (y > lowerB) && (dataA.Data[x - 1] == dataB.Data[y - 1]))                      {                          x--;                          y--; // diagonal                      }                      upVector[upOffset + k] = x;                        // overlap ?                      if (!oddDelta && (downK - d <= k) && (k <= downK + d))                      {                          if (upVector[upOffset + k] <= downVector[downOffset + k])                          {                              ret.X = downVector[downOffset + k];                              ret.Y = downVector[downOffset + k] - k;                              // ret.u = UpVector[UpOffset + k];     // 2002.09.20: no need for 2 points                               // ret.v = UpVector[UpOffset + k] - k;                              return (ret);                          } // if                      } // if                  } // for k              }
Magic Number,CSharpUtils,Diff,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,Sms,The following statement contains a magic number: for (var d = 0; d <= maxD; d++)              {                  // Extend the forward path.                  Smsrd ret;                  for (var k = downK - d; k <= downK + d; k += 2)                  {                      // Debug.Write(0' "SMS"' "extend forward path " + k.ToString());                        // find the only or better starting point                      int x;                      if (k == downK - d)                      {                          x = downVector[downOffset + k + 1]; // down                      }                      else                      {                          x = downVector[downOffset + k - 1] + 1; // a step to the right                          if ((k < downK + d) && (downVector[downOffset + k + 1] >= x))                              x = downVector[downOffset + k + 1]; // down                      }                      var y = x - k;                        // find the end of the furthest reaching forward D-path in diagonal k.                      while ((x < upperA) && (y < upperB) && (dataA.Data[x] == dataB.Data[y]))                      {                          x++;                          y++;                      }                      downVector[downOffset + k] = x;                        // overlap ?                      if (oddDelta && (upK - d < k) && (k < upK + d))                      {                          if (upVector[upOffset + k] <= downVector[downOffset + k])                          {                              ret.X = downVector[downOffset + k];                              ret.Y = downVector[downOffset + k] - k;                              // ret.u = UpVector[UpOffset + k];      // 2002.09.20: no need for 2 points                               // ret.v = UpVector[UpOffset + k] - k;                              return (ret);                          } // if                      } // if                  } // for k                    // Extend the reverse path.                  for (var k = upK - d; k <= upK + d; k += 2)                  {                      // Debug.Write(0' "SMS"' "extend reverse path " + k.ToString());                        // find the only or better starting point                      int x;                      if (k == upK + d)                      {                          x = upVector[upOffset + k - 1]; // up                      }                      else                      {                          x = upVector[upOffset + k + 1] - 1; // left                          if ((k > upK - d) && (upVector[upOffset + k - 1] < x))                              x = upVector[upOffset + k - 1]; // up                      } // if                      var y = x - k;                        while ((x > lowerA) && (y > lowerB) && (dataA.Data[x - 1] == dataB.Data[y - 1]))                      {                          x--;                          y--; // diagonal                      }                      upVector[upOffset + k] = x;                        // overlap ?                      if (!oddDelta && (downK - d <= k) && (k <= downK + d))                      {                          if (upVector[upOffset + k] <= downVector[downOffset + k])                          {                              ret.X = downVector[downOffset + k];                              ret.Y = downVector[downOffset + k] - k;                              // ret.u = UpVector[UpOffset + k];     // 2002.09.20: no need for 2 points                               // ret.v = UpVector[UpOffset + k] - k;                              return (ret);                          } // if                      } // if                  } // for k              }
Magic Number,CSharpUtils,ProcessedItem,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,ToString,The following statement contains a magic number: return $"{(LineNumber + 1)'4:0}: {(char) Action}{(char) Action} {Line}";
Magic Number,CSharpUtils,DiffData,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Diff.cs,DiffData,The following statement contains a magic number: Modified = new bool[Length + 2];
Magic Number,CSharpUtils,BitReader,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitReader.cs,EnsureData,The following statement contains a magic number: while (readBits > 0)              {                  var b = BaseStream.ReadByte();                    if (b < 0) throw new Exception("Unexpected end of stream");                    _readData |= checked((uint) b << _endPosition);                  _endPosition += 8;                  readBits -= 8;              }
Magic Number,CSharpUtils,BitReader,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitReader.cs,EnsureData,The following statement contains a magic number: while (readBits > 0)              {                  var b = BaseStream.ReadByte();                    if (b < 0) throw new Exception("Unexpected end of stream");                    _readData |= checked((uint) b << _endPosition);                  _endPosition += 8;                  readBits -= 8;              }
Magic Number,CSharpUtils,BitReader,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitReader.cs,ReadLsb,The following statement contains a magic number: if (_endPosition == _startPosition)              {                  _endPosition = _startPosition = 0;                  _readData = 0;              }              else if (_startPosition >= 8)              {                  _readData >>= _startPosition;                  _endPosition -= _startPosition;                  _startPosition = 0;              }
Magic Number,CSharpUtils,BitWriter,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitWriter.cs,WriteLsb,The following statement contains a magic number: while (currentLength >= 8)              {                  BaseStream.WriteByte((byte) currentData);                  currentData >>= 8;                  currentLength -= 8;              }
Magic Number,CSharpUtils,BitWriter,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitWriter.cs,WriteLsb,The following statement contains a magic number: while (currentLength >= 8)              {                  BaseStream.WriteByte((byte) currentData);                  currentData >>= 8;                  currentLength -= 8;              }
Magic Number,CSharpUtils,BitWriter,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\BitWriter.cs,WriteLsb,The following statement contains a magic number: while (currentLength >= 8)              {                  BaseStream.WriteByte((byte) currentData);                  currentData >>= 8;                  currentLength -= 8;              }
Magic Number,CSharpUtils,Hashing,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Hashing.cs,GetMd5Hash,The following statement contains a magic number: const int minBufferSize = 1 * 1024;
Magic Number,CSharpUtils,Hashing,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Hashing.cs,GetMd5Hash,The following statement contains a magic number: const int maxBufferSize = 1 * 1024 * 1024;
Magic Number,CSharpUtils,Hashing,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Hashing.cs,GetMd5Hash,The following statement contains a magic number: const int maxBufferSize = 1 * 1024 * 1024;
Magic Number,CSharpUtils,MathFloat,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathFloat.cs,Exp2,The following statement contains a magic number: return (float) Math.Pow(2.0' value);
Magic Number,CSharpUtils,MathFloat,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathFloat.cs,RExp2,The following statement contains a magic number: return (float) (1.0 / Math.Pow(2.0' value));
Magic Number,CSharpUtils,NumberUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\NumberUtils.cs,ParseIntegerConstant,The following statement contains a magic number: try              {                  value = value.Replace("_"' "");                  if (value.Substr(0' 1) == "-") return -ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 1) == "+") return +ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 2) == "0x") return Convert.ToInt32(value.Substr(2)' 16);                  if (value.Substr(0' 2) == "0b") return Convert.ToInt32(value.Substr(2)' 2);                  return Convert.ToInt32(value' defaultBase);              }              catch (FormatException formatException)              {                  throw (new FormatException("Can't parse the string '" + value + "'"' formatException));              }
Magic Number,CSharpUtils,NumberUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\NumberUtils.cs,ParseIntegerConstant,The following statement contains a magic number: try              {                  value = value.Replace("_"' "");                  if (value.Substr(0' 1) == "-") return -ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 1) == "+") return +ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 2) == "0x") return Convert.ToInt32(value.Substr(2)' 16);                  if (value.Substr(0' 2) == "0b") return Convert.ToInt32(value.Substr(2)' 2);                  return Convert.ToInt32(value' defaultBase);              }              catch (FormatException formatException)              {                  throw (new FormatException("Can't parse the string '" + value + "'"' formatException));              }
Magic Number,CSharpUtils,NumberUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\NumberUtils.cs,ParseIntegerConstant,The following statement contains a magic number: try              {                  value = value.Replace("_"' "");                  if (value.Substr(0' 1) == "-") return -ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 1) == "+") return +ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 2) == "0x") return Convert.ToInt32(value.Substr(2)' 16);                  if (value.Substr(0' 2) == "0b") return Convert.ToInt32(value.Substr(2)' 2);                  return Convert.ToInt32(value' defaultBase);              }              catch (FormatException formatException)              {                  throw (new FormatException("Can't parse the string '" + value + "'"' formatException));              }
Magic Number,CSharpUtils,NumberUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\NumberUtils.cs,ParseIntegerConstant,The following statement contains a magic number: try              {                  value = value.Replace("_"' "");                  if (value.Substr(0' 1) == "-") return -ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 1) == "+") return +ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 2) == "0x") return Convert.ToInt32(value.Substr(2)' 16);                  if (value.Substr(0' 2) == "0b") return Convert.ToInt32(value.Substr(2)' 2);                  return Convert.ToInt32(value' defaultBase);              }              catch (FormatException formatException)              {                  throw (new FormatException("Can't parse the string '" + value + "'"' formatException));              }
Magic Number,CSharpUtils,NumberUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\NumberUtils.cs,ParseIntegerConstant,The following statement contains a magic number: try              {                  value = value.Replace("_"' "");                  if (value.Substr(0' 1) == "-") return -ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 1) == "+") return +ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 2) == "0x") return Convert.ToInt32(value.Substr(2)' 16);                  if (value.Substr(0' 2) == "0b") return Convert.ToInt32(value.Substr(2)' 2);                  return Convert.ToInt32(value' defaultBase);              }              catch (FormatException formatException)              {                  throw (new FormatException("Can't parse the string '" + value + "'"' formatException));              }
Magic Number,CSharpUtils,NumberUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\NumberUtils.cs,ParseIntegerConstant,The following statement contains a magic number: try              {                  value = value.Replace("_"' "");                  if (value.Substr(0' 1) == "-") return -ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 1) == "+") return +ParseIntegerConstant(value.Substr(1));                  if (value.Substr(0' 2) == "0x") return Convert.ToInt32(value.Substr(2)' 16);                  if (value.Substr(0' 2) == "0b") return Convert.ToInt32(value.Substr(2)' 2);                  return Convert.ToInt32(value' defaultBase);              }              catch (FormatException formatException)              {                  throw (new FormatException("Can't parse the string '" + value + "'"' formatException));              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,PtrToShort_BE,The following statement contains a magic number: return (ushort) ((bytes[0] << 8) | (bytes[1] << 0));
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memset,The following statement contains a magic number: if (count >= 16)              {                  var value2 = (ushort) ((value << 8) | (value << 0));                  var value4 = ((uint) value2 << 16) | ((uint) value2 << 0);                    if (Is64)                  {                      var value8 = ((ulong) value4 << 32) | ((ulong) value4 << 0);                      var pointer8 = (ulong*) pointer;                      while (count >= 8)                      {                          *pointer8++ = value8;                          count -= 8;                      }                      pointer = (byte*) pointer8;                  }                  else                  {                      var pointer4 = (uint*) pointer;                      while (count >= 4)                      {                          *pointer4++ = value4;                          count -= 4;                      }                      pointer = (byte*) pointer4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memset,The following statement contains a magic number: if (count >= 16)              {                  var value2 = (ushort) ((value << 8) | (value << 0));                  var value4 = ((uint) value2 << 16) | ((uint) value2 << 0);                    if (Is64)                  {                      var value8 = ((ulong) value4 << 32) | ((ulong) value4 << 0);                      var pointer8 = (ulong*) pointer;                      while (count >= 8)                      {                          *pointer8++ = value8;                          count -= 8;                      }                      pointer = (byte*) pointer8;                  }                  else                  {                      var pointer4 = (uint*) pointer;                      while (count >= 4)                      {                          *pointer4++ = value4;                          count -= 4;                      }                      pointer = (byte*) pointer4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memset,The following statement contains a magic number: if (count >= 16)              {                  var value2 = (ushort) ((value << 8) | (value << 0));                  var value4 = ((uint) value2 << 16) | ((uint) value2 << 0);                    if (Is64)                  {                      var value8 = ((ulong) value4 << 32) | ((ulong) value4 << 0);                      var pointer8 = (ulong*) pointer;                      while (count >= 8)                      {                          *pointer8++ = value8;                          count -= 8;                      }                      pointer = (byte*) pointer8;                  }                  else                  {                      var pointer4 = (uint*) pointer;                      while (count >= 4)                      {                          *pointer4++ = value4;                          count -= 4;                      }                      pointer = (byte*) pointer4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memset,The following statement contains a magic number: if (count >= 16)              {                  var value2 = (ushort) ((value << 8) | (value << 0));                  var value4 = ((uint) value2 << 16) | ((uint) value2 << 0);                    if (Is64)                  {                      var value8 = ((ulong) value4 << 32) | ((ulong) value4 << 0);                      var pointer8 = (ulong*) pointer;                      while (count >= 8)                      {                          *pointer8++ = value8;                          count -= 8;                      }                      pointer = (byte*) pointer8;                  }                  else                  {                      var pointer4 = (uint*) pointer;                      while (count >= 4)                      {                          *pointer4++ = value4;                          count -= 4;                      }                      pointer = (byte*) pointer4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memset,The following statement contains a magic number: if (count >= 16)              {                  var value2 = (ushort) ((value << 8) | (value << 0));                  var value4 = ((uint) value2 << 16) | ((uint) value2 << 0);                    if (Is64)                  {                      var value8 = ((ulong) value4 << 32) | ((ulong) value4 << 0);                      var pointer8 = (ulong*) pointer;                      while (count >= 8)                      {                          *pointer8++ = value8;                          count -= 8;                      }                      pointer = (byte*) pointer8;                  }                  else                  {                      var pointer4 = (uint*) pointer;                      while (count >= 4)                      {                          *pointer4++ = value4;                          count -= 4;                      }                      pointer = (byte*) pointer4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memset,The following statement contains a magic number: if (count >= 16)              {                  var value2 = (ushort) ((value << 8) | (value << 0));                  var value4 = ((uint) value2 << 16) | ((uint) value2 << 0);                    if (Is64)                  {                      var value8 = ((ulong) value4 << 32) | ((ulong) value4 << 0);                      var pointer8 = (ulong*) pointer;                      while (count >= 8)                      {                          *pointer8++ = value8;                          count -= 8;                      }                      pointer = (byte*) pointer8;                  }                  else                  {                      var pointer4 = (uint*) pointer;                      while (count >= 4)                      {                          *pointer4++ = value4;                          count -= 4;                      }                      pointer = (byte*) pointer4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memset,The following statement contains a magic number: if (count >= 16)              {                  var value2 = (ushort) ((value << 8) | (value << 0));                  var value4 = ((uint) value2 << 16) | ((uint) value2 << 0);                    if (Is64)                  {                      var value8 = ((ulong) value4 << 32) | ((ulong) value4 << 0);                      var pointer8 = (ulong*) pointer;                      while (count >= 8)                      {                          *pointer8++ = value8;                          count -= 8;                      }                      pointer = (byte*) pointer8;                  }                  else                  {                      var pointer4 = (uint*) pointer;                      while (count >= 4)                      {                          *pointer4++ = value4;                          count -= 4;                      }                      pointer = (byte*) pointer4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memset,The following statement contains a magic number: if (count >= 16)              {                  var value2 = (ushort) ((value << 8) | (value << 0));                  var value4 = ((uint) value2 << 16) | ((uint) value2 << 0);                    if (Is64)                  {                      var value8 = ((ulong) value4 << 32) | ((ulong) value4 << 0);                      var pointer8 = (ulong*) pointer;                      while (count >= 8)                      {                          *pointer8++ = value8;                          count -= 8;                      }                      pointer = (byte*) pointer8;                  }                  else                  {                      var pointer4 = (uint*) pointer;                      while (count >= 4)                      {                          *pointer4++ = value4;                          count -= 4;                      }                      pointer = (byte*) pointer4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: if (Is64)              {                  while ((maxLength >= 8) && (*(ulong*) haystack == *(ulong*) needle))                  {                      match += 8;                      haystack += 8;                      needle += 8;                      maxLength -= 8;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: if (Is64)              {                  while ((maxLength >= 8) && (*(ulong*) haystack == *(ulong*) needle))                  {                      match += 8;                      haystack += 8;                      needle += 8;                      maxLength -= 8;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: if (Is64)              {                  while ((maxLength >= 8) && (*(ulong*) haystack == *(ulong*) needle))                  {                      match += 8;                      haystack += 8;                      needle += 8;                      maxLength -= 8;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: if (Is64)              {                  while ((maxLength >= 8) && (*(ulong*) haystack == *(ulong*) needle))                  {                      match += 8;                      haystack += 8;                      needle += 8;                      maxLength -= 8;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: if (Is64)              {                  while ((maxLength >= 8) && (*(ulong*) haystack == *(ulong*) needle))                  {                      match += 8;                      haystack += 8;                      needle += 8;                      maxLength -= 8;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: while ((maxLength >= 4) && (*(uint*) haystack == *(uint*) needle))              {                  match += 4;                  haystack += 4;                  needle += 4;                  maxLength -= 4;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: while ((maxLength >= 4) && (*(uint*) haystack == *(uint*) needle))              {                  match += 4;                  haystack += 4;                  needle += 4;                  maxLength -= 4;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: while ((maxLength >= 4) && (*(uint*) haystack == *(uint*) needle))              {                  match += 4;                  haystack += 4;                  needle += 4;                  maxLength -= 4;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: while ((maxLength >= 4) && (*(uint*) haystack == *(uint*) needle))              {                  match += 4;                  haystack += 4;                  needle += 4;                  maxLength -= 4;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatch,The following statement contains a magic number: while ((maxLength >= 4) && (*(uint*) haystack == *(uint*) needle))              {                  match += 4;                  haystack += 4;                  needle += 4;                  maxLength -= 4;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FindLargestMatchByte,The following statement contains a magic number: if (maxLength >= 4)              {                  var value2 = (ushort) ((value1 << 0) | (value1 << 8));                  var value4 = ((uint) value2 << 0) | ((uint) value2 << 16);                      if ((maxLength >= 8) && Is64)                  {                      var value8 = ((ulong) value4 << 0) | ((ulong) value4 << 32);                        while ((maxLength >= 8) && (*(ulong*) haystack == value8))                      {                          match += 8;                          haystack += 8;                          maxLength -= 8;                      }                  }                    while ((maxLength >= 4) && (*(uint*) haystack == value4))                  {                      match += 4;                      haystack += 4;                      maxLength -= 4;                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memcpy,The following statement contains a magic number: if (Is64 && (distance >= 8))              {                  while (size >= sizeof(ulong))                  {                      *(ulong*) destination = *(ulong*) source;                      destination += sizeof(ulong);                      source += sizeof(ulong);                      size -= sizeof(ulong);                  }              }              else if (distance >= 4)              {                  while (size >= sizeof(uint))                  {                      *(uint*) destination = *(uint*) source;                      destination += sizeof(uint);                      source += sizeof(uint);                      size -= sizeof(uint);                  }              }              else if (distance >= 2)              {                  while (size >= sizeof(ushort))                  {                      *(ushort*) destination = *(ushort*) source;                      destination += sizeof(ushort);                      source += sizeof(ushort);                      size -= sizeof(ushort);                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memcpy,The following statement contains a magic number: if (Is64 && (distance >= 8))              {                  while (size >= sizeof(ulong))                  {                      *(ulong*) destination = *(ulong*) source;                      destination += sizeof(ulong);                      source += sizeof(ulong);                      size -= sizeof(ulong);                  }              }              else if (distance >= 4)              {                  while (size >= sizeof(uint))                  {                      *(uint*) destination = *(uint*) source;                      destination += sizeof(uint);                      source += sizeof(uint);                      size -= sizeof(uint);                  }              }              else if (distance >= 2)              {                  while (size >= sizeof(ushort))                  {                      *(ushort*) destination = *(ushort*) source;                      destination += sizeof(ushort);                      source += sizeof(ushort);                      size -= sizeof(ushort);                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,Memcpy,The following statement contains a magic number: if (Is64 && (distance >= 8))              {                  while (size >= sizeof(ulong))                  {                      *(ulong*) destination = *(ulong*) source;                      destination += sizeof(ulong);                      source += sizeof(ulong);                      size -= sizeof(ulong);                  }              }              else if (distance >= 4)              {                  while (size >= sizeof(uint))                  {                      *(uint*) destination = *(uint*) source;                      destination += sizeof(uint);                      source += sizeof(uint);                      size -= sizeof(uint);                  }              }              else if (distance >= 2)              {                  while (size >= sizeof(ushort))                  {                      *(ushort*) destination = *(ushort*) source;                      destination += sizeof(ushort);                      source += sizeof(ushort);                      size -= sizeof(ushort);                  }              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FastHash,The following statement contains a magic number: switch (len)              {                  case 0: return 0;                  case 1: return (ptr[0] << 0);                  case 2: return (ptr[0] << 0) | (ptr[1] << 8);                  case 3: return (ptr[0] << 0) | (ptr[1] << 8) | (ptr[2] << 16);                  default:                      var hash = len;                      for (var n = 0; n < len; n++)                      {                          hash ^= n << 28;                          hash += *ptr++;                      }                      return hash;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FastHash,The following statement contains a magic number: switch (len)              {                  case 0: return 0;                  case 1: return (ptr[0] << 0);                  case 2: return (ptr[0] << 0) | (ptr[1] << 8);                  case 3: return (ptr[0] << 0) | (ptr[1] << 8) | (ptr[2] << 16);                  default:                      var hash = len;                      for (var n = 0; n < len; n++)                      {                          hash ^= n << 28;                          hash += *ptr++;                      }                      return hash;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FastHash,The following statement contains a magic number: switch (len)              {                  case 0: return 0;                  case 1: return (ptr[0] << 0);                  case 2: return (ptr[0] << 0) | (ptr[1] << 8);                  case 3: return (ptr[0] << 0) | (ptr[1] << 8) | (ptr[2] << 16);                  default:                      var hash = len;                      for (var n = 0; n < len; n++)                      {                          hash ^= n << 28;                          hash += *ptr++;                      }                      return hash;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FastHash,The following statement contains a magic number: switch (len)              {                  case 0: return 0;                  case 1: return (ptr[0] << 0);                  case 2: return (ptr[0] << 0) | (ptr[1] << 8);                  case 3: return (ptr[0] << 0) | (ptr[1] << 8) | (ptr[2] << 16);                  default:                      var hash = len;                      for (var n = 0; n < len; n++)                      {                          hash ^= n << 28;                          hash += *ptr++;                      }                      return hash;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FastHash,The following statement contains a magic number: switch (len)              {                  case 0: return 0;                  case 1: return (ptr[0] << 0);                  case 2: return (ptr[0] << 0) | (ptr[1] << 8);                  case 3: return (ptr[0] << 0) | (ptr[1] << 8) | (ptr[2] << 16);                  default:                      var hash = len;                      for (var n = 0; n < len; n++)                      {                          hash ^= n << 28;                          hash += *ptr++;                      }                      return hash;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FastHash,The following statement contains a magic number: switch (len)              {                  case 0: return 0;                  case 1: return (ptr[0] << 0);                  case 2: return (ptr[0] << 0) | (ptr[1] << 8);                  case 3: return (ptr[0] << 0) | (ptr[1] << 8) | (ptr[2] << 16);                  default:                      var hash = len;                      for (var n = 0; n < len; n++)                      {                          hash ^= n << 28;                          hash += *ptr++;                      }                      return hash;              }
Magic Number,CSharpUtils,PointerUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\PointerUtils.cs,FastHash,The following statement contains a magic number: switch (len)              {                  case 0: return 0;                  case 1: return (ptr[0] << 0);                  case 2: return (ptr[0] << 0) | (ptr[1] << 8);                  case 3: return (ptr[0] << 0) | (ptr[1] << 8) | (ptr[2] << 16);                  default:                      var hash = len;                      for (var n = 0; n < len; n++)                      {                          hash ^= n << 28;                          hash += *ptr++;                      }                      return hash;              }
Magic Number,CSharpUtils,ProduceConsumerBufferStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\ProduceConsumeBuffer.cs,TryReduceMemorySize,The following statement contains a magic number: if (_readTransactionStack.Count == 0)              {                  if (_consumePosition >= 512 * 1024 || _consumePosition >= Length / 2)                  {                      var newMemoryStream = new MemoryStream();                      _memoryStream.SliceWithLength(_consumePosition).CopyToFast(newMemoryStream);                      _consumePosition = 0;                      _memoryStream = newMemoryStream;                  }              }
Magic Number,CSharpUtils,ProduceConsumerBufferStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\ProduceConsumeBuffer.cs,TryReduceMemorySize,The following statement contains a magic number: if (_readTransactionStack.Count == 0)              {                  if (_consumePosition >= 512 * 1024 || _consumePosition >= Length / 2)                  {                      var newMemoryStream = new MemoryStream();                      _memoryStream.SliceWithLength(_consumePosition).CopyToFast(newMemoryStream);                      _consumePosition = 0;                      _memoryStream = newMemoryStream;                  }              }
Magic Number,CSharpUtils,ProduceConsumerBufferStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\ProduceConsumeBuffer.cs,TryReduceMemorySize,The following statement contains a magic number: if (_readTransactionStack.Count == 0)              {                  if (_consumePosition >= 512 * 1024 || _consumePosition >= Length / 2)                  {                      var newMemoryStream = new MemoryStream();                      _memoryStream.SliceWithLength(_consumePosition).CopyToFast(newMemoryStream);                      _consumePosition = 0;                      _memoryStream = newMemoryStream;                  }              }
Magic Number,CSharpUtils,ArrayUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\ArrayUtils.cs,HexDump,The following statement contains a magic number: while (offset < maxSize)              {                  var rowCount = Math.Min(maxSize - offset' 16);                    for (var n = 0; n < rowCount; n++)                  {                      Console.Write("%02X ".Sprintf(data[offset + n]));                  }                  for (var n = 0; n < rowCount; n++)                  {                      var c = ((char) data[offset + n]);                      Console.Write("{0}"' char.IsControl(c) ? '?' : c);                  }                    Console.WriteLine("");                  offset += rowCount;              }
Magic Number,CSharpUtils,DateTimeRange,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\DateTimeRange.cs,ConvertFromUnixTimestamp,The following statement contains a magic number: var origin = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,CSharpUtils,DateTimeRange,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\DateTimeRange.cs,ConvertToUnixTimestamp,The following statement contains a magic number: var origin = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,FastClampToByte,The following statement contains a magic number: if (value > 255) return 255;
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,FastClampToByte,The following statement contains a magic number: if (value > 255) return 255;
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,ByteSwap,The following statement contains a magic number: return (ushort) ((value >> 8) | (value << 8));
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,ByteSwap,The following statement contains a magic number: return (ushort) ((value >> 8) | (value << 8));
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,ByteSwap,The following statement contains a magic number: return (                  ((uint) ByteSwap((ushort) (value >> 0)) << 16) |                  ((uint) ByteSwap((ushort) (value >> 16)) << 0)              );
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,ByteSwap,The following statement contains a magic number: return (                  ((uint) ByteSwap((ushort) (value >> 0)) << 16) |                  ((uint) ByteSwap((ushort) (value >> 16)) << 0)              );
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,ByteSwap,The following statement contains a magic number: return (                  ((ulong) ByteSwap((uint) (value >> 0)) << 32) |                  ((ulong) ByteSwap((uint) (value >> 32)) << 0)              );
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,ByteSwap,The following statement contains a magic number: return (                  ((ulong) ByteSwap((uint) (value >> 0)) << 32) |                  ((ulong) ByteSwap((uint) (value >> 32)) << 0)              );
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,NumberOfSetBits,The following statement contains a magic number: i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,NumberOfSetBits,The following statement contains a magic number: return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
Magic Number,CSharpUtils,MathUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\MathUtils.cs,NumberOfSetBits,The following statement contains a magic number: return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
Magic Number,CSharpUtils,StructUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\StructUtils.cs,GetULongFrom2UInt,The following statement contains a magic number: return ((ulong) low) | (((ulong) high) << 32);
Magic Number,CSharpUtils,StructUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\StructUtils.cs,ConvertULongTo2UInt,The following statement contains a magic number: high = ((uint) (value >> 32) & uint.MaxValue);
Magic Number,CSharpUtils,TimeSpanUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\TimeSpanUtils.cs,FromMicroseconds,The following statement contains a magic number: return TimeSpan.FromMilliseconds((double) microseconds / (double) 1000.0);
Magic Number,CSharpUtils,TimeSpanUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\TimeSpanUtils.cs,InfiniteLoopDetector,The following statement contains a magic number: using (var timer = new Timer(4.0 * 1000))              {                  bool[] cancel = {false};                  timer.Elapsed += (sender' e) =>                  {                      if (cancel[0]) return;                      Console.WriteLine("InfiniteLoop Detected! : {0} : {1}"' description' e.SignalTime);                      loopAction?.Invoke();                  };                  timer.AutoReset = false;                  timer.Start();                  try                  {                      action();                  }                  finally                  {                      cancel[0] = true;                      timer.Enabled = false;                      timer.Stop();                  }              }
Magic Number,CSharpUtils,TimeSpanUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\TimeSpanUtils.cs,InfiniteLoopDetector,The following statement contains a magic number: using (var timer = new Timer(4.0 * 1000))              {                  bool[] cancel = {false};                  timer.Elapsed += (sender' e) =>                  {                      if (cancel[0]) return;                      Console.WriteLine("InfiniteLoop Detected! : {0} : {1}"' description' e.SignalTime);                      loopAction?.Invoke();                  };                  timer.AutoReset = false;                  timer.Start();                  try                  {                      action();                  }                  finally                  {                      cancel[0] = true;                      timer.Enabled = false;                      timer.Stop();                  }              }
Magic Number,CSharpUtils.Containers.RedBlackTree,Node,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Containers\RedBlackTree\RedBlackTreeWithStatsNode.cs,PrintTree,The following statement contains a magic number: Console.WriteLine(                      "{0}- {1}:{2}{3}"'                      new string(' '' level * 2)'                      label' this' info                  );
Magic Number,CSharpUtils.Extensions,BinaryReaderWriterExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\BinaryReaderWriterExtensions.cs,ReadUint32Endian,The following statement contains a magic number: var bytes = binaryReader.ReadBytes(4);
Magic Number,CSharpUtils.Extensions,BinaryReaderWriterExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\BinaryReaderWriterExtensions.cs,ReadSingleEndian,The following statement contains a magic number: var bytes = binaryReader.ReadBytes(4);
Magic Number,CSharpUtils.Extensions,BinaryReaderWriterExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\BinaryReaderWriterExtensions.cs,ReadUint16Endian,The following statement contains a magic number: var bytes = binaryReader.ReadBytes(2);
Magic Number,CSharpUtils.Extensions,BinaryReaderWriterExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\BinaryReaderWriterExtensions.cs,WriteEndian,The following statement contains a magic number: binaryWriter.Write((byte) ((value >> 8) & 0xFF));
Magic Number,CSharpUtils.Extensions,BinaryReaderWriterExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\BinaryReaderWriterExtensions.cs,WriteEndian,The following statement contains a magic number: binaryWriter.Write((byte) ((value >> 24) & 0xFF));
Magic Number,CSharpUtils.Extensions,BinaryReaderWriterExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\BinaryReaderWriterExtensions.cs,WriteEndian,The following statement contains a magic number: binaryWriter.Write((byte) ((value >> 16) & 0xFF));
Magic Number,CSharpUtils.Extensions,BinaryReaderWriterExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\BinaryReaderWriterExtensions.cs,WriteEndian,The following statement contains a magic number: binaryWriter.Write((byte) ((value >> 8) & 0xFF));
Magic Number,CSharpUtils.Extensions,DateTimeExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\DateTimeExtensions.cs,GetTotalNanoseconds,The following statement contains a magic number: return dateTime.Ticks * 10;
Magic Number,CSharpUtils.Extensions,DateTimeExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\DateTimeExtensions.cs,GetTotalMicroseconds,The following statement contains a magic number: return dateTime.Ticks / 10;
Magic Number,CSharpUtils.Extensions,DateTimeExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\DateTimeExtensions.cs,FromMicroseconds,The following statement contains a magic number: return new DateTime(microseconds * 10);
Magic Number,CSharpUtils.Extensions,ListExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\ListExtensions.cs,BoundIndex,The following statement contains a magic number: var maxIterations = 100;
Magic Number,CSharpUtils.Extensions,ListExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\ListExtensions.cs,BoundIndex,The following statement contains a magic number: while (higherIndex > lowerIndex)              {                  if (higherIndex - lowerIndex <= 2)                  {                      lowerIndex++;                  }                  index = lowerIndex + (higherIndex - lowerIndex) / 2;                  var sign = sortedAndNonRepeatedItems[index].CompareTo(item);                  //Console.WriteLine(String.Format("Index: {0} [{1} - {2}] : {3}"' Index' LowerIndex' HigherIndex' Sign));                    if (sign < 0)                  {                      lowerIndex = index;                  }                  else if (sign > 0)                  {                      higherIndex = index;                  }                  else                  {                      break;                  }                  if (maxIterations-- <= 0)                  {                      throw(new Exception("Internal Error!"));                  }              }
Magic Number,CSharpUtils.Extensions,ListExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\ListExtensions.cs,BoundIndex,The following statement contains a magic number: while (higherIndex > lowerIndex)              {                  if (higherIndex - lowerIndex <= 2)                  {                      lowerIndex++;                  }                  index = lowerIndex + (higherIndex - lowerIndex) / 2;                  var sign = sortedAndNonRepeatedItems[index].CompareTo(item);                  //Console.WriteLine(String.Format("Index: {0} [{1} - {2}] : {3}"' Index' LowerIndex' HigherIndex' Sign));                    if (sign < 0)                  {                      lowerIndex = index;                  }                  else if (sign > 0)                  {                      higherIndex = index;                  }                  else                  {                      break;                  }                  if (maxIterations-- <= 0)                  {                      throw(new Exception("Internal Error!"));                  }              }
Magic Number,CSharpUtils.Extensions,TimeSpanExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\TimeSpanExtensions.cs,GetTotalMicroseconds,The following statement contains a magic number: return timeSpan.Ticks / (TimeSpan.TicksPerMillisecond / 1000);
Magic Number,CSharpUtils.Extensions,LinqExExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\LinqExExtensions.cs,BinarySearch,The following statement contains a magic number: while (min < max)              {                  int mid = (max + min) / 2;                  T midItem = list[mid];                  TKey midKey = keySelector(midItem);                  int comp = midKey.CompareTo(key);                  if (comp < 0)                  {                      min = mid + 1;                  }                  else if (comp > 0)                  {                      max = mid - 1;                  }                  else                  {                      return midItem;                  }              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,ReadAllContentsAsString,The following statement contains a magic number: if (Equals(encoding' Encoding.UTF8))              {                  if (data.Length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF)                  {                      data = data.Skip(3).ToArray();                  }              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,ReadAllContentsAsString,The following statement contains a magic number: if (Equals(encoding' Encoding.UTF8))              {                  if (data.Length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF)                  {                      data = data.Skip(3).ToArray();                  }              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,ReadAllContentsAsString,The following statement contains a magic number: if (Equals(encoding' Encoding.UTF8))              {                  if (data.Length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF)                  {                      data = data.Skip(3).ToArray();                  }              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,CountStringzBytes,The following statement contains a magic number: if (alignTo4)              {                  var bytes2 = stream.SliceWithLength(startPosition + zeroIndex' 5).ReadBytesUpTo(5);                  var n = 0;                  for (; n < bytes2.Length; n++) if (bytes2[n] != 0) break;                  return zeroIndex + n;              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,CountStringzBytes,The following statement contains a magic number: if (alignTo4)              {                  var bytes2 = stream.SliceWithLength(startPosition + zeroIndex' 5).ReadBytesUpTo(5);                  var n = 0;                  for (; n < bytes2.Length; n++) if (bytes2[n] != 0) break;                  return zeroIndex + n;              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,CopyToFast,The following statement contains a magic number: var bufferSize = (int) Math.Min(fromStream.Length' 2 * 1024 * 1024);
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,CopyToFast,The following statement contains a magic number: var bufferSize = (int) Math.Min(fromStream.Length' 2 * 1024 * 1024);
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,CopyToFast,The following statement contains a magic number: var bufferSize = (int) Math.Min(fromStream.Length' 2 * 1024 * 1024);
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,WriteByteRepeated,The following statement contains a magic number: if (totalCount > 0)              {                  long maxBuffer = 2 * 1024 * 1024;                  var bytes = new byte[Math.Min(maxBuffer' totalCount)];                  PointerUtils.Memset(bytes' Byte' bytes.Length);                  var left = totalCount;                  long current = 0;                  if (progress == null) progress = (cur' max) => { };                    progress(0' totalCount);                    while (left > 0)                  {                      var toWrite = Math.Min(bytes.Length' left);                      stream.Write(bytes' 0' (int) toWrite);                      left -= toWrite;                      current += toWrite;                      progress(current' totalCount);                  }              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,WriteByteRepeated,The following statement contains a magic number: if (totalCount > 0)              {                  long maxBuffer = 2 * 1024 * 1024;                  var bytes = new byte[Math.Min(maxBuffer' totalCount)];                  PointerUtils.Memset(bytes' Byte' bytes.Length);                  var left = totalCount;                  long current = 0;                  if (progress == null) progress = (cur' max) => { };                    progress(0' totalCount);                    while (left > 0)                  {                      var toWrite = Math.Min(bytes.Length' left);                      stream.Write(bytes' 0' (int) toWrite);                      left -= toWrite;                      current += toWrite;                      progress(current' totalCount);                  }              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,WriteByteRepeated,The following statement contains a magic number: if (totalCount > 0)              {                  long maxBuffer = 2 * 1024 * 1024;                  var bytes = new byte[Math.Min(maxBuffer' totalCount)];                  PointerUtils.Memset(bytes' Byte' bytes.Length);                  var left = totalCount;                  long current = 0;                  if (progress == null) progress = (cur' max) => { };                    progress(0' totalCount);                    while (left > 0)                  {                      var toWrite = Math.Min(bytes.Length' left);                      stream.Write(bytes' 0' (int) toWrite);                      left -= toWrite;                      current += toWrite;                      progress(current' totalCount);                  }              }
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,WriteVariableUintBit8Extends,The following statement contains a magic number: do              {                  byte Byte = (byte) (value & 0x7F);                  value >>= 7;                  if (value != 0) Byte |= 0x80;                  stream.WriteByte(Byte);              } while (value != 0);
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,WriteVariableUlongBit8Extends,The following statement contains a magic number: do              {                  byte Byte = (byte) (value & 0x7F);                  value >>= 7;                  if (value != 0) Byte |= 0x80;                  stream.WriteByte(Byte);              } while (value != 0);
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,ReadVariableUintBit8Extends,The following statement contains a magic number: do              {                  c = stream.ReadByte();                  if (c == -1) throw (new Exception("Incomplete VariableUintBit8Extends"));                  v |= ((uint) c & 0x7F) << shift;                  shift += 7;              } while ((c & 0x80) != 0);
Magic Number,CSharpUtils.Extensions,StreamExtensions,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Extensions\StreamExtensions.cs,ReadVariableUlongBit8Extends,The following statement contains a magic number: do              {                  c = stream.ReadByte();                  if (c == -1) throw (new Exception("Incomplete VariableUintBit8Extends"));                  v |= ((ulong) c & 0x7F) << shift;                  shift += 7;              } while ((c & 0x80) != 0);
Magic Number,CSharpUtils.Getopt,GetoptCommandLineProgram,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Getopt\GetoptCommandLineProgram.cs,ShowHelp,The following statement contains a magic number: Console.WriteLine(                  "{0} - {1} - {2} - {3} - {4}"'                  versionInfo.FileDescription'                  string.Join("."' versionInfo.FileVersion.Split('.').Take(2))'                  versionInfo.Comments'                  versionInfo.CompanyName'                  versionInfo.LegalCopyright              );
Magic Number,CSharpUtils.Getopt,GetoptCommandLineProgram,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Getopt\GetoptCommandLineProgram.cs,Run,The following statement contains a magic number: try              {                  Getopt.Process();              }              catch (TargetInvocationException targetInvocationException)              {                  Console.Error.WriteLine(targetInvocationException.InnerException);                  Environment.Exit(-1);              }              catch (Exception exception)              {                  //Console.Error.WriteLine(Exception.Message);                  Console.Error.WriteLine(exception);                  Environment.Exit(-2);              }
Magic Number,CSharpUtils.Json,Json,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Json\JSON.cs,Escape,The following statement contains a magic number: foreach (var c in stringToEscape)              {                  switch (c)                  {                      case '/':                      case '\"':                      case '\'':                      case '\b':                      case '\f':                      case '\n':                      case '\r':                      case '\t':                          ret += '\\' + c;                          break;                      default:                          if (c > 255)                          {                              ret += "\\u" + Convert.ToString(c' 16).PadLeft(4' '0');                          }                          else                          {                              ret += c;                          }                          break;                  }              }
Magic Number,CSharpUtils.Json,Json,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Json\JSON.cs,Escape,The following statement contains a magic number: foreach (var c in stringToEscape)              {                  switch (c)                  {                      case '/':                      case '\"':                      case '\'':                      case '\b':                      case '\f':                      case '\n':                      case '\r':                      case '\t':                          ret += '\\' + c;                          break;                      default:                          if (c > 255)                          {                              ret += "\\u" + Convert.ToString(c' 16).PadLeft(4' '0');                          }                          else                          {                              ret += c;                          }                          break;                  }              }
Magic Number,CSharpUtils.Json,Json,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Json\JSON.cs,Escape,The following statement contains a magic number: foreach (var c in stringToEscape)              {                  switch (c)                  {                      case '/':                      case '\"':                      case '\'':                      case '\b':                      case '\f':                      case '\n':                      case '\r':                      case '\t':                          ret += '\\' + c;                          break;                      default:                          if (c > 255)                          {                              ret += "\\u" + Convert.ToString(c' 16).PadLeft(4' '0');                          }                          else                          {                              ret += c;                          }                          break;                  }              }
Magic Number,CSharpUtils.Misc.Acme1,Acme1File,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Misc\Acme1\Acme1File.cs,Load,The following statement contains a magic number: foreach (var part in parts)              {                  //Console.WriteLine(Part.EscapeString());                    var subparts = part.Split(new[] {"\r\n"' "\r"' "\n"}' 2' StringSplitOptions.None);                  var infoMatch = Regex.Match(subparts[0]' @"(\d+).*$"' RegexOptions.Compiled | RegexOptions.Multiline);                  var text = subparts[1].TrimEnd();                  var id = ConvertEx.FlexibleToInt(infoMatch.Groups[1].Value);                    _entries[id] = new Entry()                  {                      Id = id'                      Text = text'                  };                  //Console.WriteLine(Subparts.ToStringArray().EscapeString());              }
Magic Number,CSharpUtils.Streams,MapStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\MapStream.cs,Unserialize,The following statement contains a magic number: if (targetStream.ReadString(4) != "MAPS")                  throw (new InvalidDataException("Not a MapStream serialized stream"));
Magic Number,CSharpUtils.Streams,StreamBitReader,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\StreamBitReader.cs,PrepareData,The following statement contains a magic number: ByteAvailableBits = 8;
Magic Number,CSharpUtils.Streams,StreamChunker2,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\StreamChunker2.cs,Split,The following statement contains a magic number: var tempDoubleBuffer = new byte[separator.Length * 2];
Magic Number,CSharpUtils.Streams,StreamStructCachedArrayWrapper<TType>,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\StreamStructCachedArrayWrapper.cs,SecureUpToItem,The following statement contains a magic number: if (BufferedItemsCount - offset < numberOfItemsToBuffer / 2)              {                  while (true)                  {                      if (BufferedItemsCount - offset < numberOfItemsToBuffer / 2)                      {                          SecureUpToItem(BufferedItemsCount + numberOfItemsToBuffer);                      }                        if (offset >= BufferedItemsCount)                      {                          Thread.Sleep(1);                      }                      else                      {                          break;                      }                      //Console.Write("Wait({0}' {1})"' Offset' BufferedItemsCount);                  }              }
Magic Number,CSharpUtils.Streams,StreamStructCachedArrayWrapper<TType>,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\StreamStructCachedArrayWrapper.cs,SecureUpToItem,The following statement contains a magic number: if (BufferedItemsCount - offset < numberOfItemsToBuffer / 2)              {                  while (true)                  {                      if (BufferedItemsCount - offset < numberOfItemsToBuffer / 2)                      {                          SecureUpToItem(BufferedItemsCount + numberOfItemsToBuffer);                      }                        if (offset >= BufferedItemsCount)                      {                          Thread.Sleep(1);                      }                      else                      {                          break;                      }                      //Console.Write("Wait({0}' {1})"' Offset' BufferedItemsCount);                  }              }
Magic Number,CSharpUtils.Threading,GreenThread,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Threading\GreenThread.cs,ThisSemaphoreWaitOrParentThreadStopped,The following statement contains a magic number: while (true)              {                  // If the parent thread have been stopped. We should not wait any longer.                  if (Kill || !ParentThread.IsAlive)                  {                      break;                  }                    if (ThisSemaphore.WaitOne(20))                  {                      // Signaled.                      break;                  }              }
Missing Default,CSharpUtils.Streams,ConcatStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\ConcatStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.End:                      Position = offset + Length;                      break;                  case SeekOrigin.Current:                      Position += offset;                      break;              }
Missing Default,CSharpUtils.Streams,MapStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\MapStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.Current:                      Position = Position + offset;                      break;                  case SeekOrigin.End:                      Position = Length + offset;                      break;              }
Missing Default,CSharpUtils.Streams,SliceStream,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils\Streams\SliceStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.Current:                      Position = Position + offset;                      break;                  case SeekOrigin.End:                      Position = Length + offset;                      break;              }
