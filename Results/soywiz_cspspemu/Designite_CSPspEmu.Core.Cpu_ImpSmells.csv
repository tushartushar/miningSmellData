Implementation smell,Namespace,Class,File,Method,Description
Long Method,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The method has 228 lines of code.
Long Method,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,AnalyzeBranches,The method has 106 lines of code.
Long Method,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,The method has 131 lines of code.
Long Method,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The method has 117 lines of code.
Complex Method,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,Cyclomatic complexity of the method is 12
Complex Method,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,Assemble,Cyclomatic complexity of the method is 8
Complex Method,CSPspEmu.Core.Cpu.InstructionCache,MethodCompilerThread,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\InstructionCache\MethodCache.cs,_GenerateForPC,Cyclomatic complexity of the method is 9
Complex Method,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,AnalyzeBranches,Cyclomatic complexity of the method is 10
Complex Method,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,Cyclomatic complexity of the method is 9
Complex Method,CSPspEmu.Core.Cpu.VFpu,VfpuConstants,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuConstants.cs,GetRegisterNames,Cyclomatic complexity of the method is 8
Long Parameter List,CSPspEmu.Core.Cpu.Emitter,AstMipsGenerator,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\AstMipsGenerator.cs,MemoryGetPointer,The method has 5 parameters. Parameters: memory' address' safe' errorDescription' invalidAddress
Long Parameter List,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_comp_impl,The method has 7 parameters. Parameters: cpuThreadState' s' t' fcUnordererd' fcEqual' fcLess' fcInvQnan
Long Parameter List,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The method has 7 parameters. Parameters: cpuThreadState' save' r0' r1' r2' r3' address
Long Parameter List,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The method has 7 parameters. Parameters: cpuThreadState' save' r0' r1' r2' r3' address
Long Parameter List,CSPspEmu.Core.Cpu.Dynarec,DynarecFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.cs,CreateFunction,The method has 6 parameters. Parameters: instructionReader' pc' exploreNewPcCallback' doDebug' doLog' checkValidAddress
Long Parameter List,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,InternalFunctionCompiler,The method has 8 parameters. Parameters: injectContext' mipsMethodEmitter' dynarecFunctionCompiler' instructionReader' exploreNewPcCallback' entryPc' doLog' checkValidAddress
Long Parameter List,CSPspEmu.Core.Cpu.Table,InstructionTable,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionTable.cs,Id,The method has 5 parameters. Parameters: name' binaryEncoding' asmEncoding' addressType' instructionType
Long Parameter List,CSPspEmu.Core.Cpu.VFpu,VfpuRegisterInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuRegisterInfo.cs,VfpuRegisterInfo,The method has 5 parameters. Parameters: size' type' matrix' column' row
Long Identifier,CSPspEmu.Core.Cpu,CpuProcessor,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuProcessor.cs,,The length of the parameter RegisteredNativeSyscallMethods is 30.
Long Identifier,CSPspEmu.Core.Cpu,DynarecConfig,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\_DynarecConfig.cs,,The length of the parameter FunctionCallWithStaticReferences is 32.
Long Identifier,CSPspEmu.Core.Cpu,DynarecConfig,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\_DynarecConfig.cs,,The length of the parameter EnableFastPspMemoryUtilsGetFastMemoryReader is 43.
Long Identifier,CSPspEmu.Core.Cpu,DynarecConfig,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\_DynarecConfig.cs,,The length of the parameter AllowCreatingUsedFunctionsInBackground is 38.
Long Identifier,CSPspEmu.Core.Cpu,DynarecConfig,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\_DynarecConfig.cs,,The length of the parameter ForceJitOptimizationsOnEvenLargeFunctions is 41.
Long Identifier,CSPspEmu.Core.Cpu,DynarecConfig,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\_DynarecConfig.cs,,The length of the parameter InstructionCountToDisableOptimizations is 38.
Long Identifier,CSPspEmu.Core.Cpu.Emitter,AstMipsGenerator,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\AstMipsGenerator.cs,,The length of the parameter CpuThreadStateMethodCacheFieldInfo is 34.
Long Identifier,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,,The length of the parameter _instructionsEmitedSinceLastWaypoint is 36.
Long Statement,CSPspEmu.Core.Cpu.Emitter,AstMipsGenerator,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\AstMipsGenerator.cs,MethodCacheInfoCallDynamicPc,The length of the statement  "            //	var Call = (AstNodeExpr)ast.CallInstance(GetMethodCacheInfoAtPC(PC)' (Action<CpuThreadState>)MethodCacheInfo.Methods.CallDelegate' ast.CpuThreadState); " is 154.
Long Statement,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_cvt_w_s_impl,The length of the statement  "            //case CpuThreadState.FCR31.TypeEnum.Floor: CpuThreadState.FPR_I[FD] = (int)MathFloat.Floor(CpuThreadState.FPR[FS]); break; " is 123.
Long Statement,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The length of the statement  "                    //Console.Error.WriteLine("_lvl_svl_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory); " is 148.
Long Statement,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The length of the statement  "                    //Console.Error.WriteLine("_lvl_svl_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory); " is 148.
Long Statement,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The length of the statement  "                    //Console.Error.WriteLine("_lvl_svr_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory); " is 148.
Long Statement,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The length of the statement  "                    //Console.Error.WriteLine("_lvl_svr_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory); " is 148.
Long Statement,CSPspEmu.Core.Cpu.Emitter,VfpuRuntimeRegister,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Vfpu.Utils.cs,SetRegApplyPrefix2,The length of the statement  "					ast.Statement(ast.CallStatic((Action<string' int' uint' float>)CheckVfpuRegister' CalledFrom' RegIndex' PC' ast.Cast<float>(GetLocal(RegIndex))))' " is 146.
Long Statement,CSPspEmu.Core.Cpu.InstructionCache,MethodCompilerThread,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\InstructionCache\MethodCache.cs,_GenerateForPC,The length of the statement  "                            "({0}): (analyze: {1}' generateAST: {2}' optimize: {3}' generateIL: {4}' createDelegate: {5}' link: {6}): ({1}' {2}' {3}' {4}' {5}' {6}) : {7} ms"' " is 147.
Long Statement,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,CreateFunction,The length of the statement  "                    //ast.Comment("Returns immediately when argument CpuThreadState is null' so we can call it on the generation thread to do prelinking.")' " is 136.
Long Statement,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,The length of the statement  "                    throw new KeyNotFoundException($"Can't find key {_entryPc:X} in list [{_labels.Select(it => $"{it.Key:X}").JoinToString("'")}]"); " is 129.
Long Statement,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,The length of the statement  "                                //	GeneratorCSharpPsp.GenerateString<GeneratorCSharpPsp>(AstOptimizerPsp.GlobalOptimize(CpuProcessor' JumpInstruction))' " is 120.
Long Statement,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,ShowInstructionStats,The length of the statement  "                //	foreach (var Instruction in MipsMethodEmiter.SafeILGenerator.GetEmittedInstructions()) Console.WriteLine(Instruction); " is 121.
Long Statement,CSPspEmu.Core.Cpu.VFpu,VfpuDestinationPrefix,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuPrefix.cs,CheckPrefixUsage,The length of the statement  "            //Console.WriteLine("VfpuDestinationPrefix.CheckPrefixUsage | {0:X8} : {1:X8} | {2:X8} | {3} | {4}"' Value' DeclaredPC' PC' Enabled' UsedCount); " is 144.
Complex Conditional,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetIndexCell,The conditional expression  "matrix < 0 || matrix >= 8 || column < 0 || column >= 4 || row < 0 || row >= 4"  is complex.
Empty Catch Block,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,ExecuteAt,The method has an empty catch block.
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseVfprRotate,The following statement contains a magic number: BitUtils.Insert(ref imm5' 0' 2' (uint) cosIndex);
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseVfprRotate,The following statement contains a magic number: BitUtils.Insert(ref imm5' 2' 2' (uint) sinIndex);
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseVfprRotate,The following statement contains a magic number: BitUtils.Insert(ref imm5' 2' 2' (uint) sinIndex);
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseVfprRotate,The following statement contains a magic number: BitUtils.Insert(ref imm5' 4' 1' negatedSin ? 1U : 0U);
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseAndUpdateVfprDestinationPrefix,The following statement contains a magic number: switch (registerName)              {                  case "m":                  case "M":                      vfpuPrefix.DestinationMask(index' true);                      break;                  case "0:1":                      vfpuPrefix.DestinationMask(index' false);                      vfpuPrefix.DestinationSaturation(index' 1);                      break;                  case "-1:1":                      vfpuPrefix.DestinationMask(index' false);                      vfpuPrefix.DestinationSaturation(index' 3);                      break;                  default: throw new NotImplementedException($"Invalid RegisterName {registerName}");              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseAndUpdateVfprSourceTargetPrefix,The following statement contains a magic number: switch (registerName)              {                  case "x":                      isConstant = false;                      setIndex = 0;                      break;                  case "y":                      isConstant = false;                      setIndex = 1;                      break;                  case "z":                      isConstant = false;                      setIndex = 2;                      break;                  case "w":                      isConstant = false;                      setIndex = 3;                      break;                  case "3":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "0":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/3":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/4":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "2":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/6":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1/2":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  default: throw new NotImplementedException($"Invalid RegisterName {registerName}");              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseAndUpdateVfprSourceTargetPrefix,The following statement contains a magic number: switch (registerName)              {                  case "x":                      isConstant = false;                      setIndex = 0;                      break;                  case "y":                      isConstant = false;                      setIndex = 1;                      break;                  case "z":                      isConstant = false;                      setIndex = 2;                      break;                  case "w":                      isConstant = false;                      setIndex = 3;                      break;                  case "3":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "0":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/3":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/4":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "2":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/6":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1/2":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  default: throw new NotImplementedException($"Invalid RegisterName {registerName}");              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseAndUpdateVfprSourceTargetPrefix,The following statement contains a magic number: switch (registerName)              {                  case "x":                      isConstant = false;                      setIndex = 0;                      break;                  case "y":                      isConstant = false;                      setIndex = 1;                      break;                  case "z":                      isConstant = false;                      setIndex = 2;                      break;                  case "w":                      isConstant = false;                      setIndex = 3;                      break;                  case "3":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "0":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/3":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/4":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "2":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/6":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1/2":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  default: throw new NotImplementedException($"Invalid RegisterName {registerName}");              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseAndUpdateVfprSourceTargetPrefix,The following statement contains a magic number: switch (registerName)              {                  case "x":                      isConstant = false;                      setIndex = 0;                      break;                  case "y":                      isConstant = false;                      setIndex = 1;                      break;                  case "z":                      isConstant = false;                      setIndex = 2;                      break;                  case "w":                      isConstant = false;                      setIndex = 3;                      break;                  case "3":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "0":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/3":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/4":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "2":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/6":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1/2":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  default: throw new NotImplementedException($"Invalid RegisterName {registerName}");              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseAndUpdateVfprSourceTargetPrefix,The following statement contains a magic number: switch (registerName)              {                  case "x":                      isConstant = false;                      setIndex = 0;                      break;                  case "y":                      isConstant = false;                      setIndex = 1;                      break;                  case "z":                      isConstant = false;                      setIndex = 2;                      break;                  case "w":                      isConstant = false;                      setIndex = 3;                      break;                  case "3":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "0":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/3":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/4":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "2":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/6":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1/2":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  default: throw new NotImplementedException($"Invalid RegisterName {registerName}");              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,ParseAndUpdateVfprSourceTargetPrefix,The following statement contains a magic number: switch (registerName)              {                  case "x":                      isConstant = false;                      setIndex = 0;                      break;                  case "y":                      isConstant = false;                      setIndex = 1;                      break;                  case "z":                      isConstant = false;                      setIndex = 2;                      break;                  case "w":                      isConstant = false;                      setIndex = 3;                      break;                  case "3":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "0":                      isConstant = true;                      setIndex = 0;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/3":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1":                      isConstant = true;                      setIndex = 1;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/4":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "2":                      isConstant = true;                      setIndex = 2;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  case "1/6":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' true);                      break;                  case "1/2":                      isConstant = true;                      setIndex = 3;                      vfpuPrefix.SourceAbsolute(index' false);                      break;                  default: throw new NotImplementedException($"Invalid RegisterName {registerName}");              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: var lineTokens = line.Split(new[] {' '' '\t'}' 2);
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (instructionName.EndsWith(".p")) vfpuSize = 2;
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (instructionName.EndsWith(".t")) vfpuSize = 3;
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (instructionName.EndsWith(".q")) vfpuSize = 4;
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (!Instructions.ContainsKey(instructionName))              {                  // Vfpu instruction with suffix.                  if (vfpuSize > 0)                  {                      instructionName.Substr(-2);                      instructionName = instructionName.Substr(0' -2);                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (!Instructions.ContainsKey(instructionName))              {                  // Vfpu instruction with suffix.                  if (vfpuSize > 0)                  {                      instructionName.Substr(-2);                      instructionName = instructionName.Substr(0' -2);                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (Instructions.TryGetValue(instructionName' out instructionInfo))              {                  var instruction = new Instruction()                  {                      Value = instructionInfo.Value & instructionInfo.Mask'                  };                    if (vfpuSize > 0)                  {                      instruction.OneTwo = vfpuSize;                  }                    var matches = Matcher(instructionInfo.AsmEncoding' (lineTokens.Length > 1) ? lineTokens[1] : "");                  foreach (var match in matches)                  {                      var key = match.Key;                      var value = match.Value;                        switch (key)                      {                          // VFPU                          // Vector registers                          case "%zs":                          case "%zp":                          case "%zt":                          case "%zq":                          case "%zm":                              instruction.Vd = ParseVfprName(vfpuSize' value);                              break;                          case "%ys":                          case "%yp":                          case "%yt":                          case "%yq":                          case "%ym":                          case "%yn":                          case "%tym":                              if (key == "%tym")                              {                                  value = ((value[0] == 'M') ? 'E' : 'M') + value.Substring(1);                              }                              instruction.Vs = ParseVfprName(vfpuSize' value);                              break;                          case "%xs":                          case "%xp":                          case "%xt":                          case "%xq":                          case "%xm":                              instruction.Vt = ParseVfprName(vfpuSize' value);                              break;                          case "%vk":                              instruction.Imm5 = ParseVfprConstantName(value);                              break;                            case "%vr":                              instruction.Imm5 = ParseVfprRotate(value);                              break;                            //case "%zm": throw(new NotImplementedException("zm"));                            // sv.q %Xq' %Y                          case "%Xq":                              instruction.Vt51 = ParseVfprName(vfpuSize' value);                              break;                          case "%Y":                          {                              var info = ParseVfprOffset(vfpuSize' value);                              if ((info.Offset % 4) != 0) throw(new Exception("Offset must be multiple of 4"));                              instruction.Imm14 = info.Offset / 4;                              instruction.Rs = info.Rs;                          }                              break;                            // VFPU: prefixes (source/target)                          case "%vp0":                          case "%vp1":                          case "%vp2":                          case "%vp3":                          {                              var index = int.Parse(key.Substr(-1));                              VfpuPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprSourceTargetPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                          // VFPU: prefixes (destination)                          case "%vp4":                          case "%vp5":                          case "%vp6":                          case "%vp7":                          {                              var index = int.Parse(key.Substr(-1)) - 4;                              VfpuDestinationPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprDestinationPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                            //case "%xs": Instruction.VD = ParseVfprName(VfpuSize' Value); break;                            // FPU                          case "%S":                              instruction.Fs = ParseFprName(value);                              break;                          case "%D":                              instruction.Fd = ParseFprName(value);                              break;                          case "%T":                              instruction.Ft = ParseFprName(value);                              break;                            // CPU                          case "%J":                          case "%s":                              instruction.Rs = ParseGprName(value);                              break;                          case "%d":                              instruction.Rd = ParseGprName(value);                              break;                          case "%t":                              instruction.Rt = ParseGprName(value);                              break;                            case "%a":                              instruction.Pos = (uint) ParseIntegerConstant(value);                              break;                          case "%ne":                              instruction.SizeE = (uint) ParseIntegerConstant(value);                              break;                          case "%ni":                              instruction.SizeI = (uint) ParseIntegerConstant(value);                              break;                            case "%p":                              instruction.Rd = ParseIntegerConstant(value);                              break;                            case "%c":                          case "%C":                              instruction.Code = (uint) ParseIntegerConstant(value);                              break;                          case "%vi":                          case "%i":                              instruction.Imm = ParseIntegerConstant(value);                              break;                          case "%I":                              instruction.Immu = (uint) ParseIntegerConstant(value);                              break;                            case "%j":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Abs26                              });                              break;                          case "%O":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Rel16                              });                              break;                            default:                              throw new InvalidDataException(                                  $"Unknown format \'{key}\' <-- ({instructionInfo.AsmEncoding})"                              );                      }                  }                  /*                  if ((InstructionInfo.InstructionType & InstructionType.B) != 0)                  {                      //Patches.Add(new Patch() { Address = PC' LabelName =  });                  }                  else if ((InstructionInfo.InstructionType & InstructionType.Jump) != 0)                  {                  }                  */                  pc += 4;                  return new[] {instruction};              }              else              {                  switch (instructionName)                  {                      case "nop":                      {                          //return AssembleInstructions(ref PC' "sll r0' r0' r0");                          return AssembleInstructions(ref pc' "and r0' r0' r0"' patches);                      }                      case "b":                      {                          var info = Matcher("%O"' lineTokens[1]);                          return AssembleInstructions(ref pc' $"beq r0' r0' {info["%O"]}"' patches);                      }                      case "li":                      {                          var info = Matcher("%d' %i"' lineTokens[1]);                          var destReg = info["%d"];                          var value = ParseIntegerConstant(info["%i"]);                          // Needs LUI                          if ((short) value != value)                          {                              var list = new List<Instruction>();                              list.AddRange(AssembleInstructions(ref pc'                                  "lui " + destReg + "' " + ((value >> 16) & 0xFFFF)' patches));                              list.AddRange(AssembleInstructions(ref pc'                                  "ori " + destReg + "' " + destReg + "' " + (value & 0xFFFF)' patches));                              //Console.WriteLine(List.ToJson());                              return list.ToArray();                          }                          else                          {                              return AssembleInstructions(ref pc' "addi " + destReg + "' r0' " + value' patches);                          }                      }                      default:                          throw (new InvalidOperationException("Unknown instruction type '" + instructionName + "'"));                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (Instructions.TryGetValue(instructionName' out instructionInfo))              {                  var instruction = new Instruction()                  {                      Value = instructionInfo.Value & instructionInfo.Mask'                  };                    if (vfpuSize > 0)                  {                      instruction.OneTwo = vfpuSize;                  }                    var matches = Matcher(instructionInfo.AsmEncoding' (lineTokens.Length > 1) ? lineTokens[1] : "");                  foreach (var match in matches)                  {                      var key = match.Key;                      var value = match.Value;                        switch (key)                      {                          // VFPU                          // Vector registers                          case "%zs":                          case "%zp":                          case "%zt":                          case "%zq":                          case "%zm":                              instruction.Vd = ParseVfprName(vfpuSize' value);                              break;                          case "%ys":                          case "%yp":                          case "%yt":                          case "%yq":                          case "%ym":                          case "%yn":                          case "%tym":                              if (key == "%tym")                              {                                  value = ((value[0] == 'M') ? 'E' : 'M') + value.Substring(1);                              }                              instruction.Vs = ParseVfprName(vfpuSize' value);                              break;                          case "%xs":                          case "%xp":                          case "%xt":                          case "%xq":                          case "%xm":                              instruction.Vt = ParseVfprName(vfpuSize' value);                              break;                          case "%vk":                              instruction.Imm5 = ParseVfprConstantName(value);                              break;                            case "%vr":                              instruction.Imm5 = ParseVfprRotate(value);                              break;                            //case "%zm": throw(new NotImplementedException("zm"));                            // sv.q %Xq' %Y                          case "%Xq":                              instruction.Vt51 = ParseVfprName(vfpuSize' value);                              break;                          case "%Y":                          {                              var info = ParseVfprOffset(vfpuSize' value);                              if ((info.Offset % 4) != 0) throw(new Exception("Offset must be multiple of 4"));                              instruction.Imm14 = info.Offset / 4;                              instruction.Rs = info.Rs;                          }                              break;                            // VFPU: prefixes (source/target)                          case "%vp0":                          case "%vp1":                          case "%vp2":                          case "%vp3":                          {                              var index = int.Parse(key.Substr(-1));                              VfpuPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprSourceTargetPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                          // VFPU: prefixes (destination)                          case "%vp4":                          case "%vp5":                          case "%vp6":                          case "%vp7":                          {                              var index = int.Parse(key.Substr(-1)) - 4;                              VfpuDestinationPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprDestinationPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                            //case "%xs": Instruction.VD = ParseVfprName(VfpuSize' Value); break;                            // FPU                          case "%S":                              instruction.Fs = ParseFprName(value);                              break;                          case "%D":                              instruction.Fd = ParseFprName(value);                              break;                          case "%T":                              instruction.Ft = ParseFprName(value);                              break;                            // CPU                          case "%J":                          case "%s":                              instruction.Rs = ParseGprName(value);                              break;                          case "%d":                              instruction.Rd = ParseGprName(value);                              break;                          case "%t":                              instruction.Rt = ParseGprName(value);                              break;                            case "%a":                              instruction.Pos = (uint) ParseIntegerConstant(value);                              break;                          case "%ne":                              instruction.SizeE = (uint) ParseIntegerConstant(value);                              break;                          case "%ni":                              instruction.SizeI = (uint) ParseIntegerConstant(value);                              break;                            case "%p":                              instruction.Rd = ParseIntegerConstant(value);                              break;                            case "%c":                          case "%C":                              instruction.Code = (uint) ParseIntegerConstant(value);                              break;                          case "%vi":                          case "%i":                              instruction.Imm = ParseIntegerConstant(value);                              break;                          case "%I":                              instruction.Immu = (uint) ParseIntegerConstant(value);                              break;                            case "%j":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Abs26                              });                              break;                          case "%O":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Rel16                              });                              break;                            default:                              throw new InvalidDataException(                                  $"Unknown format \'{key}\' <-- ({instructionInfo.AsmEncoding})"                              );                      }                  }                  /*                  if ((InstructionInfo.InstructionType & InstructionType.B) != 0)                  {                      //Patches.Add(new Patch() { Address = PC' LabelName =  });                  }                  else if ((InstructionInfo.InstructionType & InstructionType.Jump) != 0)                  {                  }                  */                  pc += 4;                  return new[] {instruction};              }              else              {                  switch (instructionName)                  {                      case "nop":                      {                          //return AssembleInstructions(ref PC' "sll r0' r0' r0");                          return AssembleInstructions(ref pc' "and r0' r0' r0"' patches);                      }                      case "b":                      {                          var info = Matcher("%O"' lineTokens[1]);                          return AssembleInstructions(ref pc' $"beq r0' r0' {info["%O"]}"' patches);                      }                      case "li":                      {                          var info = Matcher("%d' %i"' lineTokens[1]);                          var destReg = info["%d"];                          var value = ParseIntegerConstant(info["%i"]);                          // Needs LUI                          if ((short) value != value)                          {                              var list = new List<Instruction>();                              list.AddRange(AssembleInstructions(ref pc'                                  "lui " + destReg + "' " + ((value >> 16) & 0xFFFF)' patches));                              list.AddRange(AssembleInstructions(ref pc'                                  "ori " + destReg + "' " + destReg + "' " + (value & 0xFFFF)' patches));                              //Console.WriteLine(List.ToJson());                              return list.ToArray();                          }                          else                          {                              return AssembleInstructions(ref pc' "addi " + destReg + "' r0' " + value' patches);                          }                      }                      default:                          throw (new InvalidOperationException("Unknown instruction type '" + instructionName + "'"));                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (Instructions.TryGetValue(instructionName' out instructionInfo))              {                  var instruction = new Instruction()                  {                      Value = instructionInfo.Value & instructionInfo.Mask'                  };                    if (vfpuSize > 0)                  {                      instruction.OneTwo = vfpuSize;                  }                    var matches = Matcher(instructionInfo.AsmEncoding' (lineTokens.Length > 1) ? lineTokens[1] : "");                  foreach (var match in matches)                  {                      var key = match.Key;                      var value = match.Value;                        switch (key)                      {                          // VFPU                          // Vector registers                          case "%zs":                          case "%zp":                          case "%zt":                          case "%zq":                          case "%zm":                              instruction.Vd = ParseVfprName(vfpuSize' value);                              break;                          case "%ys":                          case "%yp":                          case "%yt":                          case "%yq":                          case "%ym":                          case "%yn":                          case "%tym":                              if (key == "%tym")                              {                                  value = ((value[0] == 'M') ? 'E' : 'M') + value.Substring(1);                              }                              instruction.Vs = ParseVfprName(vfpuSize' value);                              break;                          case "%xs":                          case "%xp":                          case "%xt":                          case "%xq":                          case "%xm":                              instruction.Vt = ParseVfprName(vfpuSize' value);                              break;                          case "%vk":                              instruction.Imm5 = ParseVfprConstantName(value);                              break;                            case "%vr":                              instruction.Imm5 = ParseVfprRotate(value);                              break;                            //case "%zm": throw(new NotImplementedException("zm"));                            // sv.q %Xq' %Y                          case "%Xq":                              instruction.Vt51 = ParseVfprName(vfpuSize' value);                              break;                          case "%Y":                          {                              var info = ParseVfprOffset(vfpuSize' value);                              if ((info.Offset % 4) != 0) throw(new Exception("Offset must be multiple of 4"));                              instruction.Imm14 = info.Offset / 4;                              instruction.Rs = info.Rs;                          }                              break;                            // VFPU: prefixes (source/target)                          case "%vp0":                          case "%vp1":                          case "%vp2":                          case "%vp3":                          {                              var index = int.Parse(key.Substr(-1));                              VfpuPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprSourceTargetPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                          // VFPU: prefixes (destination)                          case "%vp4":                          case "%vp5":                          case "%vp6":                          case "%vp7":                          {                              var index = int.Parse(key.Substr(-1)) - 4;                              VfpuDestinationPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprDestinationPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                            //case "%xs": Instruction.VD = ParseVfprName(VfpuSize' Value); break;                            // FPU                          case "%S":                              instruction.Fs = ParseFprName(value);                              break;                          case "%D":                              instruction.Fd = ParseFprName(value);                              break;                          case "%T":                              instruction.Ft = ParseFprName(value);                              break;                            // CPU                          case "%J":                          case "%s":                              instruction.Rs = ParseGprName(value);                              break;                          case "%d":                              instruction.Rd = ParseGprName(value);                              break;                          case "%t":                              instruction.Rt = ParseGprName(value);                              break;                            case "%a":                              instruction.Pos = (uint) ParseIntegerConstant(value);                              break;                          case "%ne":                              instruction.SizeE = (uint) ParseIntegerConstant(value);                              break;                          case "%ni":                              instruction.SizeI = (uint) ParseIntegerConstant(value);                              break;                            case "%p":                              instruction.Rd = ParseIntegerConstant(value);                              break;                            case "%c":                          case "%C":                              instruction.Code = (uint) ParseIntegerConstant(value);                              break;                          case "%vi":                          case "%i":                              instruction.Imm = ParseIntegerConstant(value);                              break;                          case "%I":                              instruction.Immu = (uint) ParseIntegerConstant(value);                              break;                            case "%j":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Abs26                              });                              break;                          case "%O":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Rel16                              });                              break;                            default:                              throw new InvalidDataException(                                  $"Unknown format \'{key}\' <-- ({instructionInfo.AsmEncoding})"                              );                      }                  }                  /*                  if ((InstructionInfo.InstructionType & InstructionType.B) != 0)                  {                      //Patches.Add(new Patch() { Address = PC' LabelName =  });                  }                  else if ((InstructionInfo.InstructionType & InstructionType.Jump) != 0)                  {                  }                  */                  pc += 4;                  return new[] {instruction};              }              else              {                  switch (instructionName)                  {                      case "nop":                      {                          //return AssembleInstructions(ref PC' "sll r0' r0' r0");                          return AssembleInstructions(ref pc' "and r0' r0' r0"' patches);                      }                      case "b":                      {                          var info = Matcher("%O"' lineTokens[1]);                          return AssembleInstructions(ref pc' $"beq r0' r0' {info["%O"]}"' patches);                      }                      case "li":                      {                          var info = Matcher("%d' %i"' lineTokens[1]);                          var destReg = info["%d"];                          var value = ParseIntegerConstant(info["%i"]);                          // Needs LUI                          if ((short) value != value)                          {                              var list = new List<Instruction>();                              list.AddRange(AssembleInstructions(ref pc'                                  "lui " + destReg + "' " + ((value >> 16) & 0xFFFF)' patches));                              list.AddRange(AssembleInstructions(ref pc'                                  "ori " + destReg + "' " + destReg + "' " + (value & 0xFFFF)' patches));                              //Console.WriteLine(List.ToJson());                              return list.ToArray();                          }                          else                          {                              return AssembleInstructions(ref pc' "addi " + destReg + "' r0' " + value' patches);                          }                      }                      default:                          throw (new InvalidOperationException("Unknown instruction type '" + instructionName + "'"));                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (Instructions.TryGetValue(instructionName' out instructionInfo))              {                  var instruction = new Instruction()                  {                      Value = instructionInfo.Value & instructionInfo.Mask'                  };                    if (vfpuSize > 0)                  {                      instruction.OneTwo = vfpuSize;                  }                    var matches = Matcher(instructionInfo.AsmEncoding' (lineTokens.Length > 1) ? lineTokens[1] : "");                  foreach (var match in matches)                  {                      var key = match.Key;                      var value = match.Value;                        switch (key)                      {                          // VFPU                          // Vector registers                          case "%zs":                          case "%zp":                          case "%zt":                          case "%zq":                          case "%zm":                              instruction.Vd = ParseVfprName(vfpuSize' value);                              break;                          case "%ys":                          case "%yp":                          case "%yt":                          case "%yq":                          case "%ym":                          case "%yn":                          case "%tym":                              if (key == "%tym")                              {                                  value = ((value[0] == 'M') ? 'E' : 'M') + value.Substring(1);                              }                              instruction.Vs = ParseVfprName(vfpuSize' value);                              break;                          case "%xs":                          case "%xp":                          case "%xt":                          case "%xq":                          case "%xm":                              instruction.Vt = ParseVfprName(vfpuSize' value);                              break;                          case "%vk":                              instruction.Imm5 = ParseVfprConstantName(value);                              break;                            case "%vr":                              instruction.Imm5 = ParseVfprRotate(value);                              break;                            //case "%zm": throw(new NotImplementedException("zm"));                            // sv.q %Xq' %Y                          case "%Xq":                              instruction.Vt51 = ParseVfprName(vfpuSize' value);                              break;                          case "%Y":                          {                              var info = ParseVfprOffset(vfpuSize' value);                              if ((info.Offset % 4) != 0) throw(new Exception("Offset must be multiple of 4"));                              instruction.Imm14 = info.Offset / 4;                              instruction.Rs = info.Rs;                          }                              break;                            // VFPU: prefixes (source/target)                          case "%vp0":                          case "%vp1":                          case "%vp2":                          case "%vp3":                          {                              var index = int.Parse(key.Substr(-1));                              VfpuPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprSourceTargetPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                          // VFPU: prefixes (destination)                          case "%vp4":                          case "%vp5":                          case "%vp6":                          case "%vp7":                          {                              var index = int.Parse(key.Substr(-1)) - 4;                              VfpuDestinationPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprDestinationPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                            //case "%xs": Instruction.VD = ParseVfprName(VfpuSize' Value); break;                            // FPU                          case "%S":                              instruction.Fs = ParseFprName(value);                              break;                          case "%D":                              instruction.Fd = ParseFprName(value);                              break;                          case "%T":                              instruction.Ft = ParseFprName(value);                              break;                            // CPU                          case "%J":                          case "%s":                              instruction.Rs = ParseGprName(value);                              break;                          case "%d":                              instruction.Rd = ParseGprName(value);                              break;                          case "%t":                              instruction.Rt = ParseGprName(value);                              break;                            case "%a":                              instruction.Pos = (uint) ParseIntegerConstant(value);                              break;                          case "%ne":                              instruction.SizeE = (uint) ParseIntegerConstant(value);                              break;                          case "%ni":                              instruction.SizeI = (uint) ParseIntegerConstant(value);                              break;                            case "%p":                              instruction.Rd = ParseIntegerConstant(value);                              break;                            case "%c":                          case "%C":                              instruction.Code = (uint) ParseIntegerConstant(value);                              break;                          case "%vi":                          case "%i":                              instruction.Imm = ParseIntegerConstant(value);                              break;                          case "%I":                              instruction.Immu = (uint) ParseIntegerConstant(value);                              break;                            case "%j":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Abs26                              });                              break;                          case "%O":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Rel16                              });                              break;                            default:                              throw new InvalidDataException(                                  $"Unknown format \'{key}\' <-- ({instructionInfo.AsmEncoding})"                              );                      }                  }                  /*                  if ((InstructionInfo.InstructionType & InstructionType.B) != 0)                  {                      //Patches.Add(new Patch() { Address = PC' LabelName =  });                  }                  else if ((InstructionInfo.InstructionType & InstructionType.Jump) != 0)                  {                  }                  */                  pc += 4;                  return new[] {instruction};              }              else              {                  switch (instructionName)                  {                      case "nop":                      {                          //return AssembleInstructions(ref PC' "sll r0' r0' r0");                          return AssembleInstructions(ref pc' "and r0' r0' r0"' patches);                      }                      case "b":                      {                          var info = Matcher("%O"' lineTokens[1]);                          return AssembleInstructions(ref pc' $"beq r0' r0' {info["%O"]}"' patches);                      }                      case "li":                      {                          var info = Matcher("%d' %i"' lineTokens[1]);                          var destReg = info["%d"];                          var value = ParseIntegerConstant(info["%i"]);                          // Needs LUI                          if ((short) value != value)                          {                              var list = new List<Instruction>();                              list.AddRange(AssembleInstructions(ref pc'                                  "lui " + destReg + "' " + ((value >> 16) & 0xFFFF)' patches));                              list.AddRange(AssembleInstructions(ref pc'                                  "ori " + destReg + "' " + destReg + "' " + (value & 0xFFFF)' patches));                              //Console.WriteLine(List.ToJson());                              return list.ToArray();                          }                          else                          {                              return AssembleInstructions(ref pc' "addi " + destReg + "' r0' " + value' patches);                          }                      }                      default:                          throw (new InvalidOperationException("Unknown instruction type '" + instructionName + "'"));                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,AssembleInstructions,The following statement contains a magic number: if (Instructions.TryGetValue(instructionName' out instructionInfo))              {                  var instruction = new Instruction()                  {                      Value = instructionInfo.Value & instructionInfo.Mask'                  };                    if (vfpuSize > 0)                  {                      instruction.OneTwo = vfpuSize;                  }                    var matches = Matcher(instructionInfo.AsmEncoding' (lineTokens.Length > 1) ? lineTokens[1] : "");                  foreach (var match in matches)                  {                      var key = match.Key;                      var value = match.Value;                        switch (key)                      {                          // VFPU                          // Vector registers                          case "%zs":                          case "%zp":                          case "%zt":                          case "%zq":                          case "%zm":                              instruction.Vd = ParseVfprName(vfpuSize' value);                              break;                          case "%ys":                          case "%yp":                          case "%yt":                          case "%yq":                          case "%ym":                          case "%yn":                          case "%tym":                              if (key == "%tym")                              {                                  value = ((value[0] == 'M') ? 'E' : 'M') + value.Substring(1);                              }                              instruction.Vs = ParseVfprName(vfpuSize' value);                              break;                          case "%xs":                          case "%xp":                          case "%xt":                          case "%xq":                          case "%xm":                              instruction.Vt = ParseVfprName(vfpuSize' value);                              break;                          case "%vk":                              instruction.Imm5 = ParseVfprConstantName(value);                              break;                            case "%vr":                              instruction.Imm5 = ParseVfprRotate(value);                              break;                            //case "%zm": throw(new NotImplementedException("zm"));                            // sv.q %Xq' %Y                          case "%Xq":                              instruction.Vt51 = ParseVfprName(vfpuSize' value);                              break;                          case "%Y":                          {                              var info = ParseVfprOffset(vfpuSize' value);                              if ((info.Offset % 4) != 0) throw(new Exception("Offset must be multiple of 4"));                              instruction.Imm14 = info.Offset / 4;                              instruction.Rs = info.Rs;                          }                              break;                            // VFPU: prefixes (source/target)                          case "%vp0":                          case "%vp1":                          case "%vp2":                          case "%vp3":                          {                              var index = int.Parse(key.Substr(-1));                              VfpuPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprSourceTargetPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                          // VFPU: prefixes (destination)                          case "%vp4":                          case "%vp5":                          case "%vp6":                          case "%vp7":                          {                              var index = int.Parse(key.Substr(-1)) - 4;                              VfpuDestinationPrefix vfpuPrefix = instruction.Value;                              ParseAndUpdateVfprDestinationPrefix(index' value' ref vfpuPrefix);                              instruction.Value = vfpuPrefix;                          }                              break;                            //case "%xs": Instruction.VD = ParseVfprName(VfpuSize' Value); break;                            // FPU                          case "%S":                              instruction.Fs = ParseFprName(value);                              break;                          case "%D":                              instruction.Fd = ParseFprName(value);                              break;                          case "%T":                              instruction.Ft = ParseFprName(value);                              break;                            // CPU                          case "%J":                          case "%s":                              instruction.Rs = ParseGprName(value);                              break;                          case "%d":                              instruction.Rd = ParseGprName(value);                              break;                          case "%t":                              instruction.Rt = ParseGprName(value);                              break;                            case "%a":                              instruction.Pos = (uint) ParseIntegerConstant(value);                              break;                          case "%ne":                              instruction.SizeE = (uint) ParseIntegerConstant(value);                              break;                          case "%ni":                              instruction.SizeI = (uint) ParseIntegerConstant(value);                              break;                            case "%p":                              instruction.Rd = ParseIntegerConstant(value);                              break;                            case "%c":                          case "%C":                              instruction.Code = (uint) ParseIntegerConstant(value);                              break;                          case "%vi":                          case "%i":                              instruction.Imm = ParseIntegerConstant(value);                              break;                          case "%I":                              instruction.Immu = (uint) ParseIntegerConstant(value);                              break;                            case "%j":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Abs26                              });                              break;                          case "%O":                              patches.Add(new AssemblerPatch()                              {                                  Address = pc'                                  LabelName = value'                                  Type = AssemblerPatchType.Rel16                              });                              break;                            default:                              throw new InvalidDataException(                                  $"Unknown format \'{key}\' <-- ({instructionInfo.AsmEncoding})"                              );                      }                  }                  /*                  if ((InstructionInfo.InstructionType & InstructionType.B) != 0)                  {                      //Patches.Add(new Patch() { Address = PC' LabelName =  });                  }                  else if ((InstructionInfo.InstructionType & InstructionType.Jump) != 0)                  {                  }                  */                  pc += 4;                  return new[] {instruction};              }              else              {                  switch (instructionName)                  {                      case "nop":                      {                          //return AssembleInstructions(ref PC' "sll r0' r0' r0");                          return AssembleInstructions(ref pc' "and r0' r0' r0"' patches);                      }                      case "b":                      {                          var info = Matcher("%O"' lineTokens[1]);                          return AssembleInstructions(ref pc' $"beq r0' r0' {info["%O"]}"' patches);                      }                      case "li":                      {                          var info = Matcher("%d' %i"' lineTokens[1]);                          var destReg = info["%d"];                          var value = ParseIntegerConstant(info["%i"]);                          // Needs LUI                          if ((short) value != value)                          {                              var list = new List<Instruction>();                              list.AddRange(AssembleInstructions(ref pc'                                  "lui " + destReg + "' " + ((value >> 16) & 0xFFFF)' patches));                              list.AddRange(AssembleInstructions(ref pc'                                  "ori " + destReg + "' " + destReg + "' " + (value & 0xFFFF)' patches));                              //Console.WriteLine(List.ToJson());                              return list.ToArray();                          }                          else                          {                              return AssembleInstructions(ref pc' "addi " + destReg + "' r0' " + value' patches);                          }                      }                      default:                          throw (new InvalidOperationException("Unknown instruction type '" + instructionName + "'"));                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,Assemble,The following statement contains a magic number: foreach (var line in lines.Split('\n').Select(str => str.Trim()).Where(str => str.Length > 0))              {                  // Strip comments.                  var parts = line.Split(new[] {";"' "#"}' 2' StringSplitOptions.None);                  var realLine = parts[0].Trim();                    // Directive                  if (line[0] == '.')                  {                      var lineTokens = line.Split(new[] {' '' '\t'}' 2);                      switch (lineTokens[0])                      {                          case ".code":                              OutputStream.Position = ParseIntegerConstant(lineTokens[1]);                              break;                          default:                              throw (new NotImplementedException("Unsupported directive '" + lineTokens[0] + "'"));                      }                  }                  else                  {                      // Label                      if (realLine.EndsWith(":"))                      {                          labels[realLine.Substr(0' -1).Trim()] = (uint) OutputStream.Position;                      }                      // Instruction                      else                      {                          var pc = (uint) OutputStream.Position;                          var instructions = AssembleInstructions(ref pc' realLine' patches);                          foreach (var instruction in instructions)                          {                              BinaryWriter.Write(instruction.Value);                          }                      }                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,Assemble,The following statement contains a magic number: foreach (var line in lines.Split('\n').Select(str => str.Trim()).Where(str => str.Length > 0))              {                  // Strip comments.                  var parts = line.Split(new[] {";"' "#"}' 2' StringSplitOptions.None);                  var realLine = parts[0].Trim();                    // Directive                  if (line[0] == '.')                  {                      var lineTokens = line.Split(new[] {' '' '\t'}' 2);                      switch (lineTokens[0])                      {                          case ".code":                              OutputStream.Position = ParseIntegerConstant(lineTokens[1]);                              break;                          default:                              throw (new NotImplementedException("Unsupported directive '" + lineTokens[0] + "'"));                      }                  }                  else                  {                      // Label                      if (realLine.EndsWith(":"))                      {                          labels[realLine.Substr(0' -1).Trim()] = (uint) OutputStream.Position;                      }                      // Instruction                      else                      {                          var pc = (uint) OutputStream.Position;                          var instructions = AssembleInstructions(ref pc' realLine' patches);                          foreach (var instruction in instructions)                          {                              BinaryWriter.Write(instruction.Value);                          }                      }                  }              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,Assemble,The following statement contains a magic number: foreach (var patch in patches)              {                  if (!labels.ContainsKey(patch.LabelName))                  {                      throw new KeyNotFoundException($"Can't find label '{patch.LabelName}'");                  }                    var labelAddress = labels[patch.LabelName];                    OutputStream.Position = patch.Address;                  var instruction = (Instruction) BinaryReader.ReadUInt32();                  {                      switch (patch.Type)                      {                          case AssemblerPatchType.Rel16:                              instruction.Imm = ((int) labelAddress - (int) patch.Address - 4) / 4;                              break;                          case AssemblerPatchType.Abs26:                              instruction.JumpBits = (labelAddress & PspMemory.MemoryMask) / 4;                              Console.Write("0x{0:X} : {1}"' instruction.JumpBits' patch.LabelName);                              break;                          case AssemblerPatchType.Abs32:                              instruction.Value = labelAddress;                              break;                      }                  }                  OutputStream.Position = patch.Address;                  BinaryWriter.Write(instruction.Value);              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,Assemble,The following statement contains a magic number: foreach (var patch in patches)              {                  if (!labels.ContainsKey(patch.LabelName))                  {                      throw new KeyNotFoundException($"Can't find label '{patch.LabelName}'");                  }                    var labelAddress = labels[patch.LabelName];                    OutputStream.Position = patch.Address;                  var instruction = (Instruction) BinaryReader.ReadUInt32();                  {                      switch (patch.Type)                      {                          case AssemblerPatchType.Rel16:                              instruction.Imm = ((int) labelAddress - (int) patch.Address - 4) / 4;                              break;                          case AssemblerPatchType.Abs26:                              instruction.JumpBits = (labelAddress & PspMemory.MemoryMask) / 4;                              Console.Write("0x{0:X} : {1}"' instruction.JumpBits' patch.LabelName);                              break;                          case AssemblerPatchType.Abs32:                              instruction.Value = labelAddress;                              break;                      }                  }                  OutputStream.Position = patch.Address;                  BinaryWriter.Write(instruction.Value);              }
Magic Number,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,Assemble,The following statement contains a magic number: foreach (var patch in patches)              {                  if (!labels.ContainsKey(patch.LabelName))                  {                      throw new KeyNotFoundException($"Can't find label '{patch.LabelName}'");                  }                    var labelAddress = labels[patch.LabelName];                    OutputStream.Position = patch.Address;                  var instruction = (Instruction) BinaryReader.ReadUInt32();                  {                      switch (patch.Type)                      {                          case AssemblerPatchType.Rel16:                              instruction.Imm = ((int) labelAddress - (int) patch.Address - 4) / 4;                              break;                          case AssemblerPatchType.Abs26:                              instruction.JumpBits = (labelAddress & PspMemory.MemoryMask) / 4;                              Console.Write("0x{0:X} : {1}"' instruction.JumpBits' patch.LabelName);                              break;                          case AssemblerPatchType.Abs32:                              instruction.Value = labelAddress;                              break;                      }                  }                  OutputStream.Position = patch.Address;                  BinaryWriter.Write(instruction.Value);              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: var s = ((i >> 16) & 0x00008000);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: var e = ((i >> 23) & 0x000000ff) - (127 - 15);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: var e = ((i >> 23) & 0x000000ff) - (127 - 15);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: var e = ((i >> 23) & 0x000000ff) - (127 - 15);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: if (e <= 0)              {                  if (e < -10)                  {                      if (s != 0)                      {                          // handle -0.0                          return 0x8000;                      }                      return 0;                  }                  f = (f | 0x00800000) >> (1 - e);                  return s | (f >> 13);              }              else if (e == 0xff - (127 - 15))              {                  if (f == 0)                  {                      // Inf                      return s | 0x7c00;                  }                  // NAN                  f >>= 13;                  return s | 0x7c00 | f | ((f == 0) ? 1 : 0);              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: if (e <= 0)              {                  if (e < -10)                  {                      if (s != 0)                      {                          // handle -0.0                          return 0x8000;                      }                      return 0;                  }                  f = (f | 0x00800000) >> (1 - e);                  return s | (f >> 13);              }              else if (e == 0xff - (127 - 15))              {                  if (f == 0)                  {                      // Inf                      return s | 0x7c00;                  }                  // NAN                  f >>= 13;                  return s | 0x7c00 | f | ((f == 0) ? 1 : 0);              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: if (e <= 0)              {                  if (e < -10)                  {                      if (s != 0)                      {                          // handle -0.0                          return 0x8000;                      }                      return 0;                  }                  f = (f | 0x00800000) >> (1 - e);                  return s | (f >> 13);              }              else if (e == 0xff - (127 - 15))              {                  if (f == 0)                  {                      // Inf                      return s | 0x7c00;                  }                  // NAN                  f >>= 13;                  return s | 0x7c00 | f | ((f == 0) ? 1 : 0);              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: if (e <= 0)              {                  if (e < -10)                  {                      if (s != 0)                      {                          // handle -0.0                          return 0x8000;                      }                      return 0;                  }                  f = (f | 0x00800000) >> (1 - e);                  return s | (f >> 13);              }              else if (e == 0xff - (127 - 15))              {                  if (f == 0)                  {                      // Inf                      return s | 0x7c00;                  }                  // NAN                  f >>= 13;                  return s | 0x7c00 | f | ((f == 0) ? 1 : 0);              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: if (e <= 0)              {                  if (e < -10)                  {                      if (s != 0)                      {                          // handle -0.0                          return 0x8000;                      }                      return 0;                  }                  f = (f | 0x00800000) >> (1 - e);                  return s | (f >> 13);              }              else if (e == 0xff - (127 - 15))              {                  if (f == 0)                  {                      // Inf                      return s | 0x7c00;                  }                  // NAN                  f >>= 13;                  return s | 0x7c00 | f | ((f == 0) ? 1 : 0);              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: if (e > 30)              {                  // Overflow                  return s | 0x7c00;              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: return s | (e << 10) | (f >> 13);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,FloatToHalfFloat,The following statement contains a magic number: return s | (e << 10) | (f >> 13);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: var s = (imm16 >> 15) & 0x00000001;
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: var e = (imm16 >> 10) & 0x0000001f;
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: if (e == 0)              {                  // Need to handle +-0 case f==0 or f=0x8000?                  if (f == 0)                  {                      // Plus or minus zero                      return MathFloat.ReinterpretIntAsFloat(s << 31);                  }                  // Denormalized number -- renormalize it                  while ((f & 0x00000400) == 0)                  {                      f <<= 1;                      e -= 1;                  }                  e += 1;                  f &= ~0x00000400;              }              else if (e == 31)              {                  if (f == 0)                  {                      // Inf                      return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000);                  }                  // NaN                  return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000 | (f << 13));              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: if (e == 0)              {                  // Need to handle +-0 case f==0 or f=0x8000?                  if (f == 0)                  {                      // Plus or minus zero                      return MathFloat.ReinterpretIntAsFloat(s << 31);                  }                  // Denormalized number -- renormalize it                  while ((f & 0x00000400) == 0)                  {                      f <<= 1;                      e -= 1;                  }                  e += 1;                  f &= ~0x00000400;              }              else if (e == 31)              {                  if (f == 0)                  {                      // Inf                      return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000);                  }                  // NaN                  return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000 | (f << 13));              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: if (e == 0)              {                  // Need to handle +-0 case f==0 or f=0x8000?                  if (f == 0)                  {                      // Plus or minus zero                      return MathFloat.ReinterpretIntAsFloat(s << 31);                  }                  // Denormalized number -- renormalize it                  while ((f & 0x00000400) == 0)                  {                      f <<= 1;                      e -= 1;                  }                  e += 1;                  f &= ~0x00000400;              }              else if (e == 31)              {                  if (f == 0)                  {                      // Inf                      return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000);                  }                  // NaN                  return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000 | (f << 13));              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: if (e == 0)              {                  // Need to handle +-0 case f==0 or f=0x8000?                  if (f == 0)                  {                      // Plus or minus zero                      return MathFloat.ReinterpretIntAsFloat(s << 31);                  }                  // Denormalized number -- renormalize it                  while ((f & 0x00000400) == 0)                  {                      f <<= 1;                      e -= 1;                  }                  e += 1;                  f &= ~0x00000400;              }              else if (e == 31)              {                  if (f == 0)                  {                      // Inf                      return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000);                  }                  // NaN                  return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000 | (f << 13));              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: if (e == 0)              {                  // Need to handle +-0 case f==0 or f=0x8000?                  if (f == 0)                  {                      // Plus or minus zero                      return MathFloat.ReinterpretIntAsFloat(s << 31);                  }                  // Denormalized number -- renormalize it                  while ((f & 0x00000400) == 0)                  {                      f <<= 1;                      e -= 1;                  }                  e += 1;                  f &= ~0x00000400;              }              else if (e == 31)              {                  if (f == 0)                  {                      // Inf                      return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000);                  }                  // NaN                  return MathFloat.ReinterpretIntAsFloat((s << 31) | 0x7f800000 | (f << 13));              }
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: e = e + (127 - 15);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: e = e + (127 - 15);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: f = f << 13;
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: return MathFloat.ReinterpretIntAsFloat((s << 31) | (e << 23) | f);
Magic Number,CSPspEmu.Core.Cpu,HalfFloat,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\HalfFloat.cs,ToFloat,The following statement contains a magic number: return MathFloat.ReinterpretIntAsFloat((s << 31) | (e << 23) | f);
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,GetCurrentCallStack,The following statement contains a magic number: var count = Math.Min(10240' CallStackCount);
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,CpuThreadState,The following statement contains a magic number: for (var n = 0; n < 32; n++) Gpr[n] = 0;
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,CpuThreadState,The following statement contains a magic number: for (var n = 0; n < 32; n++) Fpr[n] = 0.0f;
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,CpuThreadState,The following statement contains a magic number: for (var n = 0; n < 128; n++) Vfpr[n] = 0.0f;
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,Tick2,The following statement contains a magic number: if (_tickCount > 10000)              {                  _tickCount = 0;                  if ((DateTime.UtcNow - _lastTickYield).TotalMilliseconds >= 2)                  {                      _lastTickYield = DateTime.UtcNow;                      Yield();                  }              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,Tick2,The following statement contains a magic number: if (_tickCount > 10000)              {                  _tickCount = 0;                  if ((DateTime.UtcNow - _lastTickYield).TotalMilliseconds >= 2)                  {                      _lastTickYield = DateTime.UtcNow;                      Yield();                  }              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersCpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("r{0'2}({1}) : 0x{2:X8}"' n' RegisterMnemonicNames[n]' Gpr[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersCpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("r{0'2}({1}) : 0x{2:X8}"' n' RegisterMnemonicNames[n]' Gpr[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersCpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("r{0'2}({1}) : 0x{2:X8}"' n' RegisterMnemonicNames[n]' Gpr[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersCpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("r{0'2}({1}) : 0x{2:X8}"' n' RegisterMnemonicNames[n]' Gpr[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersFpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("f{0'2} : 0x{1:X8}' {2}"' n' FprI[n]' Fpr[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersFpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("f{0'2} : 0x{1:X8}' {2}"' n' FprI[n]' Fpr[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersFpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("f{0'2} : 0x{1:X8}' {2}"' n' FprI[n]' Fpr[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersFpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("f{0'2} : 0x{1:X8}' {2}"' n' FprI[n]' Fpr[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersVFpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("c0r{0'2} : 0x{1:X8}"' n' C0R[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersVFpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("c0r{0'2} : 0x{1:X8}"' n' C0R[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersVFpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("c0r{0'2} : 0x{1:X8}"' n' C0R[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpRegistersVFpu,The following statement contains a magic number: for (var n = 0; n < 32; n++)              {                  if (n % 4 != 0) textWriter.Write("' ");                  textWriter.Write("c0r{0'2} : 0x{1:X8}"' n' C0R[n]);                  if (n % 4 == 3) textWriter.WriteLine();              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpVfpuRegisters,The following statement contains a magic number: for (var matrix = 0; matrix < 8; matrix++)              {                  textWriter.WriteLine("Matrix: {0}"' matrix);                  for (var row = 0; row < 4; row++)                  {                      var line = "";                      for (var column = 0; column < 4; column++)                      {                          line += $"' {Vfpr[matrix' column' row]}";                      }                      textWriter.WriteLine(line);                  }                  textWriter.WriteLine("");              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpVfpuRegisters,The following statement contains a magic number: for (var matrix = 0; matrix < 8; matrix++)              {                  textWriter.WriteLine("Matrix: {0}"' matrix);                  for (var row = 0; row < 4; row++)                  {                      var line = "";                      for (var column = 0; column < 4; column++)                      {                          line += $"' {Vfpr[matrix' column' row]}";                      }                      textWriter.WriteLine(line);                  }                  textWriter.WriteLine("");              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,DumpVfpuRegisters,The following statement contains a magic number: for (var matrix = 0; matrix < 8; matrix++)              {                  textWriter.WriteLine("Matrix: {0}"' matrix);                  for (var row = 0; row < 4; row++)                  {                      var line = "";                      for (var column = 0; column < 4; column++)                      {                          line += $"' {Vfpr[matrix' column' row]}";                      }                      textWriter.WriteLine(line);                  }                  textWriter.WriteLine("");              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,CopyRegistersFrom,The following statement contains a magic number: fixed (float* thisFpr = &Fpr0)              fixed (float* thatFpr = &that.Fpr0)              fixed (uint* thisGpr = &Gpr0)              fixed (uint* thatGpr = &that.Gpr0)              {                  for (var n = 0; n < 32; n++)                  {                      thisFpr[n] = thatFpr[n];                      thisGpr[n] = thatGpr[n];                  }              }
Magic Number,CSPspEmu.Core.Cpu,CpuThreadState,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,CopyRegistersFrom,The following statement contains a magic number: fixed (float* thisVfr = &Vfr0)              fixed (float* thatVfr = &that.Vfr0)              {                  for (var n = 0; n < 128; n++)                      thisVfr[n] = thatVfr[n];              }
Magic Number,CSPspEmu.Core.Cpu,VfprList,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\CpuThreadState.cs,ClearAll,The following statement contains a magic number: for (var n = 0; n < 128; n++) this[n] = value;
Magic Number,CSPspEmu.Core.Cpu.Emitter,AstMipsGenerator,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\AstMipsGenerator.cs,AstMipsGenerator,The following statement contains a magic number: for (var n = 0; n < 32; n++)                  GprCache[n] = Ast.FieldAccess(Ast.CpuThreadStateExpr'                      CpuThreadStateType.GetField(CpuThreadState.GprNames[n]));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Syscall,The following statement contains a magic number: if (_instruction.Code == SyscallInfo.NativeCallSyscallCode)              {                  var delegateId = _memory.Read4(_pc + 4);                  var syscallInfoInfo = _cpuProcessor.RegisteredNativeSyscallMethods[delegateId];                  SpecialName = syscallInfoInfo.FunctionEntryName;                    var statements = _ast.StatementsInline(                      _ast.Assign(_ast.Pc()' _pc)'                      _ast.Comment(syscallInfoInfo.Name)'                      _ast.GetTickCall(true)                  );                    if (DynarecConfig.FunctionCallWithStaticReferences)                  {                      statements.AddStatement(_ast.Statement(_ast.CallDelegate(syscallInfoInfo.PoolItem.AstFieldAccess'                          _ast.CpuThreadStateExpr)));                  }                  else                  {                      statements.AddStatement(_ast.Statement(_ast.CallInstance(_ast.CpuThreadStateExpr'                          (Action<uint>) CpuThreadState.Methods.SyscallNative' delegateId)));                  }                    statements.AddStatement(_ast.Return());                    return statements;              }              else              {                  return _ast.StatementsInline(                      _ast.AssignPc(_pc)'                      _ast.GetTickCall(true)'                      _ast.Statement(_ast.CallInstance(_ast.CpuThreadStateExpr'                          (Action<int>) CpuThreadState.Methods.Syscall'                          (int) _instruction.Code))                  );              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_branch_post,The following statement contains a magic number: if (_andLink)              {                  return _ast.If(                      BranchFlag()'                      _ast.StatementsInline(                          _ast.AssignGpr(31' branchPc + 8)'                          CallFixedAddress(branchPc)                      )                  );              }              else              {                  return _ast.Statements(                      //ast.AssignPC(PC)'                      //ast.GetTickCall()'                      _ast.GotoIfTrue(branchLabel' BranchFlag())                  );              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_branch_post,The following statement contains a magic number: if (_andLink)              {                  return _ast.If(                      BranchFlag()'                      _ast.StatementsInline(                          _ast.AssignGpr(31' branchPc + 8)'                          CallFixedAddress(branchPc)                      )                  );              }              else              {                  return _ast.Statements(                      //ast.AssignPC(PC)'                      //ast.GetTickCall()'                      _ast.GotoIfTrue(branchLabel' BranchFlag())                  );              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,ReturnFromFunction,The following statement contains a magic number: return _ast.StatementsInline(                  _ast.AssignPc(_ast.Gpr(31))'                  _ast.GetTickCall(BranchCount > 0)'                  _ast.Return()              );
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_comp,The following statement contains a magic number: var fcEqual = ((fc02 & 2) != 0);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_comp,The following statement contains a magic number: var fcLess = ((fc02 & 4) != 0);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vrot,The following statement contains a magic number: var cosIndex = BitUtils.Extract(imm5' 0' 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vrot,The following statement contains a magic number: var sinIndex = BitUtils.Extract(imm5' 2' 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vrot,The following statement contains a magic number: var sinIndex = BitUtils.Extract(imm5' 2' 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vrot,The following statement contains a magic number: var negateSin = BitUtils.ExtractBool(imm5' 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrs_t,The following statement contains a magic number: var vVd = Vec(Vd' VType.VFloat' 3);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrs_t,The following statement contains a magic number: var vVs = Vec(Vs' VType.VFloat' 3);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrs_t,The following statement contains a magic number: var vVt = Vec(Vt' VType.VFloat' 3);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrs_t,The following statement contains a magic number: return vVd.SetVector(index =>              {                  switch (index)                  {                      case 0: return vVs[1] * vVt[2];                      case 1: return vVs[2] * vVt[0];                      case 2: return vVs[0] * vVt[1];                      default: throw (new InvalidOperationException("vcrs_t.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrs_t,The following statement contains a magic number: return vVd.SetVector(index =>              {                  switch (index)                  {                      case 0: return vVs[1] * vVt[2];                      case 1: return vVs[2] * vVt[0];                      case 2: return vVs[0] * vVt[1];                      default: throw (new InvalidOperationException("vcrs_t.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrs_t,The following statement contains a magic number: return vVd.SetVector(index =>              {                  switch (index)                  {                      case 0: return vVs[1] * vVt[2];                      case 1: return vVs[2] * vVt[0];                      case 2: return vVs[0] * vVt[1];                      default: throw (new InvalidOperationException("vcrs_t.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrsp_t,The following statement contains a magic number: var d = Vec(Vd' VType.VFloat' 3);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrsp_t,The following statement contains a magic number: var s = Vec(Vs' VType.VFloat' 3);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrsp_t,The following statement contains a magic number: var t = Vec(Vt' VType.VFloat' 3);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrsp_t,The following statement contains a magic number: return d.SetVector(index =>              {                  switch (index)                  {                      case 0: return s[1] * t[2] - s[2] * t[1];                      case 1: return s[2] * t[0] - s[0] * t[2];                      case 2: return s[0] * t[1] - s[1] * t[0];                      default: throw (new InvalidOperationException("vcrsp_t.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrsp_t,The following statement contains a magic number: return d.SetVector(index =>              {                  switch (index)                  {                      case 0: return s[1] * t[2] - s[2] * t[1];                      case 1: return s[2] * t[0] - s[0] * t[2];                      case 2: return s[0] * t[1] - s[1] * t[0];                      default: throw (new InvalidOperationException("vcrsp_t.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrsp_t,The following statement contains a magic number: return d.SetVector(index =>              {                  switch (index)                  {                      case 0: return s[1] * t[2] - s[2] * t[1];                      case 1: return s[2] * t[0] - s[0] * t[2];                      case 2: return s[0] * t[1] - s[1] * t[0];                      default: throw (new InvalidOperationException("vcrsp_t.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrsp_t,The following statement contains a magic number: return d.SetVector(index =>              {                  switch (index)                  {                      case 0: return s[1] * t[2] - s[2] * t[1];                      case 1: return s[2] * t[0] - s[0] * t[2];                      case 2: return s[0] * t[1] - s[1] * t[0];                      default: throw (new InvalidOperationException("vcrsp_t.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,vcrsp_t,The following statement contains a magic number: return d.SetVector(index =>              {                  switch (index)                  {                      case 0: return s[1] * t[2] - s[2] * t[1];                      case 1: return s[2] * t[0] - s[0] * t[2];                      case 2: return s[0] * t[1] - s[1] * t[0];                      default: throw (new InvalidOperationException("vcrsp_t.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vdet,The following statement contains a magic number: var v1 = Vec(Vs' VType.VFloat' 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vdet,The following statement contains a magic number: var v2 = Vec(Vt' VType.VFloat' 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsocp,The following statement contains a magic number: var vvd = Vec(Vd' VType.VFloat' vectorSize * 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsocp,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0:                          return _ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp' 1f - vvs[0]' 0f' 1f);                      case 1: return _ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp' vvs[0]' 0f' 1f);                      case 2:                          return _ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp' 1f - vvs[1]' 0f' 1f);                      case 3: return _ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp' vvs[1]' 0f' 1f);                      default: throw (new NotImplementedException("vsocp: " + index));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsocp,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0:                          return _ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp' 1f - vvs[0]' 0f' 1f);                      case 1: return _ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp' vvs[0]' 0f' 1f);                      case 2:                          return _ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp' 1f - vvs[1]' 0f' 1f);                      case 3: return _ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp' vvs[1]' 0f' 1f);                      default: throw (new NotImplementedException("vsocp: " + index));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 4) & 15) << 0;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 4) & 15) << 0;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 12) & 15) << 4;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 12) & 15) << 4;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 12) & 15) << 4;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 20) & 15) << 8;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 20) & 15) << 8;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 20) & 15) << 8;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 28) & 15) << 12;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 28) & 15) << 12;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i0 >> 28) & 15) << 12;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 4) & 15) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 4) & 15) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 4) & 15) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 12) & 15) << 20;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 12) & 15) << 20;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 12) & 15) << 20;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 20) & 15) << 24;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 20) & 15) << 24;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 20) & 15) << 24;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 28) & 15) << 28;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 28) & 15) << 28;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt4444_step,The following statement contains a magic number: o0 |= ((i1 >> 28) & 15) << 28;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 3) & 31) << 0;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 3) & 31) << 0;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 11) & 31) << 5;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 11) & 31) << 5;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 11) & 31) << 5;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 19) & 31) << 10;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 19) & 31) << 10;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 19) & 31) << 10;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 31) & 1) << 15;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i0 >> 31) & 1) << 15;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 3) & 31) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 3) & 31) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 3) & 31) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 11) & 31) << 21;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 11) & 31) << 21;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 11) & 31) << 21;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 19) & 31) << 26;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 19) & 31) << 26;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 19) & 31) << 26;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 31) & 1) << 31;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5551_step,The following statement contains a magic number: o0 |= ((i1 >> 31) & 1) << 31;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i0 >> 3) & 31) << 0;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i0 >> 3) & 31) << 0;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i0 >> 10) & 63) << 5;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i0 >> 10) & 63) << 5;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i0 >> 10) & 63) << 5;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i0 >> 19) & 31) << 11;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i0 >> 19) & 31) << 11;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i0 >> 19) & 31) << 11;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 3) & 31) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 3) & 31) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 3) & 31) << 16;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 10) & 63) << 21;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 10) & 63) << 21;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 10) & 63) << 21;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 19) & 31) << 27;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 19) & 31) << 27;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vt5650_step,The following statement contains a magic number: o0 |= ((i1 >> 19) & 31) << 27;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vtXXXX_q,The following statement contains a magic number: if (vectorSize != 4) throw new Exception("Not implemented _vtXXXX_q for VectorSize=" + vectorSize);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vtXXXX_q,The following statement contains a magic number: var dest = Vec(VdNoPrefix' VuInt' 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vtXXXX_q,The following statement contains a magic number: var src = Vec(VsNoPrefix' VuInt' 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vtXXXX_q,The following statement contains a magic number: var node = dest.SetVector(index => _ast.CallStatic(                  vtXxxxStepCallback'                  src[index * 2 + 0]'                  src[index * 2 + 1]              )' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vtXXXX_q,The following statement contains a magic number: var node = dest.SetVector(index => _ast.CallStatic(                  vtXxxxStepCallback'                  src[index * 2 + 0]'                  src[index * 2 + 1]              )' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt1,The following statement contains a magic number: if (vectorSize != 4) return _ast.Statement();
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt1,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt1.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt1,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt1.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt1,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt1.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt1,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt1.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt1,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt1.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt1,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt1.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt2,The following statement contains a magic number: if (vectorSize != 4) return _ast.Statement();
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt2,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt2.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt2,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt2.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt2,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt2.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt2,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt2.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt2,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt2.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt2,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt2.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt3,The following statement contains a magic number: if (vectorSize != 4) return _ast.Statement();
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt3,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt3.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt3,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt3.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt3,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt3.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt3,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt3.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt3,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt3.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt3,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[1]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[1]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[2]' vvs[3]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[2]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt3.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt4,The following statement contains a magic number: if (vectorSize != 4) return _ast.Statement();
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt4,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt4.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt4,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt4.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt4,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt4.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt4,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt4.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt4,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt4.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vsrt4,The following statement contains a magic number: return vvd.SetVector(index =>              {                  switch (index)                  {                      case 0: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[0]' vvs[3]);                      case 1: return _ast.CallStatic((Func<float' float' float>) MathFloat.Max' vvs[1]' vvs[2]);                      case 2: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[1]' vvs[2]);                      case 3: return _ast.CallStatic((Func<float' float' float>) MathFloat.Min' vvs[0]' vvs[3]);                      default: throw (new InvalidOperationException("vsrt4.Assert!"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: var v1 = Vec(Vs' VType.VFloat' 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: var v2 = Vec(Vt' VType.VFloat' 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vqmul,The following statement contains a magic number: return Vec(Vd' VType.VFloat' 4).SetVector(index =>              {                  switch (index)                  {                      case 0: return +(v1[0] * v2[3]) + (v1[1] * v2[2]) - (v1[2] * v2[1]) + (v1[3] * v2[0]);                      case 1: return -(v1[0] * v2[2]) + (v1[1] * v2[3]) + (v1[2] * v2[0]) + (v1[3] * v2[1]);                      case 2: return +(v1[0] * v2[1]) - (v1[1] * v2[0]) + (v1[2] * v2[3]) + (v1[3] * v2[2]);                      case 3: return -(v1[0] * v2[0]) - (v1[1] * v2[1]) - (v1[2] * v2[2]) + (v1[3] * v2[3]);                      default: throw (new InvalidOperationException("vqmul.Assert"));                  }              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2C,The following statement contains a magic number: var vecVs = Vec(Vs' VType.VuInt' 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2C,The following statement contains a magic number: return CelVdU.Set(                  _ast.CallStatic((Func<uint' uint' uint' uint' uint>) CpuEmitterUtils._vi2c_impl' vecVs[0]' vecVs[1]'                      vecVs[2]' vecVs[3])' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2C,The following statement contains a magic number: return CelVdU.Set(                  _ast.CallStatic((Func<uint' uint' uint' uint' uint>) CpuEmitterUtils._vi2c_impl' vecVs[0]' vecVs[1]'                      vecVs[2]' vecVs[3])' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2Uc,The following statement contains a magic number: var vecVs = Vec(Vs' VType.VInt' 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2Uc,The following statement contains a magic number: return CelVdU.Set(                  _ast.CallStatic((Func<int' int' int' int' uint>) CpuEmitterUtils._vi2uc_impl' vecVs[0]' vecVs[1]'                      vecVs[2]' vecVs[3])' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2Uc,The following statement contains a magic number: return CelVdU.Set(                  _ast.CallStatic((Func<int' int' int' int' uint>) CpuEmitterUtils._vi2uc_impl' vecVs[0]' vecVs[1]'                      vecVs[2]' vecVs[3])' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vs2I,The following statement contains a magic number: if (vectorSize > 2) throw (new NotImplementedException("vs2i.VectorSize"));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vs2I,The following statement contains a magic number: var dest = _Vector(Vd' VuInt' vectorSize * 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vs2I,The following statement contains a magic number: return dest.SetVector(index =>              {                  var value = src[index / 2];                  if ((index % 2) == 0) value = _ast.Binary(value' "<<"' 16);                  return value & 0xFFFF0000;              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vs2I,The following statement contains a magic number: return dest.SetVector(index =>              {                  var value = src[index / 2];                  if ((index % 2) == 0) value = _ast.Binary(value' "<<"' 16);                  return value & 0xFFFF0000;              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vs2I,The following statement contains a magic number: return dest.SetVector(index =>              {                  var value = src[index / 2];                  if ((index % 2) == 0) value = _ast.Binary(value' "<<"' 16);                  return value & 0xFFFF0000;              }' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2S,The following statement contains a magic number: return _Vector(Vd' VType.VuInt' vectorSize / 2)                      .SetVector(index => _ast.CallStatic(                          (Func<uint' uint' uint>) CpuEmitterUtils._vi2s_impl'                          VecVsU[index * 2 + 0]'                          VecVsU[index * 2 + 1]                      )' _pc)                  ;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2S,The following statement contains a magic number: return _Vector(Vd' VType.VuInt' vectorSize / 2)                      .SetVector(index => _ast.CallStatic(                          (Func<uint' uint' uint>) CpuEmitterUtils._vi2s_impl'                          VecVsU[index * 2 + 0]'                          VecVsU[index * 2 + 1]                      )' _pc)                  ;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2S,The following statement contains a magic number: return _Vector(Vd' VType.VuInt' vectorSize / 2)                      .SetVector(index => _ast.CallStatic(                          (Func<uint' uint' uint>) CpuEmitterUtils._vi2s_impl'                          VecVsU[index * 2 + 0]'                          VecVsU[index * 2 + 1]                      )' _pc)                  ;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vf2H,The following statement contains a magic number: var vecVd = Vec(Vd' VType.VuInt' OneTwo / 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vf2H,The following statement contains a magic number: return vecVd.SetVector(index =>                      _ast.CallStatic(                          (Func<float' float' uint>) CpuEmitterUtils._vf2h_impl'                          vecVs[index * 2 + 0]'                          vecVs[index * 2 + 1]                      )                  ' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vf2H,The following statement contains a magic number: return vecVd.SetVector(index =>                      _ast.CallStatic(                          (Func<float' float' uint>) CpuEmitterUtils._vf2h_impl'                          vecVs[index * 2 + 0]'                          vecVs[index * 2 + 1]                      )                  ' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vh2F,The following statement contains a magic number: var vecVd = Vec(Vd' VType.VFloat' OneTwo * 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vh2F,The following statement contains a magic number: return vecVd.SetVector(index => _ast.CallStatic(                  index % 2 == 0                      ? (Func<uint' float>) CpuEmitterUtils._vh2f_0                      : (Func<uint' float>) CpuEmitterUtils._vh2f_1'                  vecVs[index / 2]              )' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vh2F,The following statement contains a magic number: return vecVd.SetVector(index => _ast.CallStatic(                  index % 2 == 0                      ? (Func<uint' float>) CpuEmitterUtils._vh2f_0                      : (Func<uint' float>) CpuEmitterUtils._vh2f_1'                  vecVs[index / 2]              )' _pc);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2Us,The following statement contains a magic number: return _Vector(Vd' VType.VInt' vectorSize / 2)                      .SetVector(index => _ast.CallStatic(                          (Func<int' int' int>) CpuEmitterUtils._vi2us_impl'                          VecVsI[index * 2 + 0]'                          VecVsI[index * 2 + 1]                      )' _pc)                  ;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2Us,The following statement contains a magic number: return _Vector(Vd' VType.VInt' vectorSize / 2)                      .SetVector(index => _ast.CallStatic(                          (Func<int' int' int>) CpuEmitterUtils._vi2us_impl'                          VecVsI[index * 2 + 0]'                          VecVsI[index * 2 + 1]                      )' _pc)                  ;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vi2Us,The following statement contains a magic number: return _Vector(Vd' VType.VInt' vectorSize / 2)                      .SetVector(index => _ast.CallStatic(                          (Func<int' int' int>) CpuEmitterUtils._vi2us_impl'                          VecVsI[index * 2 + 0]'                          VecVsI[index * 2 + 1]                      )' _pc)                  ;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Mtvc,The following statement contains a magic number: return _ast.Statement(_ast.CallStatic(                  (Action<CpuThreadState' VfpuControlRegistersEnum' uint>) CpuEmitterUtils._mtvc_impl'                  _ast.CpuThreadStateExpr'                  _ast.Cast<VfpuControlRegistersEnum>((int) (_instruction.Imm7 + 128)' false)'                  CelVdU.Get()              ));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,lv_q,The following statement contains a magic number: const int vectorSize = 4;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,sv_q,The following statement contains a magic number: var vectorSize = 4;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_lv_sv_l_r_q,The following statement contains a magic number: var vt5 = _Vector(Vt51' VFloat' 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_lv_sv_l_r_q,The following statement contains a magic number: return _ast.Statement(_ast.CallStatic(                  methodInfo'                  _ast.CpuThreadStateExpr'                  save'                  _ast.GetAddress(vt5.GetIndexRef(0))'                  _ast.GetAddress(vt5.GetIndexRef(1))'                  _ast.GetAddress(vt5.GetIndexRef(2))'                  _ast.GetAddress(vt5.GetIndexRef(3))'                  Address_RS_IMM14()              ));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_lv_sv_l_r_q,The following statement contains a magic number: return _ast.Statement(_ast.CallStatic(                  methodInfo'                  _ast.CpuThreadStateExpr'                  save'                  _ast.GetAddress(vt5.GetIndexRef(0))'                  _ast.GetAddress(vt5.GetIndexRef(1))'                  _ast.GetAddress(vt5.GetIndexRef(2))'                  _ast.GetAddress(vt5.GetIndexRef(3))'                  Address_RS_IMM14()              ));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_debug_vfpu,The following statement contains a magic number: fixed (float* fpr = &cpuThreadState.Vfr0)              {                  var index = 0;                  for (var matrix = 0; matrix < 8; matrix++)                  {                      Console.Error.WriteLine("Matrix {0}: "' matrix);                      for (var row = 0; row < 4; row++)                      {                          for (var column = 0; column < 4; column++)                          {                              Console.Error.Write("{0}'"' fpr[index]);                              index++;                          }                          Console.Error.WriteLine("");                      }                      Console.Error.WriteLine("");                  }              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_debug_vfpu,The following statement contains a magic number: fixed (float* fpr = &cpuThreadState.Vfr0)              {                  var index = 0;                  for (var matrix = 0; matrix < 8; matrix++)                  {                      Console.Error.WriteLine("Matrix {0}: "' matrix);                      for (var row = 0; row < 4; row++)                      {                          for (var column = 0; column < 4; column++)                          {                              Console.Error.Write("{0}'"' fpr[index]);                              index++;                          }                          Console.Error.WriteLine("");                      }                      Console.Error.WriteLine("");                  }              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_debug_vfpu,The following statement contains a magic number: fixed (float* fpr = &cpuThreadState.Vfr0)              {                  var index = 0;                  for (var matrix = 0; matrix < 8; matrix++)                  {                      Console.Error.WriteLine("Matrix {0}: "' matrix);                      for (var row = 0; row < 4; row++)                      {                          for (var column = 0; column < 4; column++)                          {                              Console.Error.Write("{0}'"' fpr[index]);                              index++;                          }                          Console.Error.WriteLine("");                      }                      Console.Error.WriteLine("");                  }              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vcmp,The following statement contains a magic number: return _ast.Statements(                  _ast.Assign(localCcOr' false)'                  _ast.Assign(localCcAnd' true)'                    // TODO: CHECK THIS!                  _ast.AssignVcc(0' true)'                  _ast.AssignVcc(1' true)'                  _ast.AssignVcc(2' true)'                  _ast.AssignVcc(3' true)'                  _List(vectorSize' index =>                  {                      AstNodeExpr expr;                      //bool UsedForAggregate;                        var left = VecVs[index];                      var right = VecVt[index];                      switch (cond2)                      {                          case ConditionEnum.VcFl:                              expr = _ast.Immediate(false);                              break;                          case ConditionEnum.VcEq:                              expr = _ast.Binary(left' "=="' right);                              break;                          case ConditionEnum.VcLt:                              expr = _ast.Binary(left' "<"' right);                              break;                          //case ConditionEnum.VC_LE: Expr = ast.Binary(Left' "<="' Right); break;                          case ConditionEnum.VcLe:                              expr = _ast.CallStatic((Func<float' float' bool>) MathFloat.IsLessOrEqualsThan' left'                                  right);                              break;                            case ConditionEnum.VcTr:                              expr = _ast.Immediate(true);                              break;                          case ConditionEnum.VcNe:                              expr = _ast.Binary(left' "!="' right);                              break;                          //case ConditionEnum.VC_GE: Expr = ast.Binary(Left' ">="' Right); break;                          case ConditionEnum.VcGe:                              expr = _ast.CallStatic((Func<float' float' bool>) MathFloat.IsGreatOrEqualsThan' left'                                  right);                              break;                          case ConditionEnum.VcGt:                              expr = _ast.Binary(left' ">"' right);                              break;                            case ConditionEnum.VcEz:                              expr = _ast.Binary(_ast.Binary(left' "=="' 0.0f)' "||"' _ast.Binary(left' "=="' -0.0f));                              break;                          case ConditionEnum.VcEn:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsNan' left);                              break;                          case ConditionEnum.VcEi:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsInfinity' left);                              break;                          case ConditionEnum.VcEs:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsNanOrInfinity' left);                              break; // Tekken Dark Resurrection                            case ConditionEnum.VcNz:                              expr = _ast.Binary(left' "!="' 0f);                              break;                          case ConditionEnum.VcNn:                              expr = _ast.Unary("!"' _ast.CallStatic((Func<float' bool>) MathFloat.IsNan' left));                              break;                          case ConditionEnum.VcNi:                              expr = _ast.Unary("!"' _ast.CallStatic((Func<float' bool>) MathFloat.IsInfinity' left));                              break;                          case ConditionEnum.VcNs:                              expr = _ast.Unary("!"'                                  _ast.CallStatic((Func<float' bool>) MathFloat.IsNanOrInfinity' left));                              break;                            default: throw (new InvalidOperationException());                      }                        return _ast.Statements(new List<AstNodeStm>                      {                          _ast.Assign(localCcTemp' expr)'                          _ast.AssignVcc(index' localCcTemp)'                          _ast.Assign(localCcOr' _ast.Binary(localCcOr' "||"' localCcTemp))'                          _ast.Assign(localCcAnd' _ast.Binary(localCcAnd' "&&"' localCcTemp))                      });                  })'                  _ast.AssignVcc(4' localCcOr)'                  _ast.AssignVcc(5' localCcAnd)              );
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vcmp,The following statement contains a magic number: return _ast.Statements(                  _ast.Assign(localCcOr' false)'                  _ast.Assign(localCcAnd' true)'                    // TODO: CHECK THIS!                  _ast.AssignVcc(0' true)'                  _ast.AssignVcc(1' true)'                  _ast.AssignVcc(2' true)'                  _ast.AssignVcc(3' true)'                  _List(vectorSize' index =>                  {                      AstNodeExpr expr;                      //bool UsedForAggregate;                        var left = VecVs[index];                      var right = VecVt[index];                      switch (cond2)                      {                          case ConditionEnum.VcFl:                              expr = _ast.Immediate(false);                              break;                          case ConditionEnum.VcEq:                              expr = _ast.Binary(left' "=="' right);                              break;                          case ConditionEnum.VcLt:                              expr = _ast.Binary(left' "<"' right);                              break;                          //case ConditionEnum.VC_LE: Expr = ast.Binary(Left' "<="' Right); break;                          case ConditionEnum.VcLe:                              expr = _ast.CallStatic((Func<float' float' bool>) MathFloat.IsLessOrEqualsThan' left'                                  right);                              break;                            case ConditionEnum.VcTr:                              expr = _ast.Immediate(true);                              break;                          case ConditionEnum.VcNe:                              expr = _ast.Binary(left' "!="' right);                              break;                          //case ConditionEnum.VC_GE: Expr = ast.Binary(Left' ">="' Right); break;                          case ConditionEnum.VcGe:                              expr = _ast.CallStatic((Func<float' float' bool>) MathFloat.IsGreatOrEqualsThan' left'                                  right);                              break;                          case ConditionEnum.VcGt:                              expr = _ast.Binary(left' ">"' right);                              break;                            case ConditionEnum.VcEz:                              expr = _ast.Binary(_ast.Binary(left' "=="' 0.0f)' "||"' _ast.Binary(left' "=="' -0.0f));                              break;                          case ConditionEnum.VcEn:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsNan' left);                              break;                          case ConditionEnum.VcEi:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsInfinity' left);                              break;                          case ConditionEnum.VcEs:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsNanOrInfinity' left);                              break; // Tekken Dark Resurrection                            case ConditionEnum.VcNz:                              expr = _ast.Binary(left' "!="' 0f);                              break;                          case ConditionEnum.VcNn:                              expr = _ast.Unary("!"' _ast.CallStatic((Func<float' bool>) MathFloat.IsNan' left));                              break;                          case ConditionEnum.VcNi:                              expr = _ast.Unary("!"' _ast.CallStatic((Func<float' bool>) MathFloat.IsInfinity' left));                              break;                          case ConditionEnum.VcNs:                              expr = _ast.Unary("!"'                                  _ast.CallStatic((Func<float' bool>) MathFloat.IsNanOrInfinity' left));                              break;                            default: throw (new InvalidOperationException());                      }                        return _ast.Statements(new List<AstNodeStm>                      {                          _ast.Assign(localCcTemp' expr)'                          _ast.AssignVcc(index' localCcTemp)'                          _ast.Assign(localCcOr' _ast.Binary(localCcOr' "||"' localCcTemp))'                          _ast.Assign(localCcAnd' _ast.Binary(localCcAnd' "&&"' localCcTemp))                      });                  })'                  _ast.AssignVcc(4' localCcOr)'                  _ast.AssignVcc(5' localCcAnd)              );
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vcmp,The following statement contains a magic number: return _ast.Statements(                  _ast.Assign(localCcOr' false)'                  _ast.Assign(localCcAnd' true)'                    // TODO: CHECK THIS!                  _ast.AssignVcc(0' true)'                  _ast.AssignVcc(1' true)'                  _ast.AssignVcc(2' true)'                  _ast.AssignVcc(3' true)'                  _List(vectorSize' index =>                  {                      AstNodeExpr expr;                      //bool UsedForAggregate;                        var left = VecVs[index];                      var right = VecVt[index];                      switch (cond2)                      {                          case ConditionEnum.VcFl:                              expr = _ast.Immediate(false);                              break;                          case ConditionEnum.VcEq:                              expr = _ast.Binary(left' "=="' right);                              break;                          case ConditionEnum.VcLt:                              expr = _ast.Binary(left' "<"' right);                              break;                          //case ConditionEnum.VC_LE: Expr = ast.Binary(Left' "<="' Right); break;                          case ConditionEnum.VcLe:                              expr = _ast.CallStatic((Func<float' float' bool>) MathFloat.IsLessOrEqualsThan' left'                                  right);                              break;                            case ConditionEnum.VcTr:                              expr = _ast.Immediate(true);                              break;                          case ConditionEnum.VcNe:                              expr = _ast.Binary(left' "!="' right);                              break;                          //case ConditionEnum.VC_GE: Expr = ast.Binary(Left' ">="' Right); break;                          case ConditionEnum.VcGe:                              expr = _ast.CallStatic((Func<float' float' bool>) MathFloat.IsGreatOrEqualsThan' left'                                  right);                              break;                          case ConditionEnum.VcGt:                              expr = _ast.Binary(left' ">"' right);                              break;                            case ConditionEnum.VcEz:                              expr = _ast.Binary(_ast.Binary(left' "=="' 0.0f)' "||"' _ast.Binary(left' "=="' -0.0f));                              break;                          case ConditionEnum.VcEn:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsNan' left);                              break;                          case ConditionEnum.VcEi:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsInfinity' left);                              break;                          case ConditionEnum.VcEs:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsNanOrInfinity' left);                              break; // Tekken Dark Resurrection                            case ConditionEnum.VcNz:                              expr = _ast.Binary(left' "!="' 0f);                              break;                          case ConditionEnum.VcNn:                              expr = _ast.Unary("!"' _ast.CallStatic((Func<float' bool>) MathFloat.IsNan' left));                              break;                          case ConditionEnum.VcNi:                              expr = _ast.Unary("!"' _ast.CallStatic((Func<float' bool>) MathFloat.IsInfinity' left));                              break;                          case ConditionEnum.VcNs:                              expr = _ast.Unary("!"'                                  _ast.CallStatic((Func<float' bool>) MathFloat.IsNanOrInfinity' left));                              break;                            default: throw (new InvalidOperationException());                      }                        return _ast.Statements(new List<AstNodeStm>                      {                          _ast.Assign(localCcTemp' expr)'                          _ast.AssignVcc(index' localCcTemp)'                          _ast.Assign(localCcOr' _ast.Binary(localCcOr' "||"' localCcTemp))'                          _ast.Assign(localCcAnd' _ast.Binary(localCcAnd' "&&"' localCcTemp))                      });                  })'                  _ast.AssignVcc(4' localCcOr)'                  _ast.AssignVcc(5' localCcAnd)              );
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,Vcmp,The following statement contains a magic number: return _ast.Statements(                  _ast.Assign(localCcOr' false)'                  _ast.Assign(localCcAnd' true)'                    // TODO: CHECK THIS!                  _ast.AssignVcc(0' true)'                  _ast.AssignVcc(1' true)'                  _ast.AssignVcc(2' true)'                  _ast.AssignVcc(3' true)'                  _List(vectorSize' index =>                  {                      AstNodeExpr expr;                      //bool UsedForAggregate;                        var left = VecVs[index];                      var right = VecVt[index];                      switch (cond2)                      {                          case ConditionEnum.VcFl:                              expr = _ast.Immediate(false);                              break;                          case ConditionEnum.VcEq:                              expr = _ast.Binary(left' "=="' right);                              break;                          case ConditionEnum.VcLt:                              expr = _ast.Binary(left' "<"' right);                              break;                          //case ConditionEnum.VC_LE: Expr = ast.Binary(Left' "<="' Right); break;                          case ConditionEnum.VcLe:                              expr = _ast.CallStatic((Func<float' float' bool>) MathFloat.IsLessOrEqualsThan' left'                                  right);                              break;                            case ConditionEnum.VcTr:                              expr = _ast.Immediate(true);                              break;                          case ConditionEnum.VcNe:                              expr = _ast.Binary(left' "!="' right);                              break;                          //case ConditionEnum.VC_GE: Expr = ast.Binary(Left' ">="' Right); break;                          case ConditionEnum.VcGe:                              expr = _ast.CallStatic((Func<float' float' bool>) MathFloat.IsGreatOrEqualsThan' left'                                  right);                              break;                          case ConditionEnum.VcGt:                              expr = _ast.Binary(left' ">"' right);                              break;                            case ConditionEnum.VcEz:                              expr = _ast.Binary(_ast.Binary(left' "=="' 0.0f)' "||"' _ast.Binary(left' "=="' -0.0f));                              break;                          case ConditionEnum.VcEn:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsNan' left);                              break;                          case ConditionEnum.VcEi:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsInfinity' left);                              break;                          case ConditionEnum.VcEs:                              expr = _ast.CallStatic((Func<float' bool>) MathFloat.IsNanOrInfinity' left);                              break; // Tekken Dark Resurrection                            case ConditionEnum.VcNz:                              expr = _ast.Binary(left' "!="' 0f);                              break;                          case ConditionEnum.VcNn:                              expr = _ast.Unary("!"' _ast.CallStatic((Func<float' bool>) MathFloat.IsNan' left));                              break;                          case ConditionEnum.VcNi:                              expr = _ast.Unary("!"' _ast.CallStatic((Func<float' bool>) MathFloat.IsInfinity' left));                              break;                          case ConditionEnum.VcNs:                              expr = _ast.Unary("!"'                                  _ast.CallStatic((Func<float' bool>) MathFloat.IsNanOrInfinity' left));                              break;                            default: throw (new InvalidOperationException());                      }                        return _ast.Statements(new List<AstNodeStm>                      {                          _ast.Assign(localCcTemp' expr)'                          _ast.AssignVcc(index' localCcTemp)'                          _ast.Assign(localCcOr' _ast.Binary(localCcOr' "||"' localCcTemp))'                          _ast.Assign(localCcAnd' _ast.Binary(localCcAnd' "&&"' localCcTemp))                      });                  })'                  _ast.AssignVcc(4' localCcOr)'                  _ast.AssignVcc(5' localCcAnd)              );
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vcmovtf,The following statement contains a magic number: if (register < 6)              {                  // TODO: CHECK THIS!                  return _ast.IfElse(                      vcc(register)'                      VecVd.SetVector(index => VecVs[index]' _pc)'                      _ast.Statements(                          _ast.Assign(_ast.PrefixSourceEnabled()' false)'                          //ast.If(ast.PrefixDestinationEnabled()' VEC_VD.SetVector(Index => VEC_VD[Index]' PC))                          _ast.If(_ast.PrefixDestinationEnabled()' VecVd.SetVector(index => VecVd[index]' _pc))                      )                  );              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitter,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Fpu_Branches.cs,_vcmovtf,The following statement contains a magic number: if (register == 6)              {                  return VecVd.SetVector(index => _ast.Ternary(vcc(index)' VecVs[index]' VecVd[index])' _pc);              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_bitrev_impl,The following statement contains a magic number: v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_bitrev_impl,The following statement contains a magic number: v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_bitrev_impl,The following statement contains a magic number: v = ((v >> 4) & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_bitrev_impl,The following statement contains a magic number: v = ((v >> 4) & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_bitrev_impl,The following statement contains a magic number: v = ((v >> 8) & 0x00FF00FF) | ((v & 0x00FF00FF) << 8);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_bitrev_impl,The following statement contains a magic number: v = ((v >> 8) & 0x00FF00FF) | ((v & 0x00FF00FF) << 8);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_bitrev_impl,The following statement contains a magic number: v = (v >> 16) | (v << 16);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_bitrev_impl,The following statement contains a magic number: v = (v >> 16) | (v << 16);
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_cfc1_impl,The following statement contains a magic number: switch (rd)              {                  case 0: // readonly?                      throw (new NotImplementedException("_cfc1_impl.RD=0"));                  case 31:                      cpuThreadState.Gpr[rt] = (int) cpuThreadState.Fcr31.Value;                      break;                  default: throw (new Exception($"Unsupported CFC1({rd})"));              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_ctc1_impl,The following statement contains a magic number: switch (rd)              {                  case 31:                      cpuThreadState.Fcr31.Value = (uint) cpuThreadState.Gpr[rt];                      break;                  default: throw (new Exception($"Unsupported CFC1({rd})"));              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lwl_exec,The following statement contains a magic number: var addressAlign = (uint) address & 3;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lwl_exec,The following statement contains a magic number: var value = *(uint*) cpuThreadState.GetMemoryPtr(address & unchecked((uint) ~3));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lwr_exec,The following statement contains a magic number: var addressAlign = (uint) address & 3;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lwr_exec,The following statement contains a magic number: var value = *(uint*) cpuThreadState.GetMemoryPtr(address & unchecked((uint) ~3));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_swl_exec,The following statement contains a magic number: var addressAlign = (uint) address & 3;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_swr_exec,The following statement contains a magic number: var addressAlign = (uint) address & 3;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The following statement contains a magic number: var k = (int) (3 - ((address >> 2) & 3));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The following statement contains a magic number: var k = (int) (3 - ((address >> 2) & 3));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The following statement contains a magic number: var k = (int) (3 - ((address >> 2) & 3));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The following statement contains a magic number: var r = stackalloc float*[4];
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The following statement contains a magic number: r[2] = r2;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The following statement contains a magic number: r[3] = r3;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The following statement contains a magic number: fixed (float* vfpr = &cpuThreadState.Vfr0)              {                  for (var j = k; j < 4; j++' address += 4)                  {                      var ptr = r[j];                      var memoryAddress = address;                      var memory = (float*) cpuThreadState.GetMemoryPtr(memoryAddress);                        //Console.Error.WriteLine("_lvl_svl_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory);                        LanguageUtils.Transfer(ref *memory' ref *ptr' save);                        //Console.Error.WriteLine("_lvl_svl_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory);                  }              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvl_svl_q,The following statement contains a magic number: fixed (float* vfpr = &cpuThreadState.Vfr0)              {                  for (var j = k; j < 4; j++' address += 4)                  {                      var ptr = r[j];                      var memoryAddress = address;                      var memory = (float*) cpuThreadState.GetMemoryPtr(memoryAddress);                        //Console.Error.WriteLine("_lvl_svl_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory);                        LanguageUtils.Transfer(ref *memory' ref *ptr' save);                        //Console.Error.WriteLine("_lvl_svl_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory);                  }              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The following statement contains a magic number: int k = (int) (4 - ((address >> 2) & 3));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The following statement contains a magic number: int k = (int) (4 - ((address >> 2) & 3));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The following statement contains a magic number: int k = (int) (4 - ((address >> 2) & 3));
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The following statement contains a magic number: var r = stackalloc float*[4];
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The following statement contains a magic number: r[2] = r2;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The following statement contains a magic number: r[3] = r3;
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_lvr_svr_q,The following statement contains a magic number: fixed (float* vfpr = &cpuThreadState.Vfr0)              {                  for (var j = 0; j < k; j++' address += 4)                  {                      var ptr = r[j];                      var memoryAddress = address;                      var memory = (float*) cpuThreadState.GetMemoryPtr(memoryAddress);                        //Console.Error.WriteLine("_lvl_svr_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory);                        LanguageUtils.Transfer(ref *memory' ref *ptr' save);                        //Console.Error.WriteLine("_lvl_svr_q({0}): {1:X8}: Reg({2:X8}) {3} Mem({4:X8})"' j' memory_address' *(int*)ptr' Save ? "->" : "<-"' *(int*)memory);                  }              }
Magic Number,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_vrndi,The following statement contains a magic number: var data = new byte[4];
Magic Number,CSPspEmu.Core.Cpu.Emitter,VfpuRuntimeRegister,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Vfpu.Utils.cs,GetRegApplyPrefix,The following statement contains a magic number: if (prefix.Enabled && prefix.IsValidIndex(prefixIndex))                  {                      // Constant.                      if (prefix.SourceConstant(prefixIndex))                      {                          float value = 0.0f;                          var sourceIndex = prefix.SourceIndex(prefixIndex);                          switch (sourceIndex)                          {                              case 0:                                  value = prefix.SourceAbsolute(prefixIndex) ? (3.0f) : (0.0f);                                  break;                              case 1:                                  value = prefix.SourceAbsolute(prefixIndex) ? (1.0f / 3.0f) : (1.0f);                                  break;                              case 2:                                  value = prefix.SourceAbsolute(prefixIndex) ? (1.0f / 4.0f) : (2.0f);                                  break;                              case 3:                                  value = prefix.SourceAbsolute(prefixIndex) ? (1.0f / 6.0f) : (0.5f);                                  break;                              default: throw (new InvalidOperationException("Invalid SourceIndex : " + sourceIndex));                          }                            astNodeExpr = Ast.Cast(GetVTypeType()' value);                      }                      // Value.                      else                      {                          astNodeExpr = _GetVRegRef(indices[(int) prefix.SourceIndex(prefixIndex)]);                          if (prefix.SourceAbsolute(prefixIndex))                              astNodeExpr = Ast.CallStatic((Func<float' float>) MathFloat.Abs' astNodeExpr);                      }                        if (prefix.SourceNegate(prefixIndex)) astNodeExpr = Ast.Unary("-"' astNodeExpr);                  }
Magic Number,CSPspEmu.Core.Cpu.Emitter,VfpuRuntimeRegister,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Vfpu.Utils.cs,GetRegApplyPrefix,The following statement contains a magic number: if (prefix.Enabled && prefix.IsValidIndex(prefixIndex))                  {                      // Constant.                      if (prefix.SourceConstant(prefixIndex))                      {                          float value = 0.0f;                          var sourceIndex = prefix.SourceIndex(prefixIndex);                          switch (sourceIndex)                          {                              case 0:                                  value = prefix.SourceAbsolute(prefixIndex) ? (3.0f) : (0.0f);                                  break;                              case 1:                                  value = prefix.SourceAbsolute(prefixIndex) ? (1.0f / 3.0f) : (1.0f);                                  break;                              case 2:                                  value = prefix.SourceAbsolute(prefixIndex) ? (1.0f / 4.0f) : (2.0f);                                  break;                              case 3:                                  value = prefix.SourceAbsolute(prefixIndex) ? (1.0f / 6.0f) : (0.5f);                                  break;                              default: throw (new InvalidOperationException("Invalid SourceIndex : " + sourceIndex));                          }                            astNodeExpr = Ast.Cast(GetVTypeType()' value);                      }                      // Value.                      else                      {                          astNodeExpr = _GetVRegRef(indices[(int) prefix.SourceIndex(prefixIndex)]);                          if (prefix.SourceAbsolute(prefixIndex))                              astNodeExpr = Ast.CallStatic((Func<float' float>) MathFloat.Abs' astNodeExpr);                      }                        if (prefix.SourceNegate(prefixIndex)) astNodeExpr = Ast.Unary("-"' astNodeExpr);                  }
Magic Number,CSPspEmu.Core.Cpu.Emitter,VfpuRuntimeRegister,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Vfpu.Utils.cs,SetRegApplyPrefix,The following statement contains a magic number: if (prefixDestination.Enabled && prefixDestination.IsValidIndex(prefixIndex))                  {                      // It is masked. It won't write the value.                      float max = 0;                      float min = 0;                      if (prefixDestination.DestinationMask(prefixIndex))                      {                          //return ast.Statement();                          astNodeExpr = _GetVRegRef(regIndex);                      }                      else                      {                          var doClamp = false;                          switch (prefixDestination.DestinationSaturation(prefixIndex))                          {                              case 1:                                  doClamp = true;                                  min = 0.0f;                                  max = 1.0f;                                  break;                              case 3:                                  doClamp = true;                                  min = -1.0f;                                  max = 1.0f;                                  break;                          }                            if (doClamp)                          {                              if (VType == CpuEmitter.VType.VFloat)                              {                                  astNodeExpr = Ast.CallStatic((Func<float' float' float' float>) MathFloat.Clamp'                                      astNodeExpr' (float) min' (float) max);                              }                              else                              {                                  astNodeExpr = Ast.Cast(GetVTypeType()'                                      Ast.CallStatic((Func<int' int' int' int>) MathFloat.ClampInt' astNodeExpr'                                          (int) min' (int) max));                              }                          }                      }                  }
Magic Number,CSPspEmu.Core.Cpu.InstructionCache,MethodCompilerThread,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\InstructionCache\MethodCache.cs,_GenerateForPC,The following statement contains a magic number: if (DynarecConfig.DebugFunctionCreation)              {                  ConsoleUtils.SaveRestoreConsoleColor(                      (timeAstGeneration + dynarecFunction.TimeLinking).TotalMilliseconds > 10                          ? ConsoleColor.Red                          : ConsoleColor.Gray' () =>                      {                          Console.WriteLine(                              "({0}): (analyze: {1}' generateAST: {2}' optimize: {3}' generateIL: {4}' createDelegate: {5}' link: {6}): ({1}' {2}' {3}' {4}' {5}' {6}) : {7} ms"'                              (dynarecFunction.MaxPc - dynarecFunction.MinPc) / 4'                              (int) dynarecFunction.TimeAnalyzeBranches.TotalMilliseconds'                              (int) dynarecFunction.TimeGenerateAst.TotalMilliseconds'                              (int) dynarecFunction.TimeOptimize.TotalMilliseconds'                              (int) dynarecFunction.TimeGenerateIl.TotalMilliseconds'                              (int) dynarecFunction.TimeCreateDelegate.TotalMilliseconds'                              (int) dynarecFunction.TimeLinking.TotalMilliseconds'                              (int) (timeAstGeneration + dynarecFunction.TimeLinking).TotalMilliseconds                          );                      });              }
Magic Number,CSPspEmu.Core.Cpu.InstructionCache,MethodCompilerThread,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\InstructionCache\MethodCache.cs,_GenerateForPC,The following statement contains a magic number: if (DynarecConfig.DebugFunctionCreation)              {                  ConsoleUtils.SaveRestoreConsoleColor(                      (timeAstGeneration + dynarecFunction.TimeLinking).TotalMilliseconds > 10                          ? ConsoleColor.Red                          : ConsoleColor.Gray' () =>                      {                          Console.WriteLine(                              "({0}): (analyze: {1}' generateAST: {2}' optimize: {3}' generateIL: {4}' createDelegate: {5}' link: {6}): ({1}' {2}' {3}' {4}' {5}' {6}) : {7} ms"'                              (dynarecFunction.MaxPc - dynarecFunction.MinPc) / 4'                              (int) dynarecFunction.TimeAnalyzeBranches.TotalMilliseconds'                              (int) dynarecFunction.TimeGenerateAst.TotalMilliseconds'                              (int) dynarecFunction.TimeOptimize.TotalMilliseconds'                              (int) dynarecFunction.TimeGenerateIl.TotalMilliseconds'                              (int) dynarecFunction.TimeCreateDelegate.TotalMilliseconds'                              (int) dynarecFunction.TimeLinking.TotalMilliseconds'                              (int) (timeAstGeneration + dynarecFunction.TimeLinking).TotalMilliseconds                          );                      });              }
Magic Number,CSPspEmu.Core.Cpu.Dynarec.Ast,AstOptimizerPsp,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\Ast\AstOptimizerPsp.cs,OptimizeLwlLwr,The following statement contains a magic number: for (var n = 0; n < containerNodes.Count; n++)              {                  // Empty node                  if (containerNodes[n] == null)                      continue;                    // A label breaks the optimization' because we don't know if the register is being to be modified.                  if (containerNodes[n] is AstNodeStmLabel)                  {                      //Console.WriteLine("clear[0]");                      lwlLwrStates.Clear();                      continue;                  }                    var pspInstructionNode = containerNodes[n] as AstNodeStmPspInstruction;                  if (pspInstructionNode == null) continue;                  var disassembledResult = pspInstructionNode.DisassembledResult;                  var instructionInfo = disassembledResult.InstructionInfo;                  var instruction = disassembledResult.Instruction;                  var pc = disassembledResult.InstructionPc;                    // A branch instruction. It breaks the optimization.                  if ((instructionInfo.InstructionType &                       (InstructionType.B | InstructionType.Jump | InstructionType.Syscall)) != 0)                  {                      //Console.WriteLine("clear[1]");                      lwlLwrStates.Clear();                      continue;                  }                    // lw(l/r) rt' x(rs)                  switch (instructionInfo.Name)                  {                      case "lwl":                          lwlLwrStates[instruction.Rt] = new LwlLwrState()                          {                              LwlListIndex = n'                              LwlRtRegister = instruction.Rt'                              LwlRsRegister = instruction.Rs'                              LwlImm = instruction.Imm'                              LwlPc = pc'                          };                          //Console.WriteLine("lwl");                          //  GPR_u(RS)' IMM_s()' GPR_u(RT)                          break;                      case "lwr":                          //Console.WriteLine("lwr");                          //Console.WriteLine(LwlLwrStates.Count);                          if (lwlLwrStates.ContainsKey(instruction.Rt))                          {                              var lwlLwrState = lwlLwrStates[instruction.Rt];                              if (                                  (lwlLwrState.LwlRsRegister == instruction.Rs) &&                                  (lwlLwrState.LwlRtRegister == instruction.Rt) &&                                  (lwlLwrState.LwlImm == instruction.Imm + 3)                              )                              {                                  containerNodes[lwlLwrState.LwlListIndex] = null;                                  containerNodes[n] = ast.Statements(                                      ast.Comment($"{lwlLwrState.LwlPc:X8}+{pc:X8} lwl+lwr")'                                      ast.AssignGpr(                                          instruction.Rt'                                          ast.MemoryGetValue<int>(                                              Memory'                                              ast.Cast<uint>(ast.Binary(ast.GPR_s(instruction.Rs)' "+"' instruction.Imm))                                          )                                      )                                  );                                  //Console.WriteLine("Valid match!");                              }                          }                          break;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,AnalyzeBranches,The following statement contains a magic number: while (true)                  {                      HandleNewBranch:                      var endOfBranchFound = false;                        if (branchesToAnalyze.Count == 0) break;                        for (_pc = branchesToAnalyze.Dequeue(); _pc <= endPc; _pc += 4)                      {                          // If already analyzed' stop scanning this branch.                          if (_analyzedPc.Contains(_pc)) break;                          _analyzedPc.Add(_pc);                          //Console.WriteLine("%08X".Sprintf(PC));                            if (_analyzedPc.Count > MaxNumberOfInstructions)                          {                              throw (new InvalidDataException(                                  $"Code sequence too long: >= {MaxNumberOfInstructions} at 0x{_entryPc:X8}"));                          }                            UpdateMinMax(_pc);                            //Console.WriteLine("    PC:{0:X}"' PC);                            var instruction = _instructionReader[_pc];                            var branchInfo = DynarecBranchAnalyzer.GetBranchInfo(instruction);                          var disassemblerInfo = _mipsDisassembler.Disassemble(_pc' instruction);                            LogInstruction(_pc' instruction);                            // Break                          if (disassemblerInfo.InstructionInfo.Name == "break")                          {                              break;                          }                          // Branch instruction.                          //else if (BranchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.JumpAlways))                          else if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.JumpInstruction))                          {                              //Console.WriteLine("Instruction");                                var jumpAddress = instruction.GetJumpAddress(_memory' _pc);                                // Located a jump-always instruction with a delayed slot. Process next instruction too.                              if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.AndLink))                              {                                  // Just a function call. Continue analyzing.                              }                              else                              {                                  if (PspMemory.IsAddressValid(jumpAddress))                                  {                                      if (!_labelsJump.ContainsKey(jumpAddress))                                      {                                          if (AddressInsideFunction(jumpAddress))                                          {                                              //Console.WriteLine("JumpAddress: {0:X8}"' JumpAddress);                                              _labelsJump[jumpAddress] =                                                  AstLabel.CreateLabel($"Jump_0x{jumpAddress:X8}");                                              branchesToAnalyze.Enqueue(jumpAddress);                                          }                                      }                                  }                                    endOfBranchFound = true;                                  continue;                              }                          }                          else if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.BranchOrJumpInstruction))                          {                              var branchAddress = instruction.GetBranchAddress(_pc);                              if (!_labels.ContainsKey(branchAddress))                              {                                  //Console.WriteLine("BranchAddress: {0:X8}"' BranchAddress);                                  UpdateMinMax(branchAddress);                                  _labels[branchAddress] =                                      AstLabel.CreateLabel($"Label_0x{branchAddress:X8}");                                  branchesToAnalyze.Enqueue(branchAddress);                              }                          }                          else if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.SyscallInstruction))                          {                              // On this special Syscall                              if (instruction.Code == SyscallInfo.NativeCallSyscallCode)                              {                                  //PC += 4;                                  goto HandleNewBranch;                              }                          }                            // Jump-Always found. And we have also processed the delayed branch slot. End the branch.                          if (endOfBranchFound)                          {                              endOfBranchFound = false;                              goto HandleNewBranch;                          }                      }                  }
Magic Number,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,EmitCpuInstruction,The following statement contains a magic number: try                  {                      var nodes = _ast.Statements();                        if (_cpuProcessor.NativeBreakpoints.Contains(_pc))                      {                          nodes.AddStatement(_ast.Statement(_ast.CallStatic((Action) IsDebuggerPresentDebugBreak)));                      }                        TryPutLabelAt(_pc' nodes);                        if (DynarecConfig.UpdatePCEveryInstruction)                      {                          nodes.AddStatement(_ast.AssignPc(_pc));                      }                        nodes.AddStatement(_GetAstCpuInstructionAT(_pc));                        return nodes;                  }                  finally                  {                      _pc += 4;                      _instructionsEmitedSinceLastWaypoint++;                  }
Magic Number,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,The following statement contains a magic number: for (_pc = _minPc; _pc <= _maxPc;)                  {                      if (!_analyzedPc.Contains(_pc))                      {                          _pc += 4;                          continue;                      }                      uint currentInstructionPc = _pc;                      Instruction currentInstruction = _instructionReader[_pc];                      _instructionsProcessed++;                        var branchInfo = DynarecBranchAnalyzer.GetBranchInfo(currentInstruction.Value);                        // Delayed branch instruction.                      if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.BranchOrJumpInstruction) != 0)                      {                          _instructionsEmitedSinceLastWaypoint += 2;                          nodes.AddStatement(EmitInstructionCountIncrement(true));                            var branchAddress = currentInstruction.GetBranchAddress(_pc);                            if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.JumpInstruction))                          {                              TryPutLabelAt(_pc' nodes);                                var delayedBranchInstruction = _GetAstCpuInstructionAT(_pc + 4); // Delayed                              var jumpInstruction = _GetAstCpuInstructionAT(_pc + 0); // Jump    #if !DISABLE_JUMP_GOTO                              var jumpInstruction2 = _cpuEmitter.LoadAt(_pc + 0);                              var jumpDisasm = _mipsDisassembler.Disassemble(_pc + 0' jumpInstruction2);                              var jumpJumpPc = jumpDisasm.Instruction.GetJumpAddress(_memory' jumpDisasm.InstructionPc);                                // An internal jump.                              if (                                  (jumpDisasm.InstructionInfo.Name == "j")                                  && (_labelsJump.ContainsKey(jumpJumpPc))                              )                              {                                  jumpInstruction = new AstNodeStmPspInstruction(jumpDisasm'                                      _ast.GotoAlways(_labelsJump[jumpJumpPc]));                                    //Console.WriteLine(                                  //	"{0}: {1} : Function({2:X8}-{3:X8})"'                                  //	DummyTempCounter'                                  //	GeneratorCSharpPsp.GenerateString<GeneratorCSharpPsp>(AstOptimizerPsp.GlobalOptimize(CpuProcessor' JumpInstruction))'                                  //	MinPC' MaxPC                                  //);                                    //DummyTempCounter++;                              }                              else if (jumpDisasm.InstructionInfo.Name == "j" || jumpDisasm.InstructionInfo.Name == "jal")                              {                                  CallingPCs.Add(jumpJumpPc);                              }  #endif                                // Put delayed instruction first.                              nodes.AddStatement(delayedBranchInstruction);                              // A jump outside the current function.                              nodes.AddStatement(jumpInstruction);                                _pc += 8;                          }                          else                          {                              // Branch instruction.                              nodes.AddStatement(EmitCpuInstruction());                                //if ((BranchInfo & CpuBranchAnalyzer.Flags.Likely) != 0)                              if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.Likely))                              {                                  //Console.WriteLine("Likely");                                  // Delayed instruction.                                  nodes.AddStatement(_cpuEmitter._branch_likely(EmitCpuInstruction()));                              }                              else                              {                                  //Console.WriteLine("Not Likely");                                  // Delayed instruction.                                  nodes.AddStatement(EmitCpuInstruction());                              }                                if (currentInstructionPc + 4 != branchAddress)                              {                                  if (_labels.ContainsKey(branchAddress))                                  {                                      nodes.AddStatement(_cpuEmitter._branch_post(_labels[branchAddress]' branchAddress));                                  }                                  // Code not reached.                                  else                                  {                                      throw (new InvalidOperationException("!Labels.ContainsKey(BranchAddress)"));                                  }                              }                              else                              {                                  throw (new InvalidOperationException("Invalid branch!"));                              }                          }                      }                      // Normal instruction.                      else                      {                          // Syscall instruction.                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              nodes.AddStatement(StorePc());                          }                          nodes.AddStatement(EmitCpuInstruction());                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              // On this special Syscall                              if (currentInstruction.Code == SyscallInfo.NativeCallSyscallCode)                              {                                  //PC += 4;                                  break;                              }                          }                      }                  }
Magic Number,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,The following statement contains a magic number: for (_pc = _minPc; _pc <= _maxPc;)                  {                      if (!_analyzedPc.Contains(_pc))                      {                          _pc += 4;                          continue;                      }                      uint currentInstructionPc = _pc;                      Instruction currentInstruction = _instructionReader[_pc];                      _instructionsProcessed++;                        var branchInfo = DynarecBranchAnalyzer.GetBranchInfo(currentInstruction.Value);                        // Delayed branch instruction.                      if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.BranchOrJumpInstruction) != 0)                      {                          _instructionsEmitedSinceLastWaypoint += 2;                          nodes.AddStatement(EmitInstructionCountIncrement(true));                            var branchAddress = currentInstruction.GetBranchAddress(_pc);                            if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.JumpInstruction))                          {                              TryPutLabelAt(_pc' nodes);                                var delayedBranchInstruction = _GetAstCpuInstructionAT(_pc + 4); // Delayed                              var jumpInstruction = _GetAstCpuInstructionAT(_pc + 0); // Jump    #if !DISABLE_JUMP_GOTO                              var jumpInstruction2 = _cpuEmitter.LoadAt(_pc + 0);                              var jumpDisasm = _mipsDisassembler.Disassemble(_pc + 0' jumpInstruction2);                              var jumpJumpPc = jumpDisasm.Instruction.GetJumpAddress(_memory' jumpDisasm.InstructionPc);                                // An internal jump.                              if (                                  (jumpDisasm.InstructionInfo.Name == "j")                                  && (_labelsJump.ContainsKey(jumpJumpPc))                              )                              {                                  jumpInstruction = new AstNodeStmPspInstruction(jumpDisasm'                                      _ast.GotoAlways(_labelsJump[jumpJumpPc]));                                    //Console.WriteLine(                                  //	"{0}: {1} : Function({2:X8}-{3:X8})"'                                  //	DummyTempCounter'                                  //	GeneratorCSharpPsp.GenerateString<GeneratorCSharpPsp>(AstOptimizerPsp.GlobalOptimize(CpuProcessor' JumpInstruction))'                                  //	MinPC' MaxPC                                  //);                                    //DummyTempCounter++;                              }                              else if (jumpDisasm.InstructionInfo.Name == "j" || jumpDisasm.InstructionInfo.Name == "jal")                              {                                  CallingPCs.Add(jumpJumpPc);                              }  #endif                                // Put delayed instruction first.                              nodes.AddStatement(delayedBranchInstruction);                              // A jump outside the current function.                              nodes.AddStatement(jumpInstruction);                                _pc += 8;                          }                          else                          {                              // Branch instruction.                              nodes.AddStatement(EmitCpuInstruction());                                //if ((BranchInfo & CpuBranchAnalyzer.Flags.Likely) != 0)                              if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.Likely))                              {                                  //Console.WriteLine("Likely");                                  // Delayed instruction.                                  nodes.AddStatement(_cpuEmitter._branch_likely(EmitCpuInstruction()));                              }                              else                              {                                  //Console.WriteLine("Not Likely");                                  // Delayed instruction.                                  nodes.AddStatement(EmitCpuInstruction());                              }                                if (currentInstructionPc + 4 != branchAddress)                              {                                  if (_labels.ContainsKey(branchAddress))                                  {                                      nodes.AddStatement(_cpuEmitter._branch_post(_labels[branchAddress]' branchAddress));                                  }                                  // Code not reached.                                  else                                  {                                      throw (new InvalidOperationException("!Labels.ContainsKey(BranchAddress)"));                                  }                              }                              else                              {                                  throw (new InvalidOperationException("Invalid branch!"));                              }                          }                      }                      // Normal instruction.                      else                      {                          // Syscall instruction.                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              nodes.AddStatement(StorePc());                          }                          nodes.AddStatement(EmitCpuInstruction());                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              // On this special Syscall                              if (currentInstruction.Code == SyscallInfo.NativeCallSyscallCode)                              {                                  //PC += 4;                                  break;                              }                          }                      }                  }
Magic Number,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,The following statement contains a magic number: for (_pc = _minPc; _pc <= _maxPc;)                  {                      if (!_analyzedPc.Contains(_pc))                      {                          _pc += 4;                          continue;                      }                      uint currentInstructionPc = _pc;                      Instruction currentInstruction = _instructionReader[_pc];                      _instructionsProcessed++;                        var branchInfo = DynarecBranchAnalyzer.GetBranchInfo(currentInstruction.Value);                        // Delayed branch instruction.                      if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.BranchOrJumpInstruction) != 0)                      {                          _instructionsEmitedSinceLastWaypoint += 2;                          nodes.AddStatement(EmitInstructionCountIncrement(true));                            var branchAddress = currentInstruction.GetBranchAddress(_pc);                            if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.JumpInstruction))                          {                              TryPutLabelAt(_pc' nodes);                                var delayedBranchInstruction = _GetAstCpuInstructionAT(_pc + 4); // Delayed                              var jumpInstruction = _GetAstCpuInstructionAT(_pc + 0); // Jump    #if !DISABLE_JUMP_GOTO                              var jumpInstruction2 = _cpuEmitter.LoadAt(_pc + 0);                              var jumpDisasm = _mipsDisassembler.Disassemble(_pc + 0' jumpInstruction2);                              var jumpJumpPc = jumpDisasm.Instruction.GetJumpAddress(_memory' jumpDisasm.InstructionPc);                                // An internal jump.                              if (                                  (jumpDisasm.InstructionInfo.Name == "j")                                  && (_labelsJump.ContainsKey(jumpJumpPc))                              )                              {                                  jumpInstruction = new AstNodeStmPspInstruction(jumpDisasm'                                      _ast.GotoAlways(_labelsJump[jumpJumpPc]));                                    //Console.WriteLine(                                  //	"{0}: {1} : Function({2:X8}-{3:X8})"'                                  //	DummyTempCounter'                                  //	GeneratorCSharpPsp.GenerateString<GeneratorCSharpPsp>(AstOptimizerPsp.GlobalOptimize(CpuProcessor' JumpInstruction))'                                  //	MinPC' MaxPC                                  //);                                    //DummyTempCounter++;                              }                              else if (jumpDisasm.InstructionInfo.Name == "j" || jumpDisasm.InstructionInfo.Name == "jal")                              {                                  CallingPCs.Add(jumpJumpPc);                              }  #endif                                // Put delayed instruction first.                              nodes.AddStatement(delayedBranchInstruction);                              // A jump outside the current function.                              nodes.AddStatement(jumpInstruction);                                _pc += 8;                          }                          else                          {                              // Branch instruction.                              nodes.AddStatement(EmitCpuInstruction());                                //if ((BranchInfo & CpuBranchAnalyzer.Flags.Likely) != 0)                              if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.Likely))                              {                                  //Console.WriteLine("Likely");                                  // Delayed instruction.                                  nodes.AddStatement(_cpuEmitter._branch_likely(EmitCpuInstruction()));                              }                              else                              {                                  //Console.WriteLine("Not Likely");                                  // Delayed instruction.                                  nodes.AddStatement(EmitCpuInstruction());                              }                                if (currentInstructionPc + 4 != branchAddress)                              {                                  if (_labels.ContainsKey(branchAddress))                                  {                                      nodes.AddStatement(_cpuEmitter._branch_post(_labels[branchAddress]' branchAddress));                                  }                                  // Code not reached.                                  else                                  {                                      throw (new InvalidOperationException("!Labels.ContainsKey(BranchAddress)"));                                  }                              }                              else                              {                                  throw (new InvalidOperationException("Invalid branch!"));                              }                          }                      }                      // Normal instruction.                      else                      {                          // Syscall instruction.                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              nodes.AddStatement(StorePc());                          }                          nodes.AddStatement(EmitCpuInstruction());                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              // On this special Syscall                              if (currentInstruction.Code == SyscallInfo.NativeCallSyscallCode)                              {                                  //PC += 4;                                  break;                              }                          }                      }                  }
Magic Number,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,The following statement contains a magic number: for (_pc = _minPc; _pc <= _maxPc;)                  {                      if (!_analyzedPc.Contains(_pc))                      {                          _pc += 4;                          continue;                      }                      uint currentInstructionPc = _pc;                      Instruction currentInstruction = _instructionReader[_pc];                      _instructionsProcessed++;                        var branchInfo = DynarecBranchAnalyzer.GetBranchInfo(currentInstruction.Value);                        // Delayed branch instruction.                      if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.BranchOrJumpInstruction) != 0)                      {                          _instructionsEmitedSinceLastWaypoint += 2;                          nodes.AddStatement(EmitInstructionCountIncrement(true));                            var branchAddress = currentInstruction.GetBranchAddress(_pc);                            if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.JumpInstruction))                          {                              TryPutLabelAt(_pc' nodes);                                var delayedBranchInstruction = _GetAstCpuInstructionAT(_pc + 4); // Delayed                              var jumpInstruction = _GetAstCpuInstructionAT(_pc + 0); // Jump    #if !DISABLE_JUMP_GOTO                              var jumpInstruction2 = _cpuEmitter.LoadAt(_pc + 0);                              var jumpDisasm = _mipsDisassembler.Disassemble(_pc + 0' jumpInstruction2);                              var jumpJumpPc = jumpDisasm.Instruction.GetJumpAddress(_memory' jumpDisasm.InstructionPc);                                // An internal jump.                              if (                                  (jumpDisasm.InstructionInfo.Name == "j")                                  && (_labelsJump.ContainsKey(jumpJumpPc))                              )                              {                                  jumpInstruction = new AstNodeStmPspInstruction(jumpDisasm'                                      _ast.GotoAlways(_labelsJump[jumpJumpPc]));                                    //Console.WriteLine(                                  //	"{0}: {1} : Function({2:X8}-{3:X8})"'                                  //	DummyTempCounter'                                  //	GeneratorCSharpPsp.GenerateString<GeneratorCSharpPsp>(AstOptimizerPsp.GlobalOptimize(CpuProcessor' JumpInstruction))'                                  //	MinPC' MaxPC                                  //);                                    //DummyTempCounter++;                              }                              else if (jumpDisasm.InstructionInfo.Name == "j" || jumpDisasm.InstructionInfo.Name == "jal")                              {                                  CallingPCs.Add(jumpJumpPc);                              }  #endif                                // Put delayed instruction first.                              nodes.AddStatement(delayedBranchInstruction);                              // A jump outside the current function.                              nodes.AddStatement(jumpInstruction);                                _pc += 8;                          }                          else                          {                              // Branch instruction.                              nodes.AddStatement(EmitCpuInstruction());                                //if ((BranchInfo & CpuBranchAnalyzer.Flags.Likely) != 0)                              if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.Likely))                              {                                  //Console.WriteLine("Likely");                                  // Delayed instruction.                                  nodes.AddStatement(_cpuEmitter._branch_likely(EmitCpuInstruction()));                              }                              else                              {                                  //Console.WriteLine("Not Likely");                                  // Delayed instruction.                                  nodes.AddStatement(EmitCpuInstruction());                              }                                if (currentInstructionPc + 4 != branchAddress)                              {                                  if (_labels.ContainsKey(branchAddress))                                  {                                      nodes.AddStatement(_cpuEmitter._branch_post(_labels[branchAddress]' branchAddress));                                  }                                  // Code not reached.                                  else                                  {                                      throw (new InvalidOperationException("!Labels.ContainsKey(BranchAddress)"));                                  }                              }                              else                              {                                  throw (new InvalidOperationException("Invalid branch!"));                              }                          }                      }                      // Normal instruction.                      else                      {                          // Syscall instruction.                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              nodes.AddStatement(StorePc());                          }                          nodes.AddStatement(EmitCpuInstruction());                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              // On this special Syscall                              if (currentInstruction.Code == SyscallInfo.NativeCallSyscallCode)                              {                                  //PC += 4;                                  break;                              }                          }                      }                  }
Magic Number,CSPspEmu.Core.Cpu.Dynarec,InternalFunctionCompiler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\DynarecFunctionCompiler.Internal.cs,GenerateCode,The following statement contains a magic number: for (_pc = _minPc; _pc <= _maxPc;)                  {                      if (!_analyzedPc.Contains(_pc))                      {                          _pc += 4;                          continue;                      }                      uint currentInstructionPc = _pc;                      Instruction currentInstruction = _instructionReader[_pc];                      _instructionsProcessed++;                        var branchInfo = DynarecBranchAnalyzer.GetBranchInfo(currentInstruction.Value);                        // Delayed branch instruction.                      if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.BranchOrJumpInstruction) != 0)                      {                          _instructionsEmitedSinceLastWaypoint += 2;                          nodes.AddStatement(EmitInstructionCountIncrement(true));                            var branchAddress = currentInstruction.GetBranchAddress(_pc);                            if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.JumpInstruction))                          {                              TryPutLabelAt(_pc' nodes);                                var delayedBranchInstruction = _GetAstCpuInstructionAT(_pc + 4); // Delayed                              var jumpInstruction = _GetAstCpuInstructionAT(_pc + 0); // Jump    #if !DISABLE_JUMP_GOTO                              var jumpInstruction2 = _cpuEmitter.LoadAt(_pc + 0);                              var jumpDisasm = _mipsDisassembler.Disassemble(_pc + 0' jumpInstruction2);                              var jumpJumpPc = jumpDisasm.Instruction.GetJumpAddress(_memory' jumpDisasm.InstructionPc);                                // An internal jump.                              if (                                  (jumpDisasm.InstructionInfo.Name == "j")                                  && (_labelsJump.ContainsKey(jumpJumpPc))                              )                              {                                  jumpInstruction = new AstNodeStmPspInstruction(jumpDisasm'                                      _ast.GotoAlways(_labelsJump[jumpJumpPc]));                                    //Console.WriteLine(                                  //	"{0}: {1} : Function({2:X8}-{3:X8})"'                                  //	DummyTempCounter'                                  //	GeneratorCSharpPsp.GenerateString<GeneratorCSharpPsp>(AstOptimizerPsp.GlobalOptimize(CpuProcessor' JumpInstruction))'                                  //	MinPC' MaxPC                                  //);                                    //DummyTempCounter++;                              }                              else if (jumpDisasm.InstructionInfo.Name == "j" || jumpDisasm.InstructionInfo.Name == "jal")                              {                                  CallingPCs.Add(jumpJumpPc);                              }  #endif                                // Put delayed instruction first.                              nodes.AddStatement(delayedBranchInstruction);                              // A jump outside the current function.                              nodes.AddStatement(jumpInstruction);                                _pc += 8;                          }                          else                          {                              // Branch instruction.                              nodes.AddStatement(EmitCpuInstruction());                                //if ((BranchInfo & CpuBranchAnalyzer.Flags.Likely) != 0)                              if (branchInfo.HasFlag(DynarecBranchAnalyzer.JumpFlags.Likely))                              {                                  //Console.WriteLine("Likely");                                  // Delayed instruction.                                  nodes.AddStatement(_cpuEmitter._branch_likely(EmitCpuInstruction()));                              }                              else                              {                                  //Console.WriteLine("Not Likely");                                  // Delayed instruction.                                  nodes.AddStatement(EmitCpuInstruction());                              }                                if (currentInstructionPc + 4 != branchAddress)                              {                                  if (_labels.ContainsKey(branchAddress))                                  {                                      nodes.AddStatement(_cpuEmitter._branch_post(_labels[branchAddress]' branchAddress));                                  }                                  // Code not reached.                                  else                                  {                                      throw (new InvalidOperationException("!Labels.ContainsKey(BranchAddress)"));                                  }                              }                              else                              {                                  throw (new InvalidOperationException("Invalid branch!"));                              }                          }                      }                      // Normal instruction.                      else                      {                          // Syscall instruction.                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              nodes.AddStatement(StorePc());                          }                          nodes.AddStatement(EmitCpuInstruction());                          if ((branchInfo & DynarecBranchAnalyzer.JumpFlags.SyscallInstruction) != 0)                          {                              // On this special Syscall                              if (currentInstruction.Code == SyscallInfo.NativeCallSyscallCode)                              {                                  //PC += 4;                                  break;                              }                          }                      }                  }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following statement contains a magic number: foreach (var part in encoding.Split(':'))              {                  if (part[0] == '-' || part[0] == '0' || part[0] == '1')                  {                      foreach (var Char in part)                      {                          Mask <<= 1;                          Value <<= 1;                          switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }                      }                  }                  else                  {                      int displacement;                        switch (part)                      {                          case "cstw":                          case "cstz":                          case "csty":                          case "cstx":                          case "absw":                          case "absz":                          case "absy":                          case "absx":                          case "mskw":                          case "mskz":                          case "msky":                          case "mskx":                          case "negw":                          case "negz":                          case "negy":                          case "negx":                          case "one":                          case "two":                          case "vt1":                              displacement = 1;                              break;                          case "vt2":                          case "satw":                          case "satz":                          case "saty":                          case "satx":                          case "swzw":                          case "swzz":                          case "swzy":                          case "swzx":                              displacement = 2;                              break;                          case "imm3":                              displacement = 3;                              break;                          case "imm4":                          case "fcond":                              displacement = 4;                              break;                          case "c0dr":                          case "c0cr":                          case "c1dr":                          case "c1cr":                          case "imm5":                          case "vt5":                          case "rs":                          case "rd":                          case "rt":                          case "sa":                          case "lsb":                          case "msb":                          case "fs":                          case "fd":                          case "ft":                              displacement = 5;                              break;                          case "vs":                          case "vt":                          case "vd":                          case "imm7":                              displacement = 7;                              break;                          case "imm8":                              displacement = 8;                              break;                          case "imm14":                              displacement = 14;                              break;                          case "imm16":                              displacement = 16;                              break;                          case "imm20":                              displacement = 20;                              break;                          case "imm26":                              displacement = 26;                              break;                          default:                              throw(new Exception("Unknown part '" + part + "'"));                      }                        Mask <<= displacement;                      Value <<= displacement;                  }              }
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuConstants,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuConstants.cs,GetRegisterNames,The following statement contains a magic number: if (type == VfpuRegisterType.Vector && size == 2) return VfpuVpregNames;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuConstants,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuConstants.cs,GetRegisterNames,The following statement contains a magic number: if (type == VfpuRegisterType.Vector && size == 3) return VfpuVtregNames;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuConstants,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuConstants.cs,GetRegisterNames,The following statement contains a magic number: if (type == VfpuRegisterType.Vector && size == 4) return VfpuVqregNames;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuConstants,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuConstants.cs,GetRegisterNames,The following statement contains a magic number: if (type == VfpuRegisterType.Matrix && size == 2) return VfpuMpregNames;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuConstants,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuConstants.cs,GetRegisterNames,The following statement contains a magic number: if (type == VfpuRegisterType.Matrix && size == 3) return VfpuMtregNames;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuConstants,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuConstants.cs,GetRegisterNames,The following statement contains a magic number: if (type == VfpuRegisterType.Matrix && size == 4) return VfpuMqregNames;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuPrefix,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuPrefix.cs,SourceIndex,The following statement contains a magic number: return BitUtils.Extract(Value' 0 + i * 2' 2);
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuPrefix,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuPrefix.cs,SourceIndex,The following statement contains a magic number: return BitUtils.Extract(Value' 0 + i * 2' 2);
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuRegisterInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuRegisterInfo.cs,VfpuRegisterInfo,The following statement contains a magic number: CheckInvalid("Size"' size < 1 || size > 4);
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuRegisterInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuRegisterInfo.cs,VfpuRegisterInfo,The following statement contains a magic number: CheckInvalid("Matrix"' matrix < 0 || matrix >= 8);
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuRegisterInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuRegisterInfo.cs,VfpuRegisterInfo,The following statement contains a magic number: CheckInvalid("Row"' row < 0 || row >= 4);
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuRegisterInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuRegisterInfo.cs,VfpuRegisterInfo,The following statement contains a magic number: CheckInvalid("Column"' column < 0 || column >= 4);
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuRegisterInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuRegisterInfo.cs,Parse,The following statement contains a magic number: return new VfpuRegisterInfo(                  size'                  name[0]'                  int.Parse(name.Substr(1' 1))'                  int.Parse(name.Substr(2' 1))'                  int.Parse(name.Substr(3' 1))              );
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuRegisterInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuRegisterInfo.cs,Parse,The following statement contains a magic number: return new VfpuRegisterInfo(                  size'                  name[0]'                  int.Parse(name.Substr(1' 1))'                  int.Parse(name.Substr(2' 1))'                  int.Parse(name.Substr(3' 1))              );
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetIndexCell,The following statement contains a magic number: if (matrix < 0 || matrix >= 8 || column < 0 || column >= 4 || row < 0 || row >= 4)              {                  throw new InvalidOperationException($"Matrix: {matrix}' Column: {column}' Row: {row}");              }
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetIndexCell,The following statement contains a magic number: if (matrix < 0 || matrix >= 8 || column < 0 || column >= 4 || row < 0 || row >= 4)              {                  throw new InvalidOperationException($"Matrix: {matrix}' Column: {column}' Row: {row}");              }
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetIndexCell,The following statement contains a magic number: if (matrix < 0 || matrix >= 8 || column < 0 || column >= 4 || row < 0 || row >= 4)              {                  throw new InvalidOperationException($"Matrix: {matrix}' Column: {column}' Row: {row}");              }
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetIndexCell,The following statement contains a magic number: return matrix * 16 + row * 4 + column;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetIndexCell,The following statement contains a magic number: return matrix * 16 + row * 4 + column;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetSizeBySuffix,The following statement contains a magic number: if (nameWithSufix.EndsWith(".p")) return 2;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetSizeBySuffix,The following statement contains a magic number: if (nameWithSufix.EndsWith(".t")) return 3;
Magic Number,CSPspEmu.Core.Cpu.VFpu,VfpuUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\VFpu\VfpuUtils.cs,GetSizeBySuffix,The following statement contains a magic number: if (nameWithSufix.EndsWith(".q")) return 4;
Missing Default,CSPspEmu.Core.Cpu.Assembler,MipsAssembler,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Assembler\MipsAssembler.cs,Assemble,The following switch statement is missing a default case: switch (patch.Type)                      {                          case AssemblerPatchType.Rel16:                              instruction.Imm = ((int) labelAddress - (int) patch.Address - 4) / 4;                              break;                          case AssemblerPatchType.Abs26:                              instruction.JumpBits = (labelAddress & PspMemory.MemoryMask) / 4;                              Console.Write("0x{0:X} : {1}"' instruction.JumpBits' patch.LabelName);                              break;                          case AssemblerPatchType.Abs32:                              instruction.Value = labelAddress;                              break;                      }
Missing Default,CSPspEmu.Core.Cpu.Emitter,CpuEmitterUtils,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitterUtils.cs,_cvt_w_s_impl,The following switch statement is missing a default case: switch (cpuThreadState.Fcr31.Rm)              {                  case CpuThreadState.Fcr31Struct.TypeEnum.Rint: return (int) MathFloat.Rint(fs);                  case CpuThreadState.Fcr31Struct.TypeEnum.Cast: return (int) MathFloat.Cast(fs);                  case CpuThreadState.Fcr31Struct.TypeEnum.Ceil: return (int) MathFloat.Ceil(fs);                  case CpuThreadState.Fcr31Struct.TypeEnum.Floor: return (int) MathFloat.Floor(fs);              }
Missing Default,CSPspEmu.Core.Cpu.Emitter,VfpuRuntimeRegister,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Emitter\CpuEmitter.Vfpu.Utils.cs,SetRegApplyPrefix,The following switch statement is missing a default case: switch (prefixDestination.DestinationSaturation(prefixIndex))                          {                              case 1:                                  doClamp = true;                                  min = 0.0f;                                  max = 1.0f;                                  break;                              case 3:                                  doClamp = true;                                  min = -1.0f;                                  max = 1.0f;                                  break;                          }
Missing Default,CSPspEmu.Core.Cpu.Dynarec.Ast,AstOptimizerPsp,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Dynarec\Ast\AstOptimizerPsp.cs,OptimizeLwlLwr,The following switch statement is missing a default case: switch (instructionInfo.Name)                  {                      case "lwl":                          lwlLwrStates[instruction.Rt] = new LwlLwrState()                          {                              LwlListIndex = n'                              LwlRtRegister = instruction.Rt'                              LwlRsRegister = instruction.Rs'                              LwlImm = instruction.Imm'                              LwlPc = pc'                          };                          //Console.WriteLine("lwl");                          //  GPR_u(RS)' IMM_s()' GPR_u(RT)                          break;                      case "lwr":                          //Console.WriteLine("lwr");                          //Console.WriteLine(LwlLwrStates.Count);                          if (lwlLwrStates.ContainsKey(instruction.Rt))                          {                              var lwlLwrState = lwlLwrStates[instruction.Rt];                              if (                                  (lwlLwrState.LwlRsRegister == instruction.Rs) &&                                  (lwlLwrState.LwlRtRegister == instruction.Rt) &&                                  (lwlLwrState.LwlImm == instruction.Imm + 3)                              )                              {                                  containerNodes[lwlLwrState.LwlListIndex] = null;                                  containerNodes[n] = ast.Statements(                                      ast.Comment($"{lwlLwrState.LwlPc:X8}+{pc:X8} lwl+lwr")'                                      ast.AssignGpr(                                          instruction.Rt'                                          ast.MemoryGetValue<int>(                                              Memory'                                              ast.Cast<uint>(ast.Binary(ast.GPR_s(instruction.Rs)' "+"' instruction.Imm))                                          )                                      )                                  );                                  //Console.WriteLine("Valid match!");                              }                          }                          break;                  }
Missing Default,CSPspEmu.Core.Cpu.Table,InstructionInfo,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Cpu\Table\InstructionInfo.cs,ParseBinaryEncoding,The following switch statement is missing a default case: switch (Char)                          {                              case '0':                                  Mask |= 1;                                  Value |= 0;                                  break;                              case '1':                                  Mask |= 1;                                  Value |= 1;                                  break;                              case '-':                                  Mask |= 0;                                  Value |= 0;                                  break;                          }
