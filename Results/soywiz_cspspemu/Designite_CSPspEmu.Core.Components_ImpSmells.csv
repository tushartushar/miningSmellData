Implementation smell,Namespace,Class,File,Method,Description
Long Method,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The method has 104 lines of code.
Complex Method,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,Cyclomatic complexity of the method is 10
Long Parameter List,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,SceUtilsBufferCopyWithRange,The method has 5 parameters. Parameters: Out' outSize' In' inSize' command
Long Parameter List,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,HleUtilsBufferCopyWithRange,The method has 6 parameters. Parameters: Out' outSize' In' inSize' command' doChecks
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,PuTuint,The following statement contains a magic number: (ct)[0] = (byte) ((st) >> 24);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,PuTuint,The following statement contains a magic number: (ct)[1] = (byte) ((st) >> 16);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,PuTuint,The following statement contains a magic number: (ct)[2] = (byte) ((st) >> 8);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,PuTuint,The following statement contains a magic number: (ct)[2] = (byte) ((st) >> 8);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,PuTuint,The following statement contains a magic number: (ct)[3] = (byte) (st);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[1] = GeTuint(cipherKey + 4);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[2] = GeTuint(cipherKey + 8);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[2] = GeTuint(cipherKey + 8);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[3] = GeTuint(cipherKey + 12);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[3] = GeTuint(cipherKey + 12);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 128)              {                  for (;;)                  {                      temp = rk[3];                      rk[4] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[5] = rk[1] ^ rk[4];                      rk[6] = rk[2] ^ rk[5];                      rk[7] = rk[3] ^ rk[6];                      if (++i == 10)                      {                          return 10;                      }                      rk += 4;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[4] = GeTuint(cipherKey + 16);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[4] = GeTuint(cipherKey + 16);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[5] = GeTuint(cipherKey + 20);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[5] = GeTuint(cipherKey + 20);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits == 192)              {                  for (;;)                  {                      temp = rk[5];                      rk[6] = rk[0] ^                              (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                              (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                              (Te4[(temp) & 0xff] & 0x0000ff00) ^                              (Te4[(temp >> 24)] & 0x000000ff) ^                              Rcon[i];                      rk[7] = rk[1] ^ rk[6];                      rk[8] = rk[2] ^ rk[7];                      rk[9] = rk[3] ^ rk[8];                      if (++i == 8)                      {                          return 12;                      }                      rk[10] = rk[4] ^ rk[9];                      rk[11] = rk[5] ^ rk[10];                      rk += 6;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[6] = GeTuint(cipherKey + 24);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[6] = GeTuint(cipherKey + 24);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[7] = GeTuint(cipherKey + 28);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: rk[7] = GeTuint(cipherKey + 28);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: if (keyBits != 256) return 0;
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupEnc,The following statement contains a magic number: for (;;)              {                  temp = rk[7];                  rk[8] = rk[0] ^                          (Te4[(temp >> 16) & 0xff] & 0xff000000) ^                          (Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^                          (Te4[(temp) & 0xff] & 0x0000ff00) ^                          (Te4[(temp >> 24)] & 0x000000ff) ^                          Rcon[i];                  rk[9] = rk[1] ^ rk[8];                  rk[10] = rk[2] ^ rk[9];                  rk[11] = rk[3] ^ rk[10];                  if (++i == 7)                  {                      return 14;                  }                  temp = rk[11];                  rk[12] = rk[4] ^                           (Te4[(temp >> 24)] & 0xff000000) ^                           (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^                           (Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^                           (Te4[(temp) & 0xff] & 0x000000ff);                  rk[13] = rk[5] ^ rk[12];                  rk[14] = rk[6] ^ rk[13];                  rk[15] = rk[7] ^ rk[14];                  rk += 8;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 0' j = 4 * nr; i < j; i += 4' j -= 4)              {                  var temp = rk[i];                  rk[i] = rk[j];                  rk[j] = temp;                  temp = rk[i + 1];                  rk[i + 1] = rk[j + 1];                  rk[j + 1] = temp;                  temp = rk[i + 2];                  rk[i + 2] = rk[j + 2];                  rk[j + 2] = temp;                  temp = rk[i + 3];                  rk[i + 3] = rk[j + 3];                  rk[j + 3] = temp;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelKeySetupDec,The following statement contains a magic number: for (i = 1; i < nr; i++)              {                  rk += 4;                  rk[0] =                      Td0[Te4[(rk[0] >> 24)] & 0xff] ^                      Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[0]) & 0xff] & 0xff];                  rk[1] =                      Td0[Te4[(rk[1] >> 24)] & 0xff] ^                      Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[1]) & 0xff] & 0xff];                  rk[2] =                      Td0[Te4[(rk[2] >> 24)] & 0xff] ^                      Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[2]) & 0xff] & 0xff];                  rk[3] =                      Td0[Te4[(rk[3] >> 24)] & 0xff] ^                      Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^                      Td2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^                      Td3[Te4[(rk[3]) & 0xff] & 0xff];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: var s1 = GeTuint(pt + 4) ^ rk[1];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: var s2 = GeTuint(pt + 8) ^ rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: var s2 = GeTuint(pt + 8) ^ rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: var s3 = GeTuint(pt + 12) ^ rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: var s3 = GeTuint(pt + 12) ^ rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Te0[(s0 >> 24)] ^                      Te1[(s1 >> 16) & 0xff] ^                      Te2[(s2 >> 8) & 0xff] ^                      Te3[(s3) & 0xff] ^                      rk[4];                  t1 =                      Te0[(s1 >> 24)] ^                      Te1[(s2 >> 16) & 0xff] ^                      Te2[(s3 >> 8) & 0xff] ^                      Te3[(s0) & 0xff] ^                      rk[5];                  t2 =                      Te0[(s2 >> 24)] ^                      Te1[(s3 >> 16) & 0xff] ^                      Te2[(s0 >> 8) & 0xff] ^                      Te3[(s1) & 0xff] ^                      rk[6];                  t3 =                      Te0[(s3 >> 24)] ^                      Te1[(s0 >> 16) & 0xff] ^                      Te2[(s1 >> 8) & 0xff] ^                      Te3[(s2) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Te0[(t0 >> 24)] ^                      Te1[(t1 >> 16) & 0xff] ^                      Te2[(t2 >> 8) & 0xff] ^                      Te3[(t3) & 0xff] ^                      rk[0];                  s1 =                      Te0[(t1 >> 24)] ^                      Te1[(t2 >> 16) & 0xff] ^                      Te2[(t3 >> 8) & 0xff] ^                      Te3[(t0) & 0xff] ^                      rk[1];                  s2 =                      Te0[(t2 >> 24)] ^                      Te1[(t3 >> 16) & 0xff] ^                      Te2[(t0 >> 8) & 0xff] ^                      Te3[(t1) & 0xff] ^                      rk[2];                  s3 =                      Te0[(t3 >> 24)] ^                      Te1[(t0 >> 16) & 0xff] ^                      Te2[(t1 >> 8) & 0xff] ^                      Te3[(t2) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s0 =                  (Te4[(t0 >> 24)] & 0xff000000) ^                  (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t2 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t3) & 0xff] & 0x000000ff) ^                  rk[0];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s0 =                  (Te4[(t0 >> 24)] & 0xff000000) ^                  (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t2 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t3) & 0xff] & 0x000000ff) ^                  rk[0];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s0 =                  (Te4[(t0 >> 24)] & 0xff000000) ^                  (Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t2 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t3) & 0xff] & 0x000000ff) ^                  rk[0];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s1 =                  (Te4[(t1 >> 24)] & 0xff000000) ^                  (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t3 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t0) & 0xff] & 0x000000ff) ^                  rk[1];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s1 =                  (Te4[(t1 >> 24)] & 0xff000000) ^                  (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t3 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t0) & 0xff] & 0x000000ff) ^                  rk[1];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s1 =                  (Te4[(t1 >> 24)] & 0xff000000) ^                  (Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t3 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t0) & 0xff] & 0x000000ff) ^                  rk[1];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: PuTuint(ct + 4' s1);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s2 =                  (Te4[(t2 >> 24)] & 0xff000000) ^                  (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t0 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t1) & 0xff] & 0x000000ff) ^                  rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s2 =                  (Te4[(t2 >> 24)] & 0xff000000) ^                  (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t0 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t1) & 0xff] & 0x000000ff) ^                  rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s2 =                  (Te4[(t2 >> 24)] & 0xff000000) ^                  (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t0 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t1) & 0xff] & 0x000000ff) ^                  rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s2 =                  (Te4[(t2 >> 24)] & 0xff000000) ^                  (Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t0 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t1) & 0xff] & 0x000000ff) ^                  rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: PuTuint(ct + 8' s2);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s3 =                  (Te4[(t3 >> 24)] & 0xff000000) ^                  (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t1 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t2) & 0xff] & 0x000000ff) ^                  rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s3 =                  (Te4[(t3 >> 24)] & 0xff000000) ^                  (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t1 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t2) & 0xff] & 0x000000ff) ^                  rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s3 =                  (Te4[(t3 >> 24)] & 0xff000000) ^                  (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t1 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t2) & 0xff] & 0x000000ff) ^                  rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: s3 =                  (Te4[(t3 >> 24)] & 0xff000000) ^                  (Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^                  (Te4[(t1 >> 8) & 0xff] & 0x0000ff00) ^                  (Te4[(t2) & 0xff] & 0x000000ff) ^                  rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelEncrypt,The following statement contains a magic number: PuTuint(ct + 12' s3);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: var s1 = GeTuint(ct + 4) ^ rk[1];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: var s2 = GeTuint(ct + 8) ^ rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: var s2 = GeTuint(ct + 8) ^ rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: var s3 = GeTuint(ct + 12) ^ rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: var s3 = GeTuint(ct + 12) ^ rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: for (;;)              {                  t0 =                      Td0[(s0 >> 24)] ^                      Td1[(s3 >> 16) & 0xff] ^                      Td2[(s2 >> 8) & 0xff] ^                      Td3[(s1) & 0xff] ^                      rk[4];                  t1 =                      Td0[(s1 >> 24)] ^                      Td1[(s0 >> 16) & 0xff] ^                      Td2[(s3 >> 8) & 0xff] ^                      Td3[(s2) & 0xff] ^                      rk[5];                  t2 =                      Td0[(s2 >> 24)] ^                      Td1[(s1 >> 16) & 0xff] ^                      Td2[(s0 >> 8) & 0xff] ^                      Td3[(s3) & 0xff] ^                      rk[6];                  t3 =                      Td0[(s3 >> 24)] ^                      Td1[(s2 >> 16) & 0xff] ^                      Td2[(s1 >> 8) & 0xff] ^                      Td3[(s0) & 0xff] ^                      rk[7];                    rk += 8;                  if (--r == 0)                  {                      break;                  }                    s0 =                      Td0[(t0 >> 24)] ^                      Td1[(t3 >> 16) & 0xff] ^                      Td2[(t2 >> 8) & 0xff] ^                      Td3[(t1) & 0xff] ^                      rk[0];                  s1 =                      Td0[(t1 >> 24)] ^                      Td1[(t0 >> 16) & 0xff] ^                      Td2[(t3 >> 8) & 0xff] ^                      Td3[(t2) & 0xff] ^                      rk[1];                  s2 =                      Td0[(t2 >> 24)] ^                      Td1[(t1 >> 16) & 0xff] ^                      Td2[(t0 >> 8) & 0xff] ^                      Td3[(t3) & 0xff] ^                      rk[2];                  s3 =                      Td0[(t3 >> 24)] ^                      Td1[(t2 >> 16) & 0xff] ^                      Td2[(t1 >> 8) & 0xff] ^                      Td3[(t0) & 0xff] ^                      rk[3];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s0 =                  (Td4[(t0 >> 24)] & 0xff000000) ^                  (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t2 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t1) & 0xff] & 0x000000ff) ^                  rk[0];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s0 =                  (Td4[(t0 >> 24)] & 0xff000000) ^                  (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t2 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t1) & 0xff] & 0x000000ff) ^                  rk[0];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s0 =                  (Td4[(t0 >> 24)] & 0xff000000) ^                  (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t2 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t1) & 0xff] & 0x000000ff) ^                  rk[0];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s1 =                  (Td4[(t1 >> 24)] & 0xff000000) ^                  (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t3 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t2) & 0xff] & 0x000000ff) ^                  rk[1];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s1 =                  (Td4[(t1 >> 24)] & 0xff000000) ^                  (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t3 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t2) & 0xff] & 0x000000ff) ^                  rk[1];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s1 =                  (Td4[(t1 >> 24)] & 0xff000000) ^                  (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t3 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t2) & 0xff] & 0x000000ff) ^                  rk[1];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: PuTuint(pt + 4' s1);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s2 =                  (Td4[(t2 >> 24)] & 0xff000000) ^                  (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t0 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t3) & 0xff] & 0x000000ff) ^                  rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s2 =                  (Td4[(t2 >> 24)] & 0xff000000) ^                  (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t0 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t3) & 0xff] & 0x000000ff) ^                  rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s2 =                  (Td4[(t2 >> 24)] & 0xff000000) ^                  (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t0 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t3) & 0xff] & 0x000000ff) ^                  rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s2 =                  (Td4[(t2 >> 24)] & 0xff000000) ^                  (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t0 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t3) & 0xff] & 0x000000ff) ^                  rk[2];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: PuTuint(pt + 8' s2);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s3 =                  (Td4[(t3 >> 24)] & 0xff000000) ^                  (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t1 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t0) & 0xff] & 0x000000ff) ^                  rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s3 =                  (Td4[(t3 >> 24)] & 0xff000000) ^                  (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t1 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t0) & 0xff] & 0x000000ff) ^                  rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s3 =                  (Td4[(t3 >> 24)] & 0xff000000) ^                  (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t1 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t0) & 0xff] & 0x000000ff) ^                  rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: s3 =                  (Td4[(t3 >> 24)] & 0xff000000) ^                  (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^                  (Td4[(t1 >> 8) & 0xff] & 0x0000ff00) ^                  (Td4[(t0) & 0xff] & 0x000000ff) ^                  rk[3];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,RijndaelDecrypt,The following statement contains a magic number: PuTuint(pt + 12' s3);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,xor_128,The following statement contains a magic number: for (var i = 0; i < 16; i++)                  Out[i] = (byte) (a[i] ^ b[i]);
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_encrypt,The following statement contains a magic number: var blockBuffBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_encrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              {                  int i;                  for (i = 0; i < size; i += 16)                  {                      //step 1: copy block to dst                      Memcpy(dst' src' 16);                      //step 2: XOR with previous block                      if (i != 0) xor_128(dst' blockBuff' dst);                      //step 3: encrypt the block -> it land in block buffer                      AES_encrypt(ctx' dst' blockBuff);                      //step 4: copy back the encrypted block to destination                      Memcpy(dst' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_encrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              {                  int i;                  for (i = 0; i < size; i += 16)                  {                      //step 1: copy block to dst                      Memcpy(dst' src' 16);                      //step 2: XOR with previous block                      if (i != 0) xor_128(dst' blockBuff' dst);                      //step 3: encrypt the block -> it land in block buffer                      AES_encrypt(ctx' dst' blockBuff);                      //step 4: copy back the encrypted block to destination                      Memcpy(dst' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_encrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              {                  int i;                  for (i = 0; i < size; i += 16)                  {                      //step 1: copy block to dst                      Memcpy(dst' src' 16);                      //step 2: XOR with previous block                      if (i != 0) xor_128(dst' blockBuff' dst);                      //step 3: encrypt the block -> it land in block buffer                      AES_encrypt(ctx' dst' blockBuff);                      //step 4: copy back the encrypted block to destination                      Memcpy(dst' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_encrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              {                  int i;                  for (i = 0; i < size; i += 16)                  {                      //step 1: copy block to dst                      Memcpy(dst' src' 16);                      //step 2: XOR with previous block                      if (i != 0) xor_128(dst' blockBuff' dst);                      //step 3: encrypt the block -> it land in block buffer                      AES_encrypt(ctx' dst' blockBuff);                      //step 4: copy back the encrypted block to destination                      Memcpy(dst' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_encrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              {                  int i;                  for (i = 0; i < size; i += 16)                  {                      //step 1: copy block to dst                      Memcpy(dst' src' 16);                      //step 2: XOR with previous block                      if (i != 0) xor_128(dst' blockBuff' dst);                      //step 3: encrypt the block -> it land in block buffer                      AES_encrypt(ctx' dst' blockBuff);                      //step 4: copy back the encrypted block to destination                      Memcpy(dst' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: var blockBuffBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: var blockBuffPreviousBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_cbc_decrypt,The following statement contains a magic number: fixed (byte* blockBuff = blockBuffBytes)              fixed (byte* blockBuffPrevious = blockBuffPreviousBytes)              {                  Memcpy(blockBuff' src' 16);                  Memcpy(blockBuffPrevious' src' 16);                  AES_decrypt(ctx' src' dst);                    dst += 16;                  src += 16;                    int i;                  for (i = 16; i < size; i += 16)                  {                      //step1: backup current block for next block decrypt                      Memcpy(blockBuff' src' 16);                      //step2: copy current block to destination                      Memcpy(dst' src' 16);                      //step3: decrypt current buffer in place                      AES_decrypt(ctx' dst' dst);                      //step4: XOR current buffer with previous buffer                      xor_128(dst' blockBuffPrevious' dst);                      //step5: swap buffers                      Memcpy(blockBuffPrevious' blockBuff' 16);                        dst += 16;                      src += 16;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,leftshift_onebit,The following statement contains a magic number: for (i = 15; i >= 0; i--)              {                  output[i] = (byte) (input[i] << 1);                  output[i] |= overflow;                  overflow = (byte) (((input[i] & 0x80) != 0) ? 1 : 0);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,generate_subkey,The following statement contains a magic number: var lBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,generate_subkey,The following statement contains a magic number: var zBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,generate_subkey,The following statement contains a magic number: var tmpBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,generate_subkey,The following statement contains a magic number: fixed (byte* tmp = tmpBytes)              fixed (byte* l = lBytes)              fixed (byte* z = zBytes)              fixed (byte* constRb = ConstRb)              {                  int i;                  for (i = 0; i < 16; i++) z[i] = 0;                    AES_encrypt(ctx' z' l);                    if ((l[0] & 0x80) == 0) /* If MSB(L) = 0' then K1 = L << 1 */                  {                      leftshift_onebit(l' k1);                  }                  else                  {                      /* Else K1 = ( L << 1 ) (+) Rb */                      leftshift_onebit(l' tmp);                      xor_128(tmp' constRb' k1);                  }                    if ((k1[0] & 0x80) == 0)                  {                      leftshift_onebit(k1' k2);                  }                  else                  {                      leftshift_onebit(k1' tmp);                      xor_128(tmp' constRb' k2);                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,Padding,The following statement contains a magic number: for (var j = 0; j < 16; j++)              {                  if (j < length)                  {                      pad[j] = lastb[j];                  }                  else if (j == length)                  {                      pad[j] = 0x80;                  }                  else                  {                      pad[j] = 0x00;                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: var xBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: var yBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: var mLastBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: var paddedBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: var k1Bytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: var k2Bytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_encrypt(ctx' y' x);                    for (i = 0; i < 16; i++)                      mac[i] = x[i];              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: var xBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: var yBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: var mLastBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: var paddedBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: var k1Bytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: var k2Bytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Crypto,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Crypto.cs,AES_CMAC_forge,The following statement contains a magic number: fixed (byte* x = xBytes)              fixed (byte* y = yBytes)              fixed (byte* mLast = mLastBytes)              fixed (byte* padded = paddedBytes)              fixed (byte* k1 = k1Bytes)              fixed (byte* k2 = k2Bytes)              {                  generate_subkey(ctx' k1' k2);                    var n = (length + 15) / 16;                    int flag;                  if (n == 0)                  {                      n = 1;                      flag = 0;                  }                  else                  {                      flag = (length % 16) == 0 ? 1 : 0;                  }                    if (flag != 0)                  {                      /* last block is complete block */                      xor_128(&input[16 * (n - 1)]' k1' mLast);                  }                  else                  {                      Padding(&input[16 * (n - 1)]' padded' length % 16);                      xor_128(padded' k2' mLast);                  }                    int i;                  for (i = 0; i < 16; i++) x[i] = 0;                  for (i = 0; i < n - 1; i++)                  {                      xor_128(x' &input[16 * i]' y); /* Y := Mi (+) X  */                      AES_encrypt(ctx' y' x); /* X := AES-128(KEY' Y); */                  }                    xor_128(x' mLast' y);                  AES_decrypt(ctx' forge' x);                  //printf("Pre-crypt value: "); for(i=0;i<0x10;i++) printf("%02x"' X[i]); printf("\n");                  xor_128(x' y' forge);                  xor_128(forge' &input[16 * (n - 1)]' y);                  //AES_encrypt(Y' X' &aes);                    //Update original input file so it produces the correct CMAC                  for (i = 0; i < 16; i++)                  {                      input[(16 * (n - 1)) + i] = y[i];                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: var cmacHeaderHashBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: var cmacDataHashBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD0,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  //#if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  //#endif              {                  check_initialized();                    Aes128CmacHeader* header = (Aes128CmacHeader*) outbuff;                    Crypto.Memcpy(outbuff' inbuff' size);                    if (header->Mode != KirkMode.Cmd1)                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header->Mode}"));                  }                    HeaderKeys* keys = (HeaderKeys*) outbuff; //0-15 AES key' 16-31 CMAC key                    //FILL PREDATA WITH RANDOM DATA                  if (generateTrash) kirk_CMD14(outbuff + sizeof(Aes128CmacHeader)' header->DataOffset);                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                    //ENCRYPT DATA                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys->Aes' 128);                    Crypto.AES_cbc_encrypt(&k1' inbuff + sizeof(Aes128CmacHeader) + header->DataOffset'                      outbuff + sizeof(Aes128CmacHeader) + header->DataOffset' chkSize);                    //CMAC HASHES                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys->Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30' cmacHeaderHash);                    Crypto.AES_CMAC(&cmacKey' outbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    Crypto.Memcpy(header->CmacHeaderHash' cmacHeaderHash' 16);                  Crypto.Memcpy(header->CmacDataHash' cmacDataHash' 16);                    //ENCRYPT KEYS                  Crypto.AES_cbc_encrypt(aesKirk1Ptr' inbuff' outbuff' 16 * 2);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD1,The following statement contains a magic number: fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  var header = *(Aes128CmacHeader*) inbuff;                  if (header.Mode != KirkMode.Cmd1)                  {                      //Console.Error.WriteLine("ResultEnum.PSP_KIRK_INVALID_MODE");                      Console.Error.WriteLine("{0}"' header.ToStringDefault(true));                      Console.WriteLine("Input:");                      ArrayUtils.HexDump(PointerUtils.PointerToByteArray(inbuff' 0x100));                      Console.WriteLine("Output:");                      ArrayUtils.HexDump(PointerUtils.PointerToByteArray(outbuff' 0x100));                      throw (new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header.Mode}"));                  }                    Console.WriteLine("Input:");                  ArrayUtils.HexDump(PointerUtils.PointerToByteArray(inbuff' 0x100));                    //Console.WriteLine("header.DataOffset = 0x{0:X8}"' header.DataOffset);                  //Console.WriteLine("header.DataSize = 0x{0:X8}"' header.DataSize);                    // Decrypts AES and CMAC keys.                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte*)&keys' 16 * 2); //decrypt AES & CMAC key to temp buffer  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys' 16 * 2);  #endif                    // HOAX WARRING! I have no idea why the hash check on last IPL block fails' so there is an option to disable checking                  if (doCheck)                  {                      kirk_CMD10(inbuff' size);                  }                    //var AES = new RijndaelManaged();    #if USE_DOTNET_CRYPTO  				DecryptAes(  					PointerUtils.PointerToByteArray(keys.AES' 16)'  					inbuff + sizeof(AES128CMACHeader) + header->DataOffset'  					outbuff'  					header->DataSize  				);  #else                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys.Aes' 128);                    Crypto.AES_cbc_decrypt(                      ctx: &k1'                      src: inbuff + sizeof(Aes128CmacHeader) + header.DataOffset'                      dst: outbuff'                      size: header.DataSize                  );  #endif              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD1,The following statement contains a magic number: fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  var header = *(Aes128CmacHeader*) inbuff;                  if (header.Mode != KirkMode.Cmd1)                  {                      //Console.Error.WriteLine("ResultEnum.PSP_KIRK_INVALID_MODE");                      Console.Error.WriteLine("{0}"' header.ToStringDefault(true));                      Console.WriteLine("Input:");                      ArrayUtils.HexDump(PointerUtils.PointerToByteArray(inbuff' 0x100));                      Console.WriteLine("Output:");                      ArrayUtils.HexDump(PointerUtils.PointerToByteArray(outbuff' 0x100));                      throw (new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header.Mode}"));                  }                    Console.WriteLine("Input:");                  ArrayUtils.HexDump(PointerUtils.PointerToByteArray(inbuff' 0x100));                    //Console.WriteLine("header.DataOffset = 0x{0:X8}"' header.DataOffset);                  //Console.WriteLine("header.DataSize = 0x{0:X8}"' header.DataSize);                    // Decrypts AES and CMAC keys.                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte*)&keys' 16 * 2); //decrypt AES & CMAC key to temp buffer  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys' 16 * 2);  #endif                    // HOAX WARRING! I have no idea why the hash check on last IPL block fails' so there is an option to disable checking                  if (doCheck)                  {                      kirk_CMD10(inbuff' size);                  }                    //var AES = new RijndaelManaged();    #if USE_DOTNET_CRYPTO  				DecryptAes(  					PointerUtils.PointerToByteArray(keys.AES' 16)'  					inbuff + sizeof(AES128CMACHeader) + header->DataOffset'  					outbuff'  					header->DataSize  				);  #else                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys.Aes' 128);                    Crypto.AES_cbc_decrypt(                      ctx: &k1'                      src: inbuff + sizeof(Aes128CmacHeader) + header.DataOffset'                      dst: outbuff'                      size: header.DataSize                  );  #endif              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD1,The following statement contains a magic number: fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  var header = *(Aes128CmacHeader*) inbuff;                  if (header.Mode != KirkMode.Cmd1)                  {                      //Console.Error.WriteLine("ResultEnum.PSP_KIRK_INVALID_MODE");                      Console.Error.WriteLine("{0}"' header.ToStringDefault(true));                      Console.WriteLine("Input:");                      ArrayUtils.HexDump(PointerUtils.PointerToByteArray(inbuff' 0x100));                      Console.WriteLine("Output:");                      ArrayUtils.HexDump(PointerUtils.PointerToByteArray(outbuff' 0x100));                      throw (new KirkException(ResultEnum.PspKirkInvalidMode'                          $"Expected mode Cmd1 but found {header.Mode}"));                  }                    Console.WriteLine("Input:");                  ArrayUtils.HexDump(PointerUtils.PointerToByteArray(inbuff' 0x100));                    //Console.WriteLine("header.DataOffset = 0x{0:X8}"' header.DataOffset);                  //Console.WriteLine("header.DataSize = 0x{0:X8}"' header.DataSize);                    // Decrypts AES and CMAC keys.                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte*)&keys' 16 * 2); //decrypt AES & CMAC key to temp buffer  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys' 16 * 2);  #endif                    // HOAX WARRING! I have no idea why the hash check on last IPL block fails' so there is an option to disable checking                  if (doCheck)                  {                      kirk_CMD10(inbuff' size);                  }                    //var AES = new RijndaelManaged();    #if USE_DOTNET_CRYPTO  				DecryptAes(  					PointerUtils.PointerToByteArray(keys.AES' 16)'  					inbuff + sizeof(AES128CMACHeader) + header->DataOffset'  					outbuff'  					header->DataSize  				);  #else                  Crypto.AesCtx k1;                  Crypto.AES_set_key(&k1' keys.Aes' 128);                    Crypto.AES_cbc_decrypt(                      ctx: &k1'                      src: inbuff + sizeof(Aes128CmacHeader) + header.DataOffset'                      dst: outbuff'                      size: header.DataSize                  );  #endif              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD4,The following statement contains a magic number: kirk_4_7_get_key(header->KeySeed' (key) =>              {                  // Set the key                  Crypto.AesCtx aesKey;                  Crypto.AES_set_key(&aesKey' key' 128);                  Crypto.AES_cbc_encrypt(&aesKey' inbuff + sizeof(KirkAes128CbcHeader)' outbuff' size);              });
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD7,The following statement contains a magic number: kirk_4_7_get_key(header->KeySeed' (key) =>              {                  //Set the key                  Crypto.AesCtx aesKey;                  Crypto.AES_set_key(&aesKey' key' 128);                    Crypto.AES_cbc_decrypt(&aesKey' inbuff + sizeof(KirkAes128CbcHeader)' outbuff' size);              });
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: var cmacHeaderHashBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: var cmacDataHashBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  #if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  #endif              {                  check_initialized();                    Aes128CmacHeader header = *(Aes128CmacHeader*) inbuff;                    if (!(header.Mode == KirkMode.Cmd1 || header.Mode == KirkMode.Cmd2 || header.Mode == KirkMode.Cmd3))                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode));                  }                    if (header.DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header.Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      throw (new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte *)&keys' 16 * 2);  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer  #endif                    Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                    //Make sure data is 16 aligned                  var chkSize = header.DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header.DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacHeaderHash' header.CmacHeaderHash' 16) != 0)                  {                      Logger.Error("header hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }                  if (Crypto.Memcmp(cmacDataHash' header.CmacDataHash' 16) != 0)                  {                      Logger.Error("data hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  #if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  #endif              {                  check_initialized();                    Aes128CmacHeader header = *(Aes128CmacHeader*) inbuff;                    if (!(header.Mode == KirkMode.Cmd1 || header.Mode == KirkMode.Cmd2 || header.Mode == KirkMode.Cmd3))                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode));                  }                    if (header.DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header.Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      throw (new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte *)&keys' 16 * 2);  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer  #endif                    Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                    //Make sure data is 16 aligned                  var chkSize = header.DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header.DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacHeaderHash' header.CmacHeaderHash' 16) != 0)                  {                      Logger.Error("header hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }                  if (Crypto.Memcmp(cmacDataHash' header.CmacDataHash' 16) != 0)                  {                      Logger.Error("data hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  #if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  #endif              {                  check_initialized();                    Aes128CmacHeader header = *(Aes128CmacHeader*) inbuff;                    if (!(header.Mode == KirkMode.Cmd1 || header.Mode == KirkMode.Cmd2 || header.Mode == KirkMode.Cmd3))                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode));                  }                    if (header.DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header.Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      throw (new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte *)&keys' 16 * 2);  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer  #endif                    Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                    //Make sure data is 16 aligned                  var chkSize = header.DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header.DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacHeaderHash' header.CmacHeaderHash' 16) != 0)                  {                      Logger.Error("header hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }                  if (Crypto.Memcmp(cmacDataHash' header.CmacDataHash' 16) != 0)                  {                      Logger.Error("data hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  #if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  #endif              {                  check_initialized();                    Aes128CmacHeader header = *(Aes128CmacHeader*) inbuff;                    if (!(header.Mode == KirkMode.Cmd1 || header.Mode == KirkMode.Cmd2 || header.Mode == KirkMode.Cmd3))                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode));                  }                    if (header.DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header.Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      throw (new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte *)&keys' 16 * 2);  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer  #endif                    Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                    //Make sure data is 16 aligned                  var chkSize = header.DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header.DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacHeaderHash' header.CmacHeaderHash' 16) != 0)                  {                      Logger.Error("header hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }                  if (Crypto.Memcmp(cmacDataHash' header.CmacDataHash' 16) != 0)                  {                      Logger.Error("data hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  #if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  #endif              {                  check_initialized();                    Aes128CmacHeader header = *(Aes128CmacHeader*) inbuff;                    if (!(header.Mode == KirkMode.Cmd1 || header.Mode == KirkMode.Cmd2 || header.Mode == KirkMode.Cmd3))                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode));                  }                    if (header.DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header.Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      throw (new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte *)&keys' 16 * 2);  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer  #endif                    Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                    //Make sure data is 16 aligned                  var chkSize = header.DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header.DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacHeaderHash' header.CmacHeaderHash' 16) != 0)                  {                      Logger.Error("header hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }                  if (Crypto.Memcmp(cmacDataHash' header.CmacDataHash' 16) != 0)                  {                      Logger.Error("data hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  #if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  #endif              {                  check_initialized();                    Aes128CmacHeader header = *(Aes128CmacHeader*) inbuff;                    if (!(header.Mode == KirkMode.Cmd1 || header.Mode == KirkMode.Cmd2 || header.Mode == KirkMode.Cmd3))                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode));                  }                    if (header.DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header.Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      throw (new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte *)&keys' 16 * 2);  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer  #endif                    Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                    //Make sure data is 16 aligned                  var chkSize = header.DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header.DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacHeaderHash' header.CmacHeaderHash' 16) != 0)                  {                      Logger.Error("header hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }                  if (Crypto.Memcmp(cmacDataHash' header.CmacDataHash' 16) != 0)                  {                      Logger.Error("data hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_CMD10,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)  #if !USE_DOTNET_CRYPTO              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)  #endif              {                  check_initialized();                    Aes128CmacHeader header = *(Aes128CmacHeader*) inbuff;                    if (!(header.Mode == KirkMode.Cmd1 || header.Mode == KirkMode.Cmd2 || header.Mode == KirkMode.Cmd3))                  {                      throw(new KirkException(ResultEnum.PspKirkInvalidMode));                  }                    if (header.DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header.Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      throw (new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key    #if USE_DOTNET_CRYPTO  				DecryptAes(kirk1_key' inbuff' (byte *)&keys' 16 * 2);  #else                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer  #endif                    Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                    Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                    //Make sure data is 16 aligned                  var chkSize = header.DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header.DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacHeaderHash' header.CmacHeaderHash' 16) != 0)                  {                      Logger.Error("header hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }                  if (Crypto.Memcmp(cmacDataHash' header.CmacDataHash' 16) != 0)                  {                      Logger.Error("data hash invalid");                      throw (new KirkException(ResultEnum.PspSubcwrHeaderHashInvalid));                  }              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_init,The following statement contains a magic number: fixed (byte* kirk1KeyPtr = Kirk1Key)              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  Crypto.AES_set_key(aesKirk1Ptr' kirk1KeyPtr' 128);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,SceUtilsSetFuseId,The following statement contains a magic number: PointerUtils.Memcpy(fuseID' (byte*) fuse' 16);
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_decrypt_keys,The following statement contains a magic number: fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' keys' 16 * 2); //decrypt AES & CMAC key to temp buffer                  return 0;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_decrypt_keys,The following statement contains a magic number: fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' keys' 16 * 2); //decrypt AES & CMAC key to temp buffer                  return 0;              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: var cmacHeaderHashBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: var cmacDataHashBytes = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  if (!(header->Mode == KirkMode.Cmd1 || header->Mode == KirkMode.Cmd2 || header->Mode == KirkMode.Cmd3))                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidMode));                  }                  if (header->DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header->Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      //throw(new KirkException(ResultEnum.PSP_KIRK_INVALID_MODE));                      throw(new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key                    Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                  if (Crypto.Memcmp(cmacHeaderHash' header->CmacHeaderHash' 16) != 0)                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidHeaderHash));                  }                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacDataHash' header->CmacDataHash' 16) != 0)                  {                      //printf("data hash invalid' correcting...\n");                  }                  else                  {                      Logger.Error("data hash is already valid!");                      throw(new NotImplementedException());                      //return 100;                  }                  // Forge collision for data hash                  Crypto.Memcpy(cmacDataHash' header->CmacDataHash' 0x10);                  Crypto.AES_CMAC_forge(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                  //printf("Last row in bad file should be :\n"); for(i=0;i<0x10;i++) printf("%02x"' cmac_data_hash[i]);                  //printf("\n\n");              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  if (!(header->Mode == KirkMode.Cmd1 || header->Mode == KirkMode.Cmd2 || header->Mode == KirkMode.Cmd3))                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidMode));                  }                  if (header->DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header->Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      //throw(new KirkException(ResultEnum.PSP_KIRK_INVALID_MODE));                      throw(new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key                    Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                  if (Crypto.Memcmp(cmacHeaderHash' header->CmacHeaderHash' 16) != 0)                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidHeaderHash));                  }                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacDataHash' header->CmacDataHash' 16) != 0)                  {                      //printf("data hash invalid' correcting...\n");                  }                  else                  {                      Logger.Error("data hash is already valid!");                      throw(new NotImplementedException());                      //return 100;                  }                  // Forge collision for data hash                  Crypto.Memcpy(cmacDataHash' header->CmacDataHash' 0x10);                  Crypto.AES_CMAC_forge(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                  //printf("Last row in bad file should be :\n"); for(i=0;i<0x10;i++) printf("%02x"' cmac_data_hash[i]);                  //printf("\n\n");              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  if (!(header->Mode == KirkMode.Cmd1 || header->Mode == KirkMode.Cmd2 || header->Mode == KirkMode.Cmd3))                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidMode));                  }                  if (header->DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header->Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      //throw(new KirkException(ResultEnum.PSP_KIRK_INVALID_MODE));                      throw(new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key                    Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                  if (Crypto.Memcmp(cmacHeaderHash' header->CmacHeaderHash' 16) != 0)                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidHeaderHash));                  }                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacDataHash' header->CmacDataHash' 16) != 0)                  {                      //printf("data hash invalid' correcting...\n");                  }                  else                  {                      Logger.Error("data hash is already valid!");                      throw(new NotImplementedException());                      //return 100;                  }                  // Forge collision for data hash                  Crypto.Memcpy(cmacDataHash' header->CmacDataHash' 0x10);                  Crypto.AES_CMAC_forge(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                  //printf("Last row in bad file should be :\n"); for(i=0;i<0x10;i++) printf("%02x"' cmac_data_hash[i]);                  //printf("\n\n");              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  if (!(header->Mode == KirkMode.Cmd1 || header->Mode == KirkMode.Cmd2 || header->Mode == KirkMode.Cmd3))                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidMode));                  }                  if (header->DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header->Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      //throw(new KirkException(ResultEnum.PSP_KIRK_INVALID_MODE));                      throw(new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key                    Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                  if (Crypto.Memcmp(cmacHeaderHash' header->CmacHeaderHash' 16) != 0)                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidHeaderHash));                  }                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacDataHash' header->CmacDataHash' 16) != 0)                  {                      //printf("data hash invalid' correcting...\n");                  }                  else                  {                      Logger.Error("data hash is already valid!");                      throw(new NotImplementedException());                      //return 100;                  }                  // Forge collision for data hash                  Crypto.Memcpy(cmacDataHash' header->CmacDataHash' 0x10);                  Crypto.AES_CMAC_forge(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                  //printf("Last row in bad file should be :\n"); for(i=0;i<0x10;i++) printf("%02x"' cmac_data_hash[i]);                  //printf("\n\n");              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  if (!(header->Mode == KirkMode.Cmd1 || header->Mode == KirkMode.Cmd2 || header->Mode == KirkMode.Cmd3))                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidMode));                  }                  if (header->DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header->Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      //throw(new KirkException(ResultEnum.PSP_KIRK_INVALID_MODE));                      throw(new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key                    Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                  if (Crypto.Memcmp(cmacHeaderHash' header->CmacHeaderHash' 16) != 0)                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidHeaderHash));                  }                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacDataHash' header->CmacDataHash' 16) != 0)                  {                      //printf("data hash invalid' correcting...\n");                  }                  else                  {                      Logger.Error("data hash is already valid!");                      throw(new NotImplementedException());                      //return 100;                  }                  // Forge collision for data hash                  Crypto.Memcpy(cmacDataHash' header->CmacDataHash' 0x10);                  Crypto.AES_CMAC_forge(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                  //printf("Last row in bad file should be :\n"); for(i=0;i<0x10;i++) printf("%02x"' cmac_data_hash[i]);                  //printf("\n\n");              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  if (!(header->Mode == KirkMode.Cmd1 || header->Mode == KirkMode.Cmd2 || header->Mode == KirkMode.Cmd3))                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidMode));                  }                  if (header->DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header->Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      //throw(new KirkException(ResultEnum.PSP_KIRK_INVALID_MODE));                      throw(new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key                    Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                  if (Crypto.Memcmp(cmacHeaderHash' header->CmacHeaderHash' 16) != 0)                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidHeaderHash));                  }                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacDataHash' header->CmacDataHash' 16) != 0)                  {                      //printf("data hash invalid' correcting...\n");                  }                  else                  {                      Logger.Error("data hash is already valid!");                      throw(new NotImplementedException());                      //return 100;                  }                  // Forge collision for data hash                  Crypto.Memcpy(cmacDataHash' header->CmacDataHash' 0x10);                  Crypto.AES_CMAC_forge(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                  //printf("Last row in bad file should be :\n"); for(i=0;i<0x10;i++) printf("%02x"' cmac_data_hash[i]);                  //printf("\n\n");              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,kirk_forge,The following statement contains a magic number: fixed (byte* cmacHeaderHash = cmacHeaderHashBytes)              fixed (byte* cmacDataHash = cmacDataHashBytes)              fixed (Crypto.AesCtx* aesKirk1Ptr = &_aesKirk1)              {                  check_initialized();                  if (!(header->Mode == KirkMode.Cmd1 || header->Mode == KirkMode.Cmd2 || header->Mode == KirkMode.Cmd3))                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidMode));                  }                  if (header->DataSize == 0)                  {                      throw (new KirkException(ResultEnum.PspKirkDataSizeIsZero));                  }                    if (header->Mode != KirkMode.Cmd1)                  {                      // Checks for cmd 2 & 3 not included right now                      //throw(new KirkException(ResultEnum.PSP_KIRK_INVALID_MODE));                      throw(new KirkException(ResultEnum.PspKirkInvalidSigCheck));                  }                    HeaderKeys keys; //0-15 AES key' 16-31 CMAC key                    Crypto.AES_cbc_decrypt(aesKirk1Ptr' inbuff' (byte*) &keys'                      32); //decrypt AES & CMAC key to temp buffer                  Crypto.AesCtx cmacKey;                  Crypto.AES_set_key(&cmacKey' keys.Cmac' 128);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30' cmacHeaderHash);                  if (Crypto.Memcmp(cmacHeaderHash' header->CmacHeaderHash' 16) != 0)                  {                      throw (new KirkException(ResultEnum.PspKirkInvalidHeaderHash));                  }                    //Make sure data is 16 aligned                  var chkSize = header->DataSize;                  if ((chkSize % 16) != 0) chkSize += 16 - (chkSize % 16);                  Crypto.AES_CMAC(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                    if (Crypto.Memcmp(cmacDataHash' header->CmacDataHash' 16) != 0)                  {                      //printf("data hash invalid' correcting...\n");                  }                  else                  {                      Logger.Error("data hash is already valid!");                      throw(new NotImplementedException());                      //return 100;                  }                  // Forge collision for data hash                  Crypto.Memcpy(cmacDataHash' header->CmacDataHash' 0x10);                  Crypto.AES_CMAC_forge(&cmacKey' inbuff + 0x60' 0x30 + chkSize + header->DataOffset' cmacDataHash);                  //printf("Last row in bad file should be :\n"); for(i=0;i<0x10;i++) printf("%02x"' cmac_data_hash[i]);                  //printf("\n\n");              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,KirkSha1,The following statement contains a magic number: var sha1Hash = Sha1(                  PointerUtils.PointerToByteArray(inputBuffer + 4' inputSize)              );
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,DecryptAes,The following statement contains a magic number: if (iv == null) iv = new byte[16];
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,DecryptAes,The following statement contains a magic number: using (var aes = CreateAes())              {                  aes.Padding = PaddingMode.Zeros;                  var decryptor = aes.CreateDecryptor(key' iv);                    var dataSize = input.Length;                    if ((dataSize % 16) != 0)                  {                      var input2 = new byte[MathUtils.NextAligned(input.Length' 16)];                      Array.Copy(input' input2' input.Length);                      input = input2;                  }                    return new CryptoStream(new MemoryStream(input)' decryptor' CryptoStreamMode.Read).ReadBytes(dataSize);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,DecryptAes,The following statement contains a magic number: using (var aes = CreateAes())              {                  aes.Padding = PaddingMode.Zeros;                  var decryptor = aes.CreateDecryptor(key' iv);                    var dataSize = input.Length;                    if ((dataSize % 16) != 0)                  {                      var input2 = new byte[MathUtils.NextAligned(input.Length' 16)];                      Array.Copy(input' input2' input.Length);                      input = input2;                  }                    return new CryptoStream(new MemoryStream(input)' decryptor' CryptoStreamMode.Read).ReadBytes(dataSize);              }
Magic Number,CSPspEmu.Core.Components.Crypto,Kirk,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Crypto\Kirk.cs,EncryptAes,The following statement contains a magic number: if (iv == null) iv = new byte[16];
Magic Number,CSPspEmu.Core.Components.Ipl,IplReader,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core.Components\Ipl\IplReader.cs,GetIplOffsets,The following statement contains a magic number: var stream = Stream.SliceWithLength(NandReader.BytesPerBlock * 4);
