Implementation smell,Namespace,Class,File,Method,Description
Long Method,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfoPriv,The method has 130 lines of code.
Long Method,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfo,The method has 136 lines of code.
Long Method,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,RelocateRelocs,The method has 149 lines of code.
Complex Method,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,ToNormalizedTypeString,Cyclomatic complexity of the method is 8
Long Parameter List,CSPspEmu.Hle,HleModuleGuest,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleGuest.cs,CreateDelegate,The method has 5 parameters. Parameters: ModuleManager' Module' NID' ModuleImportName' NIDName
Long Parameter List,CSPspEmu.Hle,HleThread,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\HleThread.cs,SetWaitAndPrepareWakeUp,The method has 5 parameters. Parameters: WaitType' WaitDescription' WaitObject' PrepareCallback' HandleCallbacks
Long Parameter List,CSPspEmu.Hle,MemoryPartition,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\MemoryPartition.cs,MemoryPartition,The method has 6 parameters. Parameters: InjectContext' Low' High' Allocated' Name' ParentPartition
Long Parameter List,CSPspEmu.Hle,MemoryPartition,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\MemoryPartition.cs,Allocate,The method has 5 parameters. Parameters: Size' AllocateAnchor' Position' Alignment' Name
Long Parameter List,CSPspEmu.Hle.Managers,HleThreadManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleThreadManager.cs,Signal,The method has 5 parameters. Parameters: PC' CallbackData' Signal' Behavior' ExecuteNow
Long Parameter List,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,LoadModule,The method has 7 parameters. Parameters: fileStream' memoryStream' memoryPartition' moduleManager' gameTitle' moduleName' isMainModule
Long Identifier,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfoPriv,The length of the parameter HleInvalidAsInvalidPointerAttribute is 35.
Long Identifier,CSPspEmu.Hle.Interop,HleEmulatorSpecialAddresses,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Interop\HleEmulatorSpecialAddresses.cs,,The length of the parameter CODE_PTR_FINALIZE_CALLBACK_SYSCALL is 34.
Long Identifier,CSPspEmu.Hle.Threading.Semaphores,HleSemaphore,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Threading\Semaphores\HleSemaphore.cs,UpdatedCurrentCount,The length of the parameter WaitingSemaphoreThreadIterator is 30.
Long Statement,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfoPriv,The length of the statement  "                //var ModuleObject = this.Cast(this.GetType()' this.FieldAccess(this.Argument<CpuThreadState>(0' "CpuThreadState")' "ModuleObject")); " is 133.
Long Statement,CSPspEmu.Hle,HleThread,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\HleThread.cs,ToString,The length of the statement  "                $"HleThread(Id={Id}' Priority={PriorityValue}' Name='{Name}'' Status={CurrentStatus}' WaitDescription='{WaitDescription}'' YieldCount={YieldCount})"; " is 149.
Long Statement,CSPspEmu.Hle,HleThread,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\HleThread.cs,ToExtendedString,The length of the statement  "                $"HleThread(Id={Id}' Priority={PriorityValue}' PC=0x{CpuThreadState.Pc:X}' LastValidPC=0x{CpuThreadState.LastValidPc:X}' SP=0x{CpuThreadState.Sp:X}' Name='{Name}'' Status={CurrentStatus}' YieldCount={YieldCount}"; " is 213.
Long Statement,CSPspEmu.Hle,HleThread,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\HleThread.cs,ToExtendedString,The length of the statement  "                        $"' CurrentWaitType={CurrentWaitType}' WaitDescription={WaitDescription}' WaitObject={WaitObject}' HandleCallbacks={HandleCallbacks}"; " is 134.
Long Statement,CSPspEmu.Hle,PreemptiveScheduler<T>,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\PreemptiveScheduler.cs,Next,The length of the statement  "                            //Console.WriteLine("Not scheduled again: {0} : Ready: {1}' Priority : {2} != {3}"' Item' Item.Ready' Item.Priority' CurrentHighestPriority); " is 141.
Long Statement,CSPspEmu.Hle,MemoryPartition,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\MemoryPartition.cs,Dump,The length of the statement  "                $"MemoryPartition(Low={Low:X}' High={High:X}' Allocated={Allocated}' Size={Size}' Name='{Name}'){((this == Mark) ? " * " : "")}"); " is 130.
Long Statement,CSPspEmu.Hle,MemoryPartition,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\MemoryPartition.cs,ToString,The length of the statement  "                    $"MemoryPartition(Low={Low:X}' High={High:X}' Allocated={Allocated}' Name='{Name}'' Size={Size}' ChildPartitions=[{string.Join("'"' _ChildPartitions)}])"; " is 154.
Long Statement,CSPspEmu.Hle.Managers,HleMemoryManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleMemoryManager.cs,Initialize,The length of the statement  "            //MemoryPartitionsUid.Set((int)MemoryPartitions.Kernel1' new MemoryPartition(InjectContext' Low: 0x88300000' High: 0x88400000' Allocated: false' Name: "Kernel Partition 2")); // 1MB " is 181.
Long Statement,CSPspEmu.Hle.Managers,HleMemoryManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleMemoryManager.cs,Initialize,The length of the statement  "            //MemoryPartitionsUid.Set(4' new MemoryPartition(InjectContext' Low: 0x8A000000' High: 0x8BC00000' Allocated: false' Name: "UMD Cache Partition")); // 28MB " is 155.
Long Statement,CSPspEmu.Hle.Managers,HleMemoryManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleMemoryManager.cs,Initialize,The length of the statement  "            //MemoryPartitionsUid.Set(6' new MemoryPartition(InjectContext' Low: 0x8BC00000' High: 0x8C000000' Allocated: false' Name: "ME Partition")); // 4MB " is 147.
Long Statement,CSPspEmu.Hle.Managers,HleThreadManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleThreadManager.cs,StepNext,The length of the statement  "            //Console.WriteLine("{0} -> {1}"' String.Join("'"' PreemptiveScheduler.GetThreadsInQueue().Select(Item => Item.Name))' (NextThread != null) ? NextThread.Name : "-"); " is 165.
Long Statement,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,RelocateRelocs,The length of the statement  "                            result = (int)S + (int)GP_OFFSET + (int)(((A & 0x00008000) != 0) ? (((A & 0x00003FFF) + 0x4000) | 0xFFFF0000) : A) - (int)GP_ADDR; " is 130.
Long Statement,CSPspEmu.Hle.Threading.Semaphores,HleSemaphore,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Threading\Semaphores\HleSemaphore.cs,UpdatedCurrentCount,The length of the statement  "                //Console.WriteLine("if (CurrentCount >= WaitingSemaphoreThread.ExpectedMinimumCount) {0}' {1}"' CurrentCount' WaitingSemaphoreThread.ExpectedMinimumCount); " is 156.
Magic Number,CSPspEmu,ArgumentReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\ArgumentReader.cs,LoadLong,The following statement contains a magic number: try              {                  var Low = CpuThreadState.Gpr[GprPosition + 0];                  var High = CpuThreadState.Gpr[GprPosition + 1];                  return (long) ((High << 32) | (Low << 0));              }              finally              {                  GprPosition += 2;              }
Magic Number,CSPspEmu,ArgumentReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\ArgumentReader.cs,LoadLong,The following statement contains a magic number: try              {                  var Low = CpuThreadState.Gpr[GprPosition + 0];                  var High = CpuThreadState.Gpr[GprPosition + 1];                  return (long) ((High << 32) | (Low << 0));              }              finally              {                  GprPosition += 2;              }
Magic Number,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfoPriv,The following statement contains a magic number: if (AstMethodCall.Type == typeof(void)) AstNodes.AddStatement(ast.Statement(AstMethodCall));              else if (AstMethodCall.Type == typeof(long))                  AstNodes.AddStatement(ast.Assign(ast.GPR_l(2)' ast.Cast<long>(AstMethodCall)));              else if (AstMethodCall.Type == typeof(float))                  AstNodes.AddStatement(ast.Assign(ast.Fpr(0)' ast.Cast<float>(AstMethodCall)));              else if (AstMethodCall.Type.IsClass)              {                  if (!AstMethodCall.Type.Implements(typeof(IHleUidPoolClass)))                  {                      throw (new InvalidCastException(                          $"Can't use a class '{AstMethodCall.Type}' not implementing IHleUidPoolClass as return value"));                  }                  AstNodes.AddStatement(ast.Assign(                      ast.Gpr(2)'                      ast.CallStatic(                          (Func<CpuThreadState' Type' IHleUidPoolClass' uint>) GetOrAllocIndexFromPoolHelper'                          ast.CpuThreadStateExpr'                          ast.Immediate(AstMethodCall.Type)'                          ast.Cast<IHleUidPoolClass>(AstMethodCall)                      )                  ));              }              else AstNodes.AddStatement(ast.Assign(ast.Gpr(2)' ast.Cast<uint>(AstMethodCall)));
Magic Number,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfoPriv,The following statement contains a magic number: if (AstMethodCall.Type == typeof(void)) AstNodes.AddStatement(ast.Statement(AstMethodCall));              else if (AstMethodCall.Type == typeof(long))                  AstNodes.AddStatement(ast.Assign(ast.GPR_l(2)' ast.Cast<long>(AstMethodCall)));              else if (AstMethodCall.Type == typeof(float))                  AstNodes.AddStatement(ast.Assign(ast.Fpr(0)' ast.Cast<float>(AstMethodCall)));              else if (AstMethodCall.Type.IsClass)              {                  if (!AstMethodCall.Type.Implements(typeof(IHleUidPoolClass)))                  {                      throw (new InvalidCastException(                          $"Can't use a class '{AstMethodCall.Type}' not implementing IHleUidPoolClass as return value"));                  }                  AstNodes.AddStatement(ast.Assign(                      ast.Gpr(2)'                      ast.CallStatic(                          (Func<CpuThreadState' Type' IHleUidPoolClass' uint>) GetOrAllocIndexFromPoolHelper'                          ast.CpuThreadStateExpr'                          ast.Immediate(AstMethodCall.Type)'                          ast.Cast<IHleUidPoolClass>(AstMethodCall)                      )                  ));              }              else AstNodes.AddStatement(ast.Assign(ast.Gpr(2)' ast.Cast<uint>(AstMethodCall)));
Magic Number,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfoPriv,The following statement contains a magic number: if (AstMethodCall.Type == typeof(void)) AstNodes.AddStatement(ast.Statement(AstMethodCall));              else if (AstMethodCall.Type == typeof(long))                  AstNodes.AddStatement(ast.Assign(ast.GPR_l(2)' ast.Cast<long>(AstMethodCall)));              else if (AstMethodCall.Type == typeof(float))                  AstNodes.AddStatement(ast.Assign(ast.Fpr(0)' ast.Cast<float>(AstMethodCall)));              else if (AstMethodCall.Type.IsClass)              {                  if (!AstMethodCall.Type.Implements(typeof(IHleUidPoolClass)))                  {                      throw (new InvalidCastException(                          $"Can't use a class '{AstMethodCall.Type}' not implementing IHleUidPoolClass as return value"));                  }                  AstNodes.AddStatement(ast.Assign(                      ast.Gpr(2)'                      ast.CallStatic(                          (Func<CpuThreadState' Type' IHleUidPoolClass' uint>) GetOrAllocIndexFromPoolHelper'                          ast.CpuThreadStateExpr'                          ast.Immediate(AstMethodCall.Type)'                          ast.Cast<IHleUidPoolClass>(AstMethodCall)                      )                  ));              }              else AstNodes.AddStatement(ast.Assign(ast.Gpr(2)' ast.Cast<uint>(AstMethodCall)));
Magic Number,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfo,The following statement contains a magic number: return (CpuThreadState) =>              {                  bool Trace = (!SkipLog && CpuThreadState.CpuProcessor.CpuConfig.DebugSyscalls);                  bool NotImplemented = NotImplementedFunc && HleConfig.DebugNotImplemented;                    if (Trace && (MethodInfo.DeclaringType.Name == "Kernel_Library")) Trace = false;                    //Console.WriteLine("aaaaaaaaaaaaa");                    if (NotImplemented)                  {                      Trace = true;                      ConsoleUtils.SaveRestoreConsoleState(() =>                      {                          Console.ForegroundColor = ConsoleColor.Yellow;                          Console.WriteLine(                              "Not implemented {0}.{1}"'                              MethodInfo.DeclaringType.Name' MethodInfo.Name                          );                      });                  }                    var Out = Console.Out;                  if (NotImplemented)                  {                      Out = Console.Error;                  }                    if (Trace)                  {                      if (ThreadManager.Current != null)                      {                          Out.Write(                              "Thread({0}:'{1}') : RA(0x{2:X})"'                              ThreadManager.Current.Id'                              ThreadManager.Current.Name'                              ThreadManager.Current.CpuThreadState.Ra                          );                      }                      else                      {                          Out.Write("NoThread:");                      }                      Out.Write(" : {0}.{1}"' MethodInfo.DeclaringType.Name' MethodInfo.Name);                      Out.Write("(");                      int Count = 0;                        var NormalRegisterReader = new NormalRegisterReader(CpuThreadState);                      foreach (var ParamInfo in ParamInfoList)                      {                          if (Count > 0) Out.Write("' ");                          Out.Write("{0}:"' ParamInfo.ParameterInfo.Name);                          switch (ParamInfo.RegisterType)                          {                              case HleModuleHost.ParamInfo.RegisterTypeEnum.Fpr:                              case HleModuleHost.ParamInfo.RegisterTypeEnum.Gpr:                                  var Object = NormalRegisterReader.Read<uint>(ParamInfo.ParameterInfo);                                  Out.Write("{0}"'                                      ToNormalizedTypeString(ParamInfo.ParameterInfo.ParameterType' CpuThreadState'                                          Object));                                  break;                              default:                                  throw (new NotImplementedException());                          }                          Count++;                      }                      Out.Write(")");                      //Console.WriteLine("");                  }                    try                  {                      CpuThreadState.Pc = CpuThreadState.Ra;                      Delegate(CpuThreadState);                  }                  catch (InvalidProgramException)                  {                      Console.WriteLine("CALLING: {0}"' MethodInfo);                      Console.WriteLine("{0}"' (new GeneratorCSharp()).GenerateRoot(AstNodes).ToString());                        foreach (var Line in AstNodeExtensions.GeneratorIlPsp.GenerateToStringList(MethodInfo' AstNodes))                      {                          Console.WriteLine(Line);                      }                        throw;                  }                  catch (MemoryPartitionNoMemoryException)                  {                      CpuThreadState.Gpr[2] = (int) SceKernelErrors.ERROR_ERRNO_NO_MEMORY;                  }                  catch (SceKernelException SceKernelException)                  {                      CpuThreadState.Gpr[2] = (int) SceKernelException.SceKernelError;                  }                  catch (SceKernelSelfStopUnloadModuleException)                  {                      throw;                  }  #if !DO_NOT_PROPAGATE_EXCEPTIONS                  catch (Exception Exception)                  {                      throw (new Exception(                          $"ERROR calling {MethodInfo.DeclaringType.Name}.{MethodInfo.Name}!"'                          Exception                      ));                  }  #endif                  finally                  {                      if (Trace)                      {                          Out.WriteLine(" : {0}"'                              ToNormalizedTypeString(MethodInfo.ReturnType' CpuThreadState'                                  ((MethodInfo.ReturnType == typeof(float))                                      ? (object) CpuThreadState.Fpr[0]                                      : (object) CpuThreadState.Gpr[2])));                          Out.WriteLine("");                      }                  }              };
Magic Number,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfo,The following statement contains a magic number: return (CpuThreadState) =>              {                  bool Trace = (!SkipLog && CpuThreadState.CpuProcessor.CpuConfig.DebugSyscalls);                  bool NotImplemented = NotImplementedFunc && HleConfig.DebugNotImplemented;                    if (Trace && (MethodInfo.DeclaringType.Name == "Kernel_Library")) Trace = false;                    //Console.WriteLine("aaaaaaaaaaaaa");                    if (NotImplemented)                  {                      Trace = true;                      ConsoleUtils.SaveRestoreConsoleState(() =>                      {                          Console.ForegroundColor = ConsoleColor.Yellow;                          Console.WriteLine(                              "Not implemented {0}.{1}"'                              MethodInfo.DeclaringType.Name' MethodInfo.Name                          );                      });                  }                    var Out = Console.Out;                  if (NotImplemented)                  {                      Out = Console.Error;                  }                    if (Trace)                  {                      if (ThreadManager.Current != null)                      {                          Out.Write(                              "Thread({0}:'{1}') : RA(0x{2:X})"'                              ThreadManager.Current.Id'                              ThreadManager.Current.Name'                              ThreadManager.Current.CpuThreadState.Ra                          );                      }                      else                      {                          Out.Write("NoThread:");                      }                      Out.Write(" : {0}.{1}"' MethodInfo.DeclaringType.Name' MethodInfo.Name);                      Out.Write("(");                      int Count = 0;                        var NormalRegisterReader = new NormalRegisterReader(CpuThreadState);                      foreach (var ParamInfo in ParamInfoList)                      {                          if (Count > 0) Out.Write("' ");                          Out.Write("{0}:"' ParamInfo.ParameterInfo.Name);                          switch (ParamInfo.RegisterType)                          {                              case HleModuleHost.ParamInfo.RegisterTypeEnum.Fpr:                              case HleModuleHost.ParamInfo.RegisterTypeEnum.Gpr:                                  var Object = NormalRegisterReader.Read<uint>(ParamInfo.ParameterInfo);                                  Out.Write("{0}"'                                      ToNormalizedTypeString(ParamInfo.ParameterInfo.ParameterType' CpuThreadState'                                          Object));                                  break;                              default:                                  throw (new NotImplementedException());                          }                          Count++;                      }                      Out.Write(")");                      //Console.WriteLine("");                  }                    try                  {                      CpuThreadState.Pc = CpuThreadState.Ra;                      Delegate(CpuThreadState);                  }                  catch (InvalidProgramException)                  {                      Console.WriteLine("CALLING: {0}"' MethodInfo);                      Console.WriteLine("{0}"' (new GeneratorCSharp()).GenerateRoot(AstNodes).ToString());                        foreach (var Line in AstNodeExtensions.GeneratorIlPsp.GenerateToStringList(MethodInfo' AstNodes))                      {                          Console.WriteLine(Line);                      }                        throw;                  }                  catch (MemoryPartitionNoMemoryException)                  {                      CpuThreadState.Gpr[2] = (int) SceKernelErrors.ERROR_ERRNO_NO_MEMORY;                  }                  catch (SceKernelException SceKernelException)                  {                      CpuThreadState.Gpr[2] = (int) SceKernelException.SceKernelError;                  }                  catch (SceKernelSelfStopUnloadModuleException)                  {                      throw;                  }  #if !DO_NOT_PROPAGATE_EXCEPTIONS                  catch (Exception Exception)                  {                      throw (new Exception(                          $"ERROR calling {MethodInfo.DeclaringType.Name}.{MethodInfo.Name}!"'                          Exception                      ));                  }  #endif                  finally                  {                      if (Trace)                      {                          Out.WriteLine(" : {0}"'                              ToNormalizedTypeString(MethodInfo.ReturnType' CpuThreadState'                                  ((MethodInfo.ReturnType == typeof(float))                                      ? (object) CpuThreadState.Fpr[0]                                      : (object) CpuThreadState.Gpr[2])));                          Out.WriteLine("");                      }                  }              };
Magic Number,CSPspEmu.Hle,HleModuleHost,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.cs,CreateDelegateForMethodInfo,The following statement contains a magic number: return (CpuThreadState) =>              {                  bool Trace = (!SkipLog && CpuThreadState.CpuProcessor.CpuConfig.DebugSyscalls);                  bool NotImplemented = NotImplementedFunc && HleConfig.DebugNotImplemented;                    if (Trace && (MethodInfo.DeclaringType.Name == "Kernel_Library")) Trace = false;                    //Console.WriteLine("aaaaaaaaaaaaa");                    if (NotImplemented)                  {                      Trace = true;                      ConsoleUtils.SaveRestoreConsoleState(() =>                      {                          Console.ForegroundColor = ConsoleColor.Yellow;                          Console.WriteLine(                              "Not implemented {0}.{1}"'                              MethodInfo.DeclaringType.Name' MethodInfo.Name                          );                      });                  }                    var Out = Console.Out;                  if (NotImplemented)                  {                      Out = Console.Error;                  }                    if (Trace)                  {                      if (ThreadManager.Current != null)                      {                          Out.Write(                              "Thread({0}:'{1}') : RA(0x{2:X})"'                              ThreadManager.Current.Id'                              ThreadManager.Current.Name'                              ThreadManager.Current.CpuThreadState.Ra                          );                      }                      else                      {                          Out.Write("NoThread:");                      }                      Out.Write(" : {0}.{1}"' MethodInfo.DeclaringType.Name' MethodInfo.Name);                      Out.Write("(");                      int Count = 0;                        var NormalRegisterReader = new NormalRegisterReader(CpuThreadState);                      foreach (var ParamInfo in ParamInfoList)                      {                          if (Count > 0) Out.Write("' ");                          Out.Write("{0}:"' ParamInfo.ParameterInfo.Name);                          switch (ParamInfo.RegisterType)                          {                              case HleModuleHost.ParamInfo.RegisterTypeEnum.Fpr:                              case HleModuleHost.ParamInfo.RegisterTypeEnum.Gpr:                                  var Object = NormalRegisterReader.Read<uint>(ParamInfo.ParameterInfo);                                  Out.Write("{0}"'                                      ToNormalizedTypeString(ParamInfo.ParameterInfo.ParameterType' CpuThreadState'                                          Object));                                  break;                              default:                                  throw (new NotImplementedException());                          }                          Count++;                      }                      Out.Write(")");                      //Console.WriteLine("");                  }                    try                  {                      CpuThreadState.Pc = CpuThreadState.Ra;                      Delegate(CpuThreadState);                  }                  catch (InvalidProgramException)                  {                      Console.WriteLine("CALLING: {0}"' MethodInfo);                      Console.WriteLine("{0}"' (new GeneratorCSharp()).GenerateRoot(AstNodes).ToString());                        foreach (var Line in AstNodeExtensions.GeneratorIlPsp.GenerateToStringList(MethodInfo' AstNodes))                      {                          Console.WriteLine(Line);                      }                        throw;                  }                  catch (MemoryPartitionNoMemoryException)                  {                      CpuThreadState.Gpr[2] = (int) SceKernelErrors.ERROR_ERRNO_NO_MEMORY;                  }                  catch (SceKernelException SceKernelException)                  {                      CpuThreadState.Gpr[2] = (int) SceKernelException.SceKernelError;                  }                  catch (SceKernelSelfStopUnloadModuleException)                  {                      throw;                  }  #if !DO_NOT_PROPAGATE_EXCEPTIONS                  catch (Exception Exception)                  {                      throw (new Exception(                          $"ERROR calling {MethodInfo.DeclaringType.Name}.{MethodInfo.Name}!"'                          Exception                      ));                  }  #endif                  finally                  {                      if (Trace)                      {                          Out.WriteLine(" : {0}"'                              ToNormalizedTypeString(MethodInfo.ReturnType' CpuThreadState'                                  ((MethodInfo.ReturnType == typeof(float))                                      ? (object) CpuThreadState.Fpr[0]                                      : (object) CpuThreadState.Gpr[2])));                          Out.WriteLine("");                      }                  }              };
Magic Number,CSPspEmu.Hle,NormalRegisterReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.Proxy.cs,ReadFromStack,The following statement contains a magic number: if (Type == typeof(int) || Type == typeof(uint))                  {                      return CpuThreadState.Memory.ReadSafe<uint>(                          (uint) (this.CpuThreadState.Gpr[29] + ((MaxGprIndex - Index) * 4)));                  }
Magic Number,CSPspEmu.Hle,NormalRegisterReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.Proxy.cs,ReadFromStack,The following statement contains a magic number: if (Type == typeof(int) || Type == typeof(uint))                  {                      return CpuThreadState.Memory.ReadSafe<uint>(                          (uint) (this.CpuThreadState.Gpr[29] + ((MaxGprIndex - Index) * 4)));                  }
Magic Number,CSPspEmu.Hle,NormalRegisterReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.Proxy.cs,ReadFromStack,The following statement contains a magic number: if (Type == typeof(long) || Type == typeof(ulong))                  {                      return CpuThreadState.Memory.ReadSafe<ulong>(                          (uint) (this.CpuThreadState.Gpr[29] + ((MaxGprIndex - Index) * 4)));                  }
Magic Number,CSPspEmu.Hle,NormalRegisterReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.Proxy.cs,ReadFromStack,The following statement contains a magic number: if (Type == typeof(long) || Type == typeof(ulong))                  {                      return CpuThreadState.Memory.ReadSafe<ulong>(                          (uint) (this.CpuThreadState.Gpr[29] + ((MaxGprIndex - Index) * 4)));                  }
Magic Number,CSPspEmu.Hle,AstRegisterReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.Proxy.cs,ReadFromStack,The following statement contains a magic number: return ast.MemoryGetValue(Type' PspMemory' ast.GPR_u(29) + ((MaxGprIndex - Index) * 4));
Magic Number,CSPspEmu.Hle,AstRegisterReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.Proxy.cs,ReadFromStack,The following statement contains a magic number: return ast.MemoryGetValue(Type' PspMemory' ast.GPR_u(29) + ((MaxGprIndex - Index) * 4));
Magic Number,CSPspEmu.Hle,RegisterReaderBase<TReturn>,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleHost.Proxy.cs,Read,The following statement contains a magic number: int SizeInWords = Marshal.SizeOf(Type) / 4;
Magic Number,CSPspEmu.Hle,HleModuleGuest,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleGuest.cs,LinkFunction,The following statement contains a magic number: Instruction.Op1 = 2;
Magic Number,CSPspEmu.Hle,HleModuleGuest,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleGuest.cs,LinkFunction,The following statement contains a magic number: CpuProcessor.Memory.WriteSafe(CallAddress + 4' 0x00000000);
Magic Number,CSPspEmu.Hle,HleModuleGuest,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Modules\HleModuleGuest.cs,LinkFunction,The following statement contains a magic number: CpuProcessor.Memory.WriteSafe(CallAddress + 4' (uint) ModuleManager.AllocDelegateSlot(                  Action: CreateDelegate(                      ModuleManager: ModuleManager'                      Module: NativeFunction.Module'                      NID: NativeFunction.NID'                      ModuleImportName: NativeFunction.ModuleName'                      NIDName: NativeFunction.Name                  )'                  ModuleImportName: NativeFunction.ModuleName'                  FunctionEntry: NativeFunction              ));
Magic Number,CSPspEmu.Hle,HleThread,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\HleThread.cs,DumpStack,The following statement contains a magic number: foreach (var CallerPC in FullCallStack.Slice(0' 4))              {                  TextWriter.WriteLine("     MEM(0x{0:X}) : NOREL(0x{1:X})"' CallerPC'                      CallerPC - ElfConfig.RelocatedBaseAddress);              }
Magic Number,CSPspEmu.Hle,HleThread,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\HleThread.cs,DumpStack,The following statement contains a magic number: if (FullCallStack.Length > 4)              {                  TextWriter.WriteLine("     ...");              }
Magic Number,CSPspEmu.Hle,MemoryPartition,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\MemoryPartition.cs,Dump,The following statement contains a magic number: Console.Write(new string(' '' Level * 2));
Magic Number,CSPspEmu.Hle.Managers,HleInterruptHandler,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleInterruptManager.cs,HleInterruptHandler,The following statement contains a magic number: SubinterruptHandlers = new HleSubinterruptHandler[16];
Magic Number,CSPspEmu.Hle.Managers,HleIoManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleIoManager.cs,ParsePath,The following statement contains a magic number: int.TryParse(match.Groups[2].Value' out fileSystemNumber);
Magic Number,CSPspEmu.Hle.Managers,HleIoManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleIoManager.cs,ParsePath,The following statement contains a magic number: return new ParsePathInfo              {                  HleIoDrvFileArg = new HleIoDrvFileArg(driverName' hleIoDriver' fileSystemNumber' null)'                  LocalPath = match.Groups[3].Value.Replace('\\'' '/')'              };
Magic Number,CSPspEmu.Hle.Managers,HleIoManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleIoManager.cs,ParseDeviceName,The following statement contains a magic number: int.TryParse(match.Groups[2].Value' out fileSystemNumber);
Magic Number,CSPspEmu.Hle.Managers,HleMemoryManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleMemoryManager.cs,Initialize,The following statement contains a magic number: MemoryPartitionsUid.Set(5'                  new MemoryPartition(InjectContext' Low: 0x08400000' High: 0x08800000' Allocated: false'                      Name: "Volatile Partition"));
Magic Number,CSPspEmu.Hle.Managers,HleModuleManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleModuleManager.cs,Initialize,The following statement contains a magic number: if (HleModuleTypes.Count < 10)              {                  ConsoleUtils.SaveRestoreConsoleColor(ConsoleColor.Red' () =>                  {                      Console.WriteLine("!!!!!!!!!!!!!!!!!!!!!!!!");                      Console.WriteLine("Can't find HLE modules!!");                      Console.WriteLine("!!!!!!!!!!!!!!!!!!!!!!!!");                  });              }
Magic Number,CSPspEmu.Hle.Managers,HleThreadManager,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Managers\HleThreadManager.cs,StepNext,The following statement contains a magic number: if (NextThread == null)              {                  if (DisplayConfig.VerticalSynchronization)                  {                      Thread.Sleep(1);                  }                  if (Threads.Count == 0)                  {                      Thread.Sleep(5);                  }                  return;              }
Magic Number,CSPspEmu.Hle.Interop,HleInterop,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Interop\HleInterop.cs,SetArgumentsToCpuThreadState,The following statement contains a magic number: var gprIndex = 4;
Magic Number,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,LoadModule,The following statement contains a magic number: var magic = fileStream.SliceWithLength(0' 4).ReadString(4);
Magic Number,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,LoadModule,The following statement contains a magic number: var magic = fileStream.SliceWithLength(0' 4).ReadString(4);
Magic Number,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,RelocateRelocs,The following statement contains a magic number: foreach (var reloc in relocs)              {                  //Console.WriteLine(Reloc.ToStringDefault());                  //Console.WriteLine("   {0:X}"' RelocatedAddress);                    // Check if R_TYPE is 0xFF (break code) and break the loop                  // immediately in order to avoid fetching non existent program headers.                    // Some games (e.g.: "Final Fantasy: Dissidia") use this kind of relocation                  // suggesting that the PSP's ELF Loader is capable of recognizing it and stop.                  if (reloc.Type == Elf.Reloc.TypeEnum.StopRelocation)                  {                      break;                  }                    var pointerBaseOffset = ElfLoader.ProgramHeaders[reloc.PointerSectionHeaderBase].VirtualAddress;                  var pointeeBaseOffset = ElfLoader.ProgramHeaders[reloc.PointeeSectionHeaderBase].VirtualAddress;                    // Address of data to relocate                  var relocatedPointerAddress = BaseAddress + reloc.PointerAddress + pointerBaseOffset;                    // Value of data to relocate                  var instruction = instructionReader[relocatedPointerAddress];                  var instructionBefore = instruction;                    var s = BaseAddress + pointeeBaseOffset;                  var gpAddr = (int) (BaseAddress + reloc.PointerAddress);                  var gpOffset = gpAddr - ((int) BaseAddress & 0xFFFF0000);                    //Console.WriteLine(Reloc.Type);                    var debugReloc = (relocatedPointerAddress >= 0x08809320 &&                                    relocatedPointerAddress <= 0x08809320 + 0x100);                  //bool DebugReloc = false;                    if (debugReloc)                  {                      Console.WriteLine("{0:X8}[{1:X8}]: {2}"' relocatedPointerAddress' instruction.Value' reloc);                  }                    switch (reloc.Type)                  {                      // Tested on PSP: R_MIPS_NONE just returns 0.                      case Elf.Reloc.TypeEnum.None: // 0                      {                      }                          break;                      /*                  case Elf.Reloc.TypeEnum.Mips16: // 1                      {                          Instruction.IMMU += S;                      }                      break;                      */                      case Elf.Reloc.TypeEnum.Mips32: // 2                      {                          instruction.Value += s;                      }                          break;                      case Elf.Reloc.TypeEnum.MipsRel32: // 3;                      {                          throw new NotImplementedException();                      }                      case Elf.Reloc.TypeEnum.Mips26: // 4                      {                          instruction.JumpReal = instruction.JumpReal + s;                      }                          break;                      case Elf.Reloc.TypeEnum.MipsHi16: // 5                      {                          hiValue = (ushort) instruction.Immu;                          deferredHi16.AddLast(relocatedPointerAddress);                      }                          break;                      case Elf.Reloc.TypeEnum.MipsLo16: // 6                      {                          var a = instruction.Immu;                            instruction.Immu = ((uint) (hiValue << 16) | a & 0x0000FFFF) + s;                            // Process deferred R_MIPS_HI16                          foreach (var dataAddr2 in deferredHi16)                          {                              var data2 = instructionReader[dataAddr2];                              var result = ((data2.Value & 0x0000FFFF) << 16) + a + s;                              // The low order 16 bits are always treated as a signed                              // value. Therefore' a negative value in the low order bits                              // requires an adjustment in the high order bits. We need                              // to make this adjustment in two ways: once for the bits we                              // took from the data' and once for the bits we are putting                              // back in to the data.                              if ((a & 0x8000) != 0)                              {                                  result -= 0x10000;                              }                              if ((result & 0x8000) != 0)                              {                                  result += 0x10000;                              }                              data2.Immu = (result >> 16);                              instructionReader[dataAddr2] = data2;                          }                          deferredHi16.Clear();                      }                          break;                      case Elf.Reloc.TypeEnum.MipsGpRel16: // 7                      {                          /*                          int A = Instruction.IMM;                          int result;                          if (A == 0)                          {                              result = (int)S - (int)GP_ADDR;                          }                          else                          {                              result = (int)S + (int)GP_OFFSET + (int)(((A & 0x00008000) != 0) ? (((A & 0x00003FFF) + 0x4000) | 0xFFFF0000) : A) - (int)GP_ADDR;                          }                          if ((result < -32768) || (result > 32768))                          {                              Console.Error.WriteLine("Relocation overflow (R_MIPS_GPREL16) : '" + result + "'");                          }                          Instruction.IMMU = (uint)result;                          */                      }                          break;                      default:                          throw new NotImplementedException($"Handling {reloc.Type} not implemented");                  }                    RelocOutput?.WriteLine(                      "RELOC %06d : 0x%08X : 0x%08X -> 0x%08X".Sprintf(                          index'                          relocatedPointerAddress' instructionBefore.Value' instruction.Value                      )                  );                    if (debugReloc)                  {                      Console.WriteLine("   -> {0:X8}"' instruction.Value);                  }                    /*                  log.error(String.format(                      "RELOC %06d : 0x%08X : 0x%08X -> 0x%08X\n"'                      i' data_addr' data_prev' data                  ));                  */                  instructionReader[relocatedPointerAddress] = instruction;                  index++;              }
Magic Number,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,RelocateRelocs,The following statement contains a magic number: foreach (var reloc in relocs)              {                  //Console.WriteLine(Reloc.ToStringDefault());                  //Console.WriteLine("   {0:X}"' RelocatedAddress);                    // Check if R_TYPE is 0xFF (break code) and break the loop                  // immediately in order to avoid fetching non existent program headers.                    // Some games (e.g.: "Final Fantasy: Dissidia") use this kind of relocation                  // suggesting that the PSP's ELF Loader is capable of recognizing it and stop.                  if (reloc.Type == Elf.Reloc.TypeEnum.StopRelocation)                  {                      break;                  }                    var pointerBaseOffset = ElfLoader.ProgramHeaders[reloc.PointerSectionHeaderBase].VirtualAddress;                  var pointeeBaseOffset = ElfLoader.ProgramHeaders[reloc.PointeeSectionHeaderBase].VirtualAddress;                    // Address of data to relocate                  var relocatedPointerAddress = BaseAddress + reloc.PointerAddress + pointerBaseOffset;                    // Value of data to relocate                  var instruction = instructionReader[relocatedPointerAddress];                  var instructionBefore = instruction;                    var s = BaseAddress + pointeeBaseOffset;                  var gpAddr = (int) (BaseAddress + reloc.PointerAddress);                  var gpOffset = gpAddr - ((int) BaseAddress & 0xFFFF0000);                    //Console.WriteLine(Reloc.Type);                    var debugReloc = (relocatedPointerAddress >= 0x08809320 &&                                    relocatedPointerAddress <= 0x08809320 + 0x100);                  //bool DebugReloc = false;                    if (debugReloc)                  {                      Console.WriteLine("{0:X8}[{1:X8}]: {2}"' relocatedPointerAddress' instruction.Value' reloc);                  }                    switch (reloc.Type)                  {                      // Tested on PSP: R_MIPS_NONE just returns 0.                      case Elf.Reloc.TypeEnum.None: // 0                      {                      }                          break;                      /*                  case Elf.Reloc.TypeEnum.Mips16: // 1                      {                          Instruction.IMMU += S;                      }                      break;                      */                      case Elf.Reloc.TypeEnum.Mips32: // 2                      {                          instruction.Value += s;                      }                          break;                      case Elf.Reloc.TypeEnum.MipsRel32: // 3;                      {                          throw new NotImplementedException();                      }                      case Elf.Reloc.TypeEnum.Mips26: // 4                      {                          instruction.JumpReal = instruction.JumpReal + s;                      }                          break;                      case Elf.Reloc.TypeEnum.MipsHi16: // 5                      {                          hiValue = (ushort) instruction.Immu;                          deferredHi16.AddLast(relocatedPointerAddress);                      }                          break;                      case Elf.Reloc.TypeEnum.MipsLo16: // 6                      {                          var a = instruction.Immu;                            instruction.Immu = ((uint) (hiValue << 16) | a & 0x0000FFFF) + s;                            // Process deferred R_MIPS_HI16                          foreach (var dataAddr2 in deferredHi16)                          {                              var data2 = instructionReader[dataAddr2];                              var result = ((data2.Value & 0x0000FFFF) << 16) + a + s;                              // The low order 16 bits are always treated as a signed                              // value. Therefore' a negative value in the low order bits                              // requires an adjustment in the high order bits. We need                              // to make this adjustment in two ways: once for the bits we                              // took from the data' and once for the bits we are putting                              // back in to the data.                              if ((a & 0x8000) != 0)                              {                                  result -= 0x10000;                              }                              if ((result & 0x8000) != 0)                              {                                  result += 0x10000;                              }                              data2.Immu = (result >> 16);                              instructionReader[dataAddr2] = data2;                          }                          deferredHi16.Clear();                      }                          break;                      case Elf.Reloc.TypeEnum.MipsGpRel16: // 7                      {                          /*                          int A = Instruction.IMM;                          int result;                          if (A == 0)                          {                              result = (int)S - (int)GP_ADDR;                          }                          else                          {                              result = (int)S + (int)GP_OFFSET + (int)(((A & 0x00008000) != 0) ? (((A & 0x00003FFF) + 0x4000) | 0xFFFF0000) : A) - (int)GP_ADDR;                          }                          if ((result < -32768) || (result > 32768))                          {                              Console.Error.WriteLine("Relocation overflow (R_MIPS_GPREL16) : '" + result + "'");                          }                          Instruction.IMMU = (uint)result;                          */                      }                          break;                      default:                          throw new NotImplementedException($"Handling {reloc.Type} not implemented");                  }                    RelocOutput?.WriteLine(                      "RELOC %06d : 0x%08X : 0x%08X -> 0x%08X".Sprintf(                          index'                          relocatedPointerAddress' instructionBefore.Value' instruction.Value                      )                  );                    if (debugReloc)                  {                      Console.WriteLine("   -> {0:X8}"' instruction.Value);                  }                    /*                  log.error(String.format(                      "RELOC %06d : 0x%08X : 0x%08X -> 0x%08X\n"'                      i' data_addr' data_prev' data                  ));                  */                  instructionReader[relocatedPointerAddress] = instruction;                  index++;              }
Magic Number,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,RelocateRelocs,The following statement contains a magic number: foreach (var reloc in relocs)              {                  //Console.WriteLine(Reloc.ToStringDefault());                  //Console.WriteLine("   {0:X}"' RelocatedAddress);                    // Check if R_TYPE is 0xFF (break code) and break the loop                  // immediately in order to avoid fetching non existent program headers.                    // Some games (e.g.: "Final Fantasy: Dissidia") use this kind of relocation                  // suggesting that the PSP's ELF Loader is capable of recognizing it and stop.                  if (reloc.Type == Elf.Reloc.TypeEnum.StopRelocation)                  {                      break;                  }                    var pointerBaseOffset = ElfLoader.ProgramHeaders[reloc.PointerSectionHeaderBase].VirtualAddress;                  var pointeeBaseOffset = ElfLoader.ProgramHeaders[reloc.PointeeSectionHeaderBase].VirtualAddress;                    // Address of data to relocate                  var relocatedPointerAddress = BaseAddress + reloc.PointerAddress + pointerBaseOffset;                    // Value of data to relocate                  var instruction = instructionReader[relocatedPointerAddress];                  var instructionBefore = instruction;                    var s = BaseAddress + pointeeBaseOffset;                  var gpAddr = (int) (BaseAddress + reloc.PointerAddress);                  var gpOffset = gpAddr - ((int) BaseAddress & 0xFFFF0000);                    //Console.WriteLine(Reloc.Type);                    var debugReloc = (relocatedPointerAddress >= 0x08809320 &&                                    relocatedPointerAddress <= 0x08809320 + 0x100);                  //bool DebugReloc = false;                    if (debugReloc)                  {                      Console.WriteLine("{0:X8}[{1:X8}]: {2}"' relocatedPointerAddress' instruction.Value' reloc);                  }                    switch (reloc.Type)                  {                      // Tested on PSP: R_MIPS_NONE just returns 0.                      case Elf.Reloc.TypeEnum.None: // 0                      {                      }                          break;                      /*                  case Elf.Reloc.TypeEnum.Mips16: // 1                      {                          Instruction.IMMU += S;                      }                      break;                      */                      case Elf.Reloc.TypeEnum.Mips32: // 2                      {                          instruction.Value += s;                      }                          break;                      case Elf.Reloc.TypeEnum.MipsRel32: // 3;                      {                          throw new NotImplementedException();                      }                      case Elf.Reloc.TypeEnum.Mips26: // 4                      {                          instruction.JumpReal = instruction.JumpReal + s;                      }                          break;                      case Elf.Reloc.TypeEnum.MipsHi16: // 5                      {                          hiValue = (ushort) instruction.Immu;                          deferredHi16.AddLast(relocatedPointerAddress);                      }                          break;                      case Elf.Reloc.TypeEnum.MipsLo16: // 6                      {                          var a = instruction.Immu;                            instruction.Immu = ((uint) (hiValue << 16) | a & 0x0000FFFF) + s;                            // Process deferred R_MIPS_HI16                          foreach (var dataAddr2 in deferredHi16)                          {                              var data2 = instructionReader[dataAddr2];                              var result = ((data2.Value & 0x0000FFFF) << 16) + a + s;                              // The low order 16 bits are always treated as a signed                              // value. Therefore' a negative value in the low order bits                              // requires an adjustment in the high order bits. We need                              // to make this adjustment in two ways: once for the bits we                              // took from the data' and once for the bits we are putting                              // back in to the data.                              if ((a & 0x8000) != 0)                              {                                  result -= 0x10000;                              }                              if ((result & 0x8000) != 0)                              {                                  result += 0x10000;                              }                              data2.Immu = (result >> 16);                              instructionReader[dataAddr2] = data2;                          }                          deferredHi16.Clear();                      }                          break;                      case Elf.Reloc.TypeEnum.MipsGpRel16: // 7                      {                          /*                          int A = Instruction.IMM;                          int result;                          if (A == 0)                          {                              result = (int)S - (int)GP_ADDR;                          }                          else                          {                              result = (int)S + (int)GP_OFFSET + (int)(((A & 0x00008000) != 0) ? (((A & 0x00003FFF) + 0x4000) | 0xFFFF0000) : A) - (int)GP_ADDR;                          }                          if ((result < -32768) || (result > 32768))                          {                              Console.Error.WriteLine("Relocation overflow (R_MIPS_GPREL16) : '" + result + "'");                          }                          Instruction.IMMU = (uint)result;                          */                      }                          break;                      default:                          throw new NotImplementedException($"Handling {reloc.Type} not implemented");                  }                    RelocOutput?.WriteLine(                      "RELOC %06d : 0x%08X : 0x%08X -> 0x%08X".Sprintf(                          index'                          relocatedPointerAddress' instructionBefore.Value' instruction.Value                      )                  );                    if (debugReloc)                  {                      Console.WriteLine("   -> {0:X8}"' instruction.Value);                  }                    /*                  log.error(String.format(                      "RELOC %06d : 0x%08X : 0x%08X -> 0x%08X\n"'                      i' data_addr' data_prev' data                  ));                  */                  instructionReader[relocatedPointerAddress] = instruction;                  index++;              }
Magic Number,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,_UpdateModuleExports,The following statement contains a magic number: foreach (var moduleExport in moduleExports)              {                  var moduleExportName = (moduleExport.Name > 0)                      ? ElfLoader.MemoryStream.ReadStringzAt(moduleExport.Name)                      : "";                    Console.WriteLine("  * Export: '{0}'"' moduleExportName);                    var hleModuleExports = new HleModuleExports                  {                      Name = moduleExportName'                      Flags = moduleExport.Flags'                      Version = moduleExport.Version                  };                    var exportsExportsStream = ElfLoader.MemoryStream.SliceWithLength(                      moduleExport.Exports'                      moduleExport.FunctionCount * sizeof(uint) * 2 + moduleExport.VariableCount * sizeof(uint) * 2                  );                    var functionNidReader =                      new BinaryReader(exportsExportsStream.ReadStream(moduleExport.FunctionCount * sizeof(uint)));                  var variableNidReader =                      new BinaryReader(exportsExportsStream.ReadStream(moduleExport.VariableCount * sizeof(uint)));                  var functionAddressReader =                      new BinaryReader(exportsExportsStream.ReadStream(moduleExport.FunctionCount * sizeof(uint)));                  var variableAddressReader =                      new BinaryReader(exportsExportsStream.ReadStream(moduleExport.VariableCount * sizeof(uint)));                    for (var n = 0; n < moduleExport.FunctionCount; n++)                  {                      var nid = functionNidReader.ReadUInt32();                      var callAddress = functionAddressReader.ReadUInt32();                      hleModuleExports.Functions[nid] = new HleModuleImportsExports.Entry() {Address = callAddress};                        Console.WriteLine("  |  - FUNC: {0:X} : {1:X} : {2}"' nid' callAddress'                          Enum.GetName(typeof(SpecialFunctionNids)' nid));                  }                    for (var n = 0; n < moduleExport.VariableCount; n++)                  {                      var nid = variableNidReader.ReadUInt32();                      var callAddress = variableAddressReader.ReadUInt32();                      hleModuleExports.Variables[nid] = new HleModuleImportsExports.Entry() {Address = callAddress};                        Console.WriteLine("  |  - VAR: {0:X} : {1:X} : {2}"' nid' callAddress'                          Enum.GetName(typeof(SpecialVariableNids)' nid));                  }                    HleModuleGuest.ModulesExports.Add(hleModuleExports);              }
Magic Number,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,_UpdateModuleExports,The following statement contains a magic number: foreach (var moduleExport in moduleExports)              {                  var moduleExportName = (moduleExport.Name > 0)                      ? ElfLoader.MemoryStream.ReadStringzAt(moduleExport.Name)                      : "";                    Console.WriteLine("  * Export: '{0}'"' moduleExportName);                    var hleModuleExports = new HleModuleExports                  {                      Name = moduleExportName'                      Flags = moduleExport.Flags'                      Version = moduleExport.Version                  };                    var exportsExportsStream = ElfLoader.MemoryStream.SliceWithLength(                      moduleExport.Exports'                      moduleExport.FunctionCount * sizeof(uint) * 2 + moduleExport.VariableCount * sizeof(uint) * 2                  );                    var functionNidReader =                      new BinaryReader(exportsExportsStream.ReadStream(moduleExport.FunctionCount * sizeof(uint)));                  var variableNidReader =                      new BinaryReader(exportsExportsStream.ReadStream(moduleExport.VariableCount * sizeof(uint)));                  var functionAddressReader =                      new BinaryReader(exportsExportsStream.ReadStream(moduleExport.FunctionCount * sizeof(uint)));                  var variableAddressReader =                      new BinaryReader(exportsExportsStream.ReadStream(moduleExport.VariableCount * sizeof(uint)));                    for (var n = 0; n < moduleExport.FunctionCount; n++)                  {                      var nid = functionNidReader.ReadUInt32();                      var callAddress = functionAddressReader.ReadUInt32();                      hleModuleExports.Functions[nid] = new HleModuleImportsExports.Entry() {Address = callAddress};                        Console.WriteLine("  |  - FUNC: {0:X} : {1:X} : {2}"' nid' callAddress'                          Enum.GetName(typeof(SpecialFunctionNids)' nid));                  }                    for (var n = 0; n < moduleExport.VariableCount; n++)                  {                      var nid = variableNidReader.ReadUInt32();                      var callAddress = variableAddressReader.ReadUInt32();                      hleModuleExports.Variables[nid] = new HleModuleImportsExports.Entry() {Address = callAddress};                        Console.WriteLine("  |  - VAR: {0:X} : {1:X} : {2}"' nid' callAddress'                          Enum.GetName(typeof(SpecialVariableNids)' nid));                  }                    HleModuleGuest.ModulesExports.Add(hleModuleExports);              }
Magic Number,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,_UpdateModuleImports,The following statement contains a magic number: foreach (var moduleImport in moduleImports)              {                  var moduleImportName = "INVALID";                  try                  {                      moduleImportName = ElfLoader.MemoryStream.ReadStringzAt(moduleImport.Name);                  }                  catch (Exception e)                  {                      Console.WriteLine(e);                  }                    var hleModuleImports = new HleModuleImports                  {                      Name = moduleImportName'                      Flags = moduleImport.Flags'                      Version = moduleImport.Version                  };                    var nidStreamReader = new BinaryReader(ElfLoader.MemoryStream.SliceWithLength(moduleImport.NidAddress'                      moduleImport.FunctionCount * sizeof(uint)));                    for (var n = 0; n < moduleImport.FunctionCount; n++)                  {                      var nid = nidStreamReader.ReadUInt32();                      var callAddress = (uint) (moduleImport.CallAddress + n * 8);                        hleModuleImports.Functions[nid] = new HleModuleImportsExports.Entry() {Address = callAddress};                  }                    HleModuleGuest.ModulesImports.Add(hleModuleImports);              }
Missing Default,CSPspEmu.Hle,HleThread,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\HleThread.cs,ToExtendedString,The following switch statement is missing a default case: switch (CurrentStatus)              {                  case Status.Waiting:                      Ret +=                          $"' CurrentWaitType={CurrentWaitType}' WaitDescription={WaitDescription}' WaitObject={WaitObject}' HandleCallbacks={HandleCallbacks}";                      break;              }
Missing Default,CSPspEmu.Hle,MemoryPartition,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\MemoryPartition.cs,GetAnchoredAddress,The following switch statement is missing a default case: switch (Anchor)              {                  case MemoryPartition.Anchor.High: return High;                  case MemoryPartition.Anchor.Low: return Low;              }
Missing Default,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,RelocateFromHeaders,The following switch statement is missing a default case: switch (programHeader.Type)                  {                      case Elf.ProgramHeader.TypeEnum.Reloc1:                          _logger.Warning("SKIPPING Elf.ProgramHeader.TypeEnum.Reloc1!");                          break;                      case Elf.ProgramHeader.TypeEnum.Reloc2:                          throw(new NotImplementedException());                  }
Missing Default,CSPspEmu.Hle.Loader,ElfPspLoader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle\Loader\ElfPspLoader.cs,RelocateFromHeaders,The following switch statement is missing a default case: switch (sectionHeader.Type)                  {                      case Elf.SectionHeader.TypeEnum.Relocation:                          Console.Error.WriteLine("Not implemented Elf.SectionHeader.TypeEnum.Relocation");                          //throw (new NotImplementedException("Not implemented Elf.SectionHeader.TypeEnum.Relocation"));                          //break;                          /*                          RelocateRelocs(                              ElfLoader.SectionHeaderFileStream(SectionHeader).ReadStructVectorUntilTheEndOfStream<Elf.Reloc>()                          );                          */                          break;                        case Elf.SectionHeader.TypeEnum.PrxRelocation:                          Console.WriteLine("PrxRelocation : {0}"' sectionHeader);                          RelocateRelocs(                              ElfLoader.SectionHeaderFileStream(sectionHeader)                                  .ReadStructVectorUntilTheEndOfStream<Elf.Reloc>()                          );                          break;                      case Elf.SectionHeader.TypeEnum.PrxRelocationFw5:                          throw (new Exception("Not implemented ElfSectionHeader.Type.PrxRelocation_FW5"));                  }
