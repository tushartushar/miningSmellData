Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,CSPspEmu.Hle.Vfs.Emulator,HleIoDriverEmulator,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Emulator\HleIoDriverEmulator.cs,IoIoctl,The method has 6 parameters. Parameters: HleIoDrvFileArg' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs.Emulator,HleIoDriverEmulator,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Emulator\HleIoDriverEmulator.cs,IoDevctl,The method has 7 parameters. Parameters: HleIoDrvFileArg' DeviceName' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The method has 7 parameters. Parameters: HleIoDrvFileArg' DeviceName' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs,HleIoDriverMountable,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\HleIoDriverMountable.cs,IoIoctl,The method has 6 parameters. Parameters: HleIoDrvFileArg' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs,HleIoDriverMountable,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\HleIoDriverMountable.cs,IoDevctl,The method has 7 parameters. Parameters: HleIoDrvFileArg' DeviceName' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs,IHleIoDriver,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\IHleIoDriver.cs,IoIoctl,The method has 6 parameters. Parameters: HleIoDrvFileArg' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs,IHleIoDriver,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\IHleIoDriver.cs,IoDevctl,The method has 7 parameters. Parameters: HleIoDrvFileArg' DeviceName' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs,ProxyHleIoDriver,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\ProxyHleIoDriver.cs,IoIoctl,The method has 6 parameters. Parameters: HleIoDrvFileArg' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs,ProxyHleIoDriver,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\ProxyHleIoDriver.cs,IoDevctl,The method has 7 parameters. Parameters: HleIoDrvFileArg' DeviceName' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoIoctl,The method has 6 parameters. Parameters: HleIoDrvFileArg' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoDevctl,The method has 7 parameters. Parameters: HleIoDrvFileArg' DeviceName' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,IoIoctl,The method has 6 parameters. Parameters: HleIoDrvFileArg' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,IoDevctl,The method has 7 parameters. Parameters: HleIoDrvFileArg' DeviceName' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs.Zip,HleIoDriverZip,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Zip\HleIoDriverZip.cs,IoIoctl,The method has 6 parameters. Parameters: HleIoDrvFileArg' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Parameter List,CSPspEmu.Hle.Vfs.Zip,HleIoDriverZip,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Zip\HleIoDriverZip.cs,IoDevctl,The method has 7 parameters. Parameters: HleIoDrvFileArg' DeviceName' Command' InputPointer' InputLength' OutputPointer' OutputLength
Long Statement,CSPspEmu.Hle.Vfs,ScePspDateTime,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\IHleIoDriver.cs,ToString,The length of the statement  "                $"ScePspDateTime(Year={Year}' Month={Month}' Day={Day}' Hour={Hour}' Minute={Minute}' Second={Second}' Microsecond={Microsecond})"; " is 131.
Long Statement,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoDopen,The length of the statement  "            //HleIoDrvFileArg.FileArgument = new DisposableDummy<DirectoryEnumerator<IsoNode>>(new DirectoryEnumerator<IsoNode>(IsoNode.Childs.ToArray())); " is 143.
Long Statement,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoDread,The length of the statement  "            //var Enumerator = (DirectoryEnumerator<IsoNode>)(DisposableDummy<DirectoryEnumerator<IsoNode>>)HleIoDrvFileArg.FileArgument; " is 125.
Long Statement,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,IoDopen,The length of the statement  "            //HleIoDrvFileArg.FileArgument = new DisposableDummy<DirectoryEnumerator<HleIoDirent>>(new DirectoryEnumerator<HleIoDirent>(Items.ToArray())); " is 142.
Long Statement,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,IoDread,The length of the statement  "            //var Enumerator = (DirectoryEnumerator<HleIoDirent>)(DisposableDummy<DirectoryEnumerator<HleIoDirent>>)HleIoDrvFileArg.FileArgument; " is 133.
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs.MemoryStick,HleIoDriverMemoryStick,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\MemoryStick\HleIoDriverMemoryStick.cs,IoDevctl,The following statement contains a magic number: switch ((CommandType) Command)              {                  case CommandType.CheckInserted:                  {                      if (OutputPointer == null || OutputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      // 0 - Device is not assigned (callback not registered).                      // 1 - Device is assigned (callback registered).                      *(uint*) OutputPointer = 1;                      return 0;                  }                  case CommandType.MScmRegisterMSInsertEjectCallback:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      int CallbackId = *(int*) InputPointer;                      MemoryStickEventHandler.ScheduleCallback(CallbackId' 1' 1);                      //var Callback = CallbackManager.Callbacks.Get(CallbackId);                      //CallbackManager.ScheduleCallback(                      //	HleCallback.Create(                      //		"RegisterInjectEjectCallback"'                      //		Callback.Function'                      //		new object[] {                      //			1' // a0                      //			1' // a1                      //			Callback.Arguments[0] // a2                      //		}                      //	)                      //);                        return 0;                  }                  case CommandType.GetMemoryStickCapacity:                  {                      if (InputPointer == null || InputLength < 4)                          return (int) SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;                      var SizeInfo = (SizeInfoStruct*) Memory.PspAddressToPointerSafe(*(uint*) InputPointer);                      var MemoryStickSectorSize = (32 * 1024);                      //var TotalSpaceInBytes = 2L * 1024 * 1024 * 1024;                      var FreeSpaceInBytes = 1L * 1024 * 1024 * 1024;                      SizeInfo->SectorSize = 0x200;                      SizeInfo->SectorCount = (uint) (MemoryStickSectorSize / SizeInfo->SectorSize);                      SizeInfo->MaxClusters = (uint) (FreeSpaceInBytes * 95 / 100) /                                              (SizeInfo->SectorSize * SizeInfo->SectorCount);                      SizeInfo->FreeClusters = SizeInfo->MaxClusters;                      SizeInfo->MaxSectors = SizeInfo->MaxClusters;                        return 0;                  }                  case CommandType.MScmUnregisterMSInsertEjectCallback:                      // Ignore.                      return 0;                  case CommandType.CheckMemoryStickIsInserted:                      *((uint*) OutputPointer) = 1;                      return 0;                  case CommandType.CheckMemoryStickStatus:                      // 0 <- Busy                      // 1 <- Ready                      *((uint*) OutputPointer) = 4;                      break;                  default:                      Console.Error.WriteLine("MemoryStick.IoDevctl Not Implemented! ({0}' 0x{1:X})"' DeviceName'                          Command);                      break;              }
Magic Number,CSPspEmu.Hle.Vfs,ScePspDateTime,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\IHleIoDriver.cs,FromDateTime,The following statement contains a magic number: return new ScePspDateTime()              {                  Year = (ushort) DateTime.Year'                  Month = (ushort) DateTime.Month'                  Day = (ushort) DateTime.Day'                  Hour = (ushort) DateTime.Hour'                  Minute = (ushort) DateTime.Minute'                  Second = (ushort) DateTime.Second'                  Microsecond = (uint) (DateTime.Millisecond * 1000)'              };
Magic Number,CSPspEmu.Hle.Vfs,ScePspDateTime,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\IHleIoDriver.cs,ToDateTime,The following statement contains a magic number: return new DateTime((int) Year' (int) Month' (int) Day' (int) Hour' (int) Minute' (int) Second'                  (int) Microsecond / 1000' DateTimeKind.Utc);
Magic Number,CSPspEmu.Hle.Vfs,ScePspDateTime,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\IHleIoDriver.cs,ToUnixTimestamp,The following statement contains a magic number: return (long) ((ToDateTime() - new DateTime(1970' 1' 1)).TotalSeconds);
Magic Number,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoOpen,The following statement contains a magic number: if (FileName.StartsWith("/sce_"))              {                  int Sector = 0' Size = 0;                  var Parts = FileName.Substring(5).Split('_');                  foreach (var Part in Parts)                  {                      if (Part.StartsWith("lbn"))                      {                          var Number = Part.Substring(3);                          Sector = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else if (Part.StartsWith("size"))                      {                          var Number = Part.Substring(4);                          Size = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else                      {                          throw(new NotImplementedException("Can't handle special filename '" + FileName + "' part '" +                                                            Part + "'"));                      }                      //Console.WriteLine(Part);                  }                  //Console.WriteLine("SPECIAL({0}' {1})"' lbn' size);                  //Console.WriteLine("SPECIAL!!!!!!!!!!!!!!!!!!!!");                  HleIoDrvFileArg.FileArgument = new IsoFileArgument()                  {                      IsoNode = null'                      StartSector = Sector'                      Size = Size'                      Stream = Iso.Stream.SliceWithLength(Sector * IsoFile.SectorSize' Size)'                  };                  return 0;              }
Magic Number,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoOpen,The following statement contains a magic number: if (FileName.StartsWith("/sce_"))              {                  int Sector = 0' Size = 0;                  var Parts = FileName.Substring(5).Split('_');                  foreach (var Part in Parts)                  {                      if (Part.StartsWith("lbn"))                      {                          var Number = Part.Substring(3);                          Sector = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else if (Part.StartsWith("size"))                      {                          var Number = Part.Substring(4);                          Size = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else                      {                          throw(new NotImplementedException("Can't handle special filename '" + FileName + "' part '" +                                                            Part + "'"));                      }                      //Console.WriteLine(Part);                  }                  //Console.WriteLine("SPECIAL({0}' {1})"' lbn' size);                  //Console.WriteLine("SPECIAL!!!!!!!!!!!!!!!!!!!!");                  HleIoDrvFileArg.FileArgument = new IsoFileArgument()                  {                      IsoNode = null'                      StartSector = Sector'                      Size = Size'                      Stream = Iso.Stream.SliceWithLength(Sector * IsoFile.SectorSize' Size)'                  };                  return 0;              }
Magic Number,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoOpen,The following statement contains a magic number: if (FileName.StartsWith("/sce_"))              {                  int Sector = 0' Size = 0;                  var Parts = FileName.Substring(5).Split('_');                  foreach (var Part in Parts)                  {                      if (Part.StartsWith("lbn"))                      {                          var Number = Part.Substring(3);                          Sector = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else if (Part.StartsWith("size"))                      {                          var Number = Part.Substring(4);                          Size = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else                      {                          throw(new NotImplementedException("Can't handle special filename '" + FileName + "' part '" +                                                            Part + "'"));                      }                      //Console.WriteLine(Part);                  }                  //Console.WriteLine("SPECIAL({0}' {1})"' lbn' size);                  //Console.WriteLine("SPECIAL!!!!!!!!!!!!!!!!!!!!");                  HleIoDrvFileArg.FileArgument = new IsoFileArgument()                  {                      IsoNode = null'                      StartSector = Sector'                      Size = Size'                      Stream = Iso.Stream.SliceWithLength(Sector * IsoFile.SectorSize' Size)'                  };                  return 0;              }
Magic Number,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoOpen,The following statement contains a magic number: if (FileName.StartsWith("/sce_"))              {                  int Sector = 0' Size = 0;                  var Parts = FileName.Substring(5).Split('_');                  foreach (var Part in Parts)                  {                      if (Part.StartsWith("lbn"))                      {                          var Number = Part.Substring(3);                          Sector = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else if (Part.StartsWith("size"))                      {                          var Number = Part.Substring(4);                          Size = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else                      {                          throw(new NotImplementedException("Can't handle special filename '" + FileName + "' part '" +                                                            Part + "'"));                      }                      //Console.WriteLine(Part);                  }                  //Console.WriteLine("SPECIAL({0}' {1})"' lbn' size);                  //Console.WriteLine("SPECIAL!!!!!!!!!!!!!!!!!!!!");                  HleIoDrvFileArg.FileArgument = new IsoFileArgument()                  {                      IsoNode = null'                      StartSector = Sector'                      Size = Size'                      Stream = Iso.Stream.SliceWithLength(Sector * IsoFile.SectorSize' Size)'                  };                  return 0;              }
Magic Number,CSPspEmu.Hle.Vfs.Iso,HleIoDriverIso,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Iso\HleIoDriverIso.cs,IoOpen,The following statement contains a magic number: if (FileName.StartsWith("/sce_"))              {                  int Sector = 0' Size = 0;                  var Parts = FileName.Substring(5).Split('_');                  foreach (var Part in Parts)                  {                      if (Part.StartsWith("lbn"))                      {                          var Number = Part.Substring(3);                          Sector = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else if (Part.StartsWith("size"))                      {                          var Number = Part.Substring(4);                          Size = NumberUtils.ParseIntegerConstant(Number' 16);                      }                      else                      {                          throw(new NotImplementedException("Can't handle special filename '" + FileName + "' part '" +                                                            Part + "'"));                      }                      //Console.WriteLine(Part);                  }                  //Console.WriteLine("SPECIAL({0}' {1})"' lbn' size);                  //Console.WriteLine("SPECIAL!!!!!!!!!!!!!!!!!!!!");                  HleIoDrvFileArg.FileArgument = new IsoFileArgument()                  {                      IsoNode = null'                      StartSector = Sector'                      Size = Size'                      Stream = Iso.Stream.SliceWithLength(Sector * IsoFile.SectorSize' Size)'                  };                  return 0;              }
Magic Number,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,ConvertFileSystemInfoToHleIoDirent,The following statement contains a magic number: {                  if (DirectoryInfo != null)                  {                      HleIoDirent.Stat.Size = 4096;                      HleIoDirent.Stat.Mode = (SceMode) 4605;                      HleIoDirent.Stat.Attributes = IOFileModes.Directory;                  }                  else                  {                      HleIoDirent.Stat.Size = FileInfo.Length;                      HleIoDirent.Stat.Mode = (SceMode) 8628;                      HleIoDirent.Stat.Attributes = IOFileModes.File;                  }                  HleIoDirent.Name = FileSystemInfo.Name.ToLower();                    HleIoDirent.Stat.TimeCreation = ScePspDateTime.FromDateTime(FileSystemInfo.CreationTime);                  HleIoDirent.Stat.TimeLastAccess = ScePspDateTime.FromDateTime(FileSystemInfo.LastAccessTime);                  HleIoDirent.Stat.TimeLastModification = ScePspDateTime.FromDateTime(FileSystemInfo.LastWriteTime);                    HleIoDirent.Stat.DeviceDependentData0 = 10;              }
Magic Number,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,ConvertFileSystemInfoToHleIoDirent,The following statement contains a magic number: {                  if (DirectoryInfo != null)                  {                      HleIoDirent.Stat.Size = 4096;                      HleIoDirent.Stat.Mode = (SceMode) 4605;                      HleIoDirent.Stat.Attributes = IOFileModes.Directory;                  }                  else                  {                      HleIoDirent.Stat.Size = FileInfo.Length;                      HleIoDirent.Stat.Mode = (SceMode) 8628;                      HleIoDirent.Stat.Attributes = IOFileModes.File;                  }                  HleIoDirent.Name = FileSystemInfo.Name.ToLower();                    HleIoDirent.Stat.TimeCreation = ScePspDateTime.FromDateTime(FileSystemInfo.CreationTime);                  HleIoDirent.Stat.TimeLastAccess = ScePspDateTime.FromDateTime(FileSystemInfo.LastAccessTime);                  HleIoDirent.Stat.TimeLastModification = ScePspDateTime.FromDateTime(FileSystemInfo.LastWriteTime);                    HleIoDirent.Stat.DeviceDependentData0 = 10;              }
Magic Number,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,ConvertFileSystemInfoToHleIoDirent,The following statement contains a magic number: {                  if (DirectoryInfo != null)                  {                      HleIoDirent.Stat.Size = 4096;                      HleIoDirent.Stat.Mode = (SceMode) 4605;                      HleIoDirent.Stat.Attributes = IOFileModes.Directory;                  }                  else                  {                      HleIoDirent.Stat.Size = FileInfo.Length;                      HleIoDirent.Stat.Mode = (SceMode) 8628;                      HleIoDirent.Stat.Attributes = IOFileModes.File;                  }                  HleIoDirent.Name = FileSystemInfo.Name.ToLower();                    HleIoDirent.Stat.TimeCreation = ScePspDateTime.FromDateTime(FileSystemInfo.CreationTime);                  HleIoDirent.Stat.TimeLastAccess = ScePspDateTime.FromDateTime(FileSystemInfo.LastAccessTime);                  HleIoDirent.Stat.TimeLastModification = ScePspDateTime.FromDateTime(FileSystemInfo.LastWriteTime);                    HleIoDirent.Stat.DeviceDependentData0 = 10;              }
Magic Number,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,ConvertFileSystemInfoToHleIoDirent,The following statement contains a magic number: {                  if (DirectoryInfo != null)                  {                      HleIoDirent.Stat.Size = 4096;                      HleIoDirent.Stat.Mode = (SceMode) 4605;                      HleIoDirent.Stat.Attributes = IOFileModes.Directory;                  }                  else                  {                      HleIoDirent.Stat.Size = FileInfo.Length;                      HleIoDirent.Stat.Mode = (SceMode) 8628;                      HleIoDirent.Stat.Attributes = IOFileModes.File;                  }                  HleIoDirent.Name = FileSystemInfo.Name.ToLower();                    HleIoDirent.Stat.TimeCreation = ScePspDateTime.FromDateTime(FileSystemInfo.CreationTime);                  HleIoDirent.Stat.TimeLastAccess = ScePspDateTime.FromDateTime(FileSystemInfo.LastAccessTime);                  HleIoDirent.Stat.TimeLastModification = ScePspDateTime.FromDateTime(FileSystemInfo.LastWriteTime);                    HleIoDirent.Stat.DeviceDependentData0 = 10;              }
Missing Default,CSPspEmu.Hle.Vfs.Local,HleIoDriverLocalFileSystem,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Vfs\Local\HleIoDriverLocalFileSystem.cs,IoLseek,The following switch statement is missing a default case: switch (Whence)              {                  case SeekAnchor.Set:                      FileStream.Position = Offset;                      break;                  case SeekAnchor.Cursor:                      FileStream.Position = FileStream.Position + Offset;                      break;                  case SeekAnchor.End:                      FileStream.Position = FileStream.Length + Offset;                      break;              }
