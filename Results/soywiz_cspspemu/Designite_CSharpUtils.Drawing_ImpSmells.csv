Implementation smell,Namespace,Class,File,Method,Description
Complex Method,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,GetDistanceMap,Cyclomatic complexity of the method is 18
Long Parameter List,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,TransferChannelsDataLinear,The method has 5 parameters. Parameters: rectangle' bitmap' newData' direction' channels
Long Parameter List,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,TransferChannelsDataLinear,The method has 5 parameters. Parameters: rectangle' bitmap' newDataPtr' direction' channels
Long Parameter List,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,TransferChannelsDataInterleaved,The method has 5 parameters. Parameters: rectangle' bitmap' newDataPtr' direction' channels
Long Parameter List,CSharpUtils.Drawing,ColorFormat,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorFormat.cs,Decode,The method has 5 parameters. Parameters: data' r' g' b' a
Long Parameter List,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,InternalAdd,The method has 5 parameters. Parameters: r' g' b' a' colors
Long Parameter List,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,MixComponent,The method has 5 parameters. Parameters: color1' color2' weightSum' weight1' weight2
Long Parameter List,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Mix,The method has 5 parameters. Parameters: color1' color2' weightSum' weight1' weight2
Long Parameter List,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,DrawGlow,The method has 6 parameters. Parameters: bitmap' distanceMap' glowDistance' glowColor' min' max
Long Parameter List,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,DrawGlow,The method has 5 parameters. Parameters: bitmap' distanceMap' glowDistance' glowColor' function
Long Identifier,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,CompareBitmaps,The length of the parameter pixelTotalDifferencePercentage is 30.
Long Identifier,CSharpUtils.Drawing,CompareResult,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,,The length of the parameter PixelTotalDifferencePercentage is 30.
Magic Number,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,CompareBitmaps,The following statement contains a magic number: for (var y = 0; y < referenceBitmap.Height; y++)              {                  for (var x = 0; x < referenceBitmap.Width; x++)                  {                      var colorReference = referenceBitmap.GetPixel(x' y);                      var colorOutput = outputBitmap.GetPixel(x' y);                      var difference3 = (                          Math.Abs(colorOutput.R - colorReference.R) +                          Math.Abs(colorOutput.G - colorReference.G) +                          Math.Abs(colorOutput.B - colorReference.B)                      );                      compareResult.PixelTotalDifference += difference3;                      if (difference3 > 6)                      {                          compareResult.DifferentPixelCount++;                      }                      compareResult.TotalPixelCount++;                  }              }
Magic Number,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,CompareBitmaps,The following statement contains a magic number: var pixelTotalDifferencePercentage = (double) compareResult.DifferentPixelCount * 100 /                                                   compareResult.TotalPixelCount;
Magic Number,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,GetColorPalette,The following statement contains a magic number: if (nColors > 2) bitscolordepth = PixelFormat.Format4bppIndexed;
Magic Number,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,GetColorPalette,The following statement contains a magic number: if (nColors > 16) bitscolordepth = PixelFormat.Format8bppIndexed;
Magic Number,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,TransferChannelsDataLinear,The following statement contains a magic number: foreach (var channel in channels)              {                  if (channel != BitmapChannel.Indexed)                  {                      numberOfChannels = 4;                      break;                  }              }
Magic Number,CSharpUtils.Drawing,BitmapUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\BitmapUtils.cs,TransferChannelsDataInterleaved,The following statement contains a magic number: foreach (var channel in channels)              {                  if (channel != BitmapChannel.Indexed)                  {                      numberOfChannels = 4;                      break;                  }              }
Magic Number,CSharpUtils.Drawing,Component,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorFormat.cs,InsertFromByte,The following statement contains a magic number: Insert(ref Base' value * Mask / 255);
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Average,The following statement contains a magic number: return Color.FromArgb(                  (byte) ((color1.A + color2.A) / 2)'                  (byte) ((color1.R + color2.R) / 2)'                  (byte) ((color1.G + color2.G) / 2)'                  (byte) ((color1.B + color2.B) / 2)              );
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Average,The following statement contains a magic number: return Color.FromArgb(                  (byte) ((color1.A + color2.A) / 2)'                  (byte) ((color1.R + color2.R) / 2)'                  (byte) ((color1.G + color2.G) / 2)'                  (byte) ((color1.B + color2.B) / 2)              );
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Average,The following statement contains a magic number: return Color.FromArgb(                  (byte) ((color1.A + color2.A) / 2)'                  (byte) ((color1.R + color2.R) / 2)'                  (byte) ((color1.G + color2.G) / 2)'                  (byte) ((color1.B + color2.B) / 2)              );
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Average,The following statement contains a magic number: return Color.FromArgb(                  (byte) ((color1.A + color2.A) / 2)'                  (byte) ((color1.R + color2.R) / 2)'                  (byte) ((color1.G + color2.G) / 2)'                  (byte) ((color1.B + color2.B) / 2)              );
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Encode,The following statement contains a magic number: return Color.FromArgb(                  (int) (BitUtils.ExtractScaled(value' colorFormat.Alpha.Offset' colorFormat.Alpha.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Red.Offset' colorFormat.Red.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Green.Offset' colorFormat.Green.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Blue.Offset' colorFormat.Blue.Size' 255))              );
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Encode,The following statement contains a magic number: return Color.FromArgb(                  (int) (BitUtils.ExtractScaled(value' colorFormat.Alpha.Offset' colorFormat.Alpha.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Red.Offset' colorFormat.Red.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Green.Offset' colorFormat.Green.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Blue.Offset' colorFormat.Blue.Size' 255))              );
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Encode,The following statement contains a magic number: return Color.FromArgb(                  (int) (BitUtils.ExtractScaled(value' colorFormat.Alpha.Offset' colorFormat.Alpha.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Red.Offset' colorFormat.Red.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Green.Offset' colorFormat.Green.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Blue.Offset' colorFormat.Blue.Size' 255))              );
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,Encode,The following statement contains a magic number: return Color.FromArgb(                  (int) (BitUtils.ExtractScaled(value' colorFormat.Alpha.Offset' colorFormat.Alpha.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Red.Offset' colorFormat.Red.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Green.Offset' colorFormat.Green.Size' 255))'                  (int) (BitUtils.ExtractScaled(value' colorFormat.Blue.Offset' colorFormat.Blue.Size' 255))              );
Magic Number,CSharpUtils.Drawing,ColorUtils,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\ColorUtils.cs,MixComponent,The following statement contains a magic number: return MathUtils.FastClamp((color1 * weight1 + color2 * weight2) / weightSum' 0' 255);
Magic Number,CSharpUtils.Drawing,ArgbRev,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\RGBA.cs,ArgbRev,The following statement contains a magic number: A = (byte) MathUtils.FastClamp(a' 0' 255);
Magic Number,CSharpUtils.Drawing,ArgbRev,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\RGBA.cs,ArgbRev,The following statement contains a magic number: R = (byte) MathUtils.FastClamp(r' 0' 255);
Magic Number,CSharpUtils.Drawing,ArgbRev,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\RGBA.cs,ArgbRev,The following statement contains a magic number: G = (byte) MathUtils.FastClamp(g' 0' 255);
Magic Number,CSharpUtils.Drawing,ArgbRev,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\RGBA.cs,ArgbRev,The following statement contains a magic number: B = (byte) MathUtils.FastClamp(b' 0' 255);
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,GetMask,The following statement contains a magic number: bitmap.LockBitsUnlock(PixelFormat.Format32bppArgb' bitmapData =>              {                  for (var y = 0; y < height; y++)                  {                      var ptr = ((byte*) bitmapData.Scan0.ToPointer()) + bitmapData.Stride * y;                      ptr += 3;                      for (var x = 0; x < width; x++)                      {                          mask[x' y] = (*ptr >= alphaThresold);                          ptr += 4;                          //Console.Write(Mask[x' y] ? 1 : 0);                      }                      //Console.WriteLine("");                  }              });
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,GetMask,The following statement contains a magic number: bitmap.LockBitsUnlock(PixelFormat.Format32bppArgb' bitmapData =>              {                  for (var y = 0; y < height; y++)                  {                      var ptr = ((byte*) bitmapData.Scan0.ToPointer()) + bitmapData.Stride * y;                      ptr += 3;                      for (var x = 0; x < width; x++)                      {                          mask[x' y] = (*ptr >= alphaThresold);                          ptr += 4;                          //Console.Write(Mask[x' y] ? 1 : 0);                      }                      //Console.WriteLine("");                  }              });
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,GetDistanceMap,The following statement contains a magic number: for (var y = 0; y < height; y++)              {                  for (var x = 0; x < width; x++)                  {                      distanceMap[x' y] = new DistanceEntry(1000' 1000);                  }              }
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,GetDistanceMap,The following statement contains a magic number: for (var y = 0; y < height; y++)              {                  for (var x = 0; x < width; x++)                  {                      distanceMap[x' y] = new DistanceEntry(1000' 1000);                  }              }
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,GetDistanceMap,The following statement contains a magic number: foreach (var passIterator in new[] {pass1' pass2})                  //foreach (var PassIterator in new[] { Pass1 })              {                  for (var n = 0; n < row.Length; n++) row[n] = new DistanceEntry(1000' 1000);                    //for (int y = 0; y < Height; y++)                  foreach (var y in passIterator)                  {                      for (var x = 0; x < width; x++)                      {                          if (!mask[x' y]) continue;                            // Inner                          row[x] = new DistanceEntry(0' 0);                            // Left edge                          if (x > 0 && !mask[x - 1' y])                          {                              int distanceX = 0' DistanceY = 0;                              for (int x2 = x - 1; x2 >= 0; x2--)                              {                                  if (mask[x2' y]) break;                                  distanceX--;                                  row[x2].SetDistanceIfLower(new DistanceEntry(distanceX' DistanceY));                              }                          }                          // Right edge                          if (x < width - 1 && !mask[x + 1' y])                          {                              int distanceX = 0' DistanceY = 0;                              for (int x2 = x + 1; x2 < width; x2++)                              {                                  if (mask[x2' y]) break;                                  distanceX++;                                  row[x2].SetDistanceIfLower(new DistanceEntry(distanceX' DistanceY));                              }                          }                      }                      for (var x = 0; x < width; x++)                      {                          distanceMap[x' y].SetDistanceIfLower(row[x]);                          row[x] = distanceMap[x' y];                          //Console.Write("{0}"' Row[x].GetChar());                      }  #if true                      for (var x = width - 2; x >= 0; x--)                      {                          var right = distanceMap[x + 1' y];                          distanceMap[x' y].SetDistanceIfLower(new DistanceEntry(right.DistanceX - 1' right.DistanceY));                          row[x] = distanceMap[x' y];                      }                      for (var x = 1; x < width; x++)                      {                          var right = distanceMap[x - 1' y];                          distanceMap[x' y].SetDistanceIfLower(new DistanceEntry(right.DistanceX + 1' right.DistanceY));                          row[x] = distanceMap[x' y];                      }  #endif                      //Console.WriteLine("");                        for (int x = 0; x < width; x++)                      {                          row[x].DistanceY++;                          //Console.Write("{0}"' Row[x].GetChar());                      }                  }              }
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,GetDistanceMap,The following statement contains a magic number: foreach (var passIterator in new[] {pass1' pass2})                  //foreach (var PassIterator in new[] { Pass1 })              {                  for (var n = 0; n < row.Length; n++) row[n] = new DistanceEntry(1000' 1000);                    //for (int y = 0; y < Height; y++)                  foreach (var y in passIterator)                  {                      for (var x = 0; x < width; x++)                      {                          if (!mask[x' y]) continue;                            // Inner                          row[x] = new DistanceEntry(0' 0);                            // Left edge                          if (x > 0 && !mask[x - 1' y])                          {                              int distanceX = 0' DistanceY = 0;                              for (int x2 = x - 1; x2 >= 0; x2--)                              {                                  if (mask[x2' y]) break;                                  distanceX--;                                  row[x2].SetDistanceIfLower(new DistanceEntry(distanceX' DistanceY));                              }                          }                          // Right edge                          if (x < width - 1 && !mask[x + 1' y])                          {                              int distanceX = 0' DistanceY = 0;                              for (int x2 = x + 1; x2 < width; x2++)                              {                                  if (mask[x2' y]) break;                                  distanceX++;                                  row[x2].SetDistanceIfLower(new DistanceEntry(distanceX' DistanceY));                              }                          }                      }                      for (var x = 0; x < width; x++)                      {                          distanceMap[x' y].SetDistanceIfLower(row[x]);                          row[x] = distanceMap[x' y];                          //Console.Write("{0}"' Row[x].GetChar());                      }  #if true                      for (var x = width - 2; x >= 0; x--)                      {                          var right = distanceMap[x + 1' y];                          distanceMap[x' y].SetDistanceIfLower(new DistanceEntry(right.DistanceX - 1' right.DistanceY));                          row[x] = distanceMap[x' y];                      }                      for (var x = 1; x < width; x++)                      {                          var right = distanceMap[x - 1' y];                          distanceMap[x' y].SetDistanceIfLower(new DistanceEntry(right.DistanceX + 1' right.DistanceY));                          row[x] = distanceMap[x' y];                      }  #endif                      //Console.WriteLine("");                        for (int x = 0; x < width; x++)                      {                          row[x].DistanceY++;                          //Console.Write("{0}"' Row[x].GetChar());                      }                  }              }
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,GetDistanceMap,The following statement contains a magic number: foreach (var passIterator in new[] {pass1' pass2})                  //foreach (var PassIterator in new[] { Pass1 })              {                  for (var n = 0; n < row.Length; n++) row[n] = new DistanceEntry(1000' 1000);                    //for (int y = 0; y < Height; y++)                  foreach (var y in passIterator)                  {                      for (var x = 0; x < width; x++)                      {                          if (!mask[x' y]) continue;                            // Inner                          row[x] = new DistanceEntry(0' 0);                            // Left edge                          if (x > 0 && !mask[x - 1' y])                          {                              int distanceX = 0' DistanceY = 0;                              for (int x2 = x - 1; x2 >= 0; x2--)                              {                                  if (mask[x2' y]) break;                                  distanceX--;                                  row[x2].SetDistanceIfLower(new DistanceEntry(distanceX' DistanceY));                              }                          }                          // Right edge                          if (x < width - 1 && !mask[x + 1' y])                          {                              int distanceX = 0' DistanceY = 0;                              for (int x2 = x + 1; x2 < width; x2++)                              {                                  if (mask[x2' y]) break;                                  distanceX++;                                  row[x2].SetDistanceIfLower(new DistanceEntry(distanceX' DistanceY));                              }                          }                      }                      for (var x = 0; x < width; x++)                      {                          distanceMap[x' y].SetDistanceIfLower(row[x]);                          row[x] = distanceMap[x' y];                          //Console.Write("{0}"' Row[x].GetChar());                      }  #if true                      for (var x = width - 2; x >= 0; x--)                      {                          var right = distanceMap[x + 1' y];                          distanceMap[x' y].SetDistanceIfLower(new DistanceEntry(right.DistanceX - 1' right.DistanceY));                          row[x] = distanceMap[x' y];                      }                      for (var x = 1; x < width; x++)                      {                          var right = distanceMap[x - 1' y];                          distanceMap[x' y].SetDistanceIfLower(new DistanceEntry(right.DistanceX + 1' right.DistanceY));                          row[x] = distanceMap[x' y];                      }  #endif                      //Console.WriteLine("");                        for (int x = 0; x < width; x++)                      {                          row[x].DistanceY++;                          //Console.Write("{0}"' Row[x].GetChar());                      }                  }              }
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,BitmapFromDistanceMap,The following statement contains a magic number: bitmap.LockBitsUnlock(PixelFormat.Format32bppArgb' bitmapData =>              {                  for (var y = 0; y < height; y++)                  {                      var ptr = ((byte*) bitmapData.Scan0.ToPointer()) + bitmapData.Stride * y;                      for (var x = 0; x < width; x++)                      {                          var distance = (byte) MathUtils.FastClamp((int) (distanceMap[x' y].Distance * 4)' 0' 255);                          *ptr++ = distance;                          *ptr++ = distance;                          *ptr++ = distance;                          *ptr++ = 0xFF;                      }                  }              });
Magic Number,CSharpUtils.Drawing.Distance,DistanceMap,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Distance\DistanceMap.cs,BitmapFromDistanceMap,The following statement contains a magic number: bitmap.LockBitsUnlock(PixelFormat.Format32bppArgb' bitmapData =>              {                  for (var y = 0; y < height; y++)                  {                      var ptr = ((byte*) bitmapData.Scan0.ToPointer()) + bitmapData.Stride * y;                      for (var x = 0; x < width; x++)                      {                          var distance = (byte) MathUtils.FastClamp((int) (distanceMap[x' y].Distance * 4)' 0' 255);                          *ptr++ = distance;                          *ptr++ = distance;                          *ptr++ = distance;                          *ptr++ = 0xFF;                      }                  }              });
Magic Number,CSharpUtils.Drawing.Extensions,BitmapExtension,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Extensions\BitmapExtension.cs,GetChannelsDataInterleaved,The following statement contains a magic number: bitmap.LockBitsUnlock(PixelFormat.Format32bppArgb' bitmapData =>              {                  var startPtr = ((byte*) bitmapData.Scan0.ToPointer());                  fixed (byte* startBufferPtr = &buffer[0])                  {                      var currentChannel = 0;                      foreach (var channel in channels)                      {                          var ptr = startPtr + (int) channel;                          var bufferPtr = startBufferPtr + currentChannel;                          for (var n = currentChannel; n < bufferSize; n += nChannels' bufferPtr += nChannels' ptr += 4)                          {                              *bufferPtr = *ptr;                          }                          currentChannel++;                      }                  }              });
Magic Number,CSharpUtils.Drawing.Extensions,BitmapExtension,C:\repos\soywiz_cspspemu\Libraries\CSharpUtils\CSharpUtils\CSharpUtils.Drawing\Extensions\BitmapExtension.cs,SetChannelsDataInterleaved,The following statement contains a magic number: bitmap.LockBitsUnlock(PixelFormat.Format32bppArgb' bitmapData =>              {                  var startPtr = ((byte*) bitmapData.Scan0.ToPointer());                  fixed (byte* startBufferPtr = &buffer[0])                  {                      var currentChannel = 0;                      foreach (var channel in channels)                      {                          var ptr = startPtr + (int) channel;                          var bufferPtr = startBufferPtr + currentChannel;                          for (var n = currentChannel; n < bufferSize; n += nChannels' bufferPtr += nChannels' ptr += 4)                          {                              *ptr = *bufferPtr;                          }                          currentChannel++;                      }                  }              });
