Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode,The method has 13 parameters. Parameters: pixelFormat' input' output' width' height' palette' paletteType' paletteCount' paletteStart' paletteShift' paletteMask' strideWidth' ignoreAlpha
Long Parameter List,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode,The method has 6 parameters. Parameters: guPixelFormat' input' output' bufferWidth' width' height
Long Parameter List,CSPspEmu.Utils.Utils,PspBitmap,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PspBitmap.cs,PspBitmap,The method has 5 parameters. Parameters: pixelFormat' width' height' address' bytesPerLine
Long Statement,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The length of the statement  "                //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType); " is 153.
Long Statement,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode,The length of the statement  "            //DecoderCallbackTable[PixelFormatInt](Input' Output' PixelCount' Width' Palette' PaletteType' PaletteCount' PaletteStart' PaletteShift' PaletteMask); " is 150.
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,CStringFormater,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\CStringFormater.cs,Sprintf,The following statement contains a magic number: return FormatRegex.Replace(format' (match) =>              {                  var pPad = match.Groups[1].Value;                  var pJustify = match.Groups[2].Value;                  var pMinLength = match.Groups[3].Value;                  var pPrecision = match.Groups[4].Value;                  var pType = match.Groups[5].Value;                    //Console.WriteLine("Match: pPad='{0}'' pJustify='{1}'' pMinLength='{2}'' pPrecision='{3}'' pType='{4}'"' pPad' pJustify' pMinLength' pPrecision' pType);                    string value;                  var padChar = pPad.Length > 0 ? pPad[0] : ' ';                  var justify = pJustify.Length > 0;                  var minLength = (pMinLength.Length > 0) ? int.Parse(pMinLength) : 0;                    switch (pType)                  {                      case "%":                          value = "%";                          break;                      case "b":                          value = Convert.ToString(arguments.LoadInteger()' 2);                          break;                      case "c":                          value = "" + (char) arguments.LoadInteger();                          break;                      case "d":                          value = Convert.ToString(arguments.LoadInteger()' 10);                          break;                      case "u":                          value = Convert.ToString((uint) arguments.LoadInteger()' 10);                          break;                      case "f":                          value = Convert.ToString(arguments.LoadFloat()' CultureInfo.DefaultThreadCurrentCulture);                          break;                      case "o":                          value = Convert.ToString((uint) arguments.LoadInteger()' 8);                          break;                      case "s":                          value = arguments.LoadString();                          break;                      case "x":                      case "X":                          value = Convert.ToString((uint) arguments.LoadInteger()' 16);                          value = (pType == "x") ? value.ToLowerInvariant() : value.ToUpperInvariant();                          break;                      default:                          throw(new NotImplementedException());                  }                    if (value.Length < minLength)                  {                      value = justify                              ? value.PadRight(minLength' padChar)                              : value.PadLeft(minLength' padChar)                          ;                  }                    return value;              });
Magic Number,CSPspEmu.Utils,Hashing,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Hashing.cs,FastHash,The following statement contains a magic number: if (count > 4 * 2048 * 2048)              {                  Logger.Error("FastHash too big count!");                  return startHash;              }
Magic Number,CSPspEmu.Utils,Hashing,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Hashing.cs,FastHash,The following statement contains a magic number: if (count > 4 * 2048 * 2048)              {                  Logger.Error("FastHash too big count!");                  return startHash;              }
Magic Number,CSPspEmu.Utils,Hashing,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Hashing.cs,FastHash,The following statement contains a magic number: if (count > 4 * 2048 * 2048)              {                  Logger.Error("FastHash too big count!");                  return startHash;              }
Magic Number,CSPspEmu.Utils,Hashing,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Hashing.cs,FastHash_64,The following statement contains a magic number: while (count >= 8)              {                  hash += (*(ulong*) pointer) + (ulong) (count << 31);                  pointer += 8;                  count -= 8;              }
Magic Number,CSPspEmu.Utils,Hashing,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Hashing.cs,FastHash_64,The following statement contains a magic number: while (count >= 8)              {                  hash += (*(ulong*) pointer) + (ulong) (count << 31);                  pointer += 8;                  count -= 8;              }
Magic Number,CSPspEmu.Utils,Hashing,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Hashing.cs,FastHash_64,The following statement contains a magic number: while (count >= 8)              {                  hash += (*(ulong*) pointer) + (ulong) (count << 31);                  pointer += 8;                  count -= 8;              }
Magic Number,CSPspEmu.Utils,Hashing,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Hashing.cs,FastHash_64,The following statement contains a magic number: while (count >= 8)              {                  hash += (*(ulong*) pointer) + (ulong) (count << 31);                  pointer += 8;                  count -= 8;              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,GetPixelsBits,The following statement contains a magic number: return (int) (Sizes[(int) pixelFormat] * 8);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: var colors = new OutputPixel[4];
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT5,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt5Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        // Create Alpha Lookup                      var alphaLookup = new byte[8];                      var alphas = (ushort) (block.Alpha >> 48);                      var alpha0 = (byte) ((alphas >> 0) & 0xFF);                      var alpha1 = (byte) ((alphas >> 8) & 0xFF);                        alphaLookup[0] = alpha0;                      alphaLookup[1] = alpha1;                      if (alpha0 > alpha1)                      {                          alphaLookup[2] = (byte) ((6 * alpha0 + alpha1) / 7);                          alphaLookup[3] = (byte) ((5 * alpha0 + 2 * alpha1) / 7);                          alphaLookup[4] = (byte) ((4 * alpha0 + 3 * alpha1) / 7);                          alphaLookup[5] = (byte) ((3 * alpha0 + 4 * alpha1) / 7);                          alphaLookup[6] = (byte) ((2 * alpha0 + 5 * alpha1) / 7);                          alphaLookup[7] = (byte) ((alpha0 + 6 * alpha1) / 7);                      }                      else                      {                          alphaLookup[2] = (byte) ((4 * alpha0 + alpha1) / 5);                          alphaLookup[3] = (byte) ((3 * alpha0 + 2 * alpha1) / 5);                          alphaLookup[4] = (byte) ((2 * alpha0 + 3 * alpha1) / 5);                          alphaLookup[5] = (byte) ((alpha0 + 4 * alpha1) / 5);                          alphaLookup[6] = (byte) (0x00);                          alphaLookup[7] = (byte) (0xFF);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = alphaLookup[((block.Alpha >> (3 * no)) & 0x7)];                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = x + x2;                              var ry = y + y2;                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = alpha;                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: var colors = new OutputPixel[4];
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT3,The following statement contains a magic number: for (var y = 0; y < _height; y += 4)              {                  for (var x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt3Block*) _inputByte)[ni];                      colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                      colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                          (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var alpha = (block.Alpha >> (4 * no)) & 0xF;                              var color = (block.ColorLookup >> (2 * no)) & 0x3;                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                              _output[n].A = (byte) ((alpha * 0xFF) / 0xF);                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: var colors = new OutputPixel[4];
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_COMPRESSED_DXT1,The following statement contains a magic number: for (int y = 0' ni = 0; y < _height; y += 4)              {                  for (int x = 0; x < _width; x += 4' ni++)                  {                      var block = ((Dxt1Block*) _inputByte)[ni];                        colors[0] = Decode_RGBA_5650_Pixel(block.Color0)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                      colors[1] = Decode_RGBA_5650_Pixel(block.Color1)                          .Transform((r' g' b' a) => OutputPixel.FromRgba(b' g' r' a));                        if (block.Color0 > block.Color1)                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 2) / 3) + ((b * 1) / 3)));                          colors[3] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 3) + ((b * 2) / 3)));                      }                      else                      {                          colors[2] = OutputPixel.OperationPerComponent(colors[0]' colors[1]'                              (a' b) => (byte) (((a * 1) / 2) + ((b * 1) / 2)));                          colors[3] = OutputPixel.FromRgba(0' 0' 0' 0);                      }                        var no = 0;                      for (var y2 = 0; y2 < 4; y2++)                      {                          for (var x2 = 0; x2 < 4; x2++' no++)                          {                              var color = ((block.ColorLookup >> (2 * no)) & 0x3);                                var rx = (x + x2);                              var ry = (y + y2);                              var n = ry * _width + rx;                                _output[n] = colors[color];                          }                      }                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_PALETTE_T8,The following statement contains a magic number: var paletteSize = 256;
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_PALETTE_T4,The following statement contains a magic number: const int paletteSize = 256;
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_PALETTE_T4,The following statement contains a magic number: for (var n = 0; n < 16; n++)              {                  translate[n] = ((_paletteStart + n) >> _paletteShift) & _paletteMask;                  //Console.WriteLine(PalettePixels[Translate[n]]);              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_PALETTE_T4,The following statement contains a magic number: for (int y = 0' n = 0; y < _height; y++)              {                  var inputRow = &_inputByte[y * _strideWidth];                  for (var x = 0; x < _width / 2; x++' n++)                  {                      var value = inputRow[x];                      _output[n * 2 + 0] = palettePixels[translate[(value >> 0) & 0xF]];                      _output[n * 2 + 1] = palettePixels[translate[(value >> 4) & 0xF]];                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_PALETTE_T4,The following statement contains a magic number: for (int y = 0' n = 0; y < _height; y++)              {                  var inputRow = &_inputByte[y * _strideWidth];                  for (var x = 0; x < _width / 2; x++' n++)                  {                      var value = inputRow[x];                      _output[n * 2 + 0] = palettePixels[translate[(value >> 0) & 0xF]];                      _output[n * 2 + 1] = palettePixels[translate[(value >> 4) & 0xF]];                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_PALETTE_T4,The following statement contains a magic number: for (int y = 0' n = 0; y < _height; y++)              {                  var inputRow = &_inputByte[y * _strideWidth];                  for (var x = 0; x < _width / 2; x++' n++)                  {                      var value = inputRow[x];                      _output[n * 2 + 0] = palettePixels[translate[(value >> 0) & 0xF]];                      _output[n * 2 + 1] = palettePixels[translate[(value >> 4) & 0xF]];                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_PALETTE_T4,The following statement contains a magic number: for (int y = 0' n = 0; y < _height; y++)              {                  var inputRow = &_inputByte[y * _strideWidth];                  for (var x = 0; x < _width / 2; x++' n++)                  {                      var value = inputRow[x];                      _output[n * 2 + 0] = palettePixels[translate[(value >> 0) & 0xF]];                      _output[n * 2 + 1] = palettePixels[translate[(value >> 4) & 0xF]];                  }              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 0' 4' pixel.R' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 0' 4' pixel.R' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 4' 4' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 4' 4' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 4' 4' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 8' 4' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 8' 4' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 8' 4' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 12' 4' pixel.A' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 12' 4' pixel.A' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_4444_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 12' 4' pixel.A' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 0' 5' pixel.R' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 0' 5' pixel.R' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 5' 5' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 5' 5' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 5' 5' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 10' 5' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 10' 5' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 10' 5' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 15' 1' pixel.A' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5551_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 15' 1' pixel.A' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5650_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 0' 5' pixel.R' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5650_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 0' 5' pixel.R' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5650_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 5' 6' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5650_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 5' 6' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5650_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 5' 6' pixel.G' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5650_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 11' 5' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5650_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 11' 5' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Encode_RGBA_5650_Pixel,The following statement contains a magic number: BitUtils.InsertScaled(ref Out' 11' 5' pixel.B' 255);
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_4444_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 4' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 4' 4' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 8' 4' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 12' 4' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5551_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 5' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 10' 5' 255)'                  A = (byte) BitUtils.ExtractScaled(value' 15' 1' 255)'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5650_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 6' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 11' 5' 255)'                  A = 0xFF'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5650_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 6' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 11' 5' 255)'                  A = 0xFF'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5650_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 6' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 11' 5' 255)'                  A = 0xFF'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5650_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 6' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 11' 5' 255)'                  A = 0xFF'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5650_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 6' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 11' 5' 255)'                  A = 0xFF'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5650_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 6' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 11' 5' 255)'                  A = 0xFF'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5650_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 6' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 11' 5' 255)'                  A = 0xFF'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Decode_RGBA_5650_Pixel,The following statement contains a magic number: return new OutputPixel              {                  R = (byte) BitUtils.ExtractScaled(value' 0' 5' 255)'                  G = (byte) BitUtils.ExtractScaled(value' 5' 6' 255)'                  B = (byte) BitUtils.ExtractScaled(value' 11' 5' 255)'                  A = 0xFF'              };
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Unswizzle,The following statement contains a magic number: var pitch = (rowWidth - 16) / 4;
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Unswizzle,The following statement contains a magic number: var pitch = (rowWidth - 16) / 4;
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Unswizzle,The following statement contains a magic number: var bxc = rowWidth / 16;
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Unswizzle,The following statement contains a magic number: var byc = textureHeight / 8;
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Unswizzle,The following statement contains a magic number: for (var by = 0; by < byc; by++)              {                  var xdest = ydest;                  for (var bx = 0; bx < bxc; bx++)                  {                      var dest = (uint*) xdest;                      for (var n = 0; n < 8; n++' dest += pitch)                      {                          *(dest++) = *(src++);                          *(dest++) = *(src++);                          *(dest++) = *(src++);                          *(dest++) = *(src++);                      }                      xdest += 16;                  }                  ydest += rowWidth * 8;              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Unswizzle,The following statement contains a magic number: for (var by = 0; by < byc; by++)              {                  var xdest = ydest;                  for (var bx = 0; bx < bxc; bx++)                  {                      var dest = (uint*) xdest;                      for (var n = 0; n < 8; n++' dest += pitch)                      {                          *(dest++) = *(src++);                          *(dest++) = *(src++);                          *(dest++) = *(src++);                          *(dest++) = *(src++);                      }                      xdest += 16;                  }                  ydest += rowWidth * 8;              }
Magic Number,CSPspEmu.Utils.Utils,PixelFormatDecoder,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PixelFormatDecoder.cs,Unswizzle,The following statement contains a magic number: for (var by = 0; by < byc; by++)              {                  var xdest = ydest;                  for (var bx = 0; bx < bxc; bx++)                  {                      var dest = (uint*) xdest;                      for (var n = 0; n < 8; n++' dest += pitch)                      {                          *(dest++) = *(src++);                          *(dest++) = *(src++);                          *(dest++) = *(src++);                          *(dest++) = *(src++);                      }                      xdest += 16;                  }                  ydest += rowWidth * 8;              }
Magic Number,CSPspEmu.Utils.Utils,PspBitmap,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PspBitmap.cs,SetPixel,The following statement contains a magic number: switch (BitsPerPixel)              {                  case 16:                      *(ushort*) (Address + position) = (ushort) value;                      break;                  case 32:                      *(uint*) (Address + position) = value;                      break;                  default: throw(new NotImplementedException());              }
Magic Number,CSPspEmu.Utils.Utils,PspBitmap,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PspBitmap.cs,SetPixel,The following statement contains a magic number: switch (BitsPerPixel)              {                  case 16:                      *(ushort*) (Address + position) = (ushort) value;                      break;                  case 32:                      *(uint*) (Address + position) = value;                      break;                  default: throw(new NotImplementedException());              }
Magic Number,CSPspEmu.Utils.Utils,PspBitmap,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PspBitmap.cs,GetPixel,The following statement contains a magic number: switch (BitsPerPixel)              {                  case 16:                      value = *(ushort*) (Address + position);                      break;                  case 32:                      value = *(uint*) (Address + position);                      break;                  default: throw (new NotImplementedException());              }
Magic Number,CSPspEmu.Utils.Utils,PspBitmap,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Utils\Utils\PspBitmap.cs,GetPixel,The following statement contains a magic number: switch (BitsPerPixel)              {                  case 16:                      value = *(ushort*) (Address + position);                      break;                  case 32:                      value = *(uint*) (Address + position);                      break;                  default: throw (new NotImplementedException());              }
