Implementation smell,Namespace,Class,File,Method,Description
Long Identifier,CSPspEmu.Core,PspPluginImpl,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\PspPluginImpl.cs,SelectWorkingPlugin,The length of the parameter AvailablePluginImplementations is 30.
Long Statement,CSPspEmu.Core.Memory,NormalPspMemory,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\Memory\NormalPspMemory.cs,PointerToPspAddressUnsafe,The length of the statement  "            if (Pointer >= &ScratchPadPtr[0] && Pointer < &ScratchPadPtr[ScratchPadSize]) return (uint)((byte*)Pointer - ScratchPadPtr); " is 124.
Long Statement,CSPspEmu.Core.Memory,NormalPspMemory,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\Memory\NormalPspMemory.cs,PointerToPspAddressUnsafe,The length of the statement  "            if (Pointer >= &FrameBufferPtr[0] && Pointer < &FrameBufferPtr[FrameBufferSize]) return (uint)((byte*)Pointer - FrameBufferPtr); " is 128.
Long Statement,CSPspEmu.Core.Memory,NormalPspMemory,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\Memory\NormalPspMemory.cs,PointerToPspAddressUnsafe,The length of the statement  "            if (Pointer >= &HardwareVectorsPtr[0] && Pointer < &HardwareVectorsPtr[MainSize]) return (uint)((byte*)Pointer - HardwareVectorsPtr); " is 133.
Long Statement,CSPspEmu.Core.Memory,NormalPspMemory,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\Memory\NormalPspMemory.cs,PointerToPspAddressUnsafe,The length of the statement  "            throw (new InvalidOperationException(String.Format("Address 0x{0:X} is not a pointer to the PspMemory"' (uint)Pointer))); " is 121.
Complex Conditional,CSPspEmu.Core.Memory,FastPspMemoryUnsafe,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\Memory\FastPspMemoryUnsafe.cs,AllocMemoryOnce,The conditional expression  "_Base == null || StaticScratchPadPtr == null || StaticFrameBufferPtr == null ||                      StaticMainPtr == null"  is complex.
Magic Number,CSPspEmu.Core.Memory,NormalPspMemory,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\Memory\NormalPspMemory.cs,PspAddressToPointerUnsafe,The following statement contains a magic number: {                  // Ignore last 3 bits (cache / kernel)                  uint Address = _Address & PspMemory.MemoryMask;                  switch (Address >> 24)                  {                      /////// hp                      case 0x00: //case 0b_00000:                      {                          if (Address < ScratchPadOffset)                          {                              break;                          }                          uint Offset = Address - ScratchPadOffset;  #if ADDITIONAL_CHECKS                          if (Offset >= ScratchPadSize) throw (new Exception($"Outside! 0x{Address:X}"));  #endif                          return &ScratchPadPtr[Address - ScratchPadOffset];                      }                      /////// hp                      case 0x04: //case 0b_00100:                      {                          uint Offset = Address - FrameBufferOffset;  #if ADDITIONAL_CHECKS                          if (Offset >= FrameBufferSize)                              throw (new Exception($"Outside! 0x{Address:X}"));  #endif                            return &FrameBufferPtr[Offset];                      }                      /////// hp                      case 0x08: //case 0b_01000:                      case 0x09: //case 0b_01001:                      case 0x0A: //case 0b_01010: // SLIM ONLY                      case 0x0B: //case 0b_01011: // SLIM ONLY                      {                          uint Offset = Address - MainOffset;  #if ADDITIONAL_CHECKS                          if (Offset >= MainSize) throw (new Exception($"Outside! 0x{Address:X}"));  #endif                            return &MainPtr[Offset];                          //return &Main[Offset];                      }                      /////// hp                      case 0x1F: //case 0b_011111                      case 0x37: //case 0b_111111: // HO IO2                      {                          //return &Vectors[Address - 0x1fc00000];                          //return HardwareVectors                          uint Offset = Address - VectorsOffset;  #if ADDITIONAL_CHECKS                          if (Offset >= VectorsSize) throw (new Exception($"Outside! 0x{Address:X}"));  #endif                          return &VectorsPtr[Offset];                      }                      case 0x1C: //case 0b_11100: // HW IO1                          break;                      default:                          break;                  }                  Console.Error.WriteLine("0x{0:X2}"' (Address >> 24));              }
Magic Number,CSPspEmu.Core.Memory,NormalPspMemory,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\Memory\NormalPspMemory.cs,PspAddressToPointerUnsafe,The following statement contains a magic number: {                  // Ignore last 3 bits (cache / kernel)                  uint Address = _Address & PspMemory.MemoryMask;                  switch (Address >> 24)                  {                      /////// hp                      case 0x00: //case 0b_00000:                      {                          if (Address < ScratchPadOffset)                          {                              break;                          }                          uint Offset = Address - ScratchPadOffset;  #if ADDITIONAL_CHECKS                          if (Offset >= ScratchPadSize) throw (new Exception($"Outside! 0x{Address:X}"));  #endif                          return &ScratchPadPtr[Address - ScratchPadOffset];                      }                      /////// hp                      case 0x04: //case 0b_00100:                      {                          uint Offset = Address - FrameBufferOffset;  #if ADDITIONAL_CHECKS                          if (Offset >= FrameBufferSize)                              throw (new Exception($"Outside! 0x{Address:X}"));  #endif                            return &FrameBufferPtr[Offset];                      }                      /////// hp                      case 0x08: //case 0b_01000:                      case 0x09: //case 0b_01001:                      case 0x0A: //case 0b_01010: // SLIM ONLY                      case 0x0B: //case 0b_01011: // SLIM ONLY                      {                          uint Offset = Address - MainOffset;  #if ADDITIONAL_CHECKS                          if (Offset >= MainSize) throw (new Exception($"Outside! 0x{Address:X}"));  #endif                            return &MainPtr[Offset];                          //return &Main[Offset];                      }                      /////// hp                      case 0x1F: //case 0b_011111                      case 0x37: //case 0b_111111: // HO IO2                      {                          //return &Vectors[Address - 0x1fc00000];                          //return HardwareVectors                          uint Offset = Address - VectorsOffset;  #if ADDITIONAL_CHECKS                          if (Offset >= VectorsSize) throw (new Exception($"Outside! 0x{Address:X}"));  #endif                          return &VectorsPtr[Offset];                      }                      case 0x1C: //case 0b_11100: // HW IO1                          break;                      default:                          break;                  }                  Console.Error.WriteLine("0x{0:X2}"' (Address >> 24));              }
Missing Default,CSPspEmu.Core,NandReader,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\NandReader.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.Current:                      Position += offset;                      break;                  case SeekOrigin.End:                      Position = Length + offset;                      break;              }
Missing Default,CSPspEmu.Core.Memory,PspMemoryStream,C:\repos\soywiz_cspspemu\Core\CSPspEmu.Core\Memory\PspMemoryStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.Current:                      Position = Position + offset;                      break;                  case SeekOrigin.End:                      Position = -offset;                      break;              }
