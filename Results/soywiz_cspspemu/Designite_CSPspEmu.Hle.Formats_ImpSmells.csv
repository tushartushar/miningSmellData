Implementation smell,Namespace,Class,File,Method,Description
Long Method,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,DecryptPrx2,The method has 108 lines of code.
Complex Method,CSPspEmu.Hle.Formats,Dax,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Dax.cs,SetStream,Cyclomatic complexity of the method is 8
Complex Method,CSPspEmu.Hle.Formats,FormatDetector,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\FormatDetector.cs,DetectSubType,Cyclomatic complexity of the method is 8
Complex Method,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,Cyclomatic complexity of the method is 11
Long Identifier,CSPspEmu.Hle.Formats,CompressedIsoProxyStream,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\CompressedIsoProxyStream.cs,,The length of the parameter SelectedCurrentPositionInMacroBlock is 35.
Long Statement,CSPspEmu.Hle.Formats,IsoFile,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\IsoFile.cs,ProcessDirectoryRecord,The length of the statement  "                // Even if a directory spans multiple sectors' the directory entries are not permitted to cross the sector boundary (unlike the path table). " is 140.
Long Statement,CSPspEmu.Hle.Formats,IsoFile,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\IsoFile.cs,ProcessDirectoryRecord,The length of the statement  "                // Where there is not enough space to record an entire directory entry at the end of a sector' that sector is zero-padded and the next " is 134.
Long Statement,CSPspEmu.Hle.Formats,IsoFile,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\IsoFile.cs,ProcessDirectoryRecord,The length of the statement  "                //Console.WriteLine("[{0}:{1:X}-{2:X}]"' DirectoryRecordSize' DirectoryStream.Position' DirectoryStream.Position + DirectoryRecordSize); " is 136.
Long Statement,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,ToString,The length of the statement  "                $"PGF.Glyph(GlyphIndex={GlyphIndex}' Char='{UnicodeChar}'' Width={Width}' Height={Height}' Left={Left}' Top={Top}' Flags={Flags})"; " is 131.
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,ExtraV2Mangle,The following statement contains a magic number: var gDataTmp = new byte[20 + 0xA0];
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,ExtraV2Mangle,The following statement contains a magic number: fixed (byte* buffer2 = gDataTmp) // aligned              {                  PointerUtils.Memcpy(buffer2 + 20' buffer1' 0xA0);                  var pl2 = (uint*) buffer2;                  pl2[0] = 5;                  pl2[1] = pl2[2] = 0;                  pl2[3] = codeExtra;                  pl2[4] = 0xA0;                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      buffer2'                      20 + 0xA0'                      buffer2'                      20 + 0xA0'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                  {                      throw new Exception($"extra de-mangle returns {ret}' ");                  }                  // copy result back                  PointerUtils.Memcpy(buffer1' buffer2' 0xA0);              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,ExtraV2Mangle,The following statement contains a magic number: fixed (byte* buffer2 = gDataTmp) // aligned              {                  PointerUtils.Memcpy(buffer2 + 20' buffer1' 0xA0);                  var pl2 = (uint*) buffer2;                  pl2[0] = 5;                  pl2[1] = pl2[2] = 0;                  pl2[3] = codeExtra;                  pl2[4] = 0xA0;                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      buffer2'                      20 + 0xA0'                      buffer2'                      20 + 0xA0'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                  {                      throw new Exception($"extra de-mangle returns {ret}' ");                  }                  // copy result back                  PointerUtils.Memcpy(buffer1' buffer2' 0xA0);              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,ExtraV2Mangle,The following statement contains a magic number: fixed (byte* buffer2 = gDataTmp) // aligned              {                  PointerUtils.Memcpy(buffer2 + 20' buffer1' 0xA0);                  var pl2 = (uint*) buffer2;                  pl2[0] = 5;                  pl2[1] = pl2[2] = 0;                  pl2[3] = codeExtra;                  pl2[4] = 0xA0;                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      buffer2'                      20 + 0xA0'                      buffer2'                      20 + 0xA0'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                  {                      throw new Exception($"extra de-mangle returns {ret}' ");                  }                  // copy result back                  PointerUtils.Memcpy(buffer1' buffer2' 0xA0);              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,ExtraV2Mangle,The following statement contains a magic number: fixed (byte* buffer2 = gDataTmp) // aligned              {                  PointerUtils.Memcpy(buffer2 + 20' buffer1' 0xA0);                  var pl2 = (uint*) buffer2;                  pl2[0] = 5;                  pl2[1] = pl2[2] = 0;                  pl2[3] = codeExtra;                  pl2[4] = 0xA0;                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      buffer2'                      20 + 0xA0'                      buffer2'                      20 + 0xA0'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                  {                      throw new Exception($"extra de-mangle returns {ret}' ");                  }                  // copy result back                  PointerUtils.Memcpy(buffer1' buffer2' 0xA0);              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,ExtraV2Mangle,The following statement contains a magic number: fixed (byte* buffer2 = gDataTmp) // aligned              {                  PointerUtils.Memcpy(buffer2 + 20' buffer1' 0xA0);                  var pl2 = (uint*) buffer2;                  pl2[0] = 5;                  pl2[1] = pl2[2] = 0;                  pl2[3] = codeExtra;                  pl2[4] = 0xA0;                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      buffer2'                      20 + 0xA0'                      buffer2'                      20 + 0xA0'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                  {                      throw new Exception($"extra de-mangle returns {ret}' ");                  }                  // copy result back                  PointerUtils.Memcpy(buffer1' buffer2' 0xA0);              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,ExtraV2Mangle,The following statement contains a magic number: fixed (byte* buffer2 = gDataTmp) // aligned              {                  PointerUtils.Memcpy(buffer2 + 20' buffer1' 0xA0);                  var pl2 = (uint*) buffer2;                  pl2[0] = 5;                  pl2[1] = pl2[2] = 0;                  pl2[3] = codeExtra;                  pl2[4] = 0xA0;                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      buffer2'                      20 + 0xA0'                      buffer2'                      20 + 0xA0'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                  {                      throw new Exception($"extra de-mangle returns {ret}' ");                  }                  // copy result back                  PointerUtils.Memcpy(buffer1' buffer2' 0xA0);              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,ExtraV2Mangle,The following statement contains a magic number: fixed (byte* buffer2 = gDataTmp) // aligned              {                  PointerUtils.Memcpy(buffer2 + 20' buffer1' 0xA0);                  var pl2 = (uint*) buffer2;                  pl2[0] = 5;                  pl2[1] = pl2[2] = 0;                  pl2[3] = codeExtra;                  pl2[4] = 0xA0;                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      buffer2'                      20 + 0xA0'                      buffer2'                      20 + 0xA0'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                  {                      throw new Exception($"extra de-mangle returns {ret}' ");                  }                  // copy result back                  PointerUtils.Memcpy(buffer1' buffer2' 0xA0);              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,DecryptPrx1,The following statement contains a magic number: fixed (byte* pbIn = pbInBytes)              fixed (byte* pbOut = pbOutBytes)              {                  //var headerPointer = (HeaderStruct*) pbIn;                  Header = *(HeaderStruct*) pbIn;                  var pti = GetTagInfo(Header.Tag);                    if (showInfo)                  {                      Console.WriteLine("TAG_INFO: {0}"' pti);                  }                    // build conversion into pbOut                  PointerUtils.Memcpy(pbOut' pbIn' pbInBytes.Length);                  PointerUtils.Memset(pbOut' 0' 0x150);                  PointerUtils.Memset(pbOut' 0x55' 0x40);                    // step3 demangle in place                  var h7Header = (Kirk.KirkAes128CbcHeader*) &pbOut[0x2C];                  h7Header->Mode = Kirk.KirkMode.DecryptCbc;                  h7Header->Unknown4 = 0;                  h7Header->Unknown8 = 0;                  h7Header->KeySeed = pti.Code; // initial seed for PRX                  h7Header->Datasize = 0x70; // size                    // redo part of the SIG check (step2)                  var buffer1Bytes = new byte[0x150];                  fixed (byte* buffer1 = buffer1Bytes)                  {                      PointerUtils.Memcpy(buffer1 + 0x00' pbIn + 0xD0' 0x80);                      PointerUtils.Memcpy(buffer1 + 0x80' pbIn + 0x80' 0x50);                      PointerUtils.Memcpy(buffer1 + 0xD0' pbIn + 0x00' 0x80);                        if (pti.CodeExtra != 0)                      {                          ExtraV2Mangle(buffer1 + 0x10' pti.CodeExtra);                      }                        PointerUtils.Memcpy(pbOut + 0x40 /* 0x2C+20 */' buffer1 + 0x40' 0x40);                  }                    for (var iXor = 0; iXor < 0x70; iXor++)                  {                      pbOut[0x40 + iXor] = (byte) (pbOut[0x40 + iXor] ^ pti.Key[0x14 + iXor]);                  }                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      pbOut + 0x2C'                      20 + 0x70'                      pbOut + 0x2C'                      20 + 0x70'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                      throw new Exception(CStringFormater.Sprintf("mangle#7 returned 0x%08X' "' ret));                    for (var iXor = 0x6F; iXor >= 0; iXor--)                      pbOut[0x40 + iXor] = (byte) (pbOut[0x2C + iXor] ^ pti.Key[0x20 + iXor]);                    PointerUtils.Memset(pbOut + 0x80' 0' 0x30); // $40 bytes kept' clean up                    pbOut[0xA0] = 1;                  // copy unscrambled parts from header                  PointerUtils.Memcpy(pbOut + 0xB0' pbIn + 0xB0' 0x20); // file size + lots of zeros                  PointerUtils.Memcpy(pbOut + 0xD0' pbIn + 0x00' 0x80); // ~PSP header                    // step4: do the actual decryption of code block                  //  point 0x40 bytes into the buffer to key info                  ret = _kirk.HleUtilsBufferCopyWithRange(                      pbOut'                      cbTotal'                      pbOut + 0x40'                      cbTotal - 0x40'                      Kirk.CommandEnum.PspKirkCmdDecryptPrivate                  );                    if (ret != 0)                      throw new Exception(CStringFormater.Sprintf("mangle#1 returned 0x%08X"' ret));                    //File.WriteAllBytes("../../../TestInput/temp.bin"' _pbOut);                    var outputSize = *(int*) &pbIn[0xB0];                    return pbOutBytes.Slice(0' outputSize).ToArray();              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,DecryptPrx1,The following statement contains a magic number: fixed (byte* pbIn = pbInBytes)              fixed (byte* pbOut = pbOutBytes)              {                  //var headerPointer = (HeaderStruct*) pbIn;                  Header = *(HeaderStruct*) pbIn;                  var pti = GetTagInfo(Header.Tag);                    if (showInfo)                  {                      Console.WriteLine("TAG_INFO: {0}"' pti);                  }                    // build conversion into pbOut                  PointerUtils.Memcpy(pbOut' pbIn' pbInBytes.Length);                  PointerUtils.Memset(pbOut' 0' 0x150);                  PointerUtils.Memset(pbOut' 0x55' 0x40);                    // step3 demangle in place                  var h7Header = (Kirk.KirkAes128CbcHeader*) &pbOut[0x2C];                  h7Header->Mode = Kirk.KirkMode.DecryptCbc;                  h7Header->Unknown4 = 0;                  h7Header->Unknown8 = 0;                  h7Header->KeySeed = pti.Code; // initial seed for PRX                  h7Header->Datasize = 0x70; // size                    // redo part of the SIG check (step2)                  var buffer1Bytes = new byte[0x150];                  fixed (byte* buffer1 = buffer1Bytes)                  {                      PointerUtils.Memcpy(buffer1 + 0x00' pbIn + 0xD0' 0x80);                      PointerUtils.Memcpy(buffer1 + 0x80' pbIn + 0x80' 0x50);                      PointerUtils.Memcpy(buffer1 + 0xD0' pbIn + 0x00' 0x80);                        if (pti.CodeExtra != 0)                      {                          ExtraV2Mangle(buffer1 + 0x10' pti.CodeExtra);                      }                        PointerUtils.Memcpy(pbOut + 0x40 /* 0x2C+20 */' buffer1 + 0x40' 0x40);                  }                    for (var iXor = 0; iXor < 0x70; iXor++)                  {                      pbOut[0x40 + iXor] = (byte) (pbOut[0x40 + iXor] ^ pti.Key[0x14 + iXor]);                  }                    var ret = _kirk.HleUtilsBufferCopyWithRange(                      pbOut + 0x2C'                      20 + 0x70'                      pbOut + 0x2C'                      20 + 0x70'                      Kirk.CommandEnum.PspKirkCmdDecrypt                  );                    if (ret != 0)                      throw new Exception(CStringFormater.Sprintf("mangle#7 returned 0x%08X' "' ret));                    for (var iXor = 0x6F; iXor >= 0; iXor--)                      pbOut[0x40 + iXor] = (byte) (pbOut[0x2C + iXor] ^ pti.Key[0x20 + iXor]);                    PointerUtils.Memset(pbOut + 0x80' 0' 0x30); // $40 bytes kept' clean up                    pbOut[0xA0] = 1;                  // copy unscrambled parts from header                  PointerUtils.Memcpy(pbOut + 0xB0' pbIn + 0xB0' 0x20); // file size + lots of zeros                  PointerUtils.Memcpy(pbOut + 0xD0' pbIn + 0x00' 0x80); // ~PSP header                    // step4: do the actual decryption of code block                  //  point 0x40 bytes into the buffer to key info                  ret = _kirk.HleUtilsBufferCopyWithRange(                      pbOut'                      cbTotal'                      pbOut + 0x40'                      cbTotal - 0x40'                      Kirk.CommandEnum.PspKirkCmdDecryptPrivate                  );                    if (ret != 0)                      throw new Exception(CStringFormater.Sprintf("mangle#1 returned 0x%08X"' ret));                    //File.WriteAllBytes("../../../TestInput/temp.bin"' _pbOut);                    var outputSize = *(int*) &pbIn[0xB0];                    return pbOutBytes.Slice(0' outputSize).ToArray();              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,Scramble,The following statement contains a magic number: buf[0] = 5;
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,Scramble,The following statement contains a magic number: buf[1] = buf[2] = 0;
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,Scramble,The following statement contains a magic number: buf[3] = (uint) code;
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,Scramble,The following statement contains a magic number: buf[4] = (uint) size;
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,DecryptPrx2,The following statement contains a magic number: fixed (byte* inbuf = pbIn)              fixed (byte* outbuf = pbOut)              fixed (byte* tmp1 = tmp1Bytes)              fixed (byte* tmp2 = tmp2Bytes)              fixed (byte* tmp3 = tmp3Bytes)              {                  //var headerPointer = (HeaderStruct*) inbuf;                  Header = *(HeaderStruct*) inbuf;                  var pti = GetTagInfo2(Header.Tag);                  Console.WriteLine("{0}"' pti);                    var retsize = *(int*) &inbuf[0xB0];                    PointerUtils.Memset(tmp1Bytes' 0' 0x150);                  PointerUtils.Memset(tmp2Bytes' 0' 0x90 + 0x14);                  PointerUtils.Memset(tmp3Bytes' 0' 0x60 + 0x14);                    PointerUtils.Memcpy(outbuf' inbuf' size);                    if (size < 0x160)                  {                      throw new InvalidDataException("buffer not big enough' ");                  }                    if (size - 0x150 < retsize)                  {                      throw new InvalidDataException("not enough data' ");                  }                    PointerUtils.Memcpy(tmp1' outbuf' 0x150);                    int i' j;                  //byte *p = tmp2+0x14;                    for (i = 0; i < 9; i++)                  {                      for (j = 0; j < 0x10; j++)                      {                          tmp2Bytes[0x14 + (i << 4) + j] = pti.Key[j];                      }                        tmp2Bytes[0x14 + (i << 4)] = (byte) i;                  }                    if (Scramble((uint*) tmp2' 0x90' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#1' ");                  }                    PointerUtils.Memcpy(outbuf' tmp1 + 0xD0' 0x5C);                  PointerUtils.Memcpy(outbuf + 0x5C' tmp1 + 0x140' 0x10);                  PointerUtils.Memcpy(outbuf + 0x6C' tmp1 + 0x12C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x80' tmp1 + 0x080' 0x30);                  PointerUtils.Memcpy(outbuf + 0xB0' tmp1 + 0x0C0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xC0' tmp1 + 0x0B0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xD0' tmp1 + 0x000' 0x80);                    PointerUtils.Memcpy(tmp3 + 0x14' outbuf + 0x5C' 0x60);                    if (Scramble((uint*) tmp3' 0x60' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#2' ");                  }                    PointerUtils.Memcpy(outbuf + 0x5C' tmp3' 0x60);                  PointerUtils.Memcpy(tmp3' outbuf + 0x6C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x70' outbuf + 0x5C' 0x10);                  PointerUtils.Memset(outbuf + 0x18' 0' 0x58);                  PointerUtils.Memcpy(outbuf + 0x04' outbuf' 0x04);                    *((uint*) outbuf) = 0x014C;                  PointerUtils.Memcpy(outbuf + 0x08' tmp2' 0x10);                    /* sha-1 */                  if (_kirk.HleUtilsBufferCopyWithRange(outbuf' 3000000' outbuf' 3000000'                          Kirk.CommandEnum.PspKirkCmdSha1Hash) !=                      Kirk.ResultEnum.Ok)                  {                      throw new InvalidDataException("error in sceUtilsBufferCopyWithRange 0xB' ");                  }                    if (PointerUtils.Memcmp(outbuf' tmp3' 0x14) != 0)                  {                      throw new InvalidDataException("WARNING (SHA-1 incorrect)' ");                  }                    int iXor;                    for (iXor = 0; iXor < 0x40; iXor++)                  {                      tmp3[iXor + 0x14] = (byte) (outbuf[iXor + 0x80] ^ tmp2Bytes[iXor + 0x10]);                  }                    if (Scramble((uint*) tmp3' 0x40' pti.Code) != 0)                  {                      throw new InvalidDataException("error in Scramble#3' ");                  }                    for (iXor = 0x3F; iXor >= 0; iXor--)                  {                      outbuf[iXor + 0x40] = (byte) (tmp3Bytes[iXor] ^ tmp2Bytes[iXor + 0x50]); // uns 8                  }                    PointerUtils.Memset(outbuf + 0x80' 0' 0x30);                  *(uint*) &outbuf[0xA0] = 1;                    PointerUtils.Memcpy(outbuf + 0xB0' outbuf + 0xC0' 0x10);                  PointerUtils.Memset(outbuf + 0xC0' 0' 0x10);                    // the real decryption                  var ret = _kirk.HleUtilsBufferCopyWithRange(outbuf' size' outbuf + 0x40' size - 0x40'                      Kirk.CommandEnum.PspKirkCmdDecryptPrivate);                  if (ret != 0)                  {                      throw new InvalidDataException(                          $"error in sceUtilsBufferCopyWithRange 0x1 (0x{ret:X})' ");                  }                    if (retsize < 0x150)                  {                      // Fill with 0                      PointerUtils.Memset(outbuf + retsize' 0' 0x150 - retsize);                  }                    return pbOut.Slice(0' retsize).ToArray();              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,DecryptPrx2,The following statement contains a magic number: fixed (byte* inbuf = pbIn)              fixed (byte* outbuf = pbOut)              fixed (byte* tmp1 = tmp1Bytes)              fixed (byte* tmp2 = tmp2Bytes)              fixed (byte* tmp3 = tmp3Bytes)              {                  //var headerPointer = (HeaderStruct*) inbuf;                  Header = *(HeaderStruct*) inbuf;                  var pti = GetTagInfo2(Header.Tag);                  Console.WriteLine("{0}"' pti);                    var retsize = *(int*) &inbuf[0xB0];                    PointerUtils.Memset(tmp1Bytes' 0' 0x150);                  PointerUtils.Memset(tmp2Bytes' 0' 0x90 + 0x14);                  PointerUtils.Memset(tmp3Bytes' 0' 0x60 + 0x14);                    PointerUtils.Memcpy(outbuf' inbuf' size);                    if (size < 0x160)                  {                      throw new InvalidDataException("buffer not big enough' ");                  }                    if (size - 0x150 < retsize)                  {                      throw new InvalidDataException("not enough data' ");                  }                    PointerUtils.Memcpy(tmp1' outbuf' 0x150);                    int i' j;                  //byte *p = tmp2+0x14;                    for (i = 0; i < 9; i++)                  {                      for (j = 0; j < 0x10; j++)                      {                          tmp2Bytes[0x14 + (i << 4) + j] = pti.Key[j];                      }                        tmp2Bytes[0x14 + (i << 4)] = (byte) i;                  }                    if (Scramble((uint*) tmp2' 0x90' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#1' ");                  }                    PointerUtils.Memcpy(outbuf' tmp1 + 0xD0' 0x5C);                  PointerUtils.Memcpy(outbuf + 0x5C' tmp1 + 0x140' 0x10);                  PointerUtils.Memcpy(outbuf + 0x6C' tmp1 + 0x12C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x80' tmp1 + 0x080' 0x30);                  PointerUtils.Memcpy(outbuf + 0xB0' tmp1 + 0x0C0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xC0' tmp1 + 0x0B0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xD0' tmp1 + 0x000' 0x80);                    PointerUtils.Memcpy(tmp3 + 0x14' outbuf + 0x5C' 0x60);                    if (Scramble((uint*) tmp3' 0x60' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#2' ");                  }                    PointerUtils.Memcpy(outbuf + 0x5C' tmp3' 0x60);                  PointerUtils.Memcpy(tmp3' outbuf + 0x6C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x70' outbuf + 0x5C' 0x10);                  PointerUtils.Memset(outbuf + 0x18' 0' 0x58);                  PointerUtils.Memcpy(outbuf + 0x04' outbuf' 0x04);                    *((uint*) outbuf) = 0x014C;                  PointerUtils.Memcpy(outbuf + 0x08' tmp2' 0x10);                    /* sha-1 */                  if (_kirk.HleUtilsBufferCopyWithRange(outbuf' 3000000' outbuf' 3000000'                          Kirk.CommandEnum.PspKirkCmdSha1Hash) !=                      Kirk.ResultEnum.Ok)                  {                      throw new InvalidDataException("error in sceUtilsBufferCopyWithRange 0xB' ");                  }                    if (PointerUtils.Memcmp(outbuf' tmp3' 0x14) != 0)                  {                      throw new InvalidDataException("WARNING (SHA-1 incorrect)' ");                  }                    int iXor;                    for (iXor = 0; iXor < 0x40; iXor++)                  {                      tmp3[iXor + 0x14] = (byte) (outbuf[iXor + 0x80] ^ tmp2Bytes[iXor + 0x10]);                  }                    if (Scramble((uint*) tmp3' 0x40' pti.Code) != 0)                  {                      throw new InvalidDataException("error in Scramble#3' ");                  }                    for (iXor = 0x3F; iXor >= 0; iXor--)                  {                      outbuf[iXor + 0x40] = (byte) (tmp3Bytes[iXor] ^ tmp2Bytes[iXor + 0x50]); // uns 8                  }                    PointerUtils.Memset(outbuf + 0x80' 0' 0x30);                  *(uint*) &outbuf[0xA0] = 1;                    PointerUtils.Memcpy(outbuf + 0xB0' outbuf + 0xC0' 0x10);                  PointerUtils.Memset(outbuf + 0xC0' 0' 0x10);                    // the real decryption                  var ret = _kirk.HleUtilsBufferCopyWithRange(outbuf' size' outbuf + 0x40' size - 0x40'                      Kirk.CommandEnum.PspKirkCmdDecryptPrivate);                  if (ret != 0)                  {                      throw new InvalidDataException(                          $"error in sceUtilsBufferCopyWithRange 0x1 (0x{ret:X})' ");                  }                    if (retsize < 0x150)                  {                      // Fill with 0                      PointerUtils.Memset(outbuf + retsize' 0' 0x150 - retsize);                  }                    return pbOut.Slice(0' retsize).ToArray();              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,DecryptPrx2,The following statement contains a magic number: fixed (byte* inbuf = pbIn)              fixed (byte* outbuf = pbOut)              fixed (byte* tmp1 = tmp1Bytes)              fixed (byte* tmp2 = tmp2Bytes)              fixed (byte* tmp3 = tmp3Bytes)              {                  //var headerPointer = (HeaderStruct*) inbuf;                  Header = *(HeaderStruct*) inbuf;                  var pti = GetTagInfo2(Header.Tag);                  Console.WriteLine("{0}"' pti);                    var retsize = *(int*) &inbuf[0xB0];                    PointerUtils.Memset(tmp1Bytes' 0' 0x150);                  PointerUtils.Memset(tmp2Bytes' 0' 0x90 + 0x14);                  PointerUtils.Memset(tmp3Bytes' 0' 0x60 + 0x14);                    PointerUtils.Memcpy(outbuf' inbuf' size);                    if (size < 0x160)                  {                      throw new InvalidDataException("buffer not big enough' ");                  }                    if (size - 0x150 < retsize)                  {                      throw new InvalidDataException("not enough data' ");                  }                    PointerUtils.Memcpy(tmp1' outbuf' 0x150);                    int i' j;                  //byte *p = tmp2+0x14;                    for (i = 0; i < 9; i++)                  {                      for (j = 0; j < 0x10; j++)                      {                          tmp2Bytes[0x14 + (i << 4) + j] = pti.Key[j];                      }                        tmp2Bytes[0x14 + (i << 4)] = (byte) i;                  }                    if (Scramble((uint*) tmp2' 0x90' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#1' ");                  }                    PointerUtils.Memcpy(outbuf' tmp1 + 0xD0' 0x5C);                  PointerUtils.Memcpy(outbuf + 0x5C' tmp1 + 0x140' 0x10);                  PointerUtils.Memcpy(outbuf + 0x6C' tmp1 + 0x12C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x80' tmp1 + 0x080' 0x30);                  PointerUtils.Memcpy(outbuf + 0xB0' tmp1 + 0x0C0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xC0' tmp1 + 0x0B0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xD0' tmp1 + 0x000' 0x80);                    PointerUtils.Memcpy(tmp3 + 0x14' outbuf + 0x5C' 0x60);                    if (Scramble((uint*) tmp3' 0x60' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#2' ");                  }                    PointerUtils.Memcpy(outbuf + 0x5C' tmp3' 0x60);                  PointerUtils.Memcpy(tmp3' outbuf + 0x6C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x70' outbuf + 0x5C' 0x10);                  PointerUtils.Memset(outbuf + 0x18' 0' 0x58);                  PointerUtils.Memcpy(outbuf + 0x04' outbuf' 0x04);                    *((uint*) outbuf) = 0x014C;                  PointerUtils.Memcpy(outbuf + 0x08' tmp2' 0x10);                    /* sha-1 */                  if (_kirk.HleUtilsBufferCopyWithRange(outbuf' 3000000' outbuf' 3000000'                          Kirk.CommandEnum.PspKirkCmdSha1Hash) !=                      Kirk.ResultEnum.Ok)                  {                      throw new InvalidDataException("error in sceUtilsBufferCopyWithRange 0xB' ");                  }                    if (PointerUtils.Memcmp(outbuf' tmp3' 0x14) != 0)                  {                      throw new InvalidDataException("WARNING (SHA-1 incorrect)' ");                  }                    int iXor;                    for (iXor = 0; iXor < 0x40; iXor++)                  {                      tmp3[iXor + 0x14] = (byte) (outbuf[iXor + 0x80] ^ tmp2Bytes[iXor + 0x10]);                  }                    if (Scramble((uint*) tmp3' 0x40' pti.Code) != 0)                  {                      throw new InvalidDataException("error in Scramble#3' ");                  }                    for (iXor = 0x3F; iXor >= 0; iXor--)                  {                      outbuf[iXor + 0x40] = (byte) (tmp3Bytes[iXor] ^ tmp2Bytes[iXor + 0x50]); // uns 8                  }                    PointerUtils.Memset(outbuf + 0x80' 0' 0x30);                  *(uint*) &outbuf[0xA0] = 1;                    PointerUtils.Memcpy(outbuf + 0xB0' outbuf + 0xC0' 0x10);                  PointerUtils.Memset(outbuf + 0xC0' 0' 0x10);                    // the real decryption                  var ret = _kirk.HleUtilsBufferCopyWithRange(outbuf' size' outbuf + 0x40' size - 0x40'                      Kirk.CommandEnum.PspKirkCmdDecryptPrivate);                  if (ret != 0)                  {                      throw new InvalidDataException(                          $"error in sceUtilsBufferCopyWithRange 0x1 (0x{ret:X})' ");                  }                    if (retsize < 0x150)                  {                      // Fill with 0                      PointerUtils.Memset(outbuf + retsize' 0' 0x150 - retsize);                  }                    return pbOut.Slice(0' retsize).ToArray();              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,DecryptPrx2,The following statement contains a magic number: fixed (byte* inbuf = pbIn)              fixed (byte* outbuf = pbOut)              fixed (byte* tmp1 = tmp1Bytes)              fixed (byte* tmp2 = tmp2Bytes)              fixed (byte* tmp3 = tmp3Bytes)              {                  //var headerPointer = (HeaderStruct*) inbuf;                  Header = *(HeaderStruct*) inbuf;                  var pti = GetTagInfo2(Header.Tag);                  Console.WriteLine("{0}"' pti);                    var retsize = *(int*) &inbuf[0xB0];                    PointerUtils.Memset(tmp1Bytes' 0' 0x150);                  PointerUtils.Memset(tmp2Bytes' 0' 0x90 + 0x14);                  PointerUtils.Memset(tmp3Bytes' 0' 0x60 + 0x14);                    PointerUtils.Memcpy(outbuf' inbuf' size);                    if (size < 0x160)                  {                      throw new InvalidDataException("buffer not big enough' ");                  }                    if (size - 0x150 < retsize)                  {                      throw new InvalidDataException("not enough data' ");                  }                    PointerUtils.Memcpy(tmp1' outbuf' 0x150);                    int i' j;                  //byte *p = tmp2+0x14;                    for (i = 0; i < 9; i++)                  {                      for (j = 0; j < 0x10; j++)                      {                          tmp2Bytes[0x14 + (i << 4) + j] = pti.Key[j];                      }                        tmp2Bytes[0x14 + (i << 4)] = (byte) i;                  }                    if (Scramble((uint*) tmp2' 0x90' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#1' ");                  }                    PointerUtils.Memcpy(outbuf' tmp1 + 0xD0' 0x5C);                  PointerUtils.Memcpy(outbuf + 0x5C' tmp1 + 0x140' 0x10);                  PointerUtils.Memcpy(outbuf + 0x6C' tmp1 + 0x12C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x80' tmp1 + 0x080' 0x30);                  PointerUtils.Memcpy(outbuf + 0xB0' tmp1 + 0x0C0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xC0' tmp1 + 0x0B0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xD0' tmp1 + 0x000' 0x80);                    PointerUtils.Memcpy(tmp3 + 0x14' outbuf + 0x5C' 0x60);                    if (Scramble((uint*) tmp3' 0x60' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#2' ");                  }                    PointerUtils.Memcpy(outbuf + 0x5C' tmp3' 0x60);                  PointerUtils.Memcpy(tmp3' outbuf + 0x6C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x70' outbuf + 0x5C' 0x10);                  PointerUtils.Memset(outbuf + 0x18' 0' 0x58);                  PointerUtils.Memcpy(outbuf + 0x04' outbuf' 0x04);                    *((uint*) outbuf) = 0x014C;                  PointerUtils.Memcpy(outbuf + 0x08' tmp2' 0x10);                    /* sha-1 */                  if (_kirk.HleUtilsBufferCopyWithRange(outbuf' 3000000' outbuf' 3000000'                          Kirk.CommandEnum.PspKirkCmdSha1Hash) !=                      Kirk.ResultEnum.Ok)                  {                      throw new InvalidDataException("error in sceUtilsBufferCopyWithRange 0xB' ");                  }                    if (PointerUtils.Memcmp(outbuf' tmp3' 0x14) != 0)                  {                      throw new InvalidDataException("WARNING (SHA-1 incorrect)' ");                  }                    int iXor;                    for (iXor = 0; iXor < 0x40; iXor++)                  {                      tmp3[iXor + 0x14] = (byte) (outbuf[iXor + 0x80] ^ tmp2Bytes[iXor + 0x10]);                  }                    if (Scramble((uint*) tmp3' 0x40' pti.Code) != 0)                  {                      throw new InvalidDataException("error in Scramble#3' ");                  }                    for (iXor = 0x3F; iXor >= 0; iXor--)                  {                      outbuf[iXor + 0x40] = (byte) (tmp3Bytes[iXor] ^ tmp2Bytes[iXor + 0x50]); // uns 8                  }                    PointerUtils.Memset(outbuf + 0x80' 0' 0x30);                  *(uint*) &outbuf[0xA0] = 1;                    PointerUtils.Memcpy(outbuf + 0xB0' outbuf + 0xC0' 0x10);                  PointerUtils.Memset(outbuf + 0xC0' 0' 0x10);                    // the real decryption                  var ret = _kirk.HleUtilsBufferCopyWithRange(outbuf' size' outbuf + 0x40' size - 0x40'                      Kirk.CommandEnum.PspKirkCmdDecryptPrivate);                  if (ret != 0)                  {                      throw new InvalidDataException(                          $"error in sceUtilsBufferCopyWithRange 0x1 (0x{ret:X})' ");                  }                    if (retsize < 0x150)                  {                      // Fill with 0                      PointerUtils.Memset(outbuf + retsize' 0' 0x150 - retsize);                  }                    return pbOut.Slice(0' retsize).ToArray();              }
Magic Number,CSPspEmu.Hle.Formats,EncryptedPrx,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\EncryptedPrx.cs,DecryptPrx2,The following statement contains a magic number: fixed (byte* inbuf = pbIn)              fixed (byte* outbuf = pbOut)              fixed (byte* tmp1 = tmp1Bytes)              fixed (byte* tmp2 = tmp2Bytes)              fixed (byte* tmp3 = tmp3Bytes)              {                  //var headerPointer = (HeaderStruct*) inbuf;                  Header = *(HeaderStruct*) inbuf;                  var pti = GetTagInfo2(Header.Tag);                  Console.WriteLine("{0}"' pti);                    var retsize = *(int*) &inbuf[0xB0];                    PointerUtils.Memset(tmp1Bytes' 0' 0x150);                  PointerUtils.Memset(tmp2Bytes' 0' 0x90 + 0x14);                  PointerUtils.Memset(tmp3Bytes' 0' 0x60 + 0x14);                    PointerUtils.Memcpy(outbuf' inbuf' size);                    if (size < 0x160)                  {                      throw new InvalidDataException("buffer not big enough' ");                  }                    if (size - 0x150 < retsize)                  {                      throw new InvalidDataException("not enough data' ");                  }                    PointerUtils.Memcpy(tmp1' outbuf' 0x150);                    int i' j;                  //byte *p = tmp2+0x14;                    for (i = 0; i < 9; i++)                  {                      for (j = 0; j < 0x10; j++)                      {                          tmp2Bytes[0x14 + (i << 4) + j] = pti.Key[j];                      }                        tmp2Bytes[0x14 + (i << 4)] = (byte) i;                  }                    if (Scramble((uint*) tmp2' 0x90' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#1' ");                  }                    PointerUtils.Memcpy(outbuf' tmp1 + 0xD0' 0x5C);                  PointerUtils.Memcpy(outbuf + 0x5C' tmp1 + 0x140' 0x10);                  PointerUtils.Memcpy(outbuf + 0x6C' tmp1 + 0x12C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x80' tmp1 + 0x080' 0x30);                  PointerUtils.Memcpy(outbuf + 0xB0' tmp1 + 0x0C0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xC0' tmp1 + 0x0B0' 0x10);                  PointerUtils.Memcpy(outbuf + 0xD0' tmp1 + 0x000' 0x80);                    PointerUtils.Memcpy(tmp3 + 0x14' outbuf + 0x5C' 0x60);                    if (Scramble((uint*) tmp3' 0x60' pti.Code) < 0)                  {                      throw new InvalidDataException("error in Scramble#2' ");                  }                    PointerUtils.Memcpy(outbuf + 0x5C' tmp3' 0x60);                  PointerUtils.Memcpy(tmp3' outbuf + 0x6C' 0x14);                  PointerUtils.Memcpy(outbuf + 0x70' outbuf + 0x5C' 0x10);                  PointerUtils.Memset(outbuf + 0x18' 0' 0x58);                  PointerUtils.Memcpy(outbuf + 0x04' outbuf' 0x04);                    *((uint*) outbuf) = 0x014C;                  PointerUtils.Memcpy(outbuf + 0x08' tmp2' 0x10);                    /* sha-1 */                  if (_kirk.HleUtilsBufferCopyWithRange(outbuf' 3000000' outbuf' 3000000'                          Kirk.CommandEnum.PspKirkCmdSha1Hash) !=                      Kirk.ResultEnum.Ok)                  {                      throw new InvalidDataException("error in sceUtilsBufferCopyWithRange 0xB' ");                  }                    if (PointerUtils.Memcmp(outbuf' tmp3' 0x14) != 0)                  {                      throw new InvalidDataException("WARNING (SHA-1 incorrect)' ");                  }                    int iXor;                    for (iXor = 0; iXor < 0x40; iXor++)                  {                      tmp3[iXor + 0x14] = (byte) (outbuf[iXor + 0x80] ^ tmp2Bytes[iXor + 0x10]);                  }                    if (Scramble((uint*) tmp3' 0x40' pti.Code) != 0)                  {                      throw new InvalidDataException("error in Scramble#3' ");                  }                    for (iXor = 0x3F; iXor >= 0; iXor--)                  {                      outbuf[iXor + 0x40] = (byte) (tmp3Bytes[iXor] ^ tmp2Bytes[iXor + 0x50]); // uns 8                  }                    PointerUtils.Memset(outbuf + 0x80' 0' 0x30);                  *(uint*) &outbuf[0xA0] = 1;                    PointerUtils.Memcpy(outbuf + 0xB0' outbuf + 0xC0' 0x10);                  PointerUtils.Memset(outbuf + 0xC0' 0' 0x10);                    // the real decryption                  var ret = _kirk.HleUtilsBufferCopyWithRange(outbuf' size' outbuf + 0x40' size - 0x40'                      Kirk.CommandEnum.PspKirkCmdDecryptPrivate);                  if (ret != 0)                  {                      throw new InvalidDataException(                          $"error in sceUtilsBufferCopyWithRange 0x1 (0x{ret:X})' ");                  }                    if (retsize < 0x150)                  {                      // Fill with 0                      PointerUtils.Memset(outbuf + retsize' 0' 0x150 - retsize);                  }                    return pbOut.Slice(0' retsize).ToArray();              }
Magic Number,CSPspEmu.Hle.Formats,FormatDetector,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\FormatDetector.cs,DetectSubType,The following statement contains a magic number: var startMagic = stream.SliceWithLength(0' 4).ReadAllContentsAsString(Encoding.ASCII);
Magic Number,CSPspEmu.Hle.Formats,FormatDetector,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\FormatDetector.cs,DetectSubType,The following statement contains a magic number: if (stream.SliceWithLength(0x8000' 6).ReadAllContentsAsString() == '\x01' + "CD001") return SubType.Iso;
Magic Number,CSPspEmu.Hle.Formats,IsoDate,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\IsoFile.cs,MapGet,The following statement contains a magic number: fixed (byte* dataPtr = Data)              {                  for (var n = 0; n < size; n++)                  {                      value *= 10;                      value += ((char) dataPtr[offset + n]) - '0';                  }              }
Magic Number,CSPspEmu.Hle.Formats,IsoDate,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\IsoFile.cs,MapSet,The following statement contains a magic number: fixed (byte* dataPtr = Data)              {                  for (int n = size - 1; n >= 0; n--)                  {                      dataPtr[offset + n] = (byte) ((char) (value % 10) + '0');                      value /= 10;                  }              }
Magic Number,CSPspEmu.Hle.Formats,IsoDate,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\IsoFile.cs,MapSet,The following statement contains a magic number: fixed (byte* dataPtr = Data)              {                  for (int n = size - 1; n >= 0; n--)                  {                      dataPtr[offset + n] = (byte) ((char) (value % 10) + '0');                      value /= 10;                  }              }
Magic Number,CSPspEmu.Hle.Formats,Pbp,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Pbp.cs,Load,The following statement contains a magic number: for (int n = 0; n < 8; n++)              {                  Files[Names[n]] = stream.SliceWithBounds(offsets[n + 0]' offsets[n + 1]);              }
Magic Number,CSPspEmu.Hle.Formats.Font,BitReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\BitReader.cs,ReadBits,The following statement contains a magic number: while (count > 0)              {                  int leftInByte = 8 - _bitOffset;                  int readCount = Math.Min(count' leftInByte);                  //Console.WriteLine("Byte[{0}] = {1}"' ByteOffset' Data[ByteOffset]);                  value |= ((_data[_byteOffset] >> _bitOffset) & ((1 << readCount) - 1)) << readOffset;                    readOffset += readCount;                  _bitOffset += readCount;                  if (_bitOffset == 8)                  {                      _bitOffset = 0;                      _byteOffset++;                  }                  count -= readCount;              }
Magic Number,CSPspEmu.Hle.Formats.Font,BitReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\BitReader.cs,ReadBits,The following statement contains a magic number: while (count > 0)              {                  int leftInByte = 8 - _bitOffset;                  int readCount = Math.Min(count' leftInByte);                  //Console.WriteLine("Byte[{0}] = {1}"' ByteOffset' Data[ByteOffset]);                  value |= ((_data[_byteOffset] >> _bitOffset) & ((1 << readCount) - 1)) << readOffset;                    readOffset += readCount;                  _bitOffset += readCount;                  if (_bitOffset == 8)                  {                      _bitOffset = 0;                      _byteOffset++;                  }                  count -= readCount;              }
Magic Number,CSPspEmu.Hle.Formats.Font,BitReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\BitReader.cs,SkipBits,The following statement contains a magic number: _bitOffset += count % 8;
Magic Number,CSPspEmu.Hle.Formats.Font,BitReader,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\BitReader.cs,SkipBits,The following statement contains a magic number: _byteOffset += count / 8;
Magic Number,CSPspEmu.Hle.Formats.Font,NativeFontIpgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,GetFontInfo,The following statement contains a magic number: return new FontInfo              {                  MaxGlyphWidth = 0'                  MaxGlyphHeight = 0'                    MaxGlyphAscender = 0'                  MaxGlyphDescender = 0'                  MaxGlyphLeftX = 0'                  MaxGlyphBaseY = 0'                  MinGlyphCenterX = 0'                  MaxGlyphTopY = 0'                  MaxGlyphAdvanceX = 0'                  MaxGlyphAdvanceY = 0'                    FontStyle = new FontStyle                  {                      Attributes = 0'                      Country = 0'                      Expire = 0'                      Family = FamilyEnum.FontFamilySerif'                      FileName = "test.pgf"'                      Name = "Arial"'                      Language = LanguageEnum.FontLanguageJapanese'                      Region = 0'                      Resolution = new HorizontalVerticalFloat(32' 32)'                      Size = new HorizontalVerticalFloat(32' 32)'                      StyleStyle = StyleEnum.FontStyleRegular'                      StyleSub = 0'                      Weight = 0'                  }'                  BPP = 4'              };
Magic Number,CSPspEmu.Hle.Formats.Font,NativeFontIpgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,GetFontInfo,The following statement contains a magic number: return new FontInfo              {                  MaxGlyphWidth = 0'                  MaxGlyphHeight = 0'                    MaxGlyphAscender = 0'                  MaxGlyphDescender = 0'                  MaxGlyphLeftX = 0'                  MaxGlyphBaseY = 0'                  MinGlyphCenterX = 0'                  MaxGlyphTopY = 0'                  MaxGlyphAdvanceX = 0'                  MaxGlyphAdvanceY = 0'                    FontStyle = new FontStyle                  {                      Attributes = 0'                      Country = 0'                      Expire = 0'                      Family = FamilyEnum.FontFamilySerif'                      FileName = "test.pgf"'                      Name = "Arial"'                      Language = LanguageEnum.FontLanguageJapanese'                      Region = 0'                      Resolution = new HorizontalVerticalFloat(32' 32)'                      Size = new HorizontalVerticalFloat(32' 32)'                      StyleStyle = StyleEnum.FontStyleRegular'                      StyleSub = 0'                      Weight = 0'                  }'                  BPP = 4'              };
Magic Number,CSPspEmu.Hle.Formats.Font,NativeFontIpgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,GetFontInfo,The following statement contains a magic number: return new FontInfo              {                  MaxGlyphWidth = 0'                  MaxGlyphHeight = 0'                    MaxGlyphAscender = 0'                  MaxGlyphDescender = 0'                  MaxGlyphLeftX = 0'                  MaxGlyphBaseY = 0'                  MinGlyphCenterX = 0'                  MaxGlyphTopY = 0'                  MaxGlyphAdvanceX = 0'                  MaxGlyphAdvanceY = 0'                    FontStyle = new FontStyle                  {                      Attributes = 0'                      Country = 0'                      Expire = 0'                      Family = FamilyEnum.FontFamilySerif'                      FileName = "test.pgf"'                      Name = "Arial"'                      Language = LanguageEnum.FontLanguageJapanese'                      Region = 0'                      Resolution = new HorizontalVerticalFloat(32' 32)'                      Size = new HorizontalVerticalFloat(32' 32)'                      StyleStyle = StyleEnum.FontStyleRegular'                      StyleSub = 0'                      Weight = 0'                  }'                  BPP = 4'              };
Magic Number,CSPspEmu.Hle.Formats.Font,NativeFontIpgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,GetFontInfo,The following statement contains a magic number: return new FontInfo              {                  MaxGlyphWidth = 0'                  MaxGlyphHeight = 0'                    MaxGlyphAscender = 0'                  MaxGlyphDescender = 0'                  MaxGlyphLeftX = 0'                  MaxGlyphBaseY = 0'                  MinGlyphCenterX = 0'                  MaxGlyphTopY = 0'                  MaxGlyphAdvanceX = 0'                  MaxGlyphAdvanceY = 0'                    FontStyle = new FontStyle                  {                      Attributes = 0'                      Country = 0'                      Expire = 0'                      Family = FamilyEnum.FontFamilySerif'                      FileName = "test.pgf"'                      Name = "Arial"'                      Language = LanguageEnum.FontLanguageJapanese'                      Region = 0'                      Resolution = new HorizontalVerticalFloat(32' 32)'                      Size = new HorizontalVerticalFloat(32' 32)'                      StyleStyle = StyleEnum.FontStyleRegular'                      StyleSub = 0'                      Weight = 0'                  }'                  BPP = 4'              };
Magic Number,CSPspEmu.Hle.Formats.Font,NativeFontIpgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,GetFontInfo,The following statement contains a magic number: return new FontInfo              {                  MaxGlyphWidth = 0'                  MaxGlyphHeight = 0'                    MaxGlyphAscender = 0'                  MaxGlyphDescender = 0'                  MaxGlyphLeftX = 0'                  MaxGlyphBaseY = 0'                  MinGlyphCenterX = 0'                  MaxGlyphTopY = 0'                  MaxGlyphAdvanceX = 0'                  MaxGlyphAdvanceY = 0'                    FontStyle = new FontStyle                  {                      Attributes = 0'                      Country = 0'                      Expire = 0'                      Family = FamilyEnum.FontFamilySerif'                      FileName = "test.pgf"'                      Name = "Arial"'                      Language = LanguageEnum.FontLanguageJapanese'                      Region = 0'                      Resolution = new HorizontalVerticalFloat(32' 32)'                      Size = new HorizontalVerticalFloat(32' 32)'                      StyleStyle = StyleEnum.FontStyleRegular'                      StyleSub = 0'                      Weight = 0'                  }'                  BPP = 4'              };
Magic Number,CSPspEmu.Hle.Formats.Font,Pgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,GetFontInfo,The following statement contains a magic number: return new FontInfo              {                  MaxGlyphWidth = Header.MaxGlyphWidth'                  MaxGlyphHeight = Header.MaxGlyphHeight'                    MaxGlyphAscender = Header.MaxBaseYAdjust'                  MaxGlyphDescender = Header.MaxBaseYAdjust - Header.MaxGlyphHeight'                  MaxGlyphLeftX = Header.MaxLeftXAdjust'                  MaxGlyphBaseY = Header.MaxBaseYAdjust'                  MinGlyphCenterX = Header.MinCenterXAdjust'                  MaxGlyphTopY = Header.MaxTopYAdjust'                  MaxGlyphAdvanceX = Header.MaxAdvance.X'                  MaxGlyphAdvanceY = Header.MaxAdvance.Y'                    FontStyle = FontStyle'                  BPP = 4'              };
Magic Number,CSPspEmu.Hle.Formats.Font,Pgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Load,The following statement contains a magic number: if (Header.Revision >= 3)              {                  HeaderExtraRevision3 = fileStream.ReadStruct<HeaderRevision3Struct>();              }
Magic Number,CSPspEmu.Hle.Formats.Font,Pgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Load,The following statement contains a magic number: if (Header.Revision == 3)              {                  fileStream.ReadStructVector(out CharmapCompressionTable1' HeaderExtraRevision3.TableCompCharMapLength1);                  fileStream.ReadStructVector(out CharmapCompressionTable2' HeaderExtraRevision3.TableCompCharMapLength2);              }
Magic Number,CSPspEmu.Hle.Formats.Font,Pgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Write,The following statement contains a magic number: if (Header.Revision >= 3)              {                  fileStream.WriteStruct(HeaderExtraRevision3);              }
Magic Number,CSPspEmu.Hle.Formats.Font,Pgf,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Write,The following statement contains a magic number: if (Header.Revision == 3)              {                  fileStream.WriteStructVector(CharmapCompressionTable1);                  fileStream.WriteStructVector(CharmapCompressionTable2);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: var bitReader = new BitReader(pgf.CharData)              {                  Position = pgf.CharPointer[glyphIndex] * 4 * 8              };
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: var bitReader = new BitReader(pgf.CharData)              {                  Position = pgf.CharPointer[glyphIndex] * 4 * 8              };
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: var shadowOffset = bitReader.Position + (int) bitReader.ReadBits(14) * 8;
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: var shadowOffset = bitReader.Position + (int) bitReader.ReadBits(14) * 8;
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: if (_glyphType == GlyphFlags.FontPgfShadowglyph)              {                  bitReader.Position = shadowOffset;                  bitReader.SkipBits(14);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: Width = bitReader.ReadBits(7);
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: Height = bitReader.ReadBits(7);
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: Left = bitReader.ReadBitsSigned(7);
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: Top = bitReader.ReadBitsSigned(7);
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: Flags = (GlyphFlags) bitReader.ReadBits(6);
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: if (Flags.HasFlag(GlyphFlags.FontPgfCharglyph))              {                  bitReader.SkipBits(7);                  // ReSharper disable once UnusedVariable                  var shadowId = bitReader.ReadBits(9);                  bitReader.SkipBits(24);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag1)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag2)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag3)) bitReader.SkipBits(56);                  AdvanceIndex = bitReader.ReadBits(8);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: if (Flags.HasFlag(GlyphFlags.FontPgfCharglyph))              {                  bitReader.SkipBits(7);                  // ReSharper disable once UnusedVariable                  var shadowId = bitReader.ReadBits(9);                  bitReader.SkipBits(24);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag1)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag2)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag3)) bitReader.SkipBits(56);                  AdvanceIndex = bitReader.ReadBits(8);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: if (Flags.HasFlag(GlyphFlags.FontPgfCharglyph))              {                  bitReader.SkipBits(7);                  // ReSharper disable once UnusedVariable                  var shadowId = bitReader.ReadBits(9);                  bitReader.SkipBits(24);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag1)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag2)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag3)) bitReader.SkipBits(56);                  AdvanceIndex = bitReader.ReadBits(8);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: if (Flags.HasFlag(GlyphFlags.FontPgfCharglyph))              {                  bitReader.SkipBits(7);                  // ReSharper disable once UnusedVariable                  var shadowId = bitReader.ReadBits(9);                  bitReader.SkipBits(24);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag1)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag2)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag3)) bitReader.SkipBits(56);                  AdvanceIndex = bitReader.ReadBits(8);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: if (Flags.HasFlag(GlyphFlags.FontPgfCharglyph))              {                  bitReader.SkipBits(7);                  // ReSharper disable once UnusedVariable                  var shadowId = bitReader.ReadBits(9);                  bitReader.SkipBits(24);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag1)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag2)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag3)) bitReader.SkipBits(56);                  AdvanceIndex = bitReader.ReadBits(8);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: if (Flags.HasFlag(GlyphFlags.FontPgfCharglyph))              {                  bitReader.SkipBits(7);                  // ReSharper disable once UnusedVariable                  var shadowId = bitReader.ReadBits(9);                  bitReader.SkipBits(24);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag1)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag2)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag3)) bitReader.SkipBits(56);                  AdvanceIndex = bitReader.ReadBits(8);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: if (Flags.HasFlag(GlyphFlags.FontPgfCharglyph))              {                  bitReader.SkipBits(7);                  // ReSharper disable once UnusedVariable                  var shadowId = bitReader.ReadBits(9);                  bitReader.SkipBits(24);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag1)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag2)) bitReader.SkipBits(56);                  if (!Flags.HasFlag(GlyphFlags.FontPgfMetricFlag3)) bitReader.SkipBits(56);                  AdvanceIndex = bitReader.ReadBits(8);              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: DataByteOffset = (uint) (bitReader.Position / 8);
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: while (pixelIndex < numberOfPixels)              {                  var code = bitReader.ReadBits(4);                    int count;                  if (code < 8)                  {                      value = bitReader.ReadBits(4);                      count = (int) code + 1;                  }                  else                  {                      count = 16 - (int) code;                  }                    for (var n = 0; n < count && pixelIndex < numberOfPixels; n++)                  {                      if (code >= 8)                      {                          value = bitReader.ReadBits(4);                      }                        uint x;                      uint y;                      if (bitmapHorizontalRows)                      {                          x = pixelIndex % Width;                          y = pixelIndex / Width;                      }                      else                      {                          x = pixelIndex / Height;                          y = pixelIndex % Height;                      }                        Data[x + y * Width] = (byte) ((value << 0) | (value << 4));                      pixelIndex++;                  }              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: while (pixelIndex < numberOfPixels)              {                  var code = bitReader.ReadBits(4);                    int count;                  if (code < 8)                  {                      value = bitReader.ReadBits(4);                      count = (int) code + 1;                  }                  else                  {                      count = 16 - (int) code;                  }                    for (var n = 0; n < count && pixelIndex < numberOfPixels; n++)                  {                      if (code >= 8)                      {                          value = bitReader.ReadBits(4);                      }                        uint x;                      uint y;                      if (bitmapHorizontalRows)                      {                          x = pixelIndex % Width;                          y = pixelIndex / Width;                      }                      else                      {                          x = pixelIndex / Height;                          y = pixelIndex % Height;                      }                        Data[x + y * Width] = (byte) ((value << 0) | (value << 4));                      pixelIndex++;                  }              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: while (pixelIndex < numberOfPixels)              {                  var code = bitReader.ReadBits(4);                    int count;                  if (code < 8)                  {                      value = bitReader.ReadBits(4);                      count = (int) code + 1;                  }                  else                  {                      count = 16 - (int) code;                  }                    for (var n = 0; n < count && pixelIndex < numberOfPixels; n++)                  {                      if (code >= 8)                      {                          value = bitReader.ReadBits(4);                      }                        uint x;                      uint y;                      if (bitmapHorizontalRows)                      {                          x = pixelIndex % Width;                          y = pixelIndex / Width;                      }                      else                      {                          x = pixelIndex / Height;                          y = pixelIndex % Height;                      }                        Data[x + y * Width] = (byte) ((value << 0) | (value << 4));                      pixelIndex++;                  }              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: while (pixelIndex < numberOfPixels)              {                  var code = bitReader.ReadBits(4);                    int count;                  if (code < 8)                  {                      value = bitReader.ReadBits(4);                      count = (int) code + 1;                  }                  else                  {                      count = 16 - (int) code;                  }                    for (var n = 0; n < count && pixelIndex < numberOfPixels; n++)                  {                      if (code >= 8)                      {                          value = bitReader.ReadBits(4);                      }                        uint x;                      uint y;                      if (bitmapHorizontalRows)                      {                          x = pixelIndex % Width;                          y = pixelIndex / Width;                      }                      else                      {                          x = pixelIndex / Height;                          y = pixelIndex % Height;                      }                        Data[x + y * Width] = (byte) ((value << 0) | (value << 4));                      pixelIndex++;                  }              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: while (pixelIndex < numberOfPixels)              {                  var code = bitReader.ReadBits(4);                    int count;                  if (code < 8)                  {                      value = bitReader.ReadBits(4);                      count = (int) code + 1;                  }                  else                  {                      count = 16 - (int) code;                  }                    for (var n = 0; n < count && pixelIndex < numberOfPixels; n++)                  {                      if (code >= 8)                      {                          value = bitReader.ReadBits(4);                      }                        uint x;                      uint y;                      if (bitmapHorizontalRows)                      {                          x = pixelIndex % Width;                          y = pixelIndex / Width;                      }                      else                      {                          x = pixelIndex / Height;                          y = pixelIndex % Height;                      }                        Data[x + y * Width] = (byte) ((value << 0) | (value << 4));                      pixelIndex++;                  }              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: while (pixelIndex < numberOfPixels)              {                  var code = bitReader.ReadBits(4);                    int count;                  if (code < 8)                  {                      value = bitReader.ReadBits(4);                      count = (int) code + 1;                  }                  else                  {                      count = 16 - (int) code;                  }                    for (var n = 0; n < count && pixelIndex < numberOfPixels; n++)                  {                      if (code >= 8)                      {                          value = bitReader.ReadBits(4);                      }                        uint x;                      uint y;                      if (bitmapHorizontalRows)                      {                          x = pixelIndex % Width;                          y = pixelIndex / Width;                      }                      else                      {                          x = pixelIndex / Height;                          y = pixelIndex % Height;                      }                        Data[x + y * Width] = (byte) ((value << 0) | (value << 4));                      pixelIndex++;                  }              }
Magic Number,CSPspEmu.Hle.Formats.Font,GlyphSymbol,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\Font\PGF.cs,Read,The following statement contains a magic number: while (pixelIndex < numberOfPixels)              {                  var code = bitReader.ReadBits(4);                    int count;                  if (code < 8)                  {                      value = bitReader.ReadBits(4);                      count = (int) code + 1;                  }                  else                  {                      count = 16 - (int) code;                  }                    for (var n = 0; n < count && pixelIndex < numberOfPixels; n++)                  {                      if (code >= 8)                      {                          value = bitReader.ReadBits(4);                      }                        uint x;                      uint y;                      if (bitmapHorizontalRows)                      {                          x = pixelIndex % Width;                          y = pixelIndex / Width;                      }                      else                      {                          x = pixelIndex / Height;                          y = pixelIndex % Height;                      }                        Data[x + y * Width] = (byte) ((value << 0) | (value << 4));                      pixelIndex++;                  }              }
Missing Default,CSPspEmu.Hle.Formats,CompressedIsoProxyStream,C:\repos\soywiz_cspspemu\Hle\CSPspEmu.Hle.Formats\CompressedIsoProxyStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.Current:                      Position = 0 + offset;                      break;                  case SeekOrigin.End:                      Position = Length + offset;                      break;              }
