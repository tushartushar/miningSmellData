Implementation smell,Namespace,Class,File,Method,Description
Long Method,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,GetTexVram,The method has 112 lines of code.
Long Parameter List,HQ2x,ColorAlphaLerp,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaLerp.cs,Lerp,The method has 6 parameters. Parameters: color1' factor1' color2' factor2' color3' factor3
Long Parameter List,HQ2x,ColorAlphaLerp,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaLerp.cs,LerpChannel,The method has 6 parameters. Parameters: value1' factor1' value2' factor2' value3' factor3
Long Parameter List,HQ2x,ColorOnlyLerp,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyLerp.cs,Lerp,The method has 6 parameters. Parameters: color1' factor1' color2' factor2' color3' factor3
Long Parameter List,HQ2x,ColorOnlyLerp,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyLerp.cs,LerpChannel,The method has 6 parameters. Parameters: value1' factor1' value2' factor2' value3' factor3
Long Parameter List,HQ2x,ColorSimpleAlphaLerp,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaLerp.cs,Lerp,The method has 6 parameters. Parameters: color1' factor1' color2' factor2' color3' factor3
Long Parameter List,HQ2x,ColorSimpleAlphaLerp,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaLerp.cs,LerpChannel,The method has 6 parameters. Parameters: value1' factor1' value2' factor2' value3' factor3
Long Parameter List,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,GetColor,The method has 5 parameters. Parameters: Data' Width' Height' x' y
Long Parameter List,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The method has 6 parameters. Parameters: engine' Data' Width' Height' x' y
Long Parameter List,HQ2x,ILerp,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ILerp.cs,Lerp,The method has 6 parameters. Parameters: colour1' factor1' colour2' factor2' colour3' factor3
Long Parameter List,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The method has 6 parameters. Parameters: pixel1' pixel2' pixel3' quantifier1' quantifier2' quantifier3
Long Parameter List,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The method has 8 parameters. Parameters: pixel1' pixel2' pixel3' pixel4' quantifier1' quantifier2' quantifier3' quantifier4
Long Parameter List,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The method has 7 parameters. Parameters: sourceImage' srcX' srcY' targetImage' tgtX' tgtY' allowAlphaBlending
Long Parameter List,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_LeftUp2_2X,The method has 5 parameters. Parameters: n3' n2' n1' pixel' blend
Long Parameter List,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_Kernel2Xv5,The method has 16 parameters. Parameters: pe' pi' ph' pf' pg' pc' pd' pb' f4' i4' h5' i5' n1' n2' n3' blend
Long Statement,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,GetTexOpengl,The length of the statement  "            //Console.WriteLine("OpenglGpuImpl.FrameBufferTexture: {0}' {1}' {2}"' OpenglGpuImpl.FrameBufferTexture' GL.IsTexture(OpenglGpuImpl.FrameBufferTexture)' GL.IsTexture(2)); " is 170.
Long Statement,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,Initialize,The length of the statement  "                "attribute vec4 position; attribute vec4 texCoords; varying vec2 v_texCoord; void main() { gl_Position = position; v_texCoord = texCoords.xy; }"' " is 145.
Long Statement,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,Initialize,The length of the statement  "            // TestTexture = GLTexture.Create().SetFormat(TextureFormat.RGBA).SetSize(2' 2).SetData(new uint[] { 0xFF0000FF' 0xFF00FFFF' 0xFFFF00FF' 0xFFFFFFFF }); " is 151.
Long Statement,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,DrawVram,The length of the statement  "                            //ShaderInfo.texture.Set(GLTextureUnit.CreateAtIndex(0).SetFiltering(GLScaleFilter.Nearest).SetWrap(GLWrap.ClampToEdge).SetTexture(TexDepth)); " is 142.
Long Statement,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The length of the statement  "                    //var square0 = new Square(this' inputBitmapDataPixels + y * inputBitmapData.Width + x' inputBitmapData.Width' inputBitmapData.Height' x' y); " is 141.
Long Statement,CSPspEmu.Gui.SMAA,Smaa,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\SMAA\Smaa.cs,pass_blend,The length of the statement  "							gl_FragColor = SMAABlendingWeightCalculationPS(texcoord' pixcoord' offset' edge_tex' area_tex' search_tex' ivec4(1' 1' 1' 0)); " is 126.
Long Statement,CSPspEmu.Gui.SMAA,Smaa,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\SMAA\Smaa.cs,Process,The length of the statement  "            //if (InputColor.Width != InputDepth.Width || InputColor.Height != InputDepth.Height) throw (new Exception("Color.Size != Texture.Size")); " is 138.
Complex Conditional,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,GetColor,The conditional expression  "x < 0 || y < 0 || x >= Width || y >= Height"  is complex.
Complex Conditional,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_Kernel2Xv5,The conditional expression  "(e < i) && (!_IsEqual(pf' pb) && !_IsEqual(ph' pd) ||                              _IsEqual(pe' pi) && (!_IsEqual(pf' i4) && !_IsEqual(ph' i5)) || _IsEqual(pe' pg) ||                              _IsEqual(pe' pc))"  is complex.
Complex Conditional,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_Kernel2Xv5,The conditional expression  "((ke << 1) <= ki) && ex3 || (ke >= (ki << 1)) && ex2"  is complex.
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu,CWCheatEntry,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatEntry.cs,_Patch,The following statement contains a magic number: try              {                  switch (OpCode)                  {                      // [t]8-bit Constant Write 0x0aaaaaaa 0x000000dd                      case 0x0:                          PspMemory.WriteSafe(Address' (byte) BitUtils.Extract(Values[0]' 0' 8));                          break;                      // [t]16-bit Constant write 0x1aaaaaaa 0x0000dddd                      case 0x1:                          PspMemory.WriteSafe(Address' (ushort) BitUtils.Extract(Values[0]' 0' 16));                          break;                      // [t]32-bit Constant write 0x2aaaaaaa 0xdddddddd                      case 0x2:                          PspMemory.WriteSafe(Address' (uint) BitUtils.Extract(Values[0]' 0' 32));                          break;                      // 32-bit Multi-Address Write/Value increase	0x4aaaaaaa 0xxxxxyyyy 0xdddddddd 0xIIIIIIII                      case 0x4:                      {                          var Count = BitUtils.Extract(Values[0]' 16' 16);                          var Increment = BitUtils.Extract(Values[0]' 0' 16);                          var Value = BitUtils.Extract(Values[1]' 0' 32);                          var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                          for (int n = 0; n < Count; n++)                          {                              PspMemory.WriteSafe((uint) (Address + n * Increment)' (uint) (Value + IncrementValue * n));                          }                      }                          break;                      case 0x8:                          // 16-bit Multi-Address Write/Value increas	0x8aaaaaaa 0xxxxxyyyy 0x1000dddd 0xIIIIIIII                          if (BitUtils.Extract(Values[1]' 28' 4) == 1)                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 16);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (ushort) (Value + IncrementValue * n));                              }                          }                          // 8-bit Multi-Address Write/Value increase	0x8aaaaaaa 0xxxxxyyyy 0x000000dd 0xIIIIIIII	                          else                          {                              var Count = BitUtils.Extract(Values[0]' 16' 16);                              var Increment = BitUtils.Extract(Values[0]' 0' 16);                              var Value = BitUtils.Extract(Values[1]' 0' 8);                              var IncrementValue = BitUtils.Extract(Values[2]' 0' 32);                              for (int n = 0; n < Count; n++)                              {                                  PspMemory.WriteSafe((uint) (Address + n * Increment)'                                      (byte) (Value + IncrementValue * n));                              }                          }                          break;                      // 16-bit XOR - 0x7aaaaaaa 0x0005vvvv                      // 8-bit  XOR - 0x7aaaaaaa 0x000400vv                      // 16-bit AND - 0x7aaaaaaa 0x0003vvvv                      // 8-bit  AND - 0x7aaaaaaa 0x000200vv                      // 16-bit OR  - 0x7aaaaaaa 0x0001vvvv                      // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                      case 0x7:                      {                          uint SubOpCode = (Values[0] >> 16) & 0xFFFF;                          uint SubValue = (Values[0] >> 0) & 0xFFFF;                          switch (SubOpCode)                          {                              // 8-bit  OR  - 0x7aaaaaaa 0x000000vv                              case 0:                                  PspMemory.WriteSafe(Address'                                      (byte) (PspMemory.ReadSafe<byte>(Address) | (SubValue & 0xFF)));                                  break;                              default:                                  Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X} : 0x{1:X}"' OpCode' SubOpCode);                                  break;                          }                      }                          break;                      default:                          Console.Error.WriteLine("Invalid CWCheatOpCode: 0x{0:X}"' OpCode);                          break;                  }              }              catch (Exception Exception)              {                  throw (new Exception($"At Address: 0x{Address:X}"' Exception));              }
Magic Number,CSPspEmu.cheats,CWCheatPlugin,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\cheats\CWCheatPlugin.cs,ParseCwCheat,The following statement contains a magic number: foreach (var LineRaw in Lines)              {                  var Line = LineRaw.Trim();                  if (Line.Substr(0' 1) == ";") continue;                  if (Line.Substr(0' 1) == "#") continue;                  var Parts = Line.Split(' '' '\t');                  foreach (var Part in Parts)                  {                      if (Part.Substr(0' 2) == "0x")                      {                          Values.Enqueue((uint) NumberUtils.ParseIntegerConstant(Part));                      }                  }              }
Magic Number,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,GetTexVram,The following statement contains a magic number: if (IGuiWindowInfo.EnableRefreshing)              {                  try                  {                      int Width = 512;                      int Height = 272;                      var FrameAddress = PspDisplay.CurrentInfo.FrameAddress;                      byte* FrameBuffer = null;                      byte* DepthBuffer = null;                      try                      {                          FrameBuffer = (byte*) Memory.PspAddressToPointerSafe(                              FrameAddress'                              PixelFormatDecoder.GetPixelsSize(PspDisplay.CurrentInfo.PixelFormat' Width * Height)                          );                      }                      catch (Exception Exception)                      {                          Console.Error.WriteLine(Exception);                      }                        //Console.Error.WriteLine("FrameBuffer == 0x{0:X}!!"' (long)FrameBuffer);                        if (FrameBuffer == null)                      {                          //Console.Error.WriteLine("FrameBuffer == null!!");                      }                        //Console.WriteLine("{0:X}"' Address);                        var Hash = PixelFormatDecoder.Hash(                          PspDisplay.CurrentInfo.PixelFormat'                          (void*) FrameBuffer'                          Width' Height                      );                        if (Hash != LastHash)                      {                          LastHash = Hash;                          Buffer.LockBitsUnlock(System.Drawing.Imaging.PixelFormat.Format32bppArgb' (BitmapData) =>                          {                              var Count = Width * Height;                              fixed (OutputPixel* BitmapDataDecodePtr = BitmapDataDecode)                              {                                  var BitmapDataPtr = (BGRA*) BitmapData.Scan0.ToPointer();                                    //var LastRow = (FrameBuffer + 512 * 260 * 4 + 4 * 10);                                  //Console.WriteLine("{0}'{1}'{2}'{3}"' LastRow[0]' LastRow[1]' LastRow[2]' LastRow[3]);                                    if (FrameBuffer == null)                                  {                                      if (OldFrameBuffer != null)                                      {                                          Console.Error.WriteLine("FrameBuffer == null");                                      }                                  }                                  else if (BitmapDataPtr == null)                                  {                                      Console.Error.WriteLine("BitmapDataPtr == null");                                  }                                  else                                  {                                      PixelFormatDecoder.Decode(                                          PspDisplay.CurrentInfo.PixelFormat'                                          (void*) FrameBuffer'                                          BitmapDataDecodePtr'                                          Width' Height                                      );                                  }                                    // Converts the decoded data to Window's format.                                  for (int n = 0; n < Count; n++)                                  {                                      BitmapDataPtr[n].R = BitmapDataDecodePtr[n].B;                                      BitmapDataPtr[n].G = BitmapDataDecodePtr[n].G;                                      BitmapDataPtr[n].B = BitmapDataDecodePtr[n].R;                                      BitmapDataPtr[n].A = 0xFF;                                  }                                    OldFrameBuffer = FrameBuffer;                                    GL.glTexImage2D(GL.GL_TEXTURE_2D' 0' GL.GL_RGBA' 512' 272' 0' GL.GL_RGBA'                                      GL.GL_UNSIGNED_BYTE' BitmapDataPtr);                                  TextureVerticalFlip = true;                              }                          });                      }                      //else                      {                          //Console.WriteLine("Display not updated!");                      }                  }                  catch (Exception Exception)                  {                      Console.Error.WriteLine(Exception);                  }              }
Magic Number,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,GetTexVram,The following statement contains a magic number: if (IGuiWindowInfo.EnableRefreshing)              {                  try                  {                      int Width = 512;                      int Height = 272;                      var FrameAddress = PspDisplay.CurrentInfo.FrameAddress;                      byte* FrameBuffer = null;                      byte* DepthBuffer = null;                      try                      {                          FrameBuffer = (byte*) Memory.PspAddressToPointerSafe(                              FrameAddress'                              PixelFormatDecoder.GetPixelsSize(PspDisplay.CurrentInfo.PixelFormat' Width * Height)                          );                      }                      catch (Exception Exception)                      {                          Console.Error.WriteLine(Exception);                      }                        //Console.Error.WriteLine("FrameBuffer == 0x{0:X}!!"' (long)FrameBuffer);                        if (FrameBuffer == null)                      {                          //Console.Error.WriteLine("FrameBuffer == null!!");                      }                        //Console.WriteLine("{0:X}"' Address);                        var Hash = PixelFormatDecoder.Hash(                          PspDisplay.CurrentInfo.PixelFormat'                          (void*) FrameBuffer'                          Width' Height                      );                        if (Hash != LastHash)                      {                          LastHash = Hash;                          Buffer.LockBitsUnlock(System.Drawing.Imaging.PixelFormat.Format32bppArgb' (BitmapData) =>                          {                              var Count = Width * Height;                              fixed (OutputPixel* BitmapDataDecodePtr = BitmapDataDecode)                              {                                  var BitmapDataPtr = (BGRA*) BitmapData.Scan0.ToPointer();                                    //var LastRow = (FrameBuffer + 512 * 260 * 4 + 4 * 10);                                  //Console.WriteLine("{0}'{1}'{2}'{3}"' LastRow[0]' LastRow[1]' LastRow[2]' LastRow[3]);                                    if (FrameBuffer == null)                                  {                                      if (OldFrameBuffer != null)                                      {                                          Console.Error.WriteLine("FrameBuffer == null");                                      }                                  }                                  else if (BitmapDataPtr == null)                                  {                                      Console.Error.WriteLine("BitmapDataPtr == null");                                  }                                  else                                  {                                      PixelFormatDecoder.Decode(                                          PspDisplay.CurrentInfo.PixelFormat'                                          (void*) FrameBuffer'                                          BitmapDataDecodePtr'                                          Width' Height                                      );                                  }                                    // Converts the decoded data to Window's format.                                  for (int n = 0; n < Count; n++)                                  {                                      BitmapDataPtr[n].R = BitmapDataDecodePtr[n].B;                                      BitmapDataPtr[n].G = BitmapDataDecodePtr[n].G;                                      BitmapDataPtr[n].B = BitmapDataDecodePtr[n].R;                                      BitmapDataPtr[n].A = 0xFF;                                  }                                    OldFrameBuffer = FrameBuffer;                                    GL.glTexImage2D(GL.GL_TEXTURE_2D' 0' GL.GL_RGBA' 512' 272' 0' GL.GL_RGBA'                                      GL.GL_UNSIGNED_BYTE' BitmapDataPtr);                                  TextureVerticalFlip = true;                              }                          });                      }                      //else                      {                          //Console.WriteLine("Display not updated!");                      }                  }                  catch (Exception Exception)                  {                      Console.Error.WriteLine(Exception);                  }              }
Magic Number,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,GetTexVram,The following statement contains a magic number: if (IGuiWindowInfo.EnableRefreshing)              {                  try                  {                      int Width = 512;                      int Height = 272;                      var FrameAddress = PspDisplay.CurrentInfo.FrameAddress;                      byte* FrameBuffer = null;                      byte* DepthBuffer = null;                      try                      {                          FrameBuffer = (byte*) Memory.PspAddressToPointerSafe(                              FrameAddress'                              PixelFormatDecoder.GetPixelsSize(PspDisplay.CurrentInfo.PixelFormat' Width * Height)                          );                      }                      catch (Exception Exception)                      {                          Console.Error.WriteLine(Exception);                      }                        //Console.Error.WriteLine("FrameBuffer == 0x{0:X}!!"' (long)FrameBuffer);                        if (FrameBuffer == null)                      {                          //Console.Error.WriteLine("FrameBuffer == null!!");                      }                        //Console.WriteLine("{0:X}"' Address);                        var Hash = PixelFormatDecoder.Hash(                          PspDisplay.CurrentInfo.PixelFormat'                          (void*) FrameBuffer'                          Width' Height                      );                        if (Hash != LastHash)                      {                          LastHash = Hash;                          Buffer.LockBitsUnlock(System.Drawing.Imaging.PixelFormat.Format32bppArgb' (BitmapData) =>                          {                              var Count = Width * Height;                              fixed (OutputPixel* BitmapDataDecodePtr = BitmapDataDecode)                              {                                  var BitmapDataPtr = (BGRA*) BitmapData.Scan0.ToPointer();                                    //var LastRow = (FrameBuffer + 512 * 260 * 4 + 4 * 10);                                  //Console.WriteLine("{0}'{1}'{2}'{3}"' LastRow[0]' LastRow[1]' LastRow[2]' LastRow[3]);                                    if (FrameBuffer == null)                                  {                                      if (OldFrameBuffer != null)                                      {                                          Console.Error.WriteLine("FrameBuffer == null");                                      }                                  }                                  else if (BitmapDataPtr == null)                                  {                                      Console.Error.WriteLine("BitmapDataPtr == null");                                  }                                  else                                  {                                      PixelFormatDecoder.Decode(                                          PspDisplay.CurrentInfo.PixelFormat'                                          (void*) FrameBuffer'                                          BitmapDataDecodePtr'                                          Width' Height                                      );                                  }                                    // Converts the decoded data to Window's format.                                  for (int n = 0; n < Count; n++)                                  {                                      BitmapDataPtr[n].R = BitmapDataDecodePtr[n].B;                                      BitmapDataPtr[n].G = BitmapDataDecodePtr[n].G;                                      BitmapDataPtr[n].B = BitmapDataDecodePtr[n].R;                                      BitmapDataPtr[n].A = 0xFF;                                  }                                    OldFrameBuffer = FrameBuffer;                                    GL.glTexImage2D(GL.GL_TEXTURE_2D' 0' GL.GL_RGBA' 512' 272' 0' GL.GL_RGBA'                                      GL.GL_UNSIGNED_BYTE' BitmapDataPtr);                                  TextureVerticalFlip = true;                              }                          });                      }                      //else                      {                          //Console.WriteLine("Display not updated!");                      }                  }                  catch (Exception Exception)                  {                      Console.Error.WriteLine(Exception);                  }              }
Magic Number,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,GetTexVram,The following statement contains a magic number: if (IGuiWindowInfo.EnableRefreshing)              {                  try                  {                      int Width = 512;                      int Height = 272;                      var FrameAddress = PspDisplay.CurrentInfo.FrameAddress;                      byte* FrameBuffer = null;                      byte* DepthBuffer = null;                      try                      {                          FrameBuffer = (byte*) Memory.PspAddressToPointerSafe(                              FrameAddress'                              PixelFormatDecoder.GetPixelsSize(PspDisplay.CurrentInfo.PixelFormat' Width * Height)                          );                      }                      catch (Exception Exception)                      {                          Console.Error.WriteLine(Exception);                      }                        //Console.Error.WriteLine("FrameBuffer == 0x{0:X}!!"' (long)FrameBuffer);                        if (FrameBuffer == null)                      {                          //Console.Error.WriteLine("FrameBuffer == null!!");                      }                        //Console.WriteLine("{0:X}"' Address);                        var Hash = PixelFormatDecoder.Hash(                          PspDisplay.CurrentInfo.PixelFormat'                          (void*) FrameBuffer'                          Width' Height                      );                        if (Hash != LastHash)                      {                          LastHash = Hash;                          Buffer.LockBitsUnlock(System.Drawing.Imaging.PixelFormat.Format32bppArgb' (BitmapData) =>                          {                              var Count = Width * Height;                              fixed (OutputPixel* BitmapDataDecodePtr = BitmapDataDecode)                              {                                  var BitmapDataPtr = (BGRA*) BitmapData.Scan0.ToPointer();                                    //var LastRow = (FrameBuffer + 512 * 260 * 4 + 4 * 10);                                  //Console.WriteLine("{0}'{1}'{2}'{3}"' LastRow[0]' LastRow[1]' LastRow[2]' LastRow[3]);                                    if (FrameBuffer == null)                                  {                                      if (OldFrameBuffer != null)                                      {                                          Console.Error.WriteLine("FrameBuffer == null");                                      }                                  }                                  else if (BitmapDataPtr == null)                                  {                                      Console.Error.WriteLine("BitmapDataPtr == null");                                  }                                  else                                  {                                      PixelFormatDecoder.Decode(                                          PspDisplay.CurrentInfo.PixelFormat'                                          (void*) FrameBuffer'                                          BitmapDataDecodePtr'                                          Width' Height                                      );                                  }                                    // Converts the decoded data to Window's format.                                  for (int n = 0; n < Count; n++)                                  {                                      BitmapDataPtr[n].R = BitmapDataDecodePtr[n].B;                                      BitmapDataPtr[n].G = BitmapDataDecodePtr[n].G;                                      BitmapDataPtr[n].B = BitmapDataDecodePtr[n].R;                                      BitmapDataPtr[n].A = 0xFF;                                  }                                    OldFrameBuffer = FrameBuffer;                                    GL.glTexImage2D(GL.GL_TEXTURE_2D' 0' GL.GL_RGBA' 512' 272' 0' GL.GL_RGBA'                                      GL.GL_UNSIGNED_BYTE' BitmapDataPtr);                                  TextureVerticalFlip = true;                              }                          });                      }                      //else                      {                          //Console.WriteLine("Display not updated!");                      }                  }                  catch (Exception Exception)                  {                      Console.Error.WriteLine(Exception);                  }              }
Magic Number,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,DrawVram,The following statement contains a magic number: if (                  (PspDisplay.CurrentInfo.Enabled || PspDisplay.CurrentInfo.PlayingVideo)              )              {                  GetTex((Tex) =>                  {                      //Console.Out.WriteLineColored(ConsoleColor.Red' "{0}"' Tex.Texture);                      if (Tex != null && Tex.Color.Texture != 0)                      {                          var TexColor = Tex.Color;                          var TexDepth = Tex.Depth;                            if (EnableSmaa)                          {                              if (TexDepth.Texture != 0)                              {                                  TexColor = Smaa.Process(TexColor' TexDepth);                              }                          }                            GL.glViewport(Rectangle.X' Rectangle.Y' Rectangle.Width' Rectangle.Height);                            Shader.Draw(GLGeometry.GL_TRIANGLE_STRIP' 4' () =>                          {                              var TextureRect = CSharpPlatform.RectangleF.FromCoords(0' 0'                                  (float) PspDisplay.CurrentInfo.Width / 512f'                                  (float) PspDisplay.CurrentInfo.Height / 272f);                              if (TextureVerticalFlip) TextureRect = TextureRect.VFlip();                              TexCoordsBuffer = GLBuffer.Create().SetData(TextureRect.GetFloat2TriangleStripCoords());                                ShaderInfo.texture.Set(GLTextureUnit.CreateAtIndex(0).SetFiltering(GLScaleFilter.Nearest)                                  .SetWrap(GLWrap.ClampToEdge).SetTexture(TexColor));                              //ShaderInfo.texture.Set(GLTextureUnit.CreateAtIndex(0).SetFiltering(GLScaleFilter.Nearest).SetWrap(GLWrap.ClampToEdge).SetTexture(TexDepth));                              ShaderInfo.position.SetData<float>(VertexBuffer' 2);                              ShaderInfo.texCoords.SetData<float>(TexCoordsBuffer' 2);                          });                      }                  });              }
Magic Number,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,DrawVram,The following statement contains a magic number: if (                  (PspDisplay.CurrentInfo.Enabled || PspDisplay.CurrentInfo.PlayingVideo)              )              {                  GetTex((Tex) =>                  {                      //Console.Out.WriteLineColored(ConsoleColor.Red' "{0}"' Tex.Texture);                      if (Tex != null && Tex.Color.Texture != 0)                      {                          var TexColor = Tex.Color;                          var TexDepth = Tex.Depth;                            if (EnableSmaa)                          {                              if (TexDepth.Texture != 0)                              {                                  TexColor = Smaa.Process(TexColor' TexDepth);                              }                          }                            GL.glViewport(Rectangle.X' Rectangle.Y' Rectangle.Width' Rectangle.Height);                            Shader.Draw(GLGeometry.GL_TRIANGLE_STRIP' 4' () =>                          {                              var TextureRect = CSharpPlatform.RectangleF.FromCoords(0' 0'                                  (float) PspDisplay.CurrentInfo.Width / 512f'                                  (float) PspDisplay.CurrentInfo.Height / 272f);                              if (TextureVerticalFlip) TextureRect = TextureRect.VFlip();                              TexCoordsBuffer = GLBuffer.Create().SetData(TextureRect.GetFloat2TriangleStripCoords());                                ShaderInfo.texture.Set(GLTextureUnit.CreateAtIndex(0).SetFiltering(GLScaleFilter.Nearest)                                  .SetWrap(GLWrap.ClampToEdge).SetTexture(TexColor));                              //ShaderInfo.texture.Set(GLTextureUnit.CreateAtIndex(0).SetFiltering(GLScaleFilter.Nearest).SetWrap(GLWrap.ClampToEdge).SetTexture(TexDepth));                              ShaderInfo.position.SetData<float>(VertexBuffer' 2);                              ShaderInfo.texCoords.SetData<float>(TexCoordsBuffer' 2);                          });                      }                  });              }
Magic Number,CSPspEmu.Gui,CommonGuiDisplayOpengl,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiDisplayOpengl.cs,DrawVram,The following statement contains a magic number: if (                  (PspDisplay.CurrentInfo.Enabled || PspDisplay.CurrentInfo.PlayingVideo)              )              {                  GetTex((Tex) =>                  {                      //Console.Out.WriteLineColored(ConsoleColor.Red' "{0}"' Tex.Texture);                      if (Tex != null && Tex.Color.Texture != 0)                      {                          var TexColor = Tex.Color;                          var TexDepth = Tex.Depth;                            if (EnableSmaa)                          {                              if (TexDepth.Texture != 0)                              {                                  TexColor = Smaa.Process(TexColor' TexDepth);                              }                          }                            GL.glViewport(Rectangle.X' Rectangle.Y' Rectangle.Width' Rectangle.Height);                            Shader.Draw(GLGeometry.GL_TRIANGLE_STRIP' 4' () =>                          {                              var TextureRect = CSharpPlatform.RectangleF.FromCoords(0' 0'                                  (float) PspDisplay.CurrentInfo.Width / 512f'                                  (float) PspDisplay.CurrentInfo.Height / 272f);                              if (TextureVerticalFlip) TextureRect = TextureRect.VFlip();                              TexCoordsBuffer = GLBuffer.Create().SetData(TextureRect.GetFloat2TriangleStripCoords());                                ShaderInfo.texture.Set(GLTextureUnit.CreateAtIndex(0).SetFiltering(GLScaleFilter.Nearest)                                  .SetWrap(GLWrap.ClampToEdge).SetTexture(TexColor));                              //ShaderInfo.texture.Set(GLTextureUnit.CreateAtIndex(0).SetFiltering(GLScaleFilter.Nearest).SetWrap(GLWrap.ClampToEdge).SetTexture(TexDepth));                              ShaderInfo.position.SetData<float>(VertexBuffer' 2);                              ShaderInfo.texCoords.SetData<float>(TexCoordsBuffer' 2);                          });                      }                  });              }
Magic Number,HQ2x,ColorAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaThreshold.cs,ColorAlphaThreshold,The following statement contains a magic number: m_Thresholds[0] = yThreshold * 65536;
Magic Number,HQ2x,ColorAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaThreshold.cs,ColorAlphaThreshold,The following statement contains a magic number: m_Thresholds[1] = uThreshold * 65536;
Magic Number,HQ2x,ColorAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaThreshold.cs,ColorAlphaThreshold,The following statement contains a magic number: m_Thresholds[2] = vThreshold * 65536;
Magic Number,HQ2x,ColorAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaThreshold.cs,ColorAlphaThreshold,The following statement contains a magic number: m_Thresholds[2] = vThreshold * 65536;
Magic Number,HQ2x,ColorAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorAlphaThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorOnlyThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyThreshold.cs,ColorOnlyThreshold,The following statement contains a magic number: m_Thresholds[0] = yThreshold * 65536;
Magic Number,HQ2x,ColorOnlyThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyThreshold.cs,ColorOnlyThreshold,The following statement contains a magic number: m_Thresholds[1] = uThreshold * 65536;
Magic Number,HQ2x,ColorOnlyThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyThreshold.cs,ColorOnlyThreshold,The following statement contains a magic number: m_Thresholds[2] = vThreshold * 65536;
Magic Number,HQ2x,ColorOnlyThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyThreshold.cs,ColorOnlyThreshold,The following statement contains a magic number: m_Thresholds[2] = vThreshold * 65536;
Magic Number,HQ2x,ColorOnlyThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorOnlyThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorOnlyThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorOnlyThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,ColorSimpleAlphaThreshold,The following statement contains a magic number: m_Thresholds[0] = yThreshold * 65536;
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,ColorSimpleAlphaThreshold,The following statement contains a magic number: m_Thresholds[1] = uThreshold * 65536;
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,ColorSimpleAlphaThreshold,The following statement contains a magic number: m_Thresholds[2] = vThreshold * 65536;
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,ColorSimpleAlphaThreshold,The following statement contains a magic number: m_Thresholds[2] = vThreshold * 65536;
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,ColorSimpleAlphaThreshold,The following statement contains a magic number: m_Thresholds[3] = aThreshold * 65536;
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,ColorSimpleAlphaThreshold,The following statement contains a magic number: m_Thresholds[3] = aThreshold * 65536;
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 4; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B +                      s_Matrix[i' 3] * color1.A;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B +                      s_Matrix[i' 3] * color2.A;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 4; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B +                      s_Matrix[i' 3] * color1.A;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B +                      s_Matrix[i' 3] * color2.A;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 4; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B +                      s_Matrix[i' 3] * color1.A;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B +                      s_Matrix[i' 3] * color2.A;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 4; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B +                      s_Matrix[i' 3] * color1.A;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B +                      s_Matrix[i' 3] * color2.A;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,ColorSimpleAlphaThreshold,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\ColorSimpleAlphaThreshold.cs,Similar,The following statement contains a magic number: for (int i = 0; i < 4; ++i)              {                  int comp1 =                      s_Matrix[i' 0] * color1.R +                      s_Matrix[i' 1] * color1.G +                      s_Matrix[i' 2] * color1.B +                      s_Matrix[i' 3] * color1.A;                  int comp2 =                      s_Matrix[i' 0] * color2.R +                      s_Matrix[i' 1] * color2.G +                      s_Matrix[i' 2] * color2.B +                      s_Matrix[i' 3] * color2.A;                    if (Math.Abs(comp1 - comp2) > m_Thresholds[i])                      return false;              }
Magic Number,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The following statement contains a magic number: Bitmap outputBitmap = new Bitmap(2 * inputBitmap.Width' 2 * inputBitmap.Height' inputBitmap.PixelFormat);
Magic Number,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The following statement contains a magic number: Bitmap outputBitmap = new Bitmap(2 * inputBitmap.Width' 2 * inputBitmap.Height' inputBitmap.PixelFormat);
Magic Number,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The following statement contains a magic number: for (int y = 0; y < inputBitmap.Height; y++)              {                  var Row0 = outputBitmapPixels + (y * 2 + 0) * outputBitmap.Width;                  var Row1 = outputBitmapPixels + (y * 2 + 1) * outputBitmap.Width;                  for (int x = 0; x < inputBitmap.Width; x++)                  {                      //var square0 = new Square(this' inputBitmapDataPixels + y * inputBitmapData.Width + x' inputBitmapData.Width' inputBitmapData.Height' x' y);                      var square0 = new Square(this' inputBitmapDataPixels' inputBitmapData.Width' inputBitmapData.Height'                          x' y);                      var square90 = square0.RotateCCW();                      var square180 = square90.RotateCCW();                      var square270 = square180.RotateCCW();                        Row0[2 * x + 0] = square0.Resolve();                      Row0[2 * x + 1] = square90.Resolve();                      Row1[2 * x + 1] = square180.Resolve();                      Row1[2 * x + 0] = square270.Resolve();                        //outputBitmap.SetPixel(2 * x + 0' 2 * y + 0' square0.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 0' square90.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 1' square180.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 0' 2 * y + 1' square270.Resolve().ToColor());                  }              }
Magic Number,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The following statement contains a magic number: for (int y = 0; y < inputBitmap.Height; y++)              {                  var Row0 = outputBitmapPixels + (y * 2 + 0) * outputBitmap.Width;                  var Row1 = outputBitmapPixels + (y * 2 + 1) * outputBitmap.Width;                  for (int x = 0; x < inputBitmap.Width; x++)                  {                      //var square0 = new Square(this' inputBitmapDataPixels + y * inputBitmapData.Width + x' inputBitmapData.Width' inputBitmapData.Height' x' y);                      var square0 = new Square(this' inputBitmapDataPixels' inputBitmapData.Width' inputBitmapData.Height'                          x' y);                      var square90 = square0.RotateCCW();                      var square180 = square90.RotateCCW();                      var square270 = square180.RotateCCW();                        Row0[2 * x + 0] = square0.Resolve();                      Row0[2 * x + 1] = square90.Resolve();                      Row1[2 * x + 1] = square180.Resolve();                      Row1[2 * x + 0] = square270.Resolve();                        //outputBitmap.SetPixel(2 * x + 0' 2 * y + 0' square0.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 0' square90.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 1' square180.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 0' 2 * y + 1' square270.Resolve().ToColor());                  }              }
Magic Number,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The following statement contains a magic number: for (int y = 0; y < inputBitmap.Height; y++)              {                  var Row0 = outputBitmapPixels + (y * 2 + 0) * outputBitmap.Width;                  var Row1 = outputBitmapPixels + (y * 2 + 1) * outputBitmap.Width;                  for (int x = 0; x < inputBitmap.Width; x++)                  {                      //var square0 = new Square(this' inputBitmapDataPixels + y * inputBitmapData.Width + x' inputBitmapData.Width' inputBitmapData.Height' x' y);                      var square0 = new Square(this' inputBitmapDataPixels' inputBitmapData.Width' inputBitmapData.Height'                          x' y);                      var square90 = square0.RotateCCW();                      var square180 = square90.RotateCCW();                      var square270 = square180.RotateCCW();                        Row0[2 * x + 0] = square0.Resolve();                      Row0[2 * x + 1] = square90.Resolve();                      Row1[2 * x + 1] = square180.Resolve();                      Row1[2 * x + 0] = square270.Resolve();                        //outputBitmap.SetPixel(2 * x + 0' 2 * y + 0' square0.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 0' square90.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 1' square180.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 0' 2 * y + 1' square270.Resolve().ToColor());                  }              }
Magic Number,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The following statement contains a magic number: for (int y = 0; y < inputBitmap.Height; y++)              {                  var Row0 = outputBitmapPixels + (y * 2 + 0) * outputBitmap.Width;                  var Row1 = outputBitmapPixels + (y * 2 + 1) * outputBitmap.Width;                  for (int x = 0; x < inputBitmap.Width; x++)                  {                      //var square0 = new Square(this' inputBitmapDataPixels + y * inputBitmapData.Width + x' inputBitmapData.Width' inputBitmapData.Height' x' y);                      var square0 = new Square(this' inputBitmapDataPixels' inputBitmapData.Width' inputBitmapData.Height'                          x' y);                      var square90 = square0.RotateCCW();                      var square180 = square90.RotateCCW();                      var square270 = square180.RotateCCW();                        Row0[2 * x + 0] = square0.Resolve();                      Row0[2 * x + 1] = square90.Resolve();                      Row1[2 * x + 1] = square180.Resolve();                      Row1[2 * x + 0] = square270.Resolve();                        //outputBitmap.SetPixel(2 * x + 0' 2 * y + 0' square0.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 0' square90.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 1' square180.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 0' 2 * y + 1' square270.Resolve().ToColor());                  }              }
Magic Number,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The following statement contains a magic number: for (int y = 0; y < inputBitmap.Height; y++)              {                  var Row0 = outputBitmapPixels + (y * 2 + 0) * outputBitmap.Width;                  var Row1 = outputBitmapPixels + (y * 2 + 1) * outputBitmap.Width;                  for (int x = 0; x < inputBitmap.Width; x++)                  {                      //var square0 = new Square(this' inputBitmapDataPixels + y * inputBitmapData.Width + x' inputBitmapData.Width' inputBitmapData.Height' x' y);                      var square0 = new Square(this' inputBitmapDataPixels' inputBitmapData.Width' inputBitmapData.Height'                          x' y);                      var square90 = square0.RotateCCW();                      var square180 = square90.RotateCCW();                      var square270 = square180.RotateCCW();                        Row0[2 * x + 0] = square0.Resolve();                      Row0[2 * x + 1] = square90.Resolve();                      Row1[2 * x + 1] = square180.Resolve();                      Row1[2 * x + 0] = square270.Resolve();                        //outputBitmap.SetPixel(2 * x + 0' 2 * y + 0' square0.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 0' square90.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 1' square180.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 0' 2 * y + 1' square270.Resolve().ToColor());                  }              }
Magic Number,HQ2x,Engine,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Process,The following statement contains a magic number: for (int y = 0; y < inputBitmap.Height; y++)              {                  var Row0 = outputBitmapPixels + (y * 2 + 0) * outputBitmap.Width;                  var Row1 = outputBitmapPixels + (y * 2 + 1) * outputBitmap.Width;                  for (int x = 0; x < inputBitmap.Width; x++)                  {                      //var square0 = new Square(this' inputBitmapDataPixels + y * inputBitmapData.Width + x' inputBitmapData.Width' inputBitmapData.Height' x' y);                      var square0 = new Square(this' inputBitmapDataPixels' inputBitmapData.Width' inputBitmapData.Height'                          x' y);                      var square90 = square0.RotateCCW();                      var square180 = square90.RotateCCW();                      var square270 = square180.RotateCCW();                        Row0[2 * x + 0] = square0.Resolve();                      Row0[2 * x + 1] = square90.Resolve();                      Row1[2 * x + 1] = square180.Resolve();                      Row1[2 * x + 0] = square270.Resolve();                        //outputBitmap.SetPixel(2 * x + 0' 2 * y + 0' square0.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 0' square90.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 1' 2 * y + 1' square180.Resolve().ToColor());                      //outputBitmap.SetPixel(2 * x + 0' 2 * y + 1' square270.Resolve().ToColor());                  }              }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Colors[2] = GetColor(Data' Width' Height' x + 1' y - 1);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Colors[3] = GetColor(Data' Width' Height' x - 1' y);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Colors[4] = GetColor(Data' Width' Height' x' y);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Colors[5] = GetColor(Data' Width' Height' x + 1' y);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Colors[6] = GetColor(Data' Width' Height' x - 1' y + 1);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Colors[7] = GetColor(Data' Width' Height' x' y + 1);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Colors[8] = GetColor(Data' Width' Height' x + 1' y + 1);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 0] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[0]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 1] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[1]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 2] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[2]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 2] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[2]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 2] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[2]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 3] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[3]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 3] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[3]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 3] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[3]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 4] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[5]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 4] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[5]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 4] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[5]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 5] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[6]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 5] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[6]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 5] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[6]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 6] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[7]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 6] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[7]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 6] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[7]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 7] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[8]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 7] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[8]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Square,The following statement contains a magic number: m_Shape[1 << 7] = m_Engine.Threshold.Similar(m_Colors[4]' m_Colors[8]);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[0] = m_Colors[2];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[1] = m_Colors[5];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[2] = m_Colors[8];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[2] = m_Colors[8];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[3] = m_Colors[1];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[4] = m_Colors[4];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[4] = m_Colors[4];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[5] = m_Colors[7];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[5] = m_Colors[7];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[6] = m_Colors[0];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[7] = m_Colors[3];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[7] = m_Colors[3];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[8] = m_Colors[6];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Colors[8] = m_Colors[6];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 0] = m_Shape[1 << 2];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 1] = m_Shape[1 << 4];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 2] = m_Shape[1 << 7];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 2] = m_Shape[1 << 7];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 3] = m_Shape[1 << 1];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 4] = m_Shape[1 << 6];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 4] = m_Shape[1 << 6];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 5] = m_Shape[1 << 0];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 6] = m_Shape[1 << 3];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 6] = m_Shape[1 << 3];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 7] = m_Shape[1 << 5];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,RotateCCW,The following statement contains a magic number: result.m_Shape[1 << 7] = m_Shape[1 << 5];
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Resolve,The following statement contains a magic number: switch (rule)                  {                      case 1: return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 2: return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 3: return Lerp3x1(m_Colors[4]' m_Colors[1]);                      case 4: return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 5: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[1]);                      case 6: return Lerp2x1x1(m_Colors[4]' m_Colors[0]' m_Colors[3]);                      case 7: return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                      case 8: return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 9: return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 10: return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 11: return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                      case 12:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 13:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 14:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp14x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return m_Colors[4];                      case 15:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 16:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp6x1x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 17:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[3]))                              return Lerp2x3x3(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[0]);                      case 18:                          if (m_Engine.Threshold.Similar(m_Colors[1]' m_Colors[5]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[1]' m_Colors[3]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[3]);                      case 19:                          if (m_Engine.Threshold.Similar(m_Colors[3]' m_Colors[7]))                              return Lerp5x2x1(m_Colors[4]' m_Colors[3]' m_Colors[1]);                          else                              return Lerp3x1(m_Colors[4]' m_Colors[1]);                      default:                          return m_Colors[4];                  }
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp3x1,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 3' color2' 1' BGRA.FromArgb(0' 0' 0' 0)' 0);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp2x1x1,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 2' color2' 1' color3' 1);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp5x2x1,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 5' color2' 2' color3' 1);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp5x2x1,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 5' color2' 2' color3' 1);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp6x1x1,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 6' color2' 1' color3' 1);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp2x3x3,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 2' color2' 3' color3' 3);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp2x3x3,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 2' color2' 3' color3' 3);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp2x3x3,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 2' color2' 3' color3' 3);
Magic Number,HQ2x,Square,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\Engine.cs,Lerp14x1x1,The following statement contains a magic number: return m_Engine.Lerp.Lerp(color1' 14' color2' 1' color3' 1);
Magic Number,HQ2x,BGRA,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\RGBA.cs,Clamp,The following statement contains a magic number: if (Value > 255) return 255;
Magic Number,HQ2x,BGRA,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\RGBA.cs,Clamp,The following statement contains a magic number: if (Value > 255) return 255;
Magic Number,HQ2x,BGRA,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\HQ2X\RGBA.cs,FromArgb,The following statement contains a magic number: return FromArgb(255' R' G' B);
Magic Number,CSPspEmu.Gui.SMAA,Smaa,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\SMAA\Smaa.cs,pass_blend,The following statement contains a magic number: return blend_shader.Process((Shader) =>              {                  Shader.GetUniform("edge_tex").Set(GLTextureUnit.CreateAtIndex(0).SetWrap(GLWrap.ClampToEdge)                      .SetFiltering(GLScaleFilter.Linear).SetTexture(edge_tex));                  Shader.GetUniform("area_tex").Set(area_tex_unit.SetIndex(1));                  Shader.GetUniform("search_tex").Set(search_tex_unit.SetIndex(2));              });
Magic Number,CSPspEmu.Gui.texture,TextureHookPlugin,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\texture\TextureHookPlugin.cs,LoadTexMapFile,The following statement contains a magic number: if (File.Exists(LinkedTextureMapFile))              {                  TexMap.Clear();                  foreach (var Line in File.ReadAllLines(LinkedTextureMapFile))                  {                      var Parts = Line.Split(new[] {" "' "\t"}' 2' StringSplitOptions.RemoveEmptyEntries);                      if (Parts.Length > 0)                      {                          var CacheHash = Convert.ToUInt64(Parts[0]' 16);                          TexMap[CacheHash] = Parts[1].Trim();                      }                  }              }
Magic Number,CSPspEmu.Gui.texture,TextureHookPlugin,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\texture\TextureHookPlugin.cs,LoadTexMapFile,The following statement contains a magic number: if (File.Exists(LinkedTextureMapFile))              {                  TexMap.Clear();                  foreach (var Line in File.ReadAllLines(LinkedTextureMapFile))                  {                      var Parts = Line.Split(new[] {" "' "\t"}' 2' StringSplitOptions.RemoveEmptyEntries);                      if (Parts.Length > 0)                      {                          var CacheHash = Convert.ToUInt64(Parts[0]' 16);                          TexMap[CacheHash] = Parts[1].Trim();                      }                  }              }
Magic Number,CSPspEmu.Gui.texture,TextureHookPlugin,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\texture\TextureHookPlugin.cs,Hook,The following statement contains a magic number: if (TexMap.ContainsKey(TextureInfo.TextureCacheKey.TextureHash))              {                  OutBitmap = new Bitmap(Image.FromFile(TexMap[TextureInfo.TextureCacheKey.TextureHash]));              }              else              {                  if (PspStoredConfig.ScaleTextures)                  {                      var InBitmap =                          new Bitmap(TextureInfo.Width' TextureInfo.Height).SetChannelsDataInterleaved(                              TextureInfo.Data.CastToStructArray<OutputPixel' byte>()' BitmapChannelList.Rgba);                      OutBitmap =                          (new Engine(new ColorAlphaLerp()' new ColorAlphaThreshold(32' 32' 32' 32))).Process(InBitmap);                  }              }
Magic Number,CSPspEmu.Gui.texture,TextureHookPlugin,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\texture\TextureHookPlugin.cs,Hook,The following statement contains a magic number: if (TexMap.ContainsKey(TextureInfo.TextureCacheKey.TextureHash))              {                  OutBitmap = new Bitmap(Image.FromFile(TexMap[TextureInfo.TextureCacheKey.TextureHash]));              }              else              {                  if (PspStoredConfig.ScaleTextures)                  {                      var InBitmap =                          new Bitmap(TextureInfo.Width' TextureInfo.Height).SetChannelsDataInterleaved(                              TextureInfo.Data.CastToStructArray<OutputPixel' byte>()' BitmapChannelList.Rgba);                      OutBitmap =                          (new Engine(new ColorAlphaLerp()' new ColorAlphaThreshold(32' 32' 32' 32))).Process(InBitmap);                  }              }
Magic Number,CSPspEmu.Gui.texture,TextureHookPlugin,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\texture\TextureHookPlugin.cs,Hook,The following statement contains a magic number: if (TexMap.ContainsKey(TextureInfo.TextureCacheKey.TextureHash))              {                  OutBitmap = new Bitmap(Image.FromFile(TexMap[TextureInfo.TextureCacheKey.TextureHash]));              }              else              {                  if (PspStoredConfig.ScaleTextures)                  {                      var InBitmap =                          new Bitmap(TextureInfo.Width' TextureInfo.Height).SetChannelsDataInterleaved(                              TextureInfo.Data.CastToStructArray<OutputPixel' byte>()' BitmapChannelList.Rgba);                      OutBitmap =                          (new Engine(new ColorAlphaLerp()' new ColorAlphaThreshold(32' 32' 32' 32))).Process(InBitmap);                  }              }
Magic Number,CSPspEmu.Gui.texture,TextureHookPlugin,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\texture\TextureHookPlugin.cs,Hook,The following statement contains a magic number: if (TexMap.ContainsKey(TextureInfo.TextureCacheKey.TextureHash))              {                  OutBitmap = new Bitmap(Image.FromFile(TexMap[TextureInfo.TextureCacheKey.TextureHash]));              }              else              {                  if (PspStoredConfig.ScaleTextures)                  {                      var InBitmap =                          new Bitmap(TextureInfo.Width' TextureInfo.Height).SetChannelsDataInterleaved(                              TextureInfo.Data.CastToStructArray<OutputPixel' byte>()' BitmapChannelList.Rgba);                      OutBitmap =                          (new Engine(new ColorAlphaLerp()' new ColorAlphaThreshold(32' 32' 32' 32))).Process(InBitmap);                  }              }
Magic Number,Imager,cImage,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\cImage.cs,ToBitmap,The following statement contains a magic number: var fillBytes = bitmapData.Stride - bitmapData.Width * 4;
Magic Number,Imager,cImage,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\cImage.cs,ToBitmap,The following statement contains a magic number: unsafe              {                  var offset = (byte*) bitmapData.Scan0.ToPointer();                  for (var y = sy; y < sy + height; y++)                  {                      for (var x = sx; x < sx + width; x++)                      {                          var pixel = this[x' y];                          *(offset + 3) = pixel.Alpha;                          *(offset + 2) = pixel.Red;                          *(offset + 1) = pixel.Green;                          *(offset + 0) = pixel.Blue;                          offset += 4;                      }                      offset += fillBytes;                  }              }
Magic Number,Imager,cImage,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\cImage.cs,ToBitmap,The following statement contains a magic number: unsafe              {                  var offset = (byte*) bitmapData.Scan0.ToPointer();                  for (var y = sy; y < sy + height; y++)                  {                      for (var x = sx; x < sx + width; x++)                      {                          var pixel = this[x' y];                          *(offset + 3) = pixel.Alpha;                          *(offset + 2) = pixel.Red;                          *(offset + 1) = pixel.Green;                          *(offset + 0) = pixel.Blue;                          offset += 4;                      }                      offset += fillBytes;                  }              }
Magic Number,Imager,cImage,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\cImage.cs,ToBitmap,The following statement contains a magic number: unsafe              {                  var offset = (byte*) bitmapData.Scan0.ToPointer();                  for (var y = sy; y < sy + height; y++)                  {                      for (var x = sx; x < sx + width; x++)                      {                          var pixel = this[x' y];                          *(offset + 3) = pixel.Alpha;                          *(offset + 2) = pixel.Red;                          *(offset + 1) = pixel.Green;                          *(offset + 0) = pixel.Blue;                          offset += 4;                      }                      offset += fillBytes;                  }              }
Magic Number,Imager,cImage,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\cImage.cs,FromBitmap,The following statement contains a magic number: var intFillX = bitmapData.Stride - bitmapData.Width * 4;
Magic Number,Imager,cImage,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\cImage.cs,FromBitmap,The following statement contains a magic number: unsafe              {                  var ptrOffset = (byte*) bitmapData.Scan0.ToPointer();                  for (var y = 0; y < height; y++)                  {                      for (var x = 0; x < width; x++)                      {                          result[x' y] = new sPixel(*(ptrOffset + 2)' *(ptrOffset + 1)' *(ptrOffset + 0)'                              *(ptrOffset + 3));                          ptrOffset += 4;                      }                      ptrOffset += intFillX;                  }              }
Magic Number,Imager,cImage,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\cImage.cs,FromBitmap,The following statement contains a magic number: unsafe              {                  var ptrOffset = (byte*) bitmapData.Scan0.ToPointer();                  for (var y = 0; y < height; y++)                  {                      for (var x = 0; x < width; x++)                      {                          result[x' y] = new sPixel(*(ptrOffset + 2)' *(ptrOffset + 1)' *(ptrOffset + 0)'                              *(ptrOffset + 3));                          ptrOffset += 4;                      }                      ptrOffset += intFillX;                  }              }
Magic Number,Imager,cImage,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\cImage.cs,FromBitmap,The following statement contains a magic number: unsafe              {                  var ptrOffset = (byte*) bitmapData.Scan0.ToPointer();                  for (var y = 0; y < height; y++)                  {                      for (var x = 0; x < width; x++)                      {                          result[x' y] = new sPixel(*(ptrOffset + 2)' *(ptrOffset + 1)' *(ptrOffset + 0)'                              *(ptrOffset + 3));                          ptrOffset += 4;                      }                      ptrOffset += intFillX;                  }              }
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,_GetAlpha,The following statement contains a magic number: return ((byte) (rgbBytes >> 24));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,_GetRed,The following statement contains a magic number: return ((byte) (rgbBytes >> 16));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,_GetGreen,The following statement contains a magic number: return ((byte) (rgbBytes >> 8));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,FromFloat,The following statement contains a magic number: return (new sPixel(                  _Float2Byte(red * 255 + .5f)'                  _Float2Byte(green * 255 + .5f)'                  _Float2Byte(blue * 255 + .5f)'                  _Float2Byte(alpha * 255 + .5f)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,FromFloat,The following statement contains a magic number: return (new sPixel(                  _Float2Byte(red * 255 + .5f)'                  _Float2Byte(green * 255 + .5f)'                  _Float2Byte(blue * 255 + .5f)'                  _Float2Byte(alpha * 255 + .5f)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,FromFloat,The following statement contains a magic number: return (new sPixel(                  _Float2Byte(red * 255 + .5f)'                  _Float2Byte(green * 255 + .5f)'                  _Float2Byte(blue * 255 + .5f)'                  _Float2Byte(alpha * 255 + .5f)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,FromFloat,The following statement contains a magic number: return (new sPixel(                  _Float2Byte(red * 255 + .5f)'                  _Float2Byte(green * 255 + .5f)'                  _Float2Byte(blue * 255 + .5f)'                  _Float2Byte(alpha * 255 + .5f)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,sPixel,The following statement contains a magic number: this._rgbBytes = (uint) alpha << 24 | (uint) red << 16 | (uint) green << 8 | blue;
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,sPixel,The following statement contains a magic number: this._rgbBytes = (uint) alpha << 24 | (uint) red << 16 | (uint) green << 8 | blue;
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,sPixel,The following statement contains a magic number: this._rgbBytes = (uint) alpha << 24 | (uint) red << 16 | (uint) green << 8 | blue;
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The following statement contains a magic number: return (new sPixel(                  (byte) ((pixel1.Red + pixel2.Red + pixel3.Red) / 3)'                  (byte) ((pixel1.Green + pixel2.Green + pixel3.Green) / 3)'                  (byte) ((pixel1.Blue + pixel2.Blue + pixel3.Blue) / 3)'                  (byte) ((pixel1.Alpha + pixel2.Alpha + pixel3.Alpha) / 3)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The following statement contains a magic number: return (new sPixel(                  (byte) ((pixel1.Red + pixel2.Red + pixel3.Red) / 3)'                  (byte) ((pixel1.Green + pixel2.Green + pixel3.Green) / 3)'                  (byte) ((pixel1.Blue + pixel2.Blue + pixel3.Blue) / 3)'                  (byte) ((pixel1.Alpha + pixel2.Alpha + pixel3.Alpha) / 3)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The following statement contains a magic number: return (new sPixel(                  (byte) ((pixel1.Red + pixel2.Red + pixel3.Red) / 3)'                  (byte) ((pixel1.Green + pixel2.Green + pixel3.Green) / 3)'                  (byte) ((pixel1.Blue + pixel2.Blue + pixel3.Blue) / 3)'                  (byte) ((pixel1.Alpha + pixel2.Alpha + pixel3.Alpha) / 3)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The following statement contains a magic number: return (new sPixel(                  (byte) ((pixel1.Red + pixel2.Red + pixel3.Red) / 3)'                  (byte) ((pixel1.Green + pixel2.Green + pixel3.Green) / 3)'                  (byte) ((pixel1.Blue + pixel2.Blue + pixel3.Blue) / 3)'                  (byte) ((pixel1.Alpha + pixel2.Alpha + pixel3.Alpha) / 3)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The following statement contains a magic number: return (new sPixel(                  (byte) ((pixel1.Red + pixel2.Red + pixel3.Red + pixel4.Red) >> 2)'                  (byte) ((pixel1.Green + pixel2.Green + pixel3.Green + pixel4.Green) >> 2)'                  (byte) ((pixel1.Blue + pixel2.Blue + pixel3.Blue + pixel4.Blue) >> 2)'                  (byte) ((pixel1.Alpha + pixel2.Alpha + pixel3.Alpha + pixel4.Alpha) >> 2)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The following statement contains a magic number: return (new sPixel(                  (byte) ((pixel1.Red + pixel2.Red + pixel3.Red + pixel4.Red) >> 2)'                  (byte) ((pixel1.Green + pixel2.Green + pixel3.Green + pixel4.Green) >> 2)'                  (byte) ((pixel1.Blue + pixel2.Blue + pixel3.Blue + pixel4.Blue) >> 2)'                  (byte) ((pixel1.Alpha + pixel2.Alpha + pixel3.Alpha + pixel4.Alpha) >> 2)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The following statement contains a magic number: return (new sPixel(                  (byte) ((pixel1.Red + pixel2.Red + pixel3.Red + pixel4.Red) >> 2)'                  (byte) ((pixel1.Green + pixel2.Green + pixel3.Green + pixel4.Green) >> 2)'                  (byte) ((pixel1.Blue + pixel2.Blue + pixel3.Blue + pixel4.Blue) >> 2)'                  (byte) ((pixel1.Alpha + pixel2.Alpha + pixel3.Alpha + pixel4.Alpha) >> 2)              ));
Magic Number,Imager,sPixel,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\sPixel.cs,Interpolate,The following statement contains a magic number: return (new sPixel(                  (byte) ((pixel1.Red + pixel2.Red + pixel3.Red + pixel4.Red) >> 2)'                  (byte) ((pixel1.Green + pixel2.Green + pixel3.Green + pixel4.Green) >> 2)'                  (byte) ((pixel1.Blue + pixel2.Blue + pixel3.Blue + pixel4.Blue) >> 2)'                  (byte) ((pixel1.Alpha + pixel2.Alpha + pixel3.Alpha + pixel4.Alpha) >> 2)              ));
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var a1 = sourceImage[srcX - 1' srcY - 2];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var b1 = sourceImage[srcX + 0' srcY - 2];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var c1 = sourceImage[srcX + 1' srcY - 2];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var a0 = sourceImage[srcX - 2' srcY - 1];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var d0 = sourceImage[srcX - 2' srcY + 0];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var g0 = sourceImage[srcX - 2' srcY + 1];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var c4 = sourceImage[srcX + 2' srcY - 1];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var f4 = sourceImage[srcX + 2' srcY + 0];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var i4 = sourceImage[srcX + 2' srcY + 1];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var g5 = sourceImage[srcX - 1' srcY + 2];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var h5 = sourceImage[srcX + 0' srcY + 2];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,Xbr2X,The following statement contains a magic number: var i5 = sourceImage[srcX + 1' srcY + 2];
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_AlphaBlend64W,The following statement contains a magic number: if (blend)                  dst = sPixel.Interpolate(dst' src' 3' 1);
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_AlphaBlend192W,The following statement contains a magic number: dst = blend ? sPixel.Interpolate(dst' src' 1' 3) : src;
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_AlphaBlend224W,The following statement contains a magic number: dst = blend ? sPixel.Interpolate(dst' src' 1' 7) : src;
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_Kernel2Xv5,The following statement contains a magic number: var e =                  (_YuvDifference(pe' pc) + _YuvDifference(pe' pg) + _YuvDifference(pi' h5) + _YuvDifference(pi' f4)) +                  (_YuvDifference(ph' pf) << 2);
Magic Number,Imager.Filters,libXBR,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\libXBR2x.cs,_Kernel2Xv5,The following statement contains a magic number: var i =                  (_YuvDifference(ph' pd) + _YuvDifference(ph' i5) + _YuvDifference(pf' i4) + _YuvDifference(pf' pb)) +                  (_YuvDifference(pe' pi) << 2);
Magic Number,Imager.Interface,OutOfBoundsUtils,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\OutOfBoundsMode.cs,_HalfSampleSymmetric,The following statement contains a magic number: while (true)              {                  if (index < 0)                      index = -1 - index;                  else if (index >= count)                      index = (2 * count - 1) - index;                  else                      return (index);              }
Magic Number,Imager.Interface,OutOfBoundsUtils,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\OutOfBoundsMode.cs,_WholeSampleSymmetric,The following statement contains a magic number: while (true)              {                  if (index < 0)                      index = -index;                  else if (index >= count)                      index = (2 * count - 2) - index;                  else                      return (index);              }
Magic Number,Imager.Interface,OutOfBoundsUtils,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\OutOfBoundsMode.cs,_WholeSampleSymmetric,The following statement contains a magic number: while (true)              {                  if (index < 0)                      index = -index;                  else if (index >= count)                      index = (2 * count - 2) - index;                  else                      return (index);              }
Magic Number,CSPspEmu.Gui.XBR.Shader,XBRShader,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\Shader\XBRShader.cs,Process,The following statement contains a magic number: Filter.SetSize(Input.Width * 2' Input.Height * 2);
Magic Number,CSPspEmu.Gui.XBR.Shader,XBRShader,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\XBR\Shader\XBRShader.cs,Process,The following statement contains a magic number: Filter.SetSize(Input.Width * 2' Input.Height * 2);
Missing Default,CSPspEmu.Gui,CommonGuiInput,C:\repos\soywiz_cspspemu\Gui\CSPspEmu.Gui\CommonGuiInput.cs,TryUpdateAnalog,The following switch statement is missing a default case: switch (AnalogKeyMap.GetOrDefault(Key' PspCtrlAnalog.None))              {                  case PspCtrlAnalog.Up:                      AnalogUp = Press;                      break;                  case PspCtrlAnalog.Down:                      AnalogDown = Press;                      break;                  case PspCtrlAnalog.Left:                      AnalogLeft = Press;                      break;                  case PspCtrlAnalog.Right:                      AnalogRight = Press;                      break;              }
