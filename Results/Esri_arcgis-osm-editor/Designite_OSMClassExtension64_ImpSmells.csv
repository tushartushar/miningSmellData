Implementation smell,Namespace,Class,File,Method,Description
Long Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The method has 287 lines of code.
Long Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The method has 308 lines of code.
Long Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,The method has 111 lines of code.
Long Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The method has 221 lines of code.
Long Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The method has 202 lines of code.
Long Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The method has 339 lines of code.
Long Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The method has 209 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The method has 287 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The method has 308 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,The method has 111 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The method has 221 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The method has 202 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The method has 339 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The method has 209 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,retrieveOSMTags,The method has 164 lines of code.
Long Method,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,insertOSMTags,The method has 126 lines of code.
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,Cyclomatic complexity of the method is 29
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,Cyclomatic complexity of the method is 22
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,hasOSMRelevantChanges,Cyclomatic complexity of the method is 13
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,assignBasicMetadata,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,mergeOSMTags,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,Cyclomatic complexity of the method is 11
Complex Method,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,storeSupportingGeometry,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,Cyclomatic complexity of the method is 29
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,Cyclomatic complexity of the method is 22
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,hasOSMRelevantChanges,Cyclomatic complexity of the method is 13
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,assignBasicMetadata,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,mergeOSMTags,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,Cyclomatic complexity of the method is 11
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,storeSupportingGeometry,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,retrieveOSMTags,Cyclomatic complexity of the method is 18
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,insertOSMTags,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,DoesHaveKeys,Cyclomatic complexity of the method is 9
Long Parameter List,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,RemoveOSMIDfromRelation,The method has 6 parameters. Parameters: relationTable' relationID' deleteMemberType' idToDelete' relationVersion' relationChangeset
Long Parameter List,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,The method has 8 parameters. Parameters: revisionTable' osmAction' osmElementType' sourceFCName' elementID' osmVersion' osmChangeSet' deletePoint
Long Parameter List,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,assignBasicMetadata,The method has 6 parameters. Parameters: pointFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' osmID' osmVersion
Long Parameter List,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The method has 6 parameters. Parameters: newlyCreatedFeature' pointFeatureClass' action' osmNewFeatureIDFieldIndex' partPointCollection' trackChanges
Long Parameter List,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The method has 9 parameters. Parameters: action' workingFeature' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges
Long Parameter List,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,storeSupportingGeometry,The method has 11 parameters. Parameters: supportingGeometry' storeFeatureClass' osmIdentifier' parentOSMID' osmIDFieldIndex' osmVersionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesIndex' trackChanges
Long Parameter List,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,RemoveOSMIDfromRelation,The method has 6 parameters. Parameters: relationTable' relationID' deleteMemberType' idToDelete' relationVersion' relationChangeset
Long Parameter List,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,The method has 8 parameters. Parameters: revisionTable' osmAction' osmElementType' sourceFCName' elementID' osmVersion' osmChangeSet' deletePoint
Long Parameter List,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,assignBasicMetadata,The method has 6 parameters. Parameters: pointFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' osmID' osmVersion
Long Parameter List,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The method has 6 parameters. Parameters: newlyCreatedFeature' pointFeatureClass' action' osmNewFeatureIDFieldIndex' partPointCollection' trackChanges
Long Parameter List,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The method has 9 parameters. Parameters: action' workingFeature' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges
Long Parameter List,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,storeSupportingGeometry,The method has 11 parameters. Parameters: supportingGeometry' storeFeatureClass' osmIdentifier' parentOSMID' osmIDFieldIndex' osmVersionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesIndex' trackChanges
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the parameter osmChangeFeatureVersionFieldIndex is 33.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the parameter osmChangeFeatureSupportElementFieldIndex is 40.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the parameter osmChangeFeatureIsMemberOfFieldIndex is 36.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the parameter osmChangeFeatureTimeStampFieldIndex is 35.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the parameter osmTrackFeatureChangesFieldIndex is 32.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the parameter osmNewFeatureVersionFieldIndex is 30.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the parameter osmNewFeatureSupportElementFieldIndex is 37.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the parameter osmNewFeatureIsMemberOfFieldIndex is 33.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the parameter osmNewFeatureTimeStampFieldIndex is 32.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the parameter workingFeatureMembersFieldIndex is 31.
Long Identifier,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the parameter existingPolygonGeometryCollection is 33.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the parameter osmChangeFeatureVersionFieldIndex is 33.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the parameter osmChangeFeatureSupportElementFieldIndex is 40.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the parameter osmChangeFeatureIsMemberOfFieldIndex is 36.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the parameter osmChangeFeatureTimeStampFieldIndex is 35.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the parameter osmTrackFeatureChangesFieldIndex is 32.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the parameter osmNewFeatureVersionFieldIndex is 30.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the parameter osmNewFeatureSupportElementFieldIndex is 37.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the parameter osmNewFeatureIsMemberOfFieldIndex is 33.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the parameter osmNewFeatureTimeStampFieldIndex is 32.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the parameter workingFeatureMembersFieldIndex is 31.
Long Identifier,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the parameter existingPolygonGeometryCollection is 33.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ArcGISCategoryRegistration,The length of the statement  "            Registry.ClassesRoot.CreateSubKey(regKey.Substring(18) + "\\Implemented Categories\\{D4E2A322-5D59-11D2-89FD-006097AFF44E}"); " is 125.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ArcGISCategoryUnregistration,The length of the statement  "            Registry.ClassesRoot.DeleteSubKey(regKey.Substring(18) + "\\Implemented Categories\\{D4E2A322-5D59-11D2-89FD-006097AFF44E}"); " is 125.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,Init,The length of the statement  "                m_wgs84 = spatialReferenceFactory.CreateGeographicCoordinateSystem((int)esriSRGeoCSType.esriSRGeoCS_WGS1984) as ISpatialReference; " is 130.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "            // this could be the case if there is no feature class extension' this is very unlikely as the fc extension itself triggers this code " is 133.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "            if (osmFeatureClassExtensionCLSID.Value.ToString().Equals("{65CA4847-8661-45eb-8E1E-B2985CA17C78}"' StringComparison.InvariantCultureIgnoreCase) == false) " is 154.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                bool IdRemoved = RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.node' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 211.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                        LogOSMAction(revisionTable' "modify"' "relation"' ((IDataset)relationTable).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 159.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                        LogOSMAction(revisionTable' "delete"' "node"' ((IDataset)deleteFeature.Class).Name' osmID' osmVersion' osmChangeSet' (IPoint)deleteFeature.Shape); " is 146.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.node' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 194.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                    LogOSMAction(revisionTable' "modify"' "relation"' ((IDataset)relationTable).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 159.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                queryfilter.WhereClause = deleteFeatureClass.WhereClauseByExtensionVersion(currentosmRelationMember.@ref' "OSMID"' _ExtensionVersion); " is 134.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                    LogOSMAction(revisionTable' "delete"' "relation"' ((IDataset)deleteFeature.Class).Name' deleteFeatureOSMID' osmVersion' osmChangeSet' null); " is 140.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                    LogOSMAction(revisionTable' "delete"' "way"' ((IDataset)deleteFeature.Class).Name' deleteFeatureOSMID' osmVersion' osmChangeSet' null); " is 135.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                        bool IdRemoved = RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.way' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 210.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                LogOSMAction(revisionTable' "modify"' "relation"' ((IDataset)relationTable).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 159.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                        bool IdRemoved = RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.way' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 210.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                LogOSMAction((ITable)currentObjectFeatureClass' "modify"' "way"' ((IDataset)currentObjectFeatureClass).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 186.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                        bool IdRemoved = RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.way' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 210.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                LogOSMAction((ITable)currentObjectFeatureClass' "modify"' "way"' ((IDataset)currentObjectFeatureClass).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 186.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "            // this could be the case if there is no feature class extension' this is very unlikely as the fc extension itself triggers this code " is 133.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "            if (osmFeatureClassExtensionCLSID.Value.ToString().Equals("{65CA4847-8661-45eb-8E1E-B2985CA17C78}"' StringComparison.InvariantCultureIgnoreCase) == false) " is 154.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                                System.Diagnostics.Debug.WriteLine("unable to locate point (osm node) feature class. defering updates to stop edit operation."); " is 128.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                            pointCollection = createOSMRelationNodeClusters("change"' changeFeature' osmChangeFeatureIDFieldIndex' osmChangeFeatureVersionFieldIndex' osmChangeFeatureSupportElementFieldIndex' osmChangeFeatureIsMemberOfFieldIndex' osmChangeFeatureTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 296.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                            pointCollection = checkAllPoints(changeFeature' pointFeatureClass' "modify"' osmChangeFeatureIDFieldIndex' pointCollection' trackChanges); " is 138.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                // if the ids of the orginal and the changed feature geometry are the same and no attributes have changed then we don't need to " is 127.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                    LogOSMAction(revisionTable' "modify"' determineOSMTypeByClassNameAndGeometry(((IDataset)changeFeature.Class).Name' changeFeature.Shape)' ((IDataset)changeFeature.Class).Name' currentFeatureOSMID' currentFeatureVersion' -1' null); " is 229.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,hasOSMRelevantChanges,The length of the statement  "                            IEnumVertex differenceVertexCollection = ((IPointCollection)((IRow)inputRowChanges).get_Value(attributeIndex)).EnumVertices as IEnumVertex; " is 139.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,The length of the statement  "            // at this point this a delete request for some that the server doesn't even know about yet - hence no tracking required " is 120.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                    assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 124.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                    assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 124.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                    IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1); " is 136.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                        assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 123.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                            assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 124.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                            assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 124.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                                    // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved " is 121.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                                                testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000); " is 131.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                                                testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1); " is 130.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                                            bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper); " is 138.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,mergeOSMTags,The length of the statement  "                _osmUtility.insertOSMTags(tagCollectionFieldIndex' source' tagList.Values.ToArray()' ((IDataset)mergeFeature.Class).Workspace); " is 127.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                // this could be the case if there is no feature class extension' this is very unlikely as the fc extension itself triggers this code " is 133.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                if (osmFeatureClassExtensionCLSID.Value.ToString().Equals("{65CA4847-8661-45eb-8E1E-B2985CA17C78}"' StringComparison.InvariantCultureIgnoreCase) == false) " is 154.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                            // if the code in instructed to create a new feature with a negative OSMID then something else duplicating a new feature with " is 125.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                            // existing attributes - that is not allowed by definition hence to decrement the temporary index by 1 to indicate a new feature " is 128.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                    // ensure that the incoming geometry are conforming to the node limit of OSM as well as multi-part geometries being prepared to be  " is 130.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                    pointCollection = createOSMRelationNodeClusters("add"' newlyCreatedFeature' osmNewFeatureIDFieldIndex' osmNewFeatureVersionFieldIndex' osmNewFeatureSupportElementFieldIndex' osmNewFeatureIsMemberOfFieldIndex' osmNewFeatureTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 284.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                        IPointCollection geometryPartPointCollection = existingGeometryCollection.get_Geometry(geometryIndex) as IPointCollection; " is 122.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                        geometryPartPointCollection = checkAllPoints(newlyCreatedFeature' pointFeatureClass' "create"' osmNewFeatureIDFieldIndex' geometryPartPointCollection' trackChanges); " is 165.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                            LogOSMAction(revisionTable' "create"' "relation"' ((IDataset)newlyCreatedFeature.Class).Name' featureOSMID' 1' -1' null); " is 121.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry); " is 124.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                                        nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion); " is 123.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper); " is 146.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                                        // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct  " is 121.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                                            // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info) " is 136.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                    storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 348.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                            storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 348.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 337.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                        IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection; " is 178.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                            IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection; " is 121.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex); " is 153.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 359.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 359.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                            string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex); " is 153.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 362.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                            storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 374.
Long Statement,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,CanBypassStoreMethod,The length of the statement  "            // we need to return false as we need track all changes' done through gp' inside or outside an edit session' engine' desktop' and server " is 136.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ArcGISCategoryRegistration,The length of the statement  "            Registry.ClassesRoot.CreateSubKey(regKey.Substring(18) + "\\Implemented Categories\\{D4E2A322-5D59-11D2-89FD-006097AFF44E}"); " is 125.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ArcGISCategoryUnregistration,The length of the statement  "            Registry.ClassesRoot.DeleteSubKey(regKey.Substring(18) + "\\Implemented Categories\\{D4E2A322-5D59-11D2-89FD-006097AFF44E}"); " is 125.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,Init,The length of the statement  "                m_wgs84 = spatialReferenceFactory.CreateGeographicCoordinateSystem((int)esriSRGeoCSType.esriSRGeoCS_WGS1984) as ISpatialReference; " is 130.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "            // this could be the case if there is no feature class extension' this is very unlikely as the fc extension itself triggers this code " is 133.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "            if (osmFeatureClassExtensionCLSID.Value.ToString().Equals("{65CA4847-8661-45eb-8E1E-B2985CA17C78}"' StringComparison.InvariantCultureIgnoreCase) == false) " is 154.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                bool IdRemoved = RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.node' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 211.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                        LogOSMAction(revisionTable' "modify"' "relation"' ((IDataset)relationTable).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 159.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                        LogOSMAction(revisionTable' "delete"' "node"' ((IDataset)deleteFeature.Class).Name' osmID' osmVersion' osmChangeSet' (IPoint)deleteFeature.Shape); " is 146.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.node' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 194.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                    LogOSMAction(revisionTable' "modify"' "relation"' ((IDataset)relationTable).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 159.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                queryfilter.WhereClause = deleteFeatureClass.WhereClauseByExtensionVersion(currentosmRelationMember.@ref' "OSMID"' _ExtensionVersion); " is 134.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                    LogOSMAction(revisionTable' "delete"' "relation"' ((IDataset)deleteFeature.Class).Name' deleteFeatureOSMID' osmVersion' osmChangeSet' null); " is 140.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                    LogOSMAction(revisionTable' "delete"' "way"' ((IDataset)deleteFeature.Class).Name' deleteFeatureOSMID' osmVersion' osmChangeSet' null); " is 135.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                        bool IdRemoved = RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.way' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 210.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                LogOSMAction(revisionTable' "modify"' "relation"' ((IDataset)relationTable).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 159.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                        bool IdRemoved = RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.way' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 210.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                LogOSMAction((ITable)currentObjectFeatureClass' "modify"' "way"' ((IDataset)currentObjectFeatureClass).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 186.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                        bool IdRemoved = RemoveOSMIDfromRelation(relationTable' Convert.ToInt64(relationIDandType.Key)' memberType.way' Convert.ToInt64(deleteFeature.get_Value(osmIDFieldIndex))' out relationVersion' out osmChangeSet); " is 210.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureDeletes,The length of the statement  "                                LogOSMAction((ITable)currentObjectFeatureClass' "modify"' "way"' ((IDataset)currentObjectFeatureClass).Name' Convert.ToInt32(relationIDandType.Key)' relationVersion' osmChangeSet' null); " is 186.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "            // this could be the case if there is no feature class extension' this is very unlikely as the fc extension itself triggers this code " is 133.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "            if (osmFeatureClassExtensionCLSID.Value.ToString().Equals("{65CA4847-8661-45eb-8E1E-B2985CA17C78}"' StringComparison.InvariantCultureIgnoreCase) == false) " is 154.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                                System.Diagnostics.Debug.WriteLine("unable to locate point (osm node) feature class. defering updates to stop edit operation."); " is 128.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                            pointCollection = createOSMRelationNodeClusters("change"' changeFeature' osmChangeFeatureIDFieldIndex' osmChangeFeatureVersionFieldIndex' osmChangeFeatureSupportElementFieldIndex' osmChangeFeatureIsMemberOfFieldIndex' osmChangeFeatureTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 296.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                            pointCollection = checkAllPoints(changeFeature' pointFeatureClass' "modify"' osmChangeFeatureIDFieldIndex' pointCollection' trackChanges); " is 138.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                // if the ids of the orginal and the changed feature geometry are the same and no attributes have changed then we don't need to " is 127.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The length of the statement  "                    LogOSMAction(revisionTable' "modify"' determineOSMTypeByClassNameAndGeometry(((IDataset)changeFeature.Class).Name' changeFeature.Shape)' ((IDataset)changeFeature.Class).Name' currentFeatureOSMID' currentFeatureVersion' -1' null); " is 229.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,hasOSMRelevantChanges,The length of the statement  "                            IEnumVertex differenceVertexCollection = ((IPointCollection)((IRow)inputRowChanges).get_Value(attributeIndex)).EnumVertices as IEnumVertex; " is 139.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,The length of the statement  "            // at this point this a delete request for some that the server doesn't even know about yet - hence no tracking required " is 120.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                    assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 124.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                    assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 124.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                    IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1); " is 136.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                        assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 123.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                            assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 124.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                            assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion); " is 124.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                                    // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved " is 121.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                                                testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000); " is 131.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                                                testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1); " is 130.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The length of the statement  "                                            bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper); " is 138.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,mergeOSMTags,The length of the statement  "                _osmUtility.insertOSMTags(tagCollectionFieldIndex' source' tagList.Values.ToArray()' ((IDataset)mergeFeature.Class).Workspace); " is 127.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                // this could be the case if there is no feature class extension' this is very unlikely as the fc extension itself triggers this code " is 133.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                if (osmFeatureClassExtensionCLSID.Value.ToString().Equals("{65CA4847-8661-45eb-8E1E-B2985CA17C78}"' StringComparison.InvariantCultureIgnoreCase) == false) " is 154.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                            // if the code in instructed to create a new feature with a negative OSMID then something else duplicating a new feature with " is 125.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                            // existing attributes - that is not allowed by definition hence to decrement the temporary index by 1 to indicate a new feature " is 128.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                    // ensure that the incoming geometry are conforming to the node limit of OSM as well as multi-part geometries being prepared to be  " is 130.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                    pointCollection = createOSMRelationNodeClusters("add"' newlyCreatedFeature' osmNewFeatureIDFieldIndex' osmNewFeatureVersionFieldIndex' osmNewFeatureSupportElementFieldIndex' osmNewFeatureIsMemberOfFieldIndex' osmNewFeatureTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 284.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                        IPointCollection geometryPartPointCollection = existingGeometryCollection.get_Geometry(geometryIndex) as IPointCollection; " is 122.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                        geometryPartPointCollection = checkAllPoints(newlyCreatedFeature' pointFeatureClass' "create"' osmNewFeatureIDFieldIndex' geometryPartPointCollection' trackChanges); " is 165.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The length of the statement  "                            LogOSMAction(revisionTable' "create"' "relation"' ((IDataset)newlyCreatedFeature.Class).Name' featureOSMID' 1' -1' null); " is 121.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry); " is 124.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                                        nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion); " is 123.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper); " is 146.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                                        // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct  " is 121.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The length of the statement  "                                            // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info) " is 136.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                    storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 348.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                            storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 348.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 337.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                        IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection; " is 178.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                            IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection; " is 121.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex); " is 153.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 359.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 359.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                            string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex); " is 153.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 362.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The length of the statement  "                            storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges); " is 374.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,CanBypassStoreMethod,The length of the statement  "            // we need to return false as we need track all changes' done through gp' inside or outside an edit session' engine' desktop' and server " is 136.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMClassExtensionManager,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMClassExtensionManager.cs,ApplyOSMClassExtension,The length of the statement  "                    // at release 2.1 we changed the OSMID field type to string' hence only when we find the string we are assuming version 2 " is 121.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMClassExtensionManager,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMClassExtensionManager.cs,RemoveOSMClassExtension,The length of the statement  "                    // at release 2.1 we changed the OSMID field type to string' hence only when we find the string we are assuming version 2 " is 121.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,retrieveOSMTags,The length of the statement  "            // next let's go through the fields with a domain table and check for additional key/value information that might not have been  " is 127.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/idCitation/citRespParty/rpIndName"' "OpenStreetMap"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddIfNotExists' false); " is 179.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/idCitation/citRespParty/rpCntInfo/cntOnlineRes/linkage"' "http://www.openstreetmap.org"' esriXmlPropertyType.esriXPTLink' esriXmlSetPropertyAction.esriXSPAAddIfNotExists' false); " is 215.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/idCitation/citRespParty/rpCntInfo/cntOnlineRes/orFunct/OnFunctCd"' "value"' "001"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 169.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/idCitation/citRespParty/role/RoleCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 140.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/idCredit"' "Map data (c) OpenStreetMap' ODbL 1.0"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddIfNotExists' false); " is 177.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/idPoC/rpOrgName"' "OpenStreetMap"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddIfNotExists' false); " is 161.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/idPoC/rpCntInfo/cntOnlineRes/linkage"' "http://www.openstreetmap.org"' esriXmlPropertyType.esriXPTLink' esriXmlSetPropertyAction.esriXSPAAddIfNotExists' false); " is 197.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/idPoC/rpCntInfo/cntOnlineRes/orFunct/OnFunctCd"' "value"' "001"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 151.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/idPoC/role/RoleCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 122.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/resMaint/maintFreq/MaintFreqCd"' "value"' "009"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 135.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/resMaint/maintScp/ScopeCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 130.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/resConst/LegConsts/useLimit"' "Map data (c) OpenStreetMap' ODbL 1.0; http://opendatacommons.org/licenses/odbl/"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddOrReplace' false); " is 237.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/resConst/LegConsts/accessConsts/RestrictCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 147.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/resConst/LegConsts/useConsts/RestrictCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 144.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/resConst/SecConsts/class/ClasscationCd"' "value"' "001"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 143.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/resConst/Consts/useLimit"' "Map data (c) OpenStreetMap' ODbL 1.0; http://opendatacommons.org/licenses/odbl/"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddOrReplace' false); " is 234.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/idPurp"' metadataPurpose' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddIfNotExists' false); " is 152.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/idAbs"' metadataAbstract' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddIfNotExists' false); " is 152.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/idConst/LegConsts/useLimit"' "CC-BY-SA; http://creativecommons.org/licenses/by-sa/2.0/"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddOrReplace' false); " is 213.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/idConst/LegConsts/accessConsts/RestrictCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 146.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/idConst/LegConsts/useConsts/RestrictCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 143.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("dataIdInfo/idConst/SecConsts/class/ClasscationCd"' "value"' "001"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 142.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/searchKeys/keyword"' "OpenStreetMap"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddIfNotExists' false); " is 164.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/searchKeys/keyword"' "Applications Prototype Lab"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddDuplicate' false); " is 175.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("dataIdInfo/searchKeys/keyword"' "ESRI"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddDuplicate' false); " is 153.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("mdMaint/maintFreq/MaintFreqCd"' "value"' "001"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 123.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("mdMaint/maintCont/role/RoleCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 123.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetPropertyX("mdConst/LegConsts/useLimit"' "Map data (c) OpenStreetMap' ODbL 1.0; http://opendatacommons.org/licenses/odbl/"' esriXmlPropertyType.esriXPTText' esriXmlSetPropertyAction.esriXSPAAddOrReplace' false); " is 225.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("mdConst/LegConsts/accessConsts/RestrictCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 135.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("mdConst/LegConsts/useConsts/RestrictCd"' "value"' "005"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 132.
Long Statement,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,CreateOSMMetadata,The length of the statement  "                    metadataXML.SetAttribute("mdConst/SecConsts/class/ClasscationCd"' "value"' "001"' esriXmlSetPropertyAction.esriXSPAAddIfNotExists); " is 131.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,osmTagsAreStillValid,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsString,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsLong,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsInt,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsDouble,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsDateTime,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,hasOSMRelevantChanges,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,determineMinTemporaryOSMID,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,determineMinTemporaryOSMID,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,findRevisionTable,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,findRelationTable,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,findPartIndex,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,detectPartAdds,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,findMatchingFeatureClass,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,osmTagsAreStillValid,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsString,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsLong,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsInt,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsDouble,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ReadAttributeValueAsDateTime,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,hasOSMRelevantChanges,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,determineMinTemporaryOSMID,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,determineMinTemporaryOSMID,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,findRevisionTable,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,findRelationTable,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,findPartIndex,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,detectPartAdds,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,findMatchingFeatureClass,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OSMClassExtensionManager,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMClassExtensionManager.cs,CurrentExtensionVersion,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,SchemaLockManager,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMClassExtensionManager.cs,Dispose,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,retrieveOSMTags,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,AreTagsTheSame,The method has an empty catch block.
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ArcGISCategoryRegistration,The following statement contains a magic number: Registry.ClassesRoot.CreateSubKey(regKey.Substring(18) + "\\Implemented Categories\\{D4E2A322-5D59-11D2-89FD-006097AFF44E}");
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ArcGISCategoryUnregistration,The following statement contains a magic number: Registry.ClassesRoot.DeleteSubKey(regKey.Substring(18) + "\\Implemented Categories\\{D4E2A322-5D59-11D2-89FD-006097AFF44E}");
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,PointFeaturesFromWayOrPoly,The following statement contains a magic number: for (int idx = 0; idx < pointCollection.PointCount; ++idx)              {                  int pointOID = pointCollection.get_Point(idx).ID;                    // Query for the feature by OSMID or ObjectID in the point feature class                  if (_ExtensionVersion == 1)                  {                      filter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(pointOID' "OSMID"' _ExtensionVersion);                  }                  else if (_ExtensionVersion == 2)                  {                      filter.WhereClause = string.Format("{0} = {1}"' pointFeatureClass.OIDFieldName' pointOID);                  }                    using (ComReleaser comReleaser = new ComReleaser())                  {                      IFeature pointFeature = null;                        try                      {                          IFeatureCursor searchCursor = pointFeatureClass.Search(filter' false);                          comReleaser.ManageLifetime(searchCursor);                          pointFeature = searchCursor.NextFeature();                      }                      catch (Exception ex)                      {                          System.Diagnostics.Debug.WriteLine(                              string.Format("Node ID Search (filter: {0}) Failed: {1}" + filter.WhereClause' ex.ToString()));                      }                        if (pointFeature != null)                          yield return pointFeature;                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The following statement contains a magic number: try              {                  // if the feature geometry has changed make sure the matching point do exist in the _osm_pt feature class                  // as well as that the geometry is tested for coincident nodes                  if (((IFeatureChanges)changeFeature).ShapeChanged)                  {                      IGeometry oldGeometry = ((IFeatureChanges)changeFeature).OriginalShape;    #if DEBUG                      // debug code                      #region ID tests                      if (oldGeometry.GeometryType != esriGeometryType.esriGeometryPoint)                      {                          IEnumVertex enum1 = ((IPointCollection)oldGeometry).EnumVertices as IEnumVertex;                            if (enum1 != null)                          {                              IPoint p1 = null;                              int partIndex1 = -1;                              int vertexIndex1 = -1;                                enum1.Next(out p1' out partIndex1' out vertexIndex1);                                while (p1 != null)                              {                                  enum1.Next(out p1' out partIndex1' out vertexIndex1);                              }                          }                      }                      #endregion  #endif                          IGeometry currentGeometry = changeFeature.Shape;    #if DEBUG                      // debug code                      #region ID tests                      if (currentGeometry.GeometryType != esriGeometryType.esriGeometryPoint)                      {                          IEnumVertex enum2 = ((IPointCollection)currentGeometry).EnumVertices as IEnumVertex;                            if (enum2 != null)                          {                              IPoint p2 = null;                              int partIndex2 = -1;                              int vertexIndex2 = -1;                                enum2.Next(out p2' out partIndex2' out vertexIndex2);                                while (p2 != null)                              {                                  enum2.Next(out p2' out partIndex2' out vertexIndex2);                              }                          }                      }                      #endregion  #endif                          IRelationalOperator relationalOperator = currentGeometry as IRelationalOperator;                        bool equalPointCount = true;                      if (currentGeometry is IPointCollection)                      {                          equalPointCount = ((IPointCollection)currentGeometry).PointCount != ((IPointCollection)oldGeometry).PointCount;                      }                        if ((relationalOperator.Equals(oldGeometry) == false) || equalPointCount)                      {                          // in case we are dealing with a point feature check if the point was updated to coincide with another node                          // if this is the case then the new node merges with the existing node and its attributes                          if (changeFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint)                          {                              // check if there are connected polygon or lines features                              //CheckforMovingAwayFromFeature(changeFeature' trackChanges);                                UpdateMergeNode(changeFeature' revisionTable);                          }                          else                          {                              // find the point feature class that contains the nodes                              IFeatureClass pointFeatureClass = null;                              pointFeatureClass = findMatchingFeatureClass(changeFeature' esriGeometryType.esriGeometryPoint);                                if (pointFeatureClass == null)                              {                                  System.Diagnostics.Debug.WriteLine("unable to locate point (osm node) feature class. defering updates to stop edit operation.");                                  return;                              }                                  // handle the special case of more than 2000 vertices                               // and multipart entities                              object MissingValue = Missing.Value;                                // lines of nodes larger than 2000 are split into multiple features                              IPointCollection pointCollection = null;                              IGeometryCollection changedGeometryCollection = null;                                pointCollection = changeFeature.Shape as IPointCollection;                                // in case of a merge operation the new geometry is empty and old one contains the updates                              // if this is actually the case then something is terribly wrong and we shouldn't continue at this point                              // (this seems to happen occasionally - not expected and not quite reproducible)                              if (pointCollection.PointCount == 0)                              {                                  throw new ArgumentOutOfRangeException("changedObject"' resourceManager.GetString("OSMClassExtension_emptyGeometry"));                                  //pointCollection = ((IFeatureChanges)changeFeature).OriginalShape as IPointCollection;                              }                                changedGeometryCollection = changeFeature.Shape as IGeometryCollection;                                if (changedGeometryCollection.GeometryCount == 0)                              {                                  changedGeometryCollection = ((IFeatureChanges)changeFeature).OriginalShape as IGeometryCollection;                              }                                int osmChangeFeatureIDFieldIndex = currentObjectFeatureClass.FindField("OSMID");                              int osmChangeFeatureVersionFieldIndex = currentObjectFeatureClass.FindField("osmversion");                              int osmChangeFeatureSupportElementFieldIndex = currentObjectFeatureClass.FindField("osmSupportingElement");                              int osmChangeFeatureIsMemberOfFieldIndex = currentObjectFeatureClass.FindField("osmMemberOf");                              int osmChangeFeatureTimeStampFieldIndex = currentObjectFeatureClass.FindField("osmtimestamp");                                DecrementTemporaryIndex();                                // depending on the incoming geometry type loop through all the points and make sure that they are put into chunks of                               // 2000 nodes/points                              pointCollection = createOSMRelationNodeClusters("change"' changeFeature' osmChangeFeatureIDFieldIndex' osmChangeFeatureVersionFieldIndex' osmChangeFeatureSupportElementFieldIndex' osmChangeFeatureIsMemberOfFieldIndex' osmChangeFeatureTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                // otherwise we have to do some node matching                              // - create if node doesn't exist yet                              // - update if the node/vertex already existed                              // - delete if the node/vertex was removed                              IPointIDAware topGeometryIDAware = pointCollection as IPointIDAware;                                if (topGeometryIDAware != null)                              {                                  topGeometryIDAware.PointIDAware = true;                              }                                int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                              int pointosmIDFieldIndex = pointFeatureClass.FindField("osmID");                              int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                              int pointVersionFieldIndex = pointFeatureClass.FindField("osmVersion");                              int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                              int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                                long changeRowOSMID = -1;                              if (osmChangeFeatureIDFieldIndex > -1)                              {                                  changeRowOSMID = Convert.ToInt64(changedObject.get_Value(osmChangeFeatureIDFieldIndex));                              }                                IGeometryCollection changeGeometryCollection = pointCollection as IGeometryCollection;                                // loop through all vertices and check for coincident and new points                              pointCollection = checkAllPoints(changeFeature' pointFeatureClass' "modify"' osmChangeFeatureIDFieldIndex' pointCollection' trackChanges);                                changeFeature.Shape = (IGeometry)pointCollection;                                // now let's check the old geometry if we need to delete a node                              List<int> nowMissingNodes = findDeletedNodeIDs(((IFeatureChanges)changeFeature).OriginalShape' changeFeature.Shape);                                // no deleted nodes were detected                              // we are done at this point                              if (nowMissingNodes.Count > 0)                              {                                  string sqlPointOSMID = pointFeatureClass.SqlIdentifier("OSMID");                                    foreach (int deleteNodeID in nowMissingNodes)                                  {                                      IQueryFilter queryfilter = new QueryFilter();                                      IFeature foundFeature = null;                                      if (_ExtensionVersion == 1)                                      {                                          queryfilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(deleteNodeID' "OSMID"' _ExtensionVersion);                                            IFeatureCursor searchCursor = pointFeatureClass.Search(queryfilter' false);                                          foundFeature = searchCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              foundFeature = pointFeatureClass.GetFeature(deleteNodeID);                                          }                                          catch                                          {                                              foundFeature = null;                                          }                                      }                                        if (foundFeature != null)                                      {                                          int wayRefCount = 0;                                            if (pointwayRefCountFieldIndex > -1)                                          {                                              wayRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                          }                                              if (wayRefCount > 1)                                          {                                              foundFeature.set_Value(pointwayRefCountFieldIndex' wayRefCount - 1);                                                //if (pointTrackChangesFieldIndex > -1)                                              //{                                              //    if (trackChanges == false)                                              //    {                                              //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                              //    }                                              //}                                                foundFeature.Store();                                          }                                          else                                          {                                              // delete the vertex from the parent feature as well                                              List<string> isMembersOf = _osmUtility.retrieveIsMemberOf(foundFeature' pointisMemberOfFieldIndex);                                                Dictionary<string' string> isMembersOfIDsAndTypes = _osmUtility.parseIsMemberOfList(isMembersOf);                                                #region use isMemberOf info to determine relationship to parent                                              IFeatureClass fc = (IFeatureClass)changedObject.Class;                                              string sqlOSMID = fc.SqlIdentifier("OSMID");                                                foreach (string currentParentID in isMembersOfIDsAndTypes.Keys)                                              {                                                  using (ComReleaser comReleaser = new ComReleaser())                                                  {                                                      IQueryFilter parentIDFilter = new QueryFilterClass();                                                      parentIDFilter.WhereClause = sqlOSMID + " = " + currentParentID;                                                        IFeatureCursor parentUpdateFeatureCursor = fc.Search(parentIDFilter' false);                                                      comReleaser.ManageLifetime(parentUpdateFeatureCursor);                                                        IFeature currentParentFeature = parentUpdateFeatureCursor.NextFeature();                                                        // for each of the found parents' loop through and remove the point                                                      while (currentParentFeature != null)                                                      {                                                          bool geometryChanged = false;                                                          IPointCollection parentPointCollection = currentParentFeature.Shape as IPointCollection;                                                            if (parentPointCollection != null)                                                          {                                                              for (int parentPointIndex = 0; parentPointIndex < parentPointCollection.PointCount; parentPointIndex++)                                                              {                                                                  IPoint currentTestPoint = parentPointCollection.get_Point(parentPointIndex);                                                                    if (currentTestPoint.ID.Equals(deleteNodeID))                                                                  {                                                                      geometryChanged = true;                                                                      parentPointCollection.RemovePoints(parentPointIndex' 1);                                                                  }                                                              }                                                          }                                                            if (geometryChanged)                                                          {                                                              currentParentFeature.Shape = parentPointCollection as IGeometry;                                                                //if (trackChanges == false)                                                              //{                                                              //    if (osmTrackChangesFieldIndex > -1)                                                              //    {                                                              //        currentParentFeature.set_Value(osmTrackChangesFieldIndex' 0);                                                              //    }                                                              //}                                                                // persist the changes back to the database                                                              currentParentFeature.Store();                                                          }                                                            currentParentFeature = parentUpdateFeatureCursor.NextFeature();                                                      }                                                  }                                              }                                              #endregion                                                foundFeature.Delete();                                          }                                      }                                  } // for each of the missing nodes                              } // missing nodes count larger than 0                           }  // geometry type test                      } // IRelationOp::Equal test                      else                      {                          // This means the shape is only different by vertex IDs or some other metadata                          //   so reset the shape to the original geometry to get back the IDs                          changeFeature.Shape = oldGeometry;                      }                  } // shape.changed              }              catch { }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,SetTemporaryIndex,The following statement contains a magic number: if (_temporaryIndex >= 0)              {                  if (_ExtensionVersion == 1)                      _temporaryIndex = determineMinTemporaryOSMID(testObject' _temporaryIndex);                  else if (_ExtensionVersion == 2)                      _temporaryIndex = determineMinTemporaryOSMID(revisionTable' _temporaryIndex);                    TempIndicies[_revisionTableName] = _temporaryIndex;              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,getLowestOSMID,The following statement contains a magic number: if (osmIDFieldIndex > -1)              {                  using (ComReleaser comReleaser = new ComReleaser())                  {                      ICursor searchCursor = inputTable.Search(null' true);                      comReleaser.ManageLifetime(searchCursor);                        long currentID = 10000;                        IRow row = searchCursor.NextRow();                        while (row != null)                      {                          try                          {                              object osmIDValue = row.get_Value(osmIDFieldIndex);                              if (osmIDValue != DBNull.Value)                              {                                  currentID = Convert.ToInt64(row.get_Value(osmIDFieldIndex));                              }                                newTempID = Math.Min(newTempID' currentID);                              row = searchCursor.NextRow();                          }                          catch                          {                              catchCounter = catchCounter + 1;                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,The following statement contains a magic number: if (revOldIdFieldIndex > -1)              {                  if (_ExtensionVersion == 1)                      row.set_Value(revOldIdFieldIndex' Convert.ToInt32(elementID));                  else if (_ExtensionVersion == 2)                      row.set_Value(revOldIdFieldIndex' Convert.ToString(elementID));              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: if (_ExtensionVersion == 2)              {                  // check if the geometry ID and the ObjectID are the same                  IPoint pointGeometry = targetFeature.Shape as IPoint;                    if (pointGeometry != null)                  {                      bool geometryChanged = false;                      IPointIDAware pointIDAware = pointGeometry as IPointIDAware;                        if (pointIDAware.PointIDAware)                      {                          if (pointGeometry.ID != targetFeature.OID)                          {                              pointGeometry.ID = targetFeature.OID;                              geometryChanged = true;                          }                      }                      else                      {                          pointIDAware.PointIDAware = true;                          pointGeometry.ID = targetFeature.OID;                          geometryChanged = true;                      }                        if (geometryChanged)                          targetFeature.Shape = pointGeometry;                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: using (ComReleaser comReleaser = new ComReleaser())              {                  osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                    long osmID = 0;                  int osmVersion = 0;                    if (osmIDValue == DBNull.Value)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                        //if (osmTrackFeatureChangesFieldIndex > -1)                      //{                      //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                      //}                      return;                  }                  else                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                    IFeatureClass fcTarget = (IFeatureClass)targetFeature.Class;                    // let's first check if a node with the same osmID already exists                  IQueryFilter osmIDQueryFilter = new QueryFilterClass();                  osmIDQueryFilter.WhereClause = fcTarget.WhereClauseByExtensionVersion(osmID' "OSMID"' _ExtensionVersion);                    IFeatureCursor osmIDCursor = fcTarget.Search(osmIDQueryFilter' false);                  comReleaser.ManageLifetime(osmIDCursor);                    IFeature matchingOSMIDFeature = osmIDCursor.NextFeature();                  if (matchingOSMIDFeature == null)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                  }                  else                  {                      ISpatialFilter spatialFilter = new SpatialFilterClass();                        IBufferConstruction bc = new BufferConstructionClass();                      IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                        spatialFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                      spatialFilter.Geometry = buffer.Envelope;                      spatialFilter.GeometryField = ((IFeatureClass)targetFeature.Class).ShapeFieldName;                      spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                        // we are looking for coincident points with a different ID                      if (osmIDFieldIndex > -1)                      {                          if (osmIDValue == DBNull.Value)                          {                              spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " IS NOT NULL";                          }                          else                          {                              if (_ExtensionVersion == 1)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> " + Convert.ToInt32(osmIDValue).ToString();                              else if (_ExtensionVersion == 2)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> '" + Convert.ToString(osmIDValue) + "'";                          }                      }                        IFeatureCursor searchCursor = fcTarget.Search(spatialFilter' false);                      comReleaser.ManageLifetime(searchCursor);                        IFeature foundFeature = searchCursor.NextFeature();                        if (foundFeature != null)                      {                          foundFeature = mergeOSMTags(foundFeature' targetFeature' true);                          assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                            if (supportElementFieldIndex > -1)                          {                              foundFeature.set_Value(supportElementFieldIndex' targetFeature.get_Value(supportElementFieldIndex));                          }                            //if (trackFeatureChanges == false)                          //{                          //    if (osmTrackFeatureChangesFieldIndex > -1)                          //    {                          //        foundFeature.set_Value(osmTrackFeatureChangesFieldIndex' 1);                          //    }                          //}                            foundFeature.Store();                            if (m_bypassOSMChangeDetection == false)                          {                              LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)foundFeature.Class).Name' osmID' osmVersion' -1' null);                          }                            foundFeature = searchCursor.NextFeature();                            targetFeature.Delete();                      }                      else                      // this is the case when we have a OSM id assigned because it is handed to us from a line or polygon but the node                       // doesn't exist yet. We just need to log the node creation itself - maybe based on store or insert cursor                      {                          osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                          if (osmIDValue == DBNull.Value)                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                // if a point feature has been explictly created it has to be an OSM feature                              if (supportElementFieldIndex > -1)                              {                                  targetFeature.set_Value(supportElementFieldIndex' "no");                              }                                if (m_bypassOSMChangeDetection == false)                              {                                  LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' _temporaryIndex' 1' -1' null);                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                                DecrementTemporaryIndex();                          }                          else                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                if (m_bypassOSMChangeDetection == false)                              {                                  if (osmID < 0)                                  {                                      LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                  }                                  else                                  {                                      // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved                                      IFeatureChanges fcc = targetFeature as IFeatureChanges;                                      if (fcc != null)                                      {                                          if (fcc.ShapeChanged)                                          {                                              IBufferConstruction pc = new BufferConstructionClass();                                              // exapnd the xy tolerance by 50% for point to be considered equal                                              IGeometry testBuffer = null;                                              if (targetFeature.Shape.SpatialReference is IGeographicCoordinateSystem)                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000);                                              }                                              else                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                                              }                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                if (equalPoint == false)                                              {                                                  LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                              }                                          }                                      }                                  }                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: using (ComReleaser comReleaser = new ComReleaser())              {                  osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                    long osmID = 0;                  int osmVersion = 0;                    if (osmIDValue == DBNull.Value)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                        //if (osmTrackFeatureChangesFieldIndex > -1)                      //{                      //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                      //}                      return;                  }                  else                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                    IFeatureClass fcTarget = (IFeatureClass)targetFeature.Class;                    // let's first check if a node with the same osmID already exists                  IQueryFilter osmIDQueryFilter = new QueryFilterClass();                  osmIDQueryFilter.WhereClause = fcTarget.WhereClauseByExtensionVersion(osmID' "OSMID"' _ExtensionVersion);                    IFeatureCursor osmIDCursor = fcTarget.Search(osmIDQueryFilter' false);                  comReleaser.ManageLifetime(osmIDCursor);                    IFeature matchingOSMIDFeature = osmIDCursor.NextFeature();                  if (matchingOSMIDFeature == null)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                  }                  else                  {                      ISpatialFilter spatialFilter = new SpatialFilterClass();                        IBufferConstruction bc = new BufferConstructionClass();                      IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                        spatialFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                      spatialFilter.Geometry = buffer.Envelope;                      spatialFilter.GeometryField = ((IFeatureClass)targetFeature.Class).ShapeFieldName;                      spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                        // we are looking for coincident points with a different ID                      if (osmIDFieldIndex > -1)                      {                          if (osmIDValue == DBNull.Value)                          {                              spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " IS NOT NULL";                          }                          else                          {                              if (_ExtensionVersion == 1)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> " + Convert.ToInt32(osmIDValue).ToString();                              else if (_ExtensionVersion == 2)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> '" + Convert.ToString(osmIDValue) + "'";                          }                      }                        IFeatureCursor searchCursor = fcTarget.Search(spatialFilter' false);                      comReleaser.ManageLifetime(searchCursor);                        IFeature foundFeature = searchCursor.NextFeature();                        if (foundFeature != null)                      {                          foundFeature = mergeOSMTags(foundFeature' targetFeature' true);                          assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                            if (supportElementFieldIndex > -1)                          {                              foundFeature.set_Value(supportElementFieldIndex' targetFeature.get_Value(supportElementFieldIndex));                          }                            //if (trackFeatureChanges == false)                          //{                          //    if (osmTrackFeatureChangesFieldIndex > -1)                          //    {                          //        foundFeature.set_Value(osmTrackFeatureChangesFieldIndex' 1);                          //    }                          //}                            foundFeature.Store();                            if (m_bypassOSMChangeDetection == false)                          {                              LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)foundFeature.Class).Name' osmID' osmVersion' -1' null);                          }                            foundFeature = searchCursor.NextFeature();                            targetFeature.Delete();                      }                      else                      // this is the case when we have a OSM id assigned because it is handed to us from a line or polygon but the node                       // doesn't exist yet. We just need to log the node creation itself - maybe based on store or insert cursor                      {                          osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                          if (osmIDValue == DBNull.Value)                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                // if a point feature has been explictly created it has to be an OSM feature                              if (supportElementFieldIndex > -1)                              {                                  targetFeature.set_Value(supportElementFieldIndex' "no");                              }                                if (m_bypassOSMChangeDetection == false)                              {                                  LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' _temporaryIndex' 1' -1' null);                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                                DecrementTemporaryIndex();                          }                          else                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                if (m_bypassOSMChangeDetection == false)                              {                                  if (osmID < 0)                                  {                                      LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                  }                                  else                                  {                                      // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved                                      IFeatureChanges fcc = targetFeature as IFeatureChanges;                                      if (fcc != null)                                      {                                          if (fcc.ShapeChanged)                                          {                                              IBufferConstruction pc = new BufferConstructionClass();                                              // exapnd the xy tolerance by 50% for point to be considered equal                                              IGeometry testBuffer = null;                                              if (targetFeature.Shape.SpatialReference is IGeographicCoordinateSystem)                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000);                                              }                                              else                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                                              }                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                if (equalPoint == false)                                              {                                                  LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                              }                                          }                                      }                                  }                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: using (ComReleaser comReleaser = new ComReleaser())              {                  osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                    long osmID = 0;                  int osmVersion = 0;                    if (osmIDValue == DBNull.Value)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                        //if (osmTrackFeatureChangesFieldIndex > -1)                      //{                      //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                      //}                      return;                  }                  else                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                    IFeatureClass fcTarget = (IFeatureClass)targetFeature.Class;                    // let's first check if a node with the same osmID already exists                  IQueryFilter osmIDQueryFilter = new QueryFilterClass();                  osmIDQueryFilter.WhereClause = fcTarget.WhereClauseByExtensionVersion(osmID' "OSMID"' _ExtensionVersion);                    IFeatureCursor osmIDCursor = fcTarget.Search(osmIDQueryFilter' false);                  comReleaser.ManageLifetime(osmIDCursor);                    IFeature matchingOSMIDFeature = osmIDCursor.NextFeature();                  if (matchingOSMIDFeature == null)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                  }                  else                  {                      ISpatialFilter spatialFilter = new SpatialFilterClass();                        IBufferConstruction bc = new BufferConstructionClass();                      IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                        spatialFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                      spatialFilter.Geometry = buffer.Envelope;                      spatialFilter.GeometryField = ((IFeatureClass)targetFeature.Class).ShapeFieldName;                      spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                        // we are looking for coincident points with a different ID                      if (osmIDFieldIndex > -1)                      {                          if (osmIDValue == DBNull.Value)                          {                              spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " IS NOT NULL";                          }                          else                          {                              if (_ExtensionVersion == 1)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> " + Convert.ToInt32(osmIDValue).ToString();                              else if (_ExtensionVersion == 2)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> '" + Convert.ToString(osmIDValue) + "'";                          }                      }                        IFeatureCursor searchCursor = fcTarget.Search(spatialFilter' false);                      comReleaser.ManageLifetime(searchCursor);                        IFeature foundFeature = searchCursor.NextFeature();                        if (foundFeature != null)                      {                          foundFeature = mergeOSMTags(foundFeature' targetFeature' true);                          assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                            if (supportElementFieldIndex > -1)                          {                              foundFeature.set_Value(supportElementFieldIndex' targetFeature.get_Value(supportElementFieldIndex));                          }                            //if (trackFeatureChanges == false)                          //{                          //    if (osmTrackFeatureChangesFieldIndex > -1)                          //    {                          //        foundFeature.set_Value(osmTrackFeatureChangesFieldIndex' 1);                          //    }                          //}                            foundFeature.Store();                            if (m_bypassOSMChangeDetection == false)                          {                              LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)foundFeature.Class).Name' osmID' osmVersion' -1' null);                          }                            foundFeature = searchCursor.NextFeature();                            targetFeature.Delete();                      }                      else                      // this is the case when we have a OSM id assigned because it is handed to us from a line or polygon but the node                       // doesn't exist yet. We just need to log the node creation itself - maybe based on store or insert cursor                      {                          osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                          if (osmIDValue == DBNull.Value)                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                // if a point feature has been explictly created it has to be an OSM feature                              if (supportElementFieldIndex > -1)                              {                                  targetFeature.set_Value(supportElementFieldIndex' "no");                              }                                if (m_bypassOSMChangeDetection == false)                              {                                  LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' _temporaryIndex' 1' -1' null);                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                                DecrementTemporaryIndex();                          }                          else                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                if (m_bypassOSMChangeDetection == false)                              {                                  if (osmID < 0)                                  {                                      LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                  }                                  else                                  {                                      // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved                                      IFeatureChanges fcc = targetFeature as IFeatureChanges;                                      if (fcc != null)                                      {                                          if (fcc.ShapeChanged)                                          {                                              IBufferConstruction pc = new BufferConstructionClass();                                              // exapnd the xy tolerance by 50% for point to be considered equal                                              IGeometry testBuffer = null;                                              if (targetFeature.Shape.SpatialReference is IGeographicCoordinateSystem)                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000);                                              }                                              else                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                                              }                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                if (equalPoint == false)                                              {                                                  LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                              }                                          }                                      }                                  }                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: using (ComReleaser comReleaser = new ComReleaser())              {                  osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                    long osmID = 0;                  int osmVersion = 0;                    if (osmIDValue == DBNull.Value)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                        //if (osmTrackFeatureChangesFieldIndex > -1)                      //{                      //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                      //}                      return;                  }                  else                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                    IFeatureClass fcTarget = (IFeatureClass)targetFeature.Class;                    // let's first check if a node with the same osmID already exists                  IQueryFilter osmIDQueryFilter = new QueryFilterClass();                  osmIDQueryFilter.WhereClause = fcTarget.WhereClauseByExtensionVersion(osmID' "OSMID"' _ExtensionVersion);                    IFeatureCursor osmIDCursor = fcTarget.Search(osmIDQueryFilter' false);                  comReleaser.ManageLifetime(osmIDCursor);                    IFeature matchingOSMIDFeature = osmIDCursor.NextFeature();                  if (matchingOSMIDFeature == null)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                  }                  else                  {                      ISpatialFilter spatialFilter = new SpatialFilterClass();                        IBufferConstruction bc = new BufferConstructionClass();                      IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                        spatialFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                      spatialFilter.Geometry = buffer.Envelope;                      spatialFilter.GeometryField = ((IFeatureClass)targetFeature.Class).ShapeFieldName;                      spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                        // we are looking for coincident points with a different ID                      if (osmIDFieldIndex > -1)                      {                          if (osmIDValue == DBNull.Value)                          {                              spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " IS NOT NULL";                          }                          else                          {                              if (_ExtensionVersion == 1)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> " + Convert.ToInt32(osmIDValue).ToString();                              else if (_ExtensionVersion == 2)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> '" + Convert.ToString(osmIDValue) + "'";                          }                      }                        IFeatureCursor searchCursor = fcTarget.Search(spatialFilter' false);                      comReleaser.ManageLifetime(searchCursor);                        IFeature foundFeature = searchCursor.NextFeature();                        if (foundFeature != null)                      {                          foundFeature = mergeOSMTags(foundFeature' targetFeature' true);                          assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                            if (supportElementFieldIndex > -1)                          {                              foundFeature.set_Value(supportElementFieldIndex' targetFeature.get_Value(supportElementFieldIndex));                          }                            //if (trackFeatureChanges == false)                          //{                          //    if (osmTrackFeatureChangesFieldIndex > -1)                          //    {                          //        foundFeature.set_Value(osmTrackFeatureChangesFieldIndex' 1);                          //    }                          //}                            foundFeature.Store();                            if (m_bypassOSMChangeDetection == false)                          {                              LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)foundFeature.Class).Name' osmID' osmVersion' -1' null);                          }                            foundFeature = searchCursor.NextFeature();                            targetFeature.Delete();                      }                      else                      // this is the case when we have a OSM id assigned because it is handed to us from a line or polygon but the node                       // doesn't exist yet. We just need to log the node creation itself - maybe based on store or insert cursor                      {                          osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                          if (osmIDValue == DBNull.Value)                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                // if a point feature has been explictly created it has to be an OSM feature                              if (supportElementFieldIndex > -1)                              {                                  targetFeature.set_Value(supportElementFieldIndex' "no");                              }                                if (m_bypassOSMChangeDetection == false)                              {                                  LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' _temporaryIndex' 1' -1' null);                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                                DecrementTemporaryIndex();                          }                          else                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                if (m_bypassOSMChangeDetection == false)                              {                                  if (osmID < 0)                                  {                                      LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                  }                                  else                                  {                                      // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved                                      IFeatureChanges fcc = targetFeature as IFeatureChanges;                                      if (fcc != null)                                      {                                          if (fcc.ShapeChanged)                                          {                                              IBufferConstruction pc = new BufferConstructionClass();                                              // exapnd the xy tolerance by 50% for point to be considered equal                                              IGeometry testBuffer = null;                                              if (targetFeature.Shape.SpatialReference is IGeographicCoordinateSystem)                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000);                                              }                                              else                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                                              }                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                if (equalPoint == false)                                              {                                                  LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                              }                                          }                                      }                                  }                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,assignBasicMetadata,The following statement contains a magic number: if (osmIDFieldIndex > -1)              {                  object osmIDValue = pointFeature.get_Value(osmIDFieldIndex);                    if (osmIDValue != DBNull.Value)                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                  else                  {                      osmID = _temporaryIndex;                      DecrementTemporaryIndex();                      if (_ExtensionVersion == 1)                          pointFeature.set_Value(osmIDFieldIndex' Convert.ToInt32(osmID));                      else if (_ExtensionVersion == 2)                          pointFeature.set_Value(osmIDFieldIndex' Convert.ToString(osmID));                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The following statement contains a magic number: try              {                  // only feature classes are currently handled' tables are not yet supported                  if (newlyCreatedFeature == null)                  {                      return;                  }                    IPoint currentPointt = newlyCreatedFeature.Shape as IPoint;                        IFeatureClass currentObjectFeatureClass = newlyCreatedFeature.Class as IFeatureClass;                    if (currentObjectFeatureClass == null)                      return;                    // check if the current feature class being edited is acutally an OpenStreetMap feature class                  // all other feature classes should not be touched by this extension                  UID osmFeatureClassExtensionCLSID = currentObjectFeatureClass.EXTCLSID;                    // this could be the case if there is no feature class extension' this is very unlikely as the fc extension itself triggers this code                  // hence it has to exist                  if (osmFeatureClassExtensionCLSID == null)                  {                      return;                  }                    if (osmFeatureClassExtensionCLSID.Value.ToString().Equals("{65CA4847-8661-45eb-8E1E-B2985CA17C78}"' StringComparison.InvariantCultureIgnoreCase) == false)                  {                      return;                  }                    int osmNewFeatureIDFieldIndex = currentObjectFeatureClass.FindField("OSMID");                  int osmNewFeatureVersionFieldIndex = currentObjectFeatureClass.FindField("osmversion");                  int osmNewFeatureSupportElementFieldIndex = currentObjectFeatureClass.FindField("osmSupportingElement");                  int osmNewFeatureIsMemberOfFieldIndex = currentObjectFeatureClass.FindField("osmMemberOf");                  int osmNewFeatureTimeStampFieldIndex = currentObjectFeatureClass.FindField("osmtimestamp");                  int osmTrackChangesFieldIndex = currentObjectFeatureClass.FindField("osmTrackchanges");                    // find the revision table for logging the changes.                  ITable revisionTable = findRevisionTable(newlyCreatedFeature);                    // Set revision table from cache or calculate from revision table                  SetTemporaryIndex(source' revisionTable);                    int revActionFieldIndex = revisionTable.Fields.FindField("osmaction");                  int revElementTypeFieldIndex = revisionTable.Fields.FindField("osmelementtype");                  int revFCNameFieldIndex = revisionTable.Fields.FindField("sourcefcname");                  int revOldIdFieldIndex = revisionTable.Fields.FindField("osmoldid"); ;                    // if the feature is a point treat it separately                  if (newlyCreatedFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint)                  {                      UpdateMergeNode(newlyCreatedFeature' revisionTable);                  }                  else                  {                      IFeatureClass pointFeatureClass = null;                        // look for a matching OSM node feature class in the current map document                      // otherwise open the node feature class directly                      pointFeatureClass = findMatchingFeatureClass(newlyCreatedFeature' esriGeometryType.esriGeometryPoint);                        if (pointFeatureClass == null)                      {                          System.Diagnostics.Debug.WriteLine("unable to locate point (osm node) feature class in adds adjustment");                          return;                      }                        // loop through the nodes if a vertex already exists as an existing point (maybe due to point snap)                      // then assign the already existing ID to it'                      // if not then create a matching supporting node in the point feature class                      IPointCollection pointCollection = newlyCreatedFeature.Shape as IPointCollection;                        // make the top level geometry ID aware                      IPointIDAware topGeometryIDAware = pointCollection as IPointIDAware;                      if (topGeometryIDAware != null)                      {                          topGeometryIDAware.PointIDAware = true;                      }                        bool trackChanges = true;                        //if (osmTrackChangesFieldIndex > -1)                      //{                      //    try                      //    {                      //        int trackChangesIndicator = Convert.ToInt32(newlyCreatedFeature.get_Value(osmTrackChangesFieldIndex));                        //        if (trackChangesIndicator != 0)                      //        {                      //            trackChanges = false;                      //        }                      //    }                      //    catch { }                      //}                          long featureOSMID = -1;                        // set some initial metadata on the newly created feature                      if (osmNewFeatureIDFieldIndex > -1)                      {                          // check if the feature needs a new ID or if it is created by a top-level geometry (in the case of multi-parts)                          object osmIDValue = newlyCreatedFeature.get_Value(osmNewFeatureIDFieldIndex);                            if (osmIDValue == DBNull.Value)                          {                              featureOSMID = _temporaryIndex;                              DecrementTemporaryIndex();                                if (_ExtensionVersion == 1)                                  newlyCreatedFeature.set_Value(osmNewFeatureIDFieldIndex' Convert.ToInt32(featureOSMID));                              else if (_ExtensionVersion == 2)                                  newlyCreatedFeature.set_Value(osmNewFeatureIDFieldIndex' Convert.ToString(featureOSMID));                          }                          else                          {                              featureOSMID = Convert.ToInt64(osmIDValue);                                // if the code in instructed to create a new feature with a negative OSMID then something else duplicating a new feature with                              // existing attributes - that is not allowed by definition hence to decrement the temporary index by 1 to indicate a new feature                              if (featureOSMID < 0)                              {                                  featureOSMID = _temporaryIndex;                                  DecrementTemporaryIndex();                              }                          }                      }                        if (osmNewFeatureVersionFieldIndex > -1)                      {                          newlyCreatedFeature.set_Value(osmNewFeatureVersionFieldIndex' 1);                      }                          IGeometryCollection existingGeometryCollection = pointCollection as IGeometryCollection;                        // ensure that the incoming geometry are conforming to the node limit of OSM as well as multi-part geometries being prepared to be                       // represented as relations                      pointCollection = createOSMRelationNodeClusters("add"' newlyCreatedFeature' osmNewFeatureIDFieldIndex' osmNewFeatureVersionFieldIndex' osmNewFeatureSupportElementFieldIndex' osmNewFeatureIsMemberOfFieldIndex' osmNewFeatureTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          // we will need a new geometry container                      IGeometryCollection updatedGeometryCollection = null;                      if (pointCollection is IPolyline)                      {                          updatedGeometryCollection = new PolylineClass();                      }                      else if (pointCollection is IPolygon)                      {                          updatedGeometryCollection = new PolygonClass();                      }                          if (updatedGeometryCollection != null)                      {                          IPointIDAware pointIDAware = updatedGeometryCollection as IPointIDAware;                            if (pointIDAware != null)                          {                              pointIDAware.PointIDAware = true;                          }                      }                        object missingValue = Missing.Value;                        // let's loop through all geometry parts                        for (int geometryIndex = 0; geometryIndex < existingGeometryCollection.GeometryCount; geometryIndex++)                      {                          IPointCollection geometryPartPointCollection = existingGeometryCollection.get_Geometry(geometryIndex) as IPointCollection;                            // check all points if they are coincident with already existing points or if they need to be created                            geometryPartPointCollection = checkAllPoints(newlyCreatedFeature' pointFeatureClass' "create"' osmNewFeatureIDFieldIndex' geometryPartPointCollection' trackChanges);                            updatedGeometryCollection.AddGeometry((IGeometry)geometryPartPointCollection' ref missingValue' ref missingValue);                      }                        // ensure that the changes and adjustments are persisted back to the geometry                      newlyCreatedFeature.Shape = updatedGeometryCollection as IGeometry;                        // ensure that if we create a multi-part polygon geometry that there is acutally a tag to indicate such (multipolygon)                      if ((pointCollection is IPolygon) && (updatedGeometryCollection.GeometryCount > 1))                      {                          int osmTagFieldIndex = newlyCreatedFeature.Fields.FindField("osmTags");                            bool tagAlreadyExits = false;                          if (osmTagFieldIndex > -1)                          {                              tag[] existingTags = _osmUtility.retrieveOSMTags(newlyCreatedFeature' osmTagFieldIndex' null);                                List<tag> featureTags = null;                              if (existingTags != null)                                  featureTags = new List<tag>(_osmUtility.retrieveOSMTags(newlyCreatedFeature' osmTagFieldIndex' null));                              else                                  featureTags = new List<tag>();                                foreach (tag currentTag in featureTags)                              {                                  if (currentTag.k.ToUpper().Equals("TYPE") == true)                                  {                                      tagAlreadyExits = true;                                  }                              }                              if (tagAlreadyExits == false)                              {                                  tag multipolygonTag = new tag();                                  multipolygonTag.k = "type";                                  multipolygonTag.v = "multipolygon";                                    featureTags.Add(multipolygonTag);                                    _osmUtility.insertOSMTags(osmTagFieldIndex' newlyCreatedFeature' featureTags.ToArray());                              }                          }                      }                        if (m_bypassOSMChangeDetection == false)                      {                          if (((IGeometryCollection)pointCollection).GeometryCount > 1)                          {                              LogOSMAction(revisionTable' "create"' "relation"' ((IDataset)newlyCreatedFeature.Class).Name' featureOSMID' 1' -1' null);                          }                          else                          {                              LogOSMAction(revisionTable' "create"' "way"' ((IDataset)newlyCreatedFeature.Class).Name' featureOSMID' 1' -1' null);                          }                      }                        // change the indicator back to track everything                      //if (osmTrackChangesFieldIndex > -1)                      //{                      //    newlyCreatedFeature.set_Value(osmTrackChangesFieldIndex' 0);                      //}                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,storeSupportingGeometry,The following statement contains a magic number: if (osmIDFieldIndex > -1)              {                  if (_ExtensionVersion == 1)                      newSupportFeature.set_Value(osmIDFieldIndex' Convert.ToInt32(osmIdentifier));                  else if (_ExtensionVersion == 2)                      newSupportFeature.set_Value(osmIDFieldIndex' Convert.ToString(osmIdentifier));              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ArcGISCategoryRegistration,The following statement contains a magic number: Registry.ClassesRoot.CreateSubKey(regKey.Substring(18) + "\\Implemented Categories\\{D4E2A322-5D59-11D2-89FD-006097AFF44E}");
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,ArcGISCategoryUnregistration,The following statement contains a magic number: Registry.ClassesRoot.DeleteSubKey(regKey.Substring(18) + "\\Implemented Categories\\{D4E2A322-5D59-11D2-89FD-006097AFF44E}");
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,PointFeaturesFromWayOrPoly,The following statement contains a magic number: for (int idx = 0; idx < pointCollection.PointCount; ++idx)              {                  int pointOID = pointCollection.get_Point(idx).ID;                    // Query for the feature by OSMID or ObjectID in the point feature class                  if (_ExtensionVersion == 1)                  {                      filter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(pointOID' "OSMID"' _ExtensionVersion);                  }                  else if (_ExtensionVersion == 2)                  {                      filter.WhereClause = string.Format("{0} = {1}"' pointFeatureClass.OIDFieldName' pointOID);                  }                    using (ComReleaser comReleaser = new ComReleaser())                  {                      IFeature pointFeature = null;                        try                      {                          IFeatureCursor searchCursor = pointFeatureClass.Search(filter' false);                          comReleaser.ManageLifetime(searchCursor);                          pointFeature = searchCursor.NextFeature();                      }                      catch (Exception ex)                      {                          System.Diagnostics.Debug.WriteLine(                              string.Format("Node ID Search (filter: {0}) Failed: {1}" + filter.WhereClause' ex.ToString()));                      }                        if (pointFeature != null)                          yield return pointFeature;                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureChanges,The following statement contains a magic number: try              {                  // if the feature geometry has changed make sure the matching point do exist in the _osm_pt feature class                  // as well as that the geometry is tested for coincident nodes                  if (((IFeatureChanges)changeFeature).ShapeChanged)                  {                      IGeometry oldGeometry = ((IFeatureChanges)changeFeature).OriginalShape;    #if DEBUG                      // debug code                      #region ID tests                      if (oldGeometry.GeometryType != esriGeometryType.esriGeometryPoint)                      {                          IEnumVertex enum1 = ((IPointCollection)oldGeometry).EnumVertices as IEnumVertex;                            if (enum1 != null)                          {                              IPoint p1 = null;                              int partIndex1 = -1;                              int vertexIndex1 = -1;                                enum1.Next(out p1' out partIndex1' out vertexIndex1);                                while (p1 != null)                              {                                  enum1.Next(out p1' out partIndex1' out vertexIndex1);                              }                          }                      }                      #endregion  #endif                          IGeometry currentGeometry = changeFeature.Shape;    #if DEBUG                      // debug code                      #region ID tests                      if (currentGeometry.GeometryType != esriGeometryType.esriGeometryPoint)                      {                          IEnumVertex enum2 = ((IPointCollection)currentGeometry).EnumVertices as IEnumVertex;                            if (enum2 != null)                          {                              IPoint p2 = null;                              int partIndex2 = -1;                              int vertexIndex2 = -1;                                enum2.Next(out p2' out partIndex2' out vertexIndex2);                                while (p2 != null)                              {                                  enum2.Next(out p2' out partIndex2' out vertexIndex2);                              }                          }                      }                      #endregion  #endif                          IRelationalOperator relationalOperator = currentGeometry as IRelationalOperator;                        bool equalPointCount = true;                      if (currentGeometry is IPointCollection)                      {                          equalPointCount = ((IPointCollection)currentGeometry).PointCount != ((IPointCollection)oldGeometry).PointCount;                      }                        if ((relationalOperator.Equals(oldGeometry) == false) || equalPointCount)                      {                          // in case we are dealing with a point feature check if the point was updated to coincide with another node                          // if this is the case then the new node merges with the existing node and its attributes                          if (changeFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint)                          {                              // check if there are connected polygon or lines features                              //CheckforMovingAwayFromFeature(changeFeature' trackChanges);                                UpdateMergeNode(changeFeature' revisionTable);                          }                          else                          {                              // find the point feature class that contains the nodes                              IFeatureClass pointFeatureClass = null;                              pointFeatureClass = findMatchingFeatureClass(changeFeature' esriGeometryType.esriGeometryPoint);                                if (pointFeatureClass == null)                              {                                  System.Diagnostics.Debug.WriteLine("unable to locate point (osm node) feature class. defering updates to stop edit operation.");                                  return;                              }                                  // handle the special case of more than 2000 vertices                               // and multipart entities                              object MissingValue = Missing.Value;                                // lines of nodes larger than 2000 are split into multiple features                              IPointCollection pointCollection = null;                              IGeometryCollection changedGeometryCollection = null;                                pointCollection = changeFeature.Shape as IPointCollection;                                // in case of a merge operation the new geometry is empty and old one contains the updates                              // if this is actually the case then something is terribly wrong and we shouldn't continue at this point                              // (this seems to happen occasionally - not expected and not quite reproducible)                              if (pointCollection.PointCount == 0)                              {                                  throw new ArgumentOutOfRangeException("changedObject"' resourceManager.GetString("OSMClassExtension_emptyGeometry"));                                  //pointCollection = ((IFeatureChanges)changeFeature).OriginalShape as IPointCollection;                              }                                changedGeometryCollection = changeFeature.Shape as IGeometryCollection;                                if (changedGeometryCollection.GeometryCount == 0)                              {                                  changedGeometryCollection = ((IFeatureChanges)changeFeature).OriginalShape as IGeometryCollection;                              }                                int osmChangeFeatureIDFieldIndex = currentObjectFeatureClass.FindField("OSMID");                              int osmChangeFeatureVersionFieldIndex = currentObjectFeatureClass.FindField("osmversion");                              int osmChangeFeatureSupportElementFieldIndex = currentObjectFeatureClass.FindField("osmSupportingElement");                              int osmChangeFeatureIsMemberOfFieldIndex = currentObjectFeatureClass.FindField("osmMemberOf");                              int osmChangeFeatureTimeStampFieldIndex = currentObjectFeatureClass.FindField("osmtimestamp");                                DecrementTemporaryIndex();                                // depending on the incoming geometry type loop through all the points and make sure that they are put into chunks of                               // 2000 nodes/points                              pointCollection = createOSMRelationNodeClusters("change"' changeFeature' osmChangeFeatureIDFieldIndex' osmChangeFeatureVersionFieldIndex' osmChangeFeatureSupportElementFieldIndex' osmChangeFeatureIsMemberOfFieldIndex' osmChangeFeatureTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                // otherwise we have to do some node matching                              // - create if node doesn't exist yet                              // - update if the node/vertex already existed                              // - delete if the node/vertex was removed                              IPointIDAware topGeometryIDAware = pointCollection as IPointIDAware;                                if (topGeometryIDAware != null)                              {                                  topGeometryIDAware.PointIDAware = true;                              }                                int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                              int pointosmIDFieldIndex = pointFeatureClass.FindField("osmID");                              int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                              int pointVersionFieldIndex = pointFeatureClass.FindField("osmVersion");                              int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                              int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                                long changeRowOSMID = -1;                              if (osmChangeFeatureIDFieldIndex > -1)                              {                                  changeRowOSMID = Convert.ToInt64(changedObject.get_Value(osmChangeFeatureIDFieldIndex));                              }                                IGeometryCollection changeGeometryCollection = pointCollection as IGeometryCollection;                                // loop through all vertices and check for coincident and new points                              pointCollection = checkAllPoints(changeFeature' pointFeatureClass' "modify"' osmChangeFeatureIDFieldIndex' pointCollection' trackChanges);                                changeFeature.Shape = (IGeometry)pointCollection;                                // now let's check the old geometry if we need to delete a node                              List<int> nowMissingNodes = findDeletedNodeIDs(((IFeatureChanges)changeFeature).OriginalShape' changeFeature.Shape);                                // no deleted nodes were detected                              // we are done at this point                              if (nowMissingNodes.Count > 0)                              {                                  string sqlPointOSMID = pointFeatureClass.SqlIdentifier("OSMID");                                    foreach (int deleteNodeID in nowMissingNodes)                                  {                                      IQueryFilter queryfilter = new QueryFilter();                                      IFeature foundFeature = null;                                      if (_ExtensionVersion == 1)                                      {                                          queryfilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(deleteNodeID' "OSMID"' _ExtensionVersion);                                            IFeatureCursor searchCursor = pointFeatureClass.Search(queryfilter' false);                                          foundFeature = searchCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              foundFeature = pointFeatureClass.GetFeature(deleteNodeID);                                          }                                          catch                                          {                                              foundFeature = null;                                          }                                      }                                        if (foundFeature != null)                                      {                                          int wayRefCount = 0;                                            if (pointwayRefCountFieldIndex > -1)                                          {                                              wayRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                          }                                              if (wayRefCount > 1)                                          {                                              foundFeature.set_Value(pointwayRefCountFieldIndex' wayRefCount - 1);                                                //if (pointTrackChangesFieldIndex > -1)                                              //{                                              //    if (trackChanges == false)                                              //    {                                              //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                              //    }                                              //}                                                foundFeature.Store();                                          }                                          else                                          {                                              // delete the vertex from the parent feature as well                                              List<string> isMembersOf = _osmUtility.retrieveIsMemberOf(foundFeature' pointisMemberOfFieldIndex);                                                Dictionary<string' string> isMembersOfIDsAndTypes = _osmUtility.parseIsMemberOfList(isMembersOf);                                                #region use isMemberOf info to determine relationship to parent                                              IFeatureClass fc = (IFeatureClass)changedObject.Class;                                              string sqlOSMID = fc.SqlIdentifier("OSMID");                                                foreach (string currentParentID in isMembersOfIDsAndTypes.Keys)                                              {                                                  using (ComReleaser comReleaser = new ComReleaser())                                                  {                                                      IQueryFilter parentIDFilter = new QueryFilterClass();                                                      parentIDFilter.WhereClause = sqlOSMID + " = " + currentParentID;                                                        IFeatureCursor parentUpdateFeatureCursor = fc.Search(parentIDFilter' false);                                                      comReleaser.ManageLifetime(parentUpdateFeatureCursor);                                                        IFeature currentParentFeature = parentUpdateFeatureCursor.NextFeature();                                                        // for each of the found parents' loop through and remove the point                                                      while (currentParentFeature != null)                                                      {                                                          bool geometryChanged = false;                                                          IPointCollection parentPointCollection = currentParentFeature.Shape as IPointCollection;                                                            if (parentPointCollection != null)                                                          {                                                              for (int parentPointIndex = 0; parentPointIndex < parentPointCollection.PointCount; parentPointIndex++)                                                              {                                                                  IPoint currentTestPoint = parentPointCollection.get_Point(parentPointIndex);                                                                    if (currentTestPoint.ID.Equals(deleteNodeID))                                                                  {                                                                      geometryChanged = true;                                                                      parentPointCollection.RemovePoints(parentPointIndex' 1);                                                                  }                                                              }                                                          }                                                            if (geometryChanged)                                                          {                                                              currentParentFeature.Shape = parentPointCollection as IGeometry;                                                                //if (trackChanges == false)                                                              //{                                                              //    if (osmTrackChangesFieldIndex > -1)                                                              //    {                                                              //        currentParentFeature.set_Value(osmTrackChangesFieldIndex' 0);                                                              //    }                                                              //}                                                                // persist the changes back to the database                                                              currentParentFeature.Store();                                                          }                                                            currentParentFeature = parentUpdateFeatureCursor.NextFeature();                                                      }                                                  }                                              }                                              #endregion                                                foundFeature.Delete();                                          }                                      }                                  } // for each of the missing nodes                              } // missing nodes count larger than 0                           }  // geometry type test                      } // IRelationOp::Equal test                      else                      {                          // This means the shape is only different by vertex IDs or some other metadata                          //   so reset the shape to the original geometry to get back the IDs                          changeFeature.Shape = oldGeometry;                      }                  } // shape.changed              }              catch { }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,SetTemporaryIndex,The following statement contains a magic number: if (_temporaryIndex >= 0)              {                  if (_ExtensionVersion == 1)                      _temporaryIndex = determineMinTemporaryOSMID(testObject' _temporaryIndex);                  else if (_ExtensionVersion == 2)                      _temporaryIndex = determineMinTemporaryOSMID(revisionTable' _temporaryIndex);                    TempIndicies[_revisionTableName] = _temporaryIndex;              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,getLowestOSMID,The following statement contains a magic number: if (osmIDFieldIndex > -1)              {                  using (ComReleaser comReleaser = new ComReleaser())                  {                      ICursor searchCursor = inputTable.Search(null' true);                      comReleaser.ManageLifetime(searchCursor);                        long currentID = 10000;                        IRow row = searchCursor.NextRow();                        while (row != null)                      {                          try                          {                              object osmIDValue = row.get_Value(osmIDFieldIndex);                              if (osmIDValue != DBNull.Value)                              {                                  currentID = Convert.ToInt64(row.get_Value(osmIDFieldIndex));                              }                                newTempID = Math.Min(newTempID' currentID);                              row = searchCursor.NextRow();                          }                          catch                          {                              catchCounter = catchCounter + 1;                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,LogOSMAction,The following statement contains a magic number: if (revOldIdFieldIndex > -1)              {                  if (_ExtensionVersion == 1)                      row.set_Value(revOldIdFieldIndex' Convert.ToInt32(elementID));                  else if (_ExtensionVersion == 2)                      row.set_Value(revOldIdFieldIndex' Convert.ToString(elementID));              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: if (_ExtensionVersion == 2)              {                  // check if the geometry ID and the ObjectID are the same                  IPoint pointGeometry = targetFeature.Shape as IPoint;                    if (pointGeometry != null)                  {                      bool geometryChanged = false;                      IPointIDAware pointIDAware = pointGeometry as IPointIDAware;                        if (pointIDAware.PointIDAware)                      {                          if (pointGeometry.ID != targetFeature.OID)                          {                              pointGeometry.ID = targetFeature.OID;                              geometryChanged = true;                          }                      }                      else                      {                          pointIDAware.PointIDAware = true;                          pointGeometry.ID = targetFeature.OID;                          geometryChanged = true;                      }                        if (geometryChanged)                          targetFeature.Shape = pointGeometry;                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: using (ComReleaser comReleaser = new ComReleaser())              {                  osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                    long osmID = 0;                  int osmVersion = 0;                    if (osmIDValue == DBNull.Value)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                        //if (osmTrackFeatureChangesFieldIndex > -1)                      //{                      //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                      //}                      return;                  }                  else                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                    IFeatureClass fcTarget = (IFeatureClass)targetFeature.Class;                    // let's first check if a node with the same osmID already exists                  IQueryFilter osmIDQueryFilter = new QueryFilterClass();                  osmIDQueryFilter.WhereClause = fcTarget.WhereClauseByExtensionVersion(osmID' "OSMID"' _ExtensionVersion);                    IFeatureCursor osmIDCursor = fcTarget.Search(osmIDQueryFilter' false);                  comReleaser.ManageLifetime(osmIDCursor);                    IFeature matchingOSMIDFeature = osmIDCursor.NextFeature();                  if (matchingOSMIDFeature == null)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                  }                  else                  {                      ISpatialFilter spatialFilter = new SpatialFilterClass();                        IBufferConstruction bc = new BufferConstructionClass();                      IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                        spatialFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                      spatialFilter.Geometry = buffer.Envelope;                      spatialFilter.GeometryField = ((IFeatureClass)targetFeature.Class).ShapeFieldName;                      spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                        // we are looking for coincident points with a different ID                      if (osmIDFieldIndex > -1)                      {                          if (osmIDValue == DBNull.Value)                          {                              spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " IS NOT NULL";                          }                          else                          {                              if (_ExtensionVersion == 1)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> " + Convert.ToInt32(osmIDValue).ToString();                              else if (_ExtensionVersion == 2)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> '" + Convert.ToString(osmIDValue) + "'";                          }                      }                        IFeatureCursor searchCursor = fcTarget.Search(spatialFilter' false);                      comReleaser.ManageLifetime(searchCursor);                        IFeature foundFeature = searchCursor.NextFeature();                        if (foundFeature != null)                      {                          foundFeature = mergeOSMTags(foundFeature' targetFeature' true);                          assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                            if (supportElementFieldIndex > -1)                          {                              foundFeature.set_Value(supportElementFieldIndex' targetFeature.get_Value(supportElementFieldIndex));                          }                            //if (trackFeatureChanges == false)                          //{                          //    if (osmTrackFeatureChangesFieldIndex > -1)                          //    {                          //        foundFeature.set_Value(osmTrackFeatureChangesFieldIndex' 1);                          //    }                          //}                            foundFeature.Store();                            if (m_bypassOSMChangeDetection == false)                          {                              LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)foundFeature.Class).Name' osmID' osmVersion' -1' null);                          }                            foundFeature = searchCursor.NextFeature();                            targetFeature.Delete();                      }                      else                      // this is the case when we have a OSM id assigned because it is handed to us from a line or polygon but the node                       // doesn't exist yet. We just need to log the node creation itself - maybe based on store or insert cursor                      {                          osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                          if (osmIDValue == DBNull.Value)                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                // if a point feature has been explictly created it has to be an OSM feature                              if (supportElementFieldIndex > -1)                              {                                  targetFeature.set_Value(supportElementFieldIndex' "no");                              }                                if (m_bypassOSMChangeDetection == false)                              {                                  LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' _temporaryIndex' 1' -1' null);                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                                DecrementTemporaryIndex();                          }                          else                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                if (m_bypassOSMChangeDetection == false)                              {                                  if (osmID < 0)                                  {                                      LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                  }                                  else                                  {                                      // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved                                      IFeatureChanges fcc = targetFeature as IFeatureChanges;                                      if (fcc != null)                                      {                                          if (fcc.ShapeChanged)                                          {                                              IBufferConstruction pc = new BufferConstructionClass();                                              // exapnd the xy tolerance by 50% for point to be considered equal                                              IGeometry testBuffer = null;                                              if (targetFeature.Shape.SpatialReference is IGeographicCoordinateSystem)                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000);                                              }                                              else                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                                              }                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                if (equalPoint == false)                                              {                                                  LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                              }                                          }                                      }                                  }                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: using (ComReleaser comReleaser = new ComReleaser())              {                  osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                    long osmID = 0;                  int osmVersion = 0;                    if (osmIDValue == DBNull.Value)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                        //if (osmTrackFeatureChangesFieldIndex > -1)                      //{                      //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                      //}                      return;                  }                  else                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                    IFeatureClass fcTarget = (IFeatureClass)targetFeature.Class;                    // let's first check if a node with the same osmID already exists                  IQueryFilter osmIDQueryFilter = new QueryFilterClass();                  osmIDQueryFilter.WhereClause = fcTarget.WhereClauseByExtensionVersion(osmID' "OSMID"' _ExtensionVersion);                    IFeatureCursor osmIDCursor = fcTarget.Search(osmIDQueryFilter' false);                  comReleaser.ManageLifetime(osmIDCursor);                    IFeature matchingOSMIDFeature = osmIDCursor.NextFeature();                  if (matchingOSMIDFeature == null)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                  }                  else                  {                      ISpatialFilter spatialFilter = new SpatialFilterClass();                        IBufferConstruction bc = new BufferConstructionClass();                      IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                        spatialFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                      spatialFilter.Geometry = buffer.Envelope;                      spatialFilter.GeometryField = ((IFeatureClass)targetFeature.Class).ShapeFieldName;                      spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                        // we are looking for coincident points with a different ID                      if (osmIDFieldIndex > -1)                      {                          if (osmIDValue == DBNull.Value)                          {                              spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " IS NOT NULL";                          }                          else                          {                              if (_ExtensionVersion == 1)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> " + Convert.ToInt32(osmIDValue).ToString();                              else if (_ExtensionVersion == 2)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> '" + Convert.ToString(osmIDValue) + "'";                          }                      }                        IFeatureCursor searchCursor = fcTarget.Search(spatialFilter' false);                      comReleaser.ManageLifetime(searchCursor);                        IFeature foundFeature = searchCursor.NextFeature();                        if (foundFeature != null)                      {                          foundFeature = mergeOSMTags(foundFeature' targetFeature' true);                          assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                            if (supportElementFieldIndex > -1)                          {                              foundFeature.set_Value(supportElementFieldIndex' targetFeature.get_Value(supportElementFieldIndex));                          }                            //if (trackFeatureChanges == false)                          //{                          //    if (osmTrackFeatureChangesFieldIndex > -1)                          //    {                          //        foundFeature.set_Value(osmTrackFeatureChangesFieldIndex' 1);                          //    }                          //}                            foundFeature.Store();                            if (m_bypassOSMChangeDetection == false)                          {                              LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)foundFeature.Class).Name' osmID' osmVersion' -1' null);                          }                            foundFeature = searchCursor.NextFeature();                            targetFeature.Delete();                      }                      else                      // this is the case when we have a OSM id assigned because it is handed to us from a line or polygon but the node                       // doesn't exist yet. We just need to log the node creation itself - maybe based on store or insert cursor                      {                          osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                          if (osmIDValue == DBNull.Value)                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                // if a point feature has been explictly created it has to be an OSM feature                              if (supportElementFieldIndex > -1)                              {                                  targetFeature.set_Value(supportElementFieldIndex' "no");                              }                                if (m_bypassOSMChangeDetection == false)                              {                                  LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' _temporaryIndex' 1' -1' null);                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                                DecrementTemporaryIndex();                          }                          else                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                if (m_bypassOSMChangeDetection == false)                              {                                  if (osmID < 0)                                  {                                      LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                  }                                  else                                  {                                      // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved                                      IFeatureChanges fcc = targetFeature as IFeatureChanges;                                      if (fcc != null)                                      {                                          if (fcc.ShapeChanged)                                          {                                              IBufferConstruction pc = new BufferConstructionClass();                                              // exapnd the xy tolerance by 50% for point to be considered equal                                              IGeometry testBuffer = null;                                              if (targetFeature.Shape.SpatialReference is IGeographicCoordinateSystem)                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000);                                              }                                              else                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                                              }                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                if (equalPoint == false)                                              {                                                  LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                              }                                          }                                      }                                  }                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: using (ComReleaser comReleaser = new ComReleaser())              {                  osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                    long osmID = 0;                  int osmVersion = 0;                    if (osmIDValue == DBNull.Value)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                        //if (osmTrackFeatureChangesFieldIndex > -1)                      //{                      //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                      //}                      return;                  }                  else                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                    IFeatureClass fcTarget = (IFeatureClass)targetFeature.Class;                    // let's first check if a node with the same osmID already exists                  IQueryFilter osmIDQueryFilter = new QueryFilterClass();                  osmIDQueryFilter.WhereClause = fcTarget.WhereClauseByExtensionVersion(osmID' "OSMID"' _ExtensionVersion);                    IFeatureCursor osmIDCursor = fcTarget.Search(osmIDQueryFilter' false);                  comReleaser.ManageLifetime(osmIDCursor);                    IFeature matchingOSMIDFeature = osmIDCursor.NextFeature();                  if (matchingOSMIDFeature == null)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                  }                  else                  {                      ISpatialFilter spatialFilter = new SpatialFilterClass();                        IBufferConstruction bc = new BufferConstructionClass();                      IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                        spatialFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                      spatialFilter.Geometry = buffer.Envelope;                      spatialFilter.GeometryField = ((IFeatureClass)targetFeature.Class).ShapeFieldName;                      spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                        // we are looking for coincident points with a different ID                      if (osmIDFieldIndex > -1)                      {                          if (osmIDValue == DBNull.Value)                          {                              spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " IS NOT NULL";                          }                          else                          {                              if (_ExtensionVersion == 1)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> " + Convert.ToInt32(osmIDValue).ToString();                              else if (_ExtensionVersion == 2)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> '" + Convert.ToString(osmIDValue) + "'";                          }                      }                        IFeatureCursor searchCursor = fcTarget.Search(spatialFilter' false);                      comReleaser.ManageLifetime(searchCursor);                        IFeature foundFeature = searchCursor.NextFeature();                        if (foundFeature != null)                      {                          foundFeature = mergeOSMTags(foundFeature' targetFeature' true);                          assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                            if (supportElementFieldIndex > -1)                          {                              foundFeature.set_Value(supportElementFieldIndex' targetFeature.get_Value(supportElementFieldIndex));                          }                            //if (trackFeatureChanges == false)                          //{                          //    if (osmTrackFeatureChangesFieldIndex > -1)                          //    {                          //        foundFeature.set_Value(osmTrackFeatureChangesFieldIndex' 1);                          //    }                          //}                            foundFeature.Store();                            if (m_bypassOSMChangeDetection == false)                          {                              LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)foundFeature.Class).Name' osmID' osmVersion' -1' null);                          }                            foundFeature = searchCursor.NextFeature();                            targetFeature.Delete();                      }                      else                      // this is the case when we have a OSM id assigned because it is handed to us from a line or polygon but the node                       // doesn't exist yet. We just need to log the node creation itself - maybe based on store or insert cursor                      {                          osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                          if (osmIDValue == DBNull.Value)                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                // if a point feature has been explictly created it has to be an OSM feature                              if (supportElementFieldIndex > -1)                              {                                  targetFeature.set_Value(supportElementFieldIndex' "no");                              }                                if (m_bypassOSMChangeDetection == false)                              {                                  LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' _temporaryIndex' 1' -1' null);                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                                DecrementTemporaryIndex();                          }                          else                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                if (m_bypassOSMChangeDetection == false)                              {                                  if (osmID < 0)                                  {                                      LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                  }                                  else                                  {                                      // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved                                      IFeatureChanges fcc = targetFeature as IFeatureChanges;                                      if (fcc != null)                                      {                                          if (fcc.ShapeChanged)                                          {                                              IBufferConstruction pc = new BufferConstructionClass();                                              // exapnd the xy tolerance by 50% for point to be considered equal                                              IGeometry testBuffer = null;                                              if (targetFeature.Shape.SpatialReference is IGeographicCoordinateSystem)                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000);                                              }                                              else                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                                              }                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                if (equalPoint == false)                                              {                                                  LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                              }                                          }                                      }                                  }                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,UpdateMergeNode,The following statement contains a magic number: using (ComReleaser comReleaser = new ComReleaser())              {                  osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                    long osmID = 0;                  int osmVersion = 0;                    if (osmIDValue == DBNull.Value)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                        //if (osmTrackFeatureChangesFieldIndex > -1)                      //{                      //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                      //}                      return;                  }                  else                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                    IFeatureClass fcTarget = (IFeatureClass)targetFeature.Class;                    // let's first check if a node with the same osmID already exists                  IQueryFilter osmIDQueryFilter = new QueryFilterClass();                  osmIDQueryFilter.WhereClause = fcTarget.WhereClauseByExtensionVersion(osmID' "OSMID"' _ExtensionVersion);                    IFeatureCursor osmIDCursor = fcTarget.Search(osmIDQueryFilter' false);                  comReleaser.ManageLifetime(osmIDCursor);                    IFeature matchingOSMIDFeature = osmIDCursor.NextFeature();                  if (matchingOSMIDFeature == null)                  {                      assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                        if (m_bypassOSMChangeDetection == false)                      {                          LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                      }                  }                  else                  {                      ISpatialFilter spatialFilter = new SpatialFilterClass();                        IBufferConstruction bc = new BufferConstructionClass();                      IGeometry buffer = bc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                        spatialFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                      spatialFilter.Geometry = buffer.Envelope;                      spatialFilter.GeometryField = ((IFeatureClass)targetFeature.Class).ShapeFieldName;                      spatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                        // we are looking for coincident points with a different ID                      if (osmIDFieldIndex > -1)                      {                          if (osmIDValue == DBNull.Value)                          {                              spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " IS NOT NULL";                          }                          else                          {                              if (_ExtensionVersion == 1)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> " + Convert.ToInt32(osmIDValue).ToString();                              else if (_ExtensionVersion == 2)                                  spatialFilter.WhereClause = fcTarget.SqlIdentifier("OSMID") + " <> '" + Convert.ToString(osmIDValue) + "'";                          }                      }                        IFeatureCursor searchCursor = fcTarget.Search(spatialFilter' false);                      comReleaser.ManageLifetime(searchCursor);                        IFeature foundFeature = searchCursor.NextFeature();                        if (foundFeature != null)                      {                          foundFeature = mergeOSMTags(foundFeature' targetFeature' true);                          assignBasicMetadata(foundFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                            if (supportElementFieldIndex > -1)                          {                              foundFeature.set_Value(supportElementFieldIndex' targetFeature.get_Value(supportElementFieldIndex));                          }                            //if (trackFeatureChanges == false)                          //{                          //    if (osmTrackFeatureChangesFieldIndex > -1)                          //    {                          //        foundFeature.set_Value(osmTrackFeatureChangesFieldIndex' 1);                          //    }                          //}                            foundFeature.Store();                            if (m_bypassOSMChangeDetection == false)                          {                              LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)foundFeature.Class).Name' osmID' osmVersion' -1' null);                          }                            foundFeature = searchCursor.NextFeature();                            targetFeature.Delete();                      }                      else                      // this is the case when we have a OSM id assigned because it is handed to us from a line or polygon but the node                       // doesn't exist yet. We just need to log the node creation itself - maybe based on store or insert cursor                      {                          osmIDValue = targetFeature.get_Value(osmIDFieldIndex);                          if (osmIDValue == DBNull.Value)                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                // if a point feature has been explictly created it has to be an OSM feature                              if (supportElementFieldIndex > -1)                              {                                  targetFeature.set_Value(supportElementFieldIndex' "no");                              }                                if (m_bypassOSMChangeDetection == false)                              {                                  LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' _temporaryIndex' 1' -1' null);                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                                DecrementTemporaryIndex();                          }                          else                          {                              assignBasicMetadata(targetFeature' osmIDFieldIndex' wayRefCountFieldIndex' osmVersionFieldIndex' out osmID' out osmVersion);                                if (m_bypassOSMChangeDetection == false)                              {                                  if (osmID < 0)                                  {                                      LogOSMAction(revisionTable' "create"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                  }                                  else                                  {                                      // the point geometry will change no matter what -- at this point we need to test further if the point has actually moved                                      IFeatureChanges fcc = targetFeature as IFeatureChanges;                                      if (fcc != null)                                      {                                          if (fcc.ShapeChanged)                                          {                                              IBufferConstruction pc = new BufferConstructionClass();                                              // exapnd the xy tolerance by 50% for point to be considered equal                                              IGeometry testBuffer = null;                                              if (targetFeature.Shape.SpatialReference is IGeographicCoordinateSystem)                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1000);                                              }                                              else                                              {                                                  testBuffer = pc.Buffer(targetFeature.Shape' ((ISpatialReferenceTolerance)targetFeature.Shape.SpatialReference).XYTolerance * 1.1);                                              }                                                bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(fcc.OriginalShape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                if (equalPoint == false)                                              {                                                  LogOSMAction(revisionTable' "modify"' "node"' ((IDataset)targetFeature.Class).Name' osmID' osmVersion' -1' null);                                              }                                          }                                      }                                  }                              }                                //if (osmTrackFeatureChangesFieldIndex > -1)                              //{                              //    targetFeature.set_Value(osmTrackFeatureChangesFieldIndex' 0);                              //}                          }                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,assignBasicMetadata,The following statement contains a magic number: if (osmIDFieldIndex > -1)              {                  object osmIDValue = pointFeature.get_Value(osmIDFieldIndex);                    if (osmIDValue != DBNull.Value)                  {                      osmID = Convert.ToInt64(osmIDValue);                  }                  else                  {                      osmID = _temporaryIndex;                      DecrementTemporaryIndex();                      if (_ExtensionVersion == 1)                          pointFeature.set_Value(osmIDFieldIndex' Convert.ToInt32(osmID));                      else if (_ExtensionVersion == 2)                          pointFeature.set_Value(osmIDFieldIndex' Convert.ToString(osmID));                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,HandleFeatureAdds,The following statement contains a magic number: try              {                  // only feature classes are currently handled' tables are not yet supported                  if (newlyCreatedFeature == null)                  {                      return;                  }                    IPoint currentPointt = newlyCreatedFeature.Shape as IPoint;                        IFeatureClass currentObjectFeatureClass = newlyCreatedFeature.Class as IFeatureClass;                    if (currentObjectFeatureClass == null)                      return;                    // check if the current feature class being edited is acutally an OpenStreetMap feature class                  // all other feature classes should not be touched by this extension                  UID osmFeatureClassExtensionCLSID = currentObjectFeatureClass.EXTCLSID;                    // this could be the case if there is no feature class extension' this is very unlikely as the fc extension itself triggers this code                  // hence it has to exist                  if (osmFeatureClassExtensionCLSID == null)                  {                      return;                  }                    if (osmFeatureClassExtensionCLSID.Value.ToString().Equals("{65CA4847-8661-45eb-8E1E-B2985CA17C78}"' StringComparison.InvariantCultureIgnoreCase) == false)                  {                      return;                  }                    int osmNewFeatureIDFieldIndex = currentObjectFeatureClass.FindField("OSMID");                  int osmNewFeatureVersionFieldIndex = currentObjectFeatureClass.FindField("osmversion");                  int osmNewFeatureSupportElementFieldIndex = currentObjectFeatureClass.FindField("osmSupportingElement");                  int osmNewFeatureIsMemberOfFieldIndex = currentObjectFeatureClass.FindField("osmMemberOf");                  int osmNewFeatureTimeStampFieldIndex = currentObjectFeatureClass.FindField("osmtimestamp");                  int osmTrackChangesFieldIndex = currentObjectFeatureClass.FindField("osmTrackchanges");                    // find the revision table for logging the changes.                  ITable revisionTable = findRevisionTable(newlyCreatedFeature);                    // Set revision table from cache or calculate from revision table                  SetTemporaryIndex(source' revisionTable);                    int revActionFieldIndex = revisionTable.Fields.FindField("osmaction");                  int revElementTypeFieldIndex = revisionTable.Fields.FindField("osmelementtype");                  int revFCNameFieldIndex = revisionTable.Fields.FindField("sourcefcname");                  int revOldIdFieldIndex = revisionTable.Fields.FindField("osmoldid"); ;                    // if the feature is a point treat it separately                  if (newlyCreatedFeature.Shape.GeometryType == esriGeometryType.esriGeometryPoint)                  {                      UpdateMergeNode(newlyCreatedFeature' revisionTable);                  }                  else                  {                      IFeatureClass pointFeatureClass = null;                        // look for a matching OSM node feature class in the current map document                      // otherwise open the node feature class directly                      pointFeatureClass = findMatchingFeatureClass(newlyCreatedFeature' esriGeometryType.esriGeometryPoint);                        if (pointFeatureClass == null)                      {                          System.Diagnostics.Debug.WriteLine("unable to locate point (osm node) feature class in adds adjustment");                          return;                      }                        // loop through the nodes if a vertex already exists as an existing point (maybe due to point snap)                      // then assign the already existing ID to it'                      // if not then create a matching supporting node in the point feature class                      IPointCollection pointCollection = newlyCreatedFeature.Shape as IPointCollection;                        // make the top level geometry ID aware                      IPointIDAware topGeometryIDAware = pointCollection as IPointIDAware;                      if (topGeometryIDAware != null)                      {                          topGeometryIDAware.PointIDAware = true;                      }                        bool trackChanges = true;                        //if (osmTrackChangesFieldIndex > -1)                      //{                      //    try                      //    {                      //        int trackChangesIndicator = Convert.ToInt32(newlyCreatedFeature.get_Value(osmTrackChangesFieldIndex));                        //        if (trackChangesIndicator != 0)                      //        {                      //            trackChanges = false;                      //        }                      //    }                      //    catch { }                      //}                          long featureOSMID = -1;                        // set some initial metadata on the newly created feature                      if (osmNewFeatureIDFieldIndex > -1)                      {                          // check if the feature needs a new ID or if it is created by a top-level geometry (in the case of multi-parts)                          object osmIDValue = newlyCreatedFeature.get_Value(osmNewFeatureIDFieldIndex);                            if (osmIDValue == DBNull.Value)                          {                              featureOSMID = _temporaryIndex;                              DecrementTemporaryIndex();                                if (_ExtensionVersion == 1)                                  newlyCreatedFeature.set_Value(osmNewFeatureIDFieldIndex' Convert.ToInt32(featureOSMID));                              else if (_ExtensionVersion == 2)                                  newlyCreatedFeature.set_Value(osmNewFeatureIDFieldIndex' Convert.ToString(featureOSMID));                          }                          else                          {                              featureOSMID = Convert.ToInt64(osmIDValue);                                // if the code in instructed to create a new feature with a negative OSMID then something else duplicating a new feature with                              // existing attributes - that is not allowed by definition hence to decrement the temporary index by 1 to indicate a new feature                              if (featureOSMID < 0)                              {                                  featureOSMID = _temporaryIndex;                                  DecrementTemporaryIndex();                              }                          }                      }                        if (osmNewFeatureVersionFieldIndex > -1)                      {                          newlyCreatedFeature.set_Value(osmNewFeatureVersionFieldIndex' 1);                      }                          IGeometryCollection existingGeometryCollection = pointCollection as IGeometryCollection;                        // ensure that the incoming geometry are conforming to the node limit of OSM as well as multi-part geometries being prepared to be                       // represented as relations                      pointCollection = createOSMRelationNodeClusters("add"' newlyCreatedFeature' osmNewFeatureIDFieldIndex' osmNewFeatureVersionFieldIndex' osmNewFeatureSupportElementFieldIndex' osmNewFeatureIsMemberOfFieldIndex' osmNewFeatureTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          // we will need a new geometry container                      IGeometryCollection updatedGeometryCollection = null;                      if (pointCollection is IPolyline)                      {                          updatedGeometryCollection = new PolylineClass();                      }                      else if (pointCollection is IPolygon)                      {                          updatedGeometryCollection = new PolygonClass();                      }                          if (updatedGeometryCollection != null)                      {                          IPointIDAware pointIDAware = updatedGeometryCollection as IPointIDAware;                            if (pointIDAware != null)                          {                              pointIDAware.PointIDAware = true;                          }                      }                        object missingValue = Missing.Value;                        // let's loop through all geometry parts                        for (int geometryIndex = 0; geometryIndex < existingGeometryCollection.GeometryCount; geometryIndex++)                      {                          IPointCollection geometryPartPointCollection = existingGeometryCollection.get_Geometry(geometryIndex) as IPointCollection;                            // check all points if they are coincident with already existing points or if they need to be created                            geometryPartPointCollection = checkAllPoints(newlyCreatedFeature' pointFeatureClass' "create"' osmNewFeatureIDFieldIndex' geometryPartPointCollection' trackChanges);                            updatedGeometryCollection.AddGeometry((IGeometry)geometryPartPointCollection' ref missingValue' ref missingValue);                      }                        // ensure that the changes and adjustments are persisted back to the geometry                      newlyCreatedFeature.Shape = updatedGeometryCollection as IGeometry;                        // ensure that if we create a multi-part polygon geometry that there is acutally a tag to indicate such (multipolygon)                      if ((pointCollection is IPolygon) && (updatedGeometryCollection.GeometryCount > 1))                      {                          int osmTagFieldIndex = newlyCreatedFeature.Fields.FindField("osmTags");                            bool tagAlreadyExits = false;                          if (osmTagFieldIndex > -1)                          {                              tag[] existingTags = _osmUtility.retrieveOSMTags(newlyCreatedFeature' osmTagFieldIndex' null);                                List<tag> featureTags = null;                              if (existingTags != null)                                  featureTags = new List<tag>(_osmUtility.retrieveOSMTags(newlyCreatedFeature' osmTagFieldIndex' null));                              else                                  featureTags = new List<tag>();                                foreach (tag currentTag in featureTags)                              {                                  if (currentTag.k.ToUpper().Equals("TYPE") == true)                                  {                                      tagAlreadyExits = true;                                  }                              }                              if (tagAlreadyExits == false)                              {                                  tag multipolygonTag = new tag();                                  multipolygonTag.k = "type";                                  multipolygonTag.v = "multipolygon";                                    featureTags.Add(multipolygonTag);                                    _osmUtility.insertOSMTags(osmTagFieldIndex' newlyCreatedFeature' featureTags.ToArray());                              }                          }                      }                        if (m_bypassOSMChangeDetection == false)                      {                          if (((IGeometryCollection)pointCollection).GeometryCount > 1)                          {                              LogOSMAction(revisionTable' "create"' "relation"' ((IDataset)newlyCreatedFeature.Class).Name' featureOSMID' 1' -1' null);                          }                          else                          {                              LogOSMAction(revisionTable' "create"' "way"' ((IDataset)newlyCreatedFeature.Class).Name' featureOSMID' 1' -1' null);                          }                      }                        // change the indicator back to track everything                      //if (osmTrackChangesFieldIndex > -1)                      //{                      //    newlyCreatedFeature.set_Value(osmTrackChangesFieldIndex' 0);                      //}                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The following statement contains a magic number: try              {                  // add this point we should get all the vertices with a new ID back                  IEnumVertex enumVertex = partPointCollection.EnumVertices;                  //List<int> addIDs = detectPartAdds(((IFeatureChanges)newlyCreatedFeature).OriginalShape' partPointCollection as IGeometry);                  List<long> addIDs = detectPartAdds(null' partPointCollection as IGeometry);                    //check if we have the case of a coincident point                  // - in case we do have a coincident point then update the ID with the existing ID and increase the ref counter                  // - in case we don't have a point then let's store a new supporting node                     int pointSupportElementFieldIndex = pointFeatureClass.FindField("osmSupportingElement");                  int pointOSMIDFieldIndex = pointFeatureClass.FindField("OSMID");                  int pointwayRefCountFieldIndex = pointFeatureClass.FindField("wayRefCount");                  int pointVersionFieldIndex = pointFeatureClass.FindField("osmversion");                  int pointisMemberOfFieldIndex = pointFeatureClass.FindField("osmMemberOf");                  int pointTrackChangesFieldIndex = pointFeatureClass.FindField("osmTrackChanges");                    string sqlOSMID = pointFeatureClass.SqlIdentifier("OSMID");                    IQueryFilter nodeQueryFilter = new QueryFilterClass();                    enumVertex.Reset();                    IPoint currentPoint = null;                  int partIndex = -1;                  int vertexIndex = -1;                  int addVertexCounter = 0;                    enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                    // for polygon and line features loop through all the points and determine if they are new or coincident points                  while (currentPoint != null)                  {                      if (enumVertex.IsLastInPart() && newlyCreatedFeature.Shape is IPolygon)                      {                          // skip the last vertex for a part in a polygon as it is supposed to be coincident with the first node                      }                      else                      {                          currentPoint.Project(((IGeoDataset)pointFeatureClass).SpatialReference);                            // to find the coincident point let's run an intersection operation with the existing point feature class                          ISpatialFilter pointSearchFilter = new SpatialFilterClass();                            // Original code from Thomas to see if there a duplicate node                          IBufferConstruction bc = new BufferConstructionClass();                          // exapnd the xy tolerance by 50% for point to be considered equal                          IGeometry buffer = null;                          if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                          }                          else                          {                              buffer = bc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.1);                          }                            ((IPolygon)buffer).SimplifyPreserveFromTo();                            pointSearchFilter.Geometry = buffer.Envelope;                          pointSearchFilter.SearchOrder = esriSearchOrder.esriSearchOrderSpatial;                          pointSearchFilter.GeometryField = pointFeatureClass.ShapeFieldName;                          pointSearchFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelContains;                            using (ComReleaser comReleaser = new ComReleaser())                          {                                IFeatureCursor updateCursor = pointFeatureClass.Search(pointSearchFilter' false);                              comReleaser.ManageLifetime(updateCursor);                                IFeature foundFeature = updateCursor.NextFeature();                                // if we find an already existing point/node feature then are dealing with coincident geometries                              // and we need to adjustment the vertex ID to reference the already existing one                              if (foundFeature != null)                              {                                  long searchOSMID = 0;                                  if (osmNewFeatureIDFieldIndex > -1)                                  {                                      searchOSMID = Convert.ToInt64(foundFeature.get_Value(osmNewFeatureIDFieldIndex));                                  }                                    // if we found a match' please ensure that it is not the node (by id) itself                                  // this can happen when we store the top level geometry first' and then add the individual parts second                                  bool comparison = false;                                  if (_ExtensionVersion == 1)                                      comparison = currentPoint.ID != searchOSMID;                                  else if (_ExtensionVersion == 2)                                      comparison = currentPoint.ID != foundFeature.OID;                                    if (comparison)                                  {                                      partPointCollection.UpdatePoint(vertexIndex' (IPoint)foundFeature.Shape);                                        if (_ExtensionVersion == 1)                                      {                                          currentPoint.ID = (int)searchOSMID;                                          enumVertex.put_ID((int)searchOSMID);                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          currentPoint.ID = foundFeature.OID;                                          enumVertex.put_ID(foundFeature.OID);                                      }                                        // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        foundFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        foundFeature.Store();                                  }                                    else if (!comparison && action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                  {                                      // for split the new higher-order geometry contains the (existing) nodes but it will also                                      // be deleted later-on due to the split behavior                                      // update the ref count on the node                                      if (pointwayRefCountFieldIndex > -1)                                      {                                          int currentRefCount = Convert.ToInt32(foundFeature.get_Value(pointwayRefCountFieldIndex));                                            currentRefCount = currentRefCount + 1;                                          foundFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                            foundFeature.Store();                                      }                                  }                                    addVertexCounter = addVertexCounter + 1;                              }                              else                              {                                  // then we have a previously existing node // let's just track the move                                  if (currentPoint.ID > 0)                                  {                                      IFeature existingNodeFeature = null;                                        if (_ExtensionVersion == 1)                                      {                                          nodeQueryFilter.WhereClause = pointFeatureClass.WhereClauseByExtensionVersion(currentPoint.ID' "OSMID"' _ExtensionVersion);                                          IFeatureCursor nodeUpdateCursor = pointFeatureClass.Search(nodeQueryFilter' false);                                          comReleaser.ManageLifetime(nodeUpdateCursor);                                            existingNodeFeature = nodeUpdateCursor.NextFeature();                                      }                                      else if (_ExtensionVersion == 2)                                      {                                          try                                          {                                              existingNodeFeature = pointFeatureClass.GetFeature(currentPoint.ID);                                          }                                          catch                                          {                                              existingNodeFeature = null;                                          }                                      }                                        if (existingNodeFeature != null)                                      {                                          if (action.ToLower(CultureInfo.InvariantCulture).Equals("create"))                                          {                                              // update the ref count on the node                                              if (pointwayRefCountFieldIndex > -1)                                              {                                                  int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                    currentRefCount = currentRefCount + 1;                                                  existingNodeFeature.set_Value(pointwayRefCountFieldIndex' currentRefCount);                                              }                                          }                                            // -------                                          // if the ref counter on the node is larger than 1 it means that some other entity is using the same node                                          // in this case we create a new node for the parent feature and decrease the ref counter on the found feature                                          if (pointwayRefCountFieldIndex > -1)                                          {                                              int currentRefCount = Convert.ToInt32(existingNodeFeature.get_Value(pointwayRefCountFieldIndex));                                                if (currentRefCount > 1)                                              {                                                  IBufferConstruction pc = new BufferConstructionClass();                                                  // exapnd the xy tolerance by 50% for point to be considered equal                                                  IGeometry testBuffer = null;                                                  if (currentPoint.SpatialReference is IGeographicCoordinateSystem)                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1000);                                                  }                                                  else                                                  {                                                      testBuffer = pc.Buffer(currentPoint' ((ISpatialReferenceTolerance)currentPoint.SpatialReference).XYTolerance * 1.5);                                                  }                                                    bool equalPoint = ((IRelationalOperator2)testBuffer).ContainsEx(existingNodeFeature.Shape' esriSpatialRelationExEnum.esriSpatialRelationExProper);                                                    if (equalPoint == false)                                                  {                                                        IFeature newSupportFeature = pointFeatureClass.CreateFeature();                                                        IPoint newSupportPoint = ((IClone)currentPoint).Clone() as IPoint;                                                      newSupportPoint.ID = newSupportFeature.OID;                                                        newSupportFeature.Shape = newSupportPoint;                                                        // the current point needs a new ID                                                      currentPoint.ID = newSupportFeature.OID;                                                      enumVertex.put_ID(newSupportFeature.OID);                                                        if (pointSupportElementFieldIndex > -1)                                                          newSupportFeature.set_Value(pointSupportElementFieldIndex' "yes");                                                        if (pointOSMIDFieldIndex > -1)                                                      {                                                          if (_ExtensionVersion == 1)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(_temporaryIndex));                                                          else if (_ExtensionVersion == 2)                                                              newSupportFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(_temporaryIndex));                                                            DecrementTemporaryIndex();                                                      }                                                        if (pointVersionFieldIndex > -1)                                                      {                                                          newSupportFeature.set_Value(pointVersionFieldIndex' 1);                                                      }                                                        //if (trackChanges == false)                                                      //{                                                      //    if (pointTrackChangesFieldIndex > -1)                                                      //    {                                                      //        newSupportFeature.set_Value(pointTrackChangesFieldIndex' 1);                                                      //    }                                                      //}                                                        newSupportFeature.Store();                                                        // the replaced vertices will be recognized as deletes later on                                                       // and then the ref counter will be adjusted approppriately                                                  }                                              }                                              else                                              {                                                  // assign the updated geometry to the existing node                                                  existingNodeFeature.Shape = ((IClone)currentPoint).Clone() as IPoint;                                              }                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        existingNodeFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            // persist the changes for the point                                          existingNodeFeature.Store();                                      }                                      else                                      {                                          // now here is the checking for the special case due to a merge operation                                          // a merge operation is defined by a delete and an add - this is problematic for the OSM data structure                                          // as we need to keep track of the way (polygon/polyline) as well as the points                                          // the core editor doesn't know about this relationship and hence after the first delete request' all the nodes                                          // are deleted as well -                                           // since this is a special case and we are "only" deleting supporting nodes/points I hope that most users would accept                                          // that we are recreating the points from scratch                                          // if this procedure turns out to be an unacceptable no-no then we need to block the merge operation with a more succinct                                           // error message                                          if (currentPoint.ID > -1)                                          {                                              // we are populating the add IDs as we go - but as opposed to adding the currently used one (for which we deleted the OSM metadata info)                                              // we pick a new ID                                              addIDs.Add(_temporaryIndex);                                              DecrementTemporaryIndex();                                          }                                            // in this case we have a new point/node geometry                                          // - create a matching node in the node feature class and log the creation in the revision table                                            IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                            // add the id to the local point copy as well                                          if (_ExtensionVersion == 1)                                          {                                              enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                              currentPoint.ID = Convert.ToInt32(addIDs[addVertexCounter]);                                          }                                          else if (_ExtensionVersion == 2)                                          {                                              enumVertex.put_ID(newSupportingPointFeature.OID);                                              currentPoint.ID = newSupportingPointFeature.OID;                                          }                                            newSupportingPointFeature.Shape = currentPoint;                                            if (pointSupportElementFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                          }                                            if (pointOSMIDFieldIndex > -1)                                          {                                              if (_ExtensionVersion == 1)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                              else if (_ExtensionVersion == 2)                                                  newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                          }                                            if (pointVersionFieldIndex > -1)                                          {                                              newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                          }                                            //if (trackChanges == false)                                          //{                                          //    if (pointTrackChangesFieldIndex > -1)                                          //    {                                          //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                          //    }                                          //}                                            newSupportingPointFeature.Store();                                      }                                        addVertexCounter = addVertexCounter + 1;                                  }                                  else                                  {                                      IFeature newSupportingPointFeature = pointFeatureClass.CreateFeature();                                        // in this case we have a new point/node geometry                                      // - create a matching node in the node feature class and log the creation in the revision table                                        if (_ExtensionVersion == 1)                                          enumVertex.put_ID(Convert.ToInt32(addIDs[addVertexCounter]));                                      else if (_ExtensionVersion == 2)                                      {                                          enumVertex.put_ID(newSupportingPointFeature.OID);                                          currentPoint.ID = newSupportingPointFeature.OID;                                      }                                        newSupportingPointFeature.Shape = currentPoint;                                        if (pointSupportElementFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointSupportElementFieldIndex' "yes");                                      }                                        if (pointOSMIDFieldIndex > -1)                                      {                                          if (_ExtensionVersion == 1)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToInt32(addIDs[addVertexCounter]));                                          else if (_ExtensionVersion == 2)                                              newSupportingPointFeature.set_Value(pointOSMIDFieldIndex' Convert.ToString(addIDs[addVertexCounter]));                                      }                                        if (pointwayRefCountFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointwayRefCountFieldIndex' 1);                                      }                                        if (pointVersionFieldIndex > -1)                                      {                                          newSupportingPointFeature.set_Value(pointVersionFieldIndex' 1);                                      }                                        //if (trackChanges == false)                                      //{                                      //    if (pointTrackChangesFieldIndex > -1)                                      //    {                                      //        newSupportingPointFeature.set_Value(pointTrackChangesFieldIndex' 1);                                      //    }                                      //}                                        newSupportingPointFeature.Store();                                        addVertexCounter = addVertexCounter + 1;                                  }                              }                          }                      }                        enumVertex.Next(out currentPoint' out partIndex' out vertexIndex);                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,createOSMRelationNodeClusters,The following statement contains a magic number: if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolyline)              {                  if (existingGeometryCollection.GeometryCount > 1 || pointCollection.PointCount > 2000)                  {                      // ensure that the newly generated polyline has the same spatial reference as the "old" one                      IGeometryCollection newLineGeometry = new PolylineClass() as IGeometryCollection;                      ((IPolyline)newLineGeometry).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                      IPointIDAware newLinePointIDAware = newLineGeometry as IPointIDAware;                      newLinePointIDAware.PointIDAware = true;                        // create mulit-part polyline                      member newLineMember = null;                      for (int linePartIndex = 0; linePartIndex < existingGeometryCollection.GeometryCount; linePartIndex++)                      {                          IPath currentPath = existingGeometryCollection.get_Geometry(linePartIndex) as IPath;                            IPointCollection pathPointCollection = currentPath as IPointCollection;                          if (pathPointCollection.PointCount > 2000)                          {                              IPointCollection newPathPointCollection = new PathClass() as IPointCollection;                              ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                for (int pointIndex = 0; pointIndex < pathPointCollection.PointCount; pointIndex++)                              {                                  // break the line point collection into chunks of 2000 points (waynodes) --                                   // a number provided by the OSM v0.6 API                                  if ((pointIndex % 2000) == 0)                                  {                                      newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                        // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                                      newLineMember = new member();                                      newLineMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newLineMember.role = String.Empty;                                      newLineMember.type = memberType.way;                                        relationMemberList.Add(newLineMember);                                        storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                        newPathPointCollection = new PathClass() as IPointCollection;                                      ((IPath)newPathPointCollection).SpatialReference = ((IPolyline)pointCollection).SpatialReference;                                    }                                    newPathPointCollection.AddPoint(pathPointCollection.get_Point(pointIndex)' ref MissingValue' ref MissingValue);                                }                                newLineGeometry.AddGeometry((IPath)newPathPointCollection' ref MissingValue' ref MissingValue);                                // since we need to keep feature level OSM metadata around' we need to be sure to add a support object                              newLineMember = new member();                              newLineMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newLineMember.role = String.Empty;                              newLineMember.type = memberType.way;                                relationMemberList.Add(newLineMember);                                storeSupportingGeometry((IGeometry)newPathPointCollection' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                            }                          else                          {                              if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' currentPath);                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                              }                              else                              {                                  newLineGeometry.AddGeometry(currentPath' ref MissingValue' ref MissingValue);                                    newLineMember = new member();                                  newLineMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newLineMember.role = String.Empty;                                  newLineMember.type = memberType.way;                                    relationMemberList.Add(newLineMember);                                    storeSupportingGeometry((IGeometry)currentPath' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newLineMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                      }                        // make sure that all the newly added geometries are recognized and the geometry caches are invalidated                      newLineGeometry.GeometriesChanged();                      // assign the newly created line geometry to the existing point collection pointer                      pointCollection = newLineGeometry as IPointCollection;                  }              }              else if (workingFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon)              {                  IGeometryCollection existingPolygonGeometryCollection = pointCollection as IGeometryCollection;                    if (existingPolygonGeometryCollection.GeometryCount > 1)                  {                      IPolygon4 polyPointCollection = pointCollection as IPolygon4;                      polyPointCollection.SimplifyPreserveFromTo();                        // each ring (way) element can't have more than 2000 nodes                      IGeometryCollection outerRingGeometryCollection = polyPointCollection.ExteriorRingBag as IGeometryCollection;                        for (int outerRingIndex = 0; outerRingIndex < outerRingGeometryCollection.GeometryCount; outerRingIndex++)                      {                          IGeometryCollection innerRingGeometryCollection = polyPointCollection.get_InteriorRingBag((IRing)outerRingGeometryCollection.get_Geometry(outerRingIndex)) as IGeometryCollection;                            for (int innerRingIndex = 0; innerRingIndex < innerRingGeometryCollection.GeometryCount; innerRingIndex++)                          {                              IPointCollection innerRingPointCollection = innerRingGeometryCollection.get_Geometry(innerRingIndex) as IPointCollection;                                if (innerRingPointCollection.PointCount > 2000)                              {                                  string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' innerRingIndex);                                  throw new ArgumentException(errorMessage);                              }                                if (action.Equals("change"))                              {                                  int partIndex = findPartIndex(originalGeometryCollection' innerRingGeometryCollection.get_Geometry(innerRingIndex));                                    if (partIndex > -1)                                  {                                      relationMemberList.Add(currentMembers[partIndex]);                                  }                                  else                                  {                                      member newHoleMember = new member();                                      newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                      DecrementTemporaryIndex();                                      newHoleMember.role = "inner";                                      newHoleMember.type = memberType.way;                                        relationMemberList.Add(newHoleMember);                                        storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                                  }                              }                              else                              {                                  member newHoleMember = new member();                                  newHoleMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newHoleMember.role = "inner";                                  newHoleMember.type = memberType.way;                                    relationMemberList.Add(newHoleMember);                                    storeSupportingGeometry(innerRingGeometryCollection.get_Geometry(innerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newHoleMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                            IPointCollection ringPointCollection = outerRingGeometryCollection.get_Geometry(outerRingIndex) as IPointCollection;                            if (ringPointCollection.PointCount > 2000)                          {                              string errorMessage = String.Format(resourceManager.GetString("OSMClassExtension_FeatureInspector_pointnumber_exceeeded_in_ring")' 2000' outerRingIndex);                              throw new ArgumentException(errorMessage);                          }                            if (action.Equals("change"))                          {                              int partIndex = findPartIndex(originalGeometryCollection' outerRingGeometryCollection.get_Geometry(outerRingIndex));                                if (partIndex > -1)                              {                                  relationMemberList.Add(currentMembers[partIndex]);                              }                              else                              {                                  member newPolygonMember = new member();                                  newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                                  DecrementTemporaryIndex();                                  newPolygonMember.role = "outer";                                  newPolygonMember.type = memberType.way;                                    relationMemberList.Add(newPolygonMember);                                    storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt32(newPolygonMember.@ref)' (int)workingFeature.get_Value(osmIDFieldIndex)' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                              }                          }                          else                          {                              member newPolygonMember = new member();                              newPolygonMember.@ref = Convert.ToString(_temporaryIndex);                              DecrementTemporaryIndex();                              newPolygonMember.role = "outer";                              newPolygonMember.type = memberType.way;                                relationMemberList.Add(newPolygonMember);                                storeSupportingGeometry(outerRingGeometryCollection.get_Geometry(outerRingIndex)' (IFeatureClass)workingFeature.Class' Convert.ToInt64(newPolygonMember.@ref)' Convert.ToInt64(workingFeature.get_Value(osmIDFieldIndex))' osmIDFieldIndex' versionFieldIndex' osmSupportElementFieldIndex' osmIsMemberOfFieldIndex' osmTimeStampFieldIndex' osmTrackChangesFieldIndex' trackChanges);                          }                      }                  }                    if (existingGeometryCollection.GeometryCount > 1)                  {                      if (workingFeatureMembersFieldIndex > -1)                      {                          _osmUtility.insertMembers(workingFeatureMembersFieldIndex' workingFeature' relationMemberList.ToArray());                      }                  }              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,storeSupportingGeometry,The following statement contains a magic number: if (osmIDFieldIndex > -1)              {                  if (_ExtensionVersion == 1)                      newSupportFeature.set_Value(osmIDFieldIndex' Convert.ToInt32(osmIdentifier));                  else if (_ExtensionVersion == 2)                      newSupportFeature.set_Value(osmIDFieldIndex' Convert.ToString(osmIdentifier));              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OSMClassExtensionManager,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMClassExtensionManager.cs,WhereClauseByExtensionVersion,The following statement contains a magic number: if (extensionVersion == 1)              {                  whereClause = table.SqlIdentifier(fieldName) + " = " + Convert.ToString(osmID);              }              else if (extensionVersion == 2)              {                  whereClause = table.SqlIdentifier(fieldName) + " = '" + Convert.ToString(osmID) + "'";              }              else              {                  whereClause = table.SqlIdentifier(fieldName) + " = '" + Convert.ToString(osmID) + "'";              }
Magic Number,ESRI.ArcGIS.OSM.OSMClassExtension,OSMUtility,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OSMUtility.cs,parseIsMemberOfList,The following statement contains a magic number: try              {                  foreach (string isMemberOfItem in isMemberOfList)                  {                      string[] splitResults = isMemberOfItem.Split("_".ToCharArray());                        if (splitResults.Length == 1)                      {                          isMemberOfDictionary.Add(splitResults[0]' "rel");                      }                      else if (splitResults.Length == 2)                      {                          isMemberOfDictionary.Add(splitResults[0]' splitResults[1]);                      }                      else                      {                          isMemberOfDictionary.Add(splitResults[0]' splitResults[1]);                      }                  }              }              catch (Exception ex)              {                  System.Diagnostics.Debug.WriteLine(ex.Message);                  System.Diagnostics.Debug.WriteLine(ex.StackTrace);              }
Duplicate Code,ESRI.ArcGIS.Editor,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((304' 324)' (352' 372))
Duplicate Code,ESRI.ArcGIS.OSM.OSMClassExtension,OpenStreetMapClassExtension,C:\repos\Esri_arcgis-osm-editor\src\OSMClassExtension\OpenStreetMapClassExtension.cs,checkAllPoints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((304' 324)' (352' 372))
