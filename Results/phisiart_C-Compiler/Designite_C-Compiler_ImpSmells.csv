Implementation smell,Namespace,Class,File,Method,Description
Long Method,ABT,Decln,C:\repos\phisiart_C-Compiler\ABT\Declarations.cs,CGenDecln,The method has 135 lines of code.
Long Method,ABT,Variable,C:\repos\phisiart_C-Compiler\ABT\Expressions.cs,CGenValue,The method has 126 lines of code.
Long Method,ABT,FuncCall,C:\repos\phisiart_C-Compiler\ABT\Expressions.cs,CGenValue,The method has 133 lines of code.
Long Method,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,SignedIntegralToArith,The method has 108 lines of code.
Long Method,ABT,IncDecExpr,C:\repos\phisiart_C-Compiler\ABT\UnaryOperators.cs,CGenValue,The method has 179 lines of code.
Long Method,Parsing,CParsers,C:\repos\phisiart_C-Compiler\Parser\CParsers.cs,SetDeclarationRules,The method has 405 lines of code.
Long Method,Parsing,CParsers,C:\repos\phisiart_C-Compiler\Parser\CParsers.cs,SetExpressionRules,The method has 281 lines of code.
Long Method,Parsing,CParsers,C:\repos\phisiart_C-Compiler\Parser\CParsers.cs,SetStatementRules,The method has 149 lines of code.
Long Method,LexicalAnalysis,FSAFloat,C:\repos\phisiart_C-Compiler\Scanner\Float.cs,ReadChar,The method has 122 lines of code.
Long Method,LexicalAnalysis,FSAInt,C:\repos\phisiart_C-Compiler\Scanner\Int.cs,ReadChar,The method has 112 lines of code.
Long Method,LexicalAnalysis,FSAOperator,C:\repos\phisiart_C-Compiler\Scanner\Operator.cs,ReadChar,The method has 189 lines of code.
Complex Method,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,ToPointer,Cyclomatic complexity of the method is 10
Complex Method,AST,Sub,C:\repos\phisiart_C-Compiler\AST\BinaryOperators.cs,GetExpr,Cyclomatic complexity of the method is 8
Complex Method,AST,StructOrUnionSpec,C:\repos\phisiart_C-Compiler\AST\DeclarationSpecifiers.cs,GetExprType,Cyclomatic complexity of the method is 8
Complex Method,AST,EnumSpec,C:\repos\phisiart_C-Compiler\AST\DeclarationSpecifiers.cs,GetExprType,Cyclomatic complexity of the method is 9
Long Parameter List,ABT,Scope,C:\repos\phisiart_C-Compiler\ABT\Environment.cs,Scope,The method has 6 parameters. Parameters: stack_entries' stack_offset' global_entries' curr_func' typedef_entries' enum_entries
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,SignedIntegralToArith,The length of the statement  "                            return new TypeCast(TypeCastType.INT32_TO_FLOAT' new TypeCast(TypeCastType.INT8_TO_INT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 148.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,SignedIntegralToArith,The length of the statement  "                            return new TypeCast(TypeCastType.INT32_TO_DOUBLE' new TypeCast(TypeCastType.INT8_TO_INT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 149.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,SignedIntegralToArith,The length of the statement  "                            return new TypeCast(TypeCastType.INT32_TO_FLOAT' new TypeCast(TypeCastType.INT16_TO_INT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 149.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,SignedIntegralToArith,The length of the statement  "                            return new TypeCast(TypeCastType.INT32_TO_DOUBLE' new TypeCast(TypeCastType.INT16_TO_INT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 150.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,UnsignedIntegralToArith,The length of the statement  "                            return new TypeCast(TypeCastType.INT32_TO_FLOAT' new TypeCast(TypeCastType.UINT8_TO_UINT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 150.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,UnsignedIntegralToArith,The length of the statement  "                            return new TypeCast(TypeCastType.INT32_TO_DOUBLE' new TypeCast(TypeCastType.UINT8_TO_UINT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 151.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,UnsignedIntegralToArith,The length of the statement  "                            return new TypeCast(TypeCastType.INT32_TO_FLOAT' new TypeCast(TypeCastType.UINT16_TO_UINT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 151.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,UnsignedIntegralToArith,The length of the statement  "                            return new TypeCast(TypeCastType.INT32_TO_DOUBLE' new TypeCast(TypeCastType.UINT16_TO_UINT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 152.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,FloatToArith,The length of the statement  "                            return new TypeCast(TypeCastType.PRESERVE_INT8' new TypeCast(TypeCastType.FLOAT_TO_INT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 148.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,FloatToArith,The length of the statement  "                            return new TypeCast(TypeCastType.PRESERVE_INT16' new TypeCast(TypeCastType.FLOAT_TO_INT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 149.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,FloatToArith,The length of the statement  "                            return new TypeCast(TypeCastType.PRESERVE_INT16' new TypeCast(TypeCastType.FLOAT_TO_INT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 149.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,FloatToArith,The length of the statement  "                            return FloatToArith(FloatToArith(expr' new FloatType(type.IsConst' type.IsVolatile))' new CharType(type.IsConst' type.IsVolatile)); " is 131.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,FloatToArith,The length of the statement  "                            return FloatToArith(FloatToArith(expr' new FloatType(type.IsConst' type.IsVolatile))' new ShortType(type.IsConst' type.IsVolatile)); " is 132.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,FloatToArith,The length of the statement  "                            return new TypeCast(TypeCastType.PRESERVE_INT16' new TypeCast(TypeCastType.DOUBLE_TO_INT32' expr' new LongType(type.IsConst' type.IsVolatile))' type); " is 150.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,UsualArithmeticConversion,The length of the statement  "                return new Tuple<Expr' Expr' ExprTypeKind>(MakeCast(e1' new DoubleType(c1' v1))' MakeCast(e2' new DoubleType(c2' v2))' ExprTypeKind.DOUBLE); " is 140.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,UsualArithmeticConversion,The length of the statement  "                return new Tuple<Expr' Expr' ExprTypeKind>(MakeCast(e1' new FloatType(c1' v1))' MakeCast(e2' new FloatType(c2' v2))' ExprTypeKind.FLOAT); " is 137.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,UsualArithmeticConversion,The length of the statement  "                return new Tuple<Expr' Expr' ExprTypeKind>(MakeCast(e1' new ULongType(c1' v1))' MakeCast(e2' new ULongType(c2' v2))' ExprTypeKind.ULONG); " is 137.
Long Statement,ABT,TypeCast,C:\repos\phisiart_C-Compiler\ABT\TypeCast.cs,UsualArithmeticConversion,The length of the statement  "            return new Tuple<Expr' Expr' ExprTypeKind>(MakeCast(e1' new LongType(c1' v1))' MakeCast(e2' new LongType(c2' v2))' ExprTypeKind.LONG); " is 134.
Long Statement,CompilerTests,TestDeclarations,C:\repos\phisiart_C-Compiler\ParserTests\TestDeclarations.cs,TypeSpecifier,The length of the statement  "            TestParserRule("MyAwesomeType"' new ParserEnvironment().AddSymbol("MyAwesomeType"' StorageClsSpec.TYPEDEF)' CParsers.TypeDefName " is 128.
Long Statement,CompilerTests,TestDeclarations,C:\repos\phisiart_C-Compiler\ParserTests\TestDeclarations.cs,TypeDefName,The length of the statement  "            TestParserRule("MyAwesomeType"' new ParserEnvironment().AddSymbol("MyAwesomeType"' StorageClsSpec.TYPEDEF)' CParsers.TypeDefName " is 128.
Long Statement,Parsing,CParsers,C:\repos\phisiart_C-Compiler\Parser\CParsers.cs,SetExpressionRules,The length of the statement  "            //   | conditional-expression                                       # first-set = first-set(cast-expression) = first-set(unary-expression) ++ { '(' } " is 149.
Long Statement,Parsing,CParsers,C:\repos\phisiart_C-Compiler\Parser\CParsers.cs,SetExpressionRules,The length of the statement  "            //   : unary-expression                     # first-set = { id' const' string' '++'' '--'' '&'' '*'' '+'' '-'' '~'' '!'' 'sizeof' } " is 131.
Long Statement,Parsing,ConstCharParser,C:\repos\phisiart_C-Compiler\Parser\CParsers.cs,Parse,The length of the statement  "                return ParserSucceeded.Create(new IntLiteral(token.Value' TokenInt.IntSuffix.NONE)' input.Environment' input.Source.Skip(1)); " is 125.
Long Statement,Parsing,ParserThenParser<R1;R2>,C:\repos\phisiart_C-Compiler\Parser\ParserClasses.cs,Parse,The length of the statement  "            return ParserSucceeded.Create(Tuple.Create(secondResult.Result' firstResult.Result)' secondResult.Environment' secondResult.Source); " is 132.
Long Statement,AST,Add,C:\repos\phisiart_C-Compiler\AST\BinaryOperators.cs,GetExpr,The length of the statement  "                left = ABT.TypeCast.MakeCast(left' new ABT.PointerType(((ABT.ArrayType)left.Type).ElemType' left.Type.IsConst' left.Type.IsVolatile)); " is 134.
Long Statement,AST,Add,C:\repos\phisiart_C-Compiler\AST\BinaryOperators.cs,GetExpr,The length of the statement  "                right = ABT.TypeCast.MakeCast(right' new ABT.PointerType(((ABT.ArrayType)right.Type).ElemType' right.Type.IsConst' right.Type.IsVolatile)); " is 139.
Long Statement,AST,Sub,C:\repos\phisiart_C-Compiler\AST\BinaryOperators.cs,GetExpr,The length of the statement  "                left = ABT.TypeCast.MakeCast(left' new ABT.PointerType((left.Type as ABT.ArrayType).ElemType' left.Type.IsConst' left.Type.IsVolatile)); " is 136.
Long Statement,AST,Sub,C:\repos\phisiart_C-Compiler\AST\BinaryOperators.cs,GetExpr,The length of the statement  "                right = ABT.TypeCast.MakeCast(right' new ABT.PointerType((right.Type as ABT.ArrayType).ElemType' right.Type.IsConst' right.Type.IsVolatile)); " is 141.
Long Statement,AST,StructOrUnionSpec,C:\repos\phisiart_C-Compiler\AST\DeclarationSpecifiers.cs,GetMembers,The length of the statement  "            var result = memberDeclns.Aggregate(ImmutableList<Tuple<Option<String>' ExprType>>.Empty' (acc' decln) => acc.AddRange(Semant(decln.GetMemberDeclns' ref env)) " is 158.
Long Statement,AST,FuncCall,C:\repos\phisiart_C-Compiler\AST\Expressions.cs,GetExpr,The length of the statement  "                env = env.PushEntry(ABT.Env.EntryKind.TYPEDEF' (this.Func as Variable).Name' ABT.FunctionType.Create(new ABT.LongType(true)' args.ConvertAll(_ => Tuple.Create(""' _.Type))' false " is 178.
Long Statement,AST,TranslnUnit,C:\repos\phisiart_C-Compiler\AST\ExternalDeclarations.cs,GetTranslnUnit,The length of the statement  "            var externDeclns = this.Declns.Aggregate(ImmutableList<Tuple<Env' ExternDecln>>.Empty' (acc' externDecln) => acc.AddRange(Semant(externDecln.GetExternDecln' ref env)) " is 166.
Long Statement,AST,FuncDef,C:\repos\phisiart_C-Compiler\AST\ExternalDeclarations.cs,GetExternDecln,The length of the statement  "            return SemantReturn.Create(env' ImmutableList.Create(Tuple.Create(env' new ABT.FuncDef(name' storageClass' funcType' stmt) as ExternDecln))); " is 141.
Complex Conditional,ABT,BinaryOpSupportingArithmeticOperands,C:\repos\phisiart_C-Compiler\ABT\BinaryOperators.cs,BinaryOpSupportingArithmeticOperands,The conditional expression  "!(left.Type is LongType || left.Type is ULongType                    || left.Type is FloatType || left.Type is DoubleType)"  is complex.
Complex Conditional,ABT,BinaryLogicalOp,C:\repos\phisiart_C-Compiler\ABT\BinaryOperators.cs,BinaryLogicalOp,The conditional expression  "!(left.Type is LongType || left.Type is ULongType                    || left.Type is FloatType || left.Type is DoubleType)"  is complex.
Complex Conditional,ABT,BinaryLogicalOp,C:\repos\phisiart_C-Compiler\ABT\BinaryOperators.cs,BinaryLogicalOp,The conditional expression  "!(right.Type is LongType || right.Type is ULongType                    || right.Type is FloatType || right.Type is DoubleType)"  is complex.
Complex Conditional,ABT,LogicalNot,C:\repos\phisiart_C-Compiler\ABT\UnaryOperators.cs,LogicalNot,The conditional expression  "!(expr.Type is LongType || expr.Type is ULongType                    || expr.Type is FloatType || expr.Type is DoubleType)"  is complex.
Virtual Method Call from Constructor,ABT,BinaryOpSupportingIntegralOperands,C:\repos\phisiart_C-Compiler\ABT\BinaryOperators.cs,BinaryOpSupportingIntegralOperands,The constructor "BinaryOpSupportingIntegralOperands" calls a virtual method "EqualType".
Virtual Method Call from Constructor,ABT,BinaryOpSupportingOnlyIntegralOperands,C:\repos\phisiart_C-Compiler\ABT\BinaryOperators.cs,BinaryOpSupportingOnlyIntegralOperands,The constructor "BinaryOpSupportingOnlyIntegralOperands" calls a virtual method "GetQualifiedType".
Virtual Method Call from Constructor,ABT,BinaryArithmeticOp,C:\repos\phisiart_C-Compiler\ABT\BinaryOperators.cs,BinaryArithmeticOp,The constructor "BinaryArithmeticOp" calls a virtual method "GetQualifiedType".
Magic Number,ABT,ConstDouble,C:\repos\phisiart_C-Compiler\ABT\ConstExpressions.cs,CGenValue,The following statement contains a magic number: Int32 secondInt = BitConverter.ToInt32(bytes' 4);
Magic Number,ABT,Decln,C:\repos\phisiart_C-Compiler\ABT\Declarations.cs,CGenDecln,The following statement contains a magic number: if (env.IsGlobal()) {                    if (this.initr.IsSome) {                      Initr initr = this.initr.Value;                      switch (this.scs) {                          case StorageClass.AUTO:                              state.GLOBL(this.name);                              break;                            case StorageClass.EXTERN:                              throw new InvalidProgramException();                            case StorageClass.STATIC:                              break;                            case StorageClass.TYPEDEF:                              // Ignore.                              return;                            default:                              throw new InvalidProgramException();                      }                        state.DATA();                        state.ALIGN(ExprType.ALIGN_LONG);                        state.CGenLabel(this.name);                        Int32 last = 0;                      initr.Iterate(this.type' (Int32 offset' Expr expr) => {                          if (offset > last) {                              state.ZERO(offset - last);                          }                            if (!expr.IsConstExpr) {                              throw new InvalidOperationException("Cannot initialize with non-const expression.");                          }                            switch (expr.Type.Kind) {                              // TODO: without const char/short' how do I initialize?                              case ExprTypeKind.CHAR:                              case ExprTypeKind.UCHAR:                              case ExprTypeKind.SHORT:                              case ExprTypeKind.USHORT:                                  throw new NotImplementedException();                              case ExprTypeKind.LONG:                                  state.LONG(((ConstLong)expr).Value);                                  break;                                case ExprTypeKind.ULONG:                                  state.LONG((Int32)((ConstULong)expr).Value);                                  break;                                case ExprTypeKind.POINTER:                                  state.LONG((Int32)((ConstPtr)expr).Value);                                  break;                                case ExprTypeKind.FLOAT:                                  byte[] float_bytes = BitConverter.GetBytes(((ConstFloat)expr).Value);                                  Int32 intval = BitConverter.ToInt32(float_bytes' 0);                                  state.LONG(intval);                                  break;                                case ExprTypeKind.DOUBLE:                                  byte[] double_bytes = BitConverter.GetBytes(((ConstDouble)expr).Value);                                  Int32 first_int = BitConverter.ToInt32(double_bytes' 0);                                  Int32 second_int = BitConverter.ToInt32(double_bytes' 4);                                  state.LONG(first_int);                                  state.LONG(second_int);                                  break;                                default:                                  throw new InvalidProgramException();                          }                            last = offset + expr.Type.SizeOf;                      });                    } else {                        // Global without initialization.                        switch (this.scs) {                          case StorageClass.AUTO:                              // .comm name'size'align                              break;                            case StorageClass.EXTERN:                              break;                            case StorageClass.STATIC:                              // .local name                              // .comm name'size'align                              state.LOCAL(this.name);                              break;                            case StorageClass.TYPEDEF:                              // Ignore.                              return;                            default:                              throw new InvalidProgramException();                      }                        if (this.type.Kind != ExprTypeKind.FUNCTION) {                          state.COMM(this.name' this.type.SizeOf' ExprType.ALIGN_LONG);                      }                                          }                    state.NEWLINE();                } else {                  // stack object                    state.CGenExpandStackTo(env.StackSize' ToString());                    Int32 stack_size = env.StackSize;                    // pos should be equal to stack_size' but whatever...                  Int32 pos = env.Find(this.name).Value.Offset;                  if (this.initr.IsNone) {                      return;                  }                    Initr initr = this.initr.Value;                  initr.Iterate(this.type' (Int32 offset' Expr expr) => {                      Reg ret = expr.CGenValue(state);                      switch (expr.Type.Kind) {                          case ExprTypeKind.CHAR:                          case ExprTypeKind.UCHAR:                              state.MOVB(Reg.EAX' pos + offset' Reg.EBP);                              break;                            case ExprTypeKind.SHORT:                          case ExprTypeKind.USHORT:                              state.MOVW(Reg.EAX' pos + offset' Reg.EBP);                              break;                            case ExprTypeKind.DOUBLE:                              state.FSTPL(pos + offset' Reg.EBP);                              break;                            case ExprTypeKind.FLOAT:                              state.FSTPS(pos + offset' Reg.EBP);                              break;                            case ExprTypeKind.LONG:                          case ExprTypeKind.ULONG:                          case ExprTypeKind.POINTER:                              state.MOVL(Reg.EAX' pos + offset' Reg.EBP);                              break;                            case ExprTypeKind.STRUCT_OR_UNION:                              state.MOVL(Reg.EAX' Reg.ESI);                              state.LEA(pos + offset' Reg.EBP' Reg.EDI);                              state.MOVL(expr.Type.SizeOf' Reg.ECX);                              state.CGenMemCpy();                              break;                            case ExprTypeKind.ARRAY:                          case ExprTypeKind.FUNCTION:                              throw new InvalidProgramException($"How could a {expr.Type.Kind} be in a init list?");                            default:                              throw new InvalidProgramException();                      }                        state.CGenForceStackSizeTo(stack_size);                    });                }
Magic Number,ABT,Scope,C:\repos\phisiart_C-Compiler\ABT\Environment.cs,PushEntry,The following statement contains a magic number: switch (loc) {                  case EntryKind.STACK:                      scope.esp_pos -= Utils.RoundUp(type.SizeOf' 4);                      scope.locals.Add(new Utils.StoreEntry(name' type' scope.esp_pos));                      break;                  case EntryKind.GLOBAL:                      scope.globals.Add(new Utils.StoreEntry(name' type' 0));                      break;                  case EntryKind.TYPEDEF:                      scope.typedefs.Add(new Utils.StoreEntry(name' type' 0));                      break;                  default:                      return null;                  }
Magic Number,ABT,ReturnStmt,C:\repos\phisiart_C-Compiler\ABT\Statements.cs,CGenStmt,The following statement contains a magic number: if (this.ExprOpt.IsSome) {                  // Evaluate the Value.                  this.ExprOpt.Value.CGenValue(state);                    // If the function returns a struct' copy it to the address given by 8(%ebp).                  if (this.ExprOpt.Value.Type is StructOrUnionType) {                      state.MOVL(Reg.EAX' Reg.ESI);                      state.MOVL(2 * ExprType.SIZEOF_POINTER' Reg.EBP' Reg.EDI);                      state.MOVL(this.ExprOpt.Value.Type.SizeOf' Reg.ECX);                      state.CGenMemCpy();                      state.MOVL(2 * ExprType.SIZEOF_POINTER' Reg.EBP' Reg.EAX);                  }                    // Restore stack size.                  state.CGenForceStackSizeTo(stack_size);              }
Magic Number,ABT,ReturnStmt,C:\repos\phisiart_C-Compiler\ABT\Statements.cs,CGenStmt,The following statement contains a magic number: if (this.ExprOpt.IsSome) {                  // Evaluate the Value.                  this.ExprOpt.Value.CGenValue(state);                    // If the function returns a struct' copy it to the address given by 8(%ebp).                  if (this.ExprOpt.Value.Type is StructOrUnionType) {                      state.MOVL(Reg.EAX' Reg.ESI);                      state.MOVL(2 * ExprType.SIZEOF_POINTER' Reg.EBP' Reg.EDI);                      state.MOVL(this.ExprOpt.Value.Type.SizeOf' Reg.ECX);                      state.CGenMemCpy();                      state.MOVL(2 * ExprType.SIZEOF_POINTER' Reg.EBP' Reg.EAX);                  }                    // Restore stack size.                  state.CGenForceStackSizeTo(stack_size);              }
Magic Number,ABT,FunctionType,C:\repos\phisiart_C-Compiler\ABT\Types\Types.cs,Create,The following statement contains a magic number: if (ret_type is StructOrUnionType) {                  offsets = offsets.Select(_ => _ + 3 * SIZEOF_POINTER).ToList();              } else {                  offsets = offsets.Select(_ => _ + 2 * SIZEOF_POINTER).ToList();              }
Magic Number,ABT,FunctionType,C:\repos\phisiart_C-Compiler\ABT\Types\Types.cs,Create,The following statement contains a magic number: if (ret_type is StructOrUnionType) {                  offsets = offsets.Select(_ => _ + 3 * SIZEOF_POINTER).ToList();              } else {                  offsets = offsets.Select(_ => _ + 2 * SIZEOF_POINTER).ToList();              }
Magic Number,CompilerTests,TypePrinterTests,C:\repos\phisiart_C-Compiler\CompilerTests\TypePrinterTests.cs,TestArrayType,The following statement contains a magic number: var type = new ABT.ArrayType(                  new ABT.LongType(isConst: true)'                  3              );
Magic Number,CompilerTests,TypePrinterTests,C:\repos\phisiart_C-Compiler\CompilerTests\TypePrinterTests.cs,TestArrayType,The following statement contains a magic number: var multiDimArrayType = new ABT.ArrayType(                  new ABT.ArrayType(                      new ABT.LongType(isConst: true)'                      3                  )'                  4              );
Magic Number,CompilerTests,TypePrinterTests,C:\repos\phisiart_C-Compiler\CompilerTests\TypePrinterTests.cs,TestArrayType,The following statement contains a magic number: var multiDimArrayType = new ABT.ArrayType(                  new ABT.ArrayType(                      new ABT.LongType(isConst: true)'                      3                  )'                  4              );
Magic Number,CompilerTests,TypePrinterTests,C:\repos\phisiart_C-Compiler\CompilerTests\TypePrinterTests.cs,TestArrayPointer,The following statement contains a magic number: var arrPtr = new ABT.PointerType(                  new ABT.ArrayType(                      new ABT.LongType()'                      3                  )              );
Magic Number,CompilerTests,TypePrinterTests,C:\repos\phisiart_C-Compiler\CompilerTests\TypePrinterTests.cs,TestPointerArray,The following statement contains a magic number: var ptrArr = new ABT.ArrayType(                  new ABT.PointerType(                      new ABT.LongType()                  )'                  3              );
Magic Number,LexicalAnalysis,FSAChar,C:\repos\phisiart_C-Compiler\Scanner\Char.cs,RetrieveChar,The following statement contains a magic number: if (this._scanned.Length == 3) {                  switch (this._scanned[1]) {                      case 'a':                          return '\a';                      case 'b':                          return '\b';                      case 'f':                          return '\f';                      case 'n':                          return '\n';                      case 'r':                          return '\r';                      case 't':                          return '\t';                      case 'v':                          return '\v';                      case '\'':                          return '\'';                      case '\"':                          return '\"';                      case '\\':                          return '\\';                      case '?':                          return '?';                      default:                          return this._scanned[1];                  }              }
Magic Number,LexicalAnalysis,FSAFloat,C:\repos\phisiart_C-Compiler\Scanner\Float.cs,RetrieveToken,The following statement contains a magic number: if (this._expPos) {                  val = (this._intPart + this._fracPart * Math.Pow(0.1' this._fracCount)) * Math.Pow(10' this._expPart);              } else {                  val = (this._intPart + this._fracPart * Math.Pow(0.1' this._fracCount)) * Math.Pow(10' -this._expPart);              }
Magic Number,LexicalAnalysis,FSAFloat,C:\repos\phisiart_C-Compiler\Scanner\Float.cs,RetrieveToken,The following statement contains a magic number: if (this._expPos) {                  val = (this._intPart + this._fracPart * Math.Pow(0.1' this._fracCount)) * Math.Pow(10' this._expPart);              } else {                  val = (this._intPart + this._fracPart * Math.Pow(0.1' this._fracCount)) * Math.Pow(10' -this._expPart);              }
Magic Number,LexicalAnalysis,FSAFloat,C:\repos\phisiart_C-Compiler\Scanner\Float.cs,RetrieveToken,The following statement contains a magic number: if (this._expPos) {                  val = (this._intPart + this._fracPart * Math.Pow(0.1' this._fracCount)) * Math.Pow(10' this._expPart);              } else {                  val = (this._intPart + this._fracPart * Math.Pow(0.1' this._fracCount)) * Math.Pow(10' -this._expPart);              }
Magic Number,LexicalAnalysis,FSAFloat,C:\repos\phisiart_C-Compiler\Scanner\Float.cs,RetrieveToken,The following statement contains a magic number: if (this._expPos) {                  val = (this._intPart + this._fracPart * Math.Pow(0.1' this._fracCount)) * Math.Pow(10' this._expPart);              } else {                  val = (this._intPart + this._fracPart * Math.Pow(0.1' this._fracCount)) * Math.Pow(10' -this._expPart);              }
Magic Number,LexicalAnalysis,FSAFloat,C:\repos\phisiart_C-Compiler\Scanner\Float.cs,ReadChar,The following statement contains a magic number: switch (this._state) {                  case State.ERROR:                  case State.END:                      this._state = State.ERROR;                      break;                    case State.START:                      if (Char.IsDigit(ch)) {                          this._intPart = ch - '0';                          this._state = State.D;                      } else if (ch == '.') {                          this._state = State.P;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.D:                      if (Char.IsDigit(ch)) {                          this._intPart *= 10;                          this._intPart += ch - '0';                          this._state = State.D;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == '.') {                          this._state = State.DP;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.P:                      if (Char.IsDigit(ch)) {                          this._fracPart = ch - '0';                          this._fracCount = 1;                          this._state = State.PD;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DP:                      if (Char.IsDigit(ch)) {                          this._fracPart = ch - '0';                          this._fracCount = 1;                          this._state = State.PD;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.PD:                      if (Char.IsDigit(ch)) {                          this._fracPart *= 10;                          this._fracPart += ch - '0';                          this._fracCount++;                          this._state = State.PD;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.DE:                      if (Char.IsDigit(ch)) {                          this._expPart = ch - '0';                          this._state = State.DED;                      } else if (ch == '+' || ch == '-') {                          if (ch == '-') {                              this._expPos = false;                          }                          this._state = State.DES;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DES:                      if (Char.IsDigit(ch)) {                          this._expPart = ch - '0';                          this._state = State.DED;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DPL:                      this._suffix = TokenFloat.FloatSuffix.L;                      this._state = State.END;                      break;                    case State.DED:                      if (Char.IsDigit(ch)) {                          this._expPart *= 10;                          this._expPart += ch - '0';                          this._state = State.DED;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.PDF:                      this._state = State.END;                      break;                    default:                      this._state = State.ERROR;                      break;              }
Magic Number,LexicalAnalysis,FSAFloat,C:\repos\phisiart_C-Compiler\Scanner\Float.cs,ReadChar,The following statement contains a magic number: switch (this._state) {                  case State.ERROR:                  case State.END:                      this._state = State.ERROR;                      break;                    case State.START:                      if (Char.IsDigit(ch)) {                          this._intPart = ch - '0';                          this._state = State.D;                      } else if (ch == '.') {                          this._state = State.P;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.D:                      if (Char.IsDigit(ch)) {                          this._intPart *= 10;                          this._intPart += ch - '0';                          this._state = State.D;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == '.') {                          this._state = State.DP;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.P:                      if (Char.IsDigit(ch)) {                          this._fracPart = ch - '0';                          this._fracCount = 1;                          this._state = State.PD;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DP:                      if (Char.IsDigit(ch)) {                          this._fracPart = ch - '0';                          this._fracCount = 1;                          this._state = State.PD;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.PD:                      if (Char.IsDigit(ch)) {                          this._fracPart *= 10;                          this._fracPart += ch - '0';                          this._fracCount++;                          this._state = State.PD;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.DE:                      if (Char.IsDigit(ch)) {                          this._expPart = ch - '0';                          this._state = State.DED;                      } else if (ch == '+' || ch == '-') {                          if (ch == '-') {                              this._expPos = false;                          }                          this._state = State.DES;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DES:                      if (Char.IsDigit(ch)) {                          this._expPart = ch - '0';                          this._state = State.DED;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DPL:                      this._suffix = TokenFloat.FloatSuffix.L;                      this._state = State.END;                      break;                    case State.DED:                      if (Char.IsDigit(ch)) {                          this._expPart *= 10;                          this._expPart += ch - '0';                          this._state = State.DED;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.PDF:                      this._state = State.END;                      break;                    default:                      this._state = State.ERROR;                      break;              }
Magic Number,LexicalAnalysis,FSAFloat,C:\repos\phisiart_C-Compiler\Scanner\Float.cs,ReadChar,The following statement contains a magic number: switch (this._state) {                  case State.ERROR:                  case State.END:                      this._state = State.ERROR;                      break;                    case State.START:                      if (Char.IsDigit(ch)) {                          this._intPart = ch - '0';                          this._state = State.D;                      } else if (ch == '.') {                          this._state = State.P;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.D:                      if (Char.IsDigit(ch)) {                          this._intPart *= 10;                          this._intPart += ch - '0';                          this._state = State.D;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == '.') {                          this._state = State.DP;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.P:                      if (Char.IsDigit(ch)) {                          this._fracPart = ch - '0';                          this._fracCount = 1;                          this._state = State.PD;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DP:                      if (Char.IsDigit(ch)) {                          this._fracPart = ch - '0';                          this._fracCount = 1;                          this._state = State.PD;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.PD:                      if (Char.IsDigit(ch)) {                          this._fracPart *= 10;                          this._fracPart += ch - '0';                          this._fracCount++;                          this._state = State.PD;                      } else if (ch == 'e' || ch == 'E') {                          this._state = State.DE;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.DE:                      if (Char.IsDigit(ch)) {                          this._expPart = ch - '0';                          this._state = State.DED;                      } else if (ch == '+' || ch == '-') {                          if (ch == '-') {                              this._expPos = false;                          }                          this._state = State.DES;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DES:                      if (Char.IsDigit(ch)) {                          this._expPart = ch - '0';                          this._state = State.DED;                      } else {                          this._state = State.ERROR;                      }                      break;                    case State.DPL:                      this._suffix = TokenFloat.FloatSuffix.L;                      this._state = State.END;                      break;                    case State.DED:                      if (Char.IsDigit(ch)) {                          this._expPart *= 10;                          this._expPart += ch - '0';                          this._state = State.DED;                      } else if (ch == 'f' || ch == 'F') {                          this._suffix = TokenFloat.FloatSuffix.F;                          this._state = State.PDF;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenFloat.FloatSuffix.L;                          this._state = State.DPL;                      } else {                          this._state = State.END;                      }                      break;                    case State.PDF:                      this._state = State.END;                      break;                    default:                      this._state = State.ERROR;                      break;              }
Magic Number,LexicalAnalysis,FSAInt,C:\repos\phisiart_C-Compiler\Scanner\Int.cs,ReadChar,The following statement contains a magic number: switch (this._state) {                  case State.ERROR:                  case State.END:                      this._state = State.ERROR;                      break;                  case State.START:                      if (ch == '0') {                          this._state = State.Z;                      } else if (Char.IsDigit(ch)) {                          this._state = State.D;                          this._val += ch - '0';                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.Z:                      if (ch == 'x' || ch == 'X') {                          this._state = State.ZX;                      } else if (Utils.IsOctDigit(ch)) {                          this._val *= 8;                          this._val += ch - '0';                          this._state = State.O;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.D:                      if (Char.IsDigit(ch)) {                          this._val *= 10;                          this._val += ch - '0';                          this._state = State.D;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.ZX:                      if (Utils.IsHexDigit(ch)) {                          this._val *= 0x10;                          this._val += Utils.GetHexDigit(ch);                          this._state = State.H;                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.O:                      if (Utils.IsOctDigit(ch)) {                          this._val *= 8;                          this._val += ch - '0';                          this._state = State.O;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.L:                      if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.UL;                          this._state = State.UL;                      } else {                          this._state = State.END;                      }                      break;                  case State.H:                      if (Utils.IsHexDigit(ch)) {                          this._val *= 0x10;                          this._val += Utils.GetHexDigit(ch);                          this._state = State.H;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.U:                      if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.UL;                          this._state = State.UL;                      } else {                          this._state = State.END;                      }                      break;                  case State.UL:                      this._state = State.END;                      break;                  default:                      this._state = State.ERROR;                      break;              }
Magic Number,LexicalAnalysis,FSAInt,C:\repos\phisiart_C-Compiler\Scanner\Int.cs,ReadChar,The following statement contains a magic number: switch (this._state) {                  case State.ERROR:                  case State.END:                      this._state = State.ERROR;                      break;                  case State.START:                      if (ch == '0') {                          this._state = State.Z;                      } else if (Char.IsDigit(ch)) {                          this._state = State.D;                          this._val += ch - '0';                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.Z:                      if (ch == 'x' || ch == 'X') {                          this._state = State.ZX;                      } else if (Utils.IsOctDigit(ch)) {                          this._val *= 8;                          this._val += ch - '0';                          this._state = State.O;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.D:                      if (Char.IsDigit(ch)) {                          this._val *= 10;                          this._val += ch - '0';                          this._state = State.D;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.ZX:                      if (Utils.IsHexDigit(ch)) {                          this._val *= 0x10;                          this._val += Utils.GetHexDigit(ch);                          this._state = State.H;                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.O:                      if (Utils.IsOctDigit(ch)) {                          this._val *= 8;                          this._val += ch - '0';                          this._state = State.O;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.L:                      if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.UL;                          this._state = State.UL;                      } else {                          this._state = State.END;                      }                      break;                  case State.H:                      if (Utils.IsHexDigit(ch)) {                          this._val *= 0x10;                          this._val += Utils.GetHexDigit(ch);                          this._state = State.H;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.U:                      if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.UL;                          this._state = State.UL;                      } else {                          this._state = State.END;                      }                      break;                  case State.UL:                      this._state = State.END;                      break;                  default:                      this._state = State.ERROR;                      break;              }
Magic Number,LexicalAnalysis,FSAInt,C:\repos\phisiart_C-Compiler\Scanner\Int.cs,ReadChar,The following statement contains a magic number: switch (this._state) {                  case State.ERROR:                  case State.END:                      this._state = State.ERROR;                      break;                  case State.START:                      if (ch == '0') {                          this._state = State.Z;                      } else if (Char.IsDigit(ch)) {                          this._state = State.D;                          this._val += ch - '0';                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.Z:                      if (ch == 'x' || ch == 'X') {                          this._state = State.ZX;                      } else if (Utils.IsOctDigit(ch)) {                          this._val *= 8;                          this._val += ch - '0';                          this._state = State.O;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.D:                      if (Char.IsDigit(ch)) {                          this._val *= 10;                          this._val += ch - '0';                          this._state = State.D;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.ZX:                      if (Utils.IsHexDigit(ch)) {                          this._val *= 0x10;                          this._val += Utils.GetHexDigit(ch);                          this._state = State.H;                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.O:                      if (Utils.IsOctDigit(ch)) {                          this._val *= 8;                          this._val += ch - '0';                          this._state = State.O;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.L:                      if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.UL;                          this._state = State.UL;                      } else {                          this._state = State.END;                      }                      break;                  case State.H:                      if (Utils.IsHexDigit(ch)) {                          this._val *= 0x10;                          this._val += Utils.GetHexDigit(ch);                          this._state = State.H;                      } else if (ch == 'u' || ch == 'U') {                          this._suffix = TokenInt.IntSuffix.U;                          this._state = State.U;                      } else if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.L;                          this._state = State.L;                      } else {                          this._state = State.END;                      }                      break;                  case State.U:                      if (ch == 'l' || ch == 'L') {                          this._suffix = TokenInt.IntSuffix.UL;                          this._state = State.UL;                      } else {                          this._state = State.END;                      }                      break;                  case State.UL:                      this._state = State.END;                      break;                  default:                      this._state = State.ERROR;                      break;              }
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenState,The following statement contains a magic number: this.label_idx = 2;
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenExpandStackBy4Bytes,The following statement contains a magic number: this.StackSize += 4;
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenExpandStackBy4Bytes,The following statement contains a magic number: SUBL(4' Reg.ESP);
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenExpandStackBy8Bytes,The following statement contains a magic number: this.StackSize += 8;
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenExpandStackBy8Bytes,The following statement contains a magic number: SUBL(8' Reg.ESP);
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenShrinkStackBy4Bytes,The following statement contains a magic number: this.StackSize -= 4;
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenShrinkStackBy4Bytes,The following statement contains a magic number: ADDL(4' Reg.ESP);
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenShrinkStackBy8Bytes,The following statement contains a magic number: this.StackSize -= 8;
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenShrinkStackBy8Bytes,The following statement contains a magic number: ADDL(8' Reg.ESP);
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenPushLong,The following statement contains a magic number: this.StackSize += 4;
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenPushLong,The following statement contains a magic number: this.StackSize += 4;
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenPopLong,The following statement contains a magic number: if (this.StackSize == saved_size) {                  POPL(dst);                  this.StackSize -= 4;              } else {                  MOVL(-saved_size' Reg.EBP' dst);              }
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenMemCpy,The following statement contains a magic number: SHRL(2' Reg.ECX);
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenMemCpy,The following statement contains a magic number: ANDB(3' Reg.CL);
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenMemCpyReversed,The following statement contains a magic number: ANDL(3' Reg.ECX);
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenMemCpyReversed,The following statement contains a magic number: ANDL(~3' Reg.ECX);
Magic Number,CodeGeneration,CGenState,C:\repos\phisiart_C-Compiler\CGen\CGen.cs,CGenMemCpyReversed,The following statement contains a magic number: SHRL(2' Reg.ECX);
Missing Default,LexicalAnalysis,FSAIdentifier,C:\repos\phisiart_C-Compiler\Scanner\Identifier.cs,ReadChar,The following switch statement is missing a default case: switch (this._state) {                  case State.END:                  case State.ERROR:                      this._state = State.ERROR;                      break;                  case State.START:                      if (ch == '_' || Char.IsLetter(ch)) {                          this._state = State.ID;                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.ID:                      if (Char.IsLetterOrDigit(ch) || ch == '_') {                          this._state = State.ID;                      } else {                          this._state = State.END;                      }                      break;              }
Missing Default,LexicalAnalysis,FSASpace,C:\repos\phisiart_C-Compiler\Scanner\Tokens.cs,ReadChar,The following switch statement is missing a default case: switch (this._state) {                  case State.END:                  case State.ERROR:                      this._state = State.ERROR;                      break;                  case State.START:                      if (Utils.IsSpace(ch)) {                          this._state = State.SPACE;                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.SPACE:                      if (Utils.IsSpace(ch)) {                          this._state = State.SPACE;                      } else {                          this._state = State.END;                      }                      break;              }
Missing Default,LexicalAnalysis,FSANewLine,C:\repos\phisiart_C-Compiler\Scanner\Tokens.cs,ReadChar,The following switch statement is missing a default case: switch (this._state) {                  case State.END:                  case State.ERROR:                      this._state = State.ERROR;                      break;                  case State.START:                      if (ch == '\n') {                          this._state = State.NEWLINE;                      } else {                          this._state = State.ERROR;                      }                      break;                  case State.NEWLINE:                      this._state = State.END;                      break;              }
