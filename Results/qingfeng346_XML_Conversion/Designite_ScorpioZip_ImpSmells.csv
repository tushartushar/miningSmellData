Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadHeader,The method has 130 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The method has 167 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,RunUpdates,The method has 110 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The method has 130 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The method has 170 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The method has 100 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 110 lines of code.
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Core,FileSystemScanner,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\FileSystemScanner.cs,ScanDir,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Core,NameFilter,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\NameFilter.cs,SplitQuoted,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\StreamUtils.cs,Copy,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadHeader,Cyclomatic complexity of the method is 27
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,CreateZip,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractZip,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractFileEntry,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractEntry,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\WindowsNameTransform.cs,MakeValidName,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntryFactory.cs,MakeFileEntry,Cyclomatic complexity of the method is 27
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetInputStream,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestArchive,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,BeginUpdate,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteLocalEntryHeader,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteCentralDirectoryHeader,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CopyBytes,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetOutputStream,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,AddEntry,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,RunUpdates,Cyclomatic complexity of the method is 31
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,DiskArchiveStorage,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetTempFileName,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteLocalHeader,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,CloseEntry,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,InitialRead,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,BodyRead,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,Cyclomatic complexity of the method is 31
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,CloseEntry,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,Finish,Cyclomatic complexity of the method is 20
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,Deflate,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,SetLevel,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,Cyclomatic complexity of the method is 40
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Inflate,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,Cyclomatic complexity of the method is 53
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 12
Long Parameter List,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\PathFilter.cs,ExtendedPathFilter,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\StreamUtils.cs,Copy,The method has 7 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\StreamUtils.cs,Copy,The method has 8 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicEncryptCryptoTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicDecryptCryptoTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,CreateZip,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,CreateZip,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractZip,The method has 7 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractZip,The method has 8 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CopyBytes,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CopyEntryDataDirect,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\InflaterInputStream.cs,BeginWrite,The method has 5 parameters.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,UpdateCommentOnly,The length of the parameter CentralHeaderCommentSizeOffset is 30.
Long Statement,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\PathFilter.cs,IsMatch,The length of the statement  "		result = (MinSize <= fileInfo.Length) && (MaxSize >= fileInfo.Length) && (MinDate <= fileInfo.LastWriteTime) && (MaxDate >= fileInfo.LastWriteTime); " is 148.
Long Statement,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadFooter,The length of the statement  "	uint total = (uint)((uint)footer [4] & 0xff) | (uint)(((uint)footer [5] & 0xff) << 8) | (uint)(((uint)footer [6] & 0xff) << 16) | (uint)((uint)footer [7] << 24); " is 161.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractZip,The length of the statement  "	ExtractZip (inputStream' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime' true); " is 122.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractFileEntry,The length of the statement  "						StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size); " is 148.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,HasDosAttributes,The length of the statement  "		if (((HostSystem == (int)HostSystemID.Msdos) || (HostSystem == (int)HostSystemID.WindowsNT)) && (ExternalFileAttributes & attributes) == attributes) { " is 150.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The length of the statement  "		if (((versionToExtract & 0xff) >= ZipConstants.VersionZip64) && ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The length of the statement  "			DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 124.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntryFactory.cs,MakeFileEntry,The length of the statement  "	ZipEntry result = new ZipEntry (nameTransform_.TransformFile (entryName != null && entryName.Length > 0 ? entryName : fileName)); " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 124.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 120.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,FindEntry,The length of the statement  "		if (string.Compare (name' entries_ [i].Name' CultureInfo.InvariantCulture' ignoreCase ? CompareOptions.IgnoreCase : CompareOptions.None) == 0) { " is 144.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) { " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) { " is 127.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) { " is 158.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) { " is 363.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) { " is 135.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "					throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size)); " is 125.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize)); " is 156.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,UpdateCommentOnly,The length of the statement  "		long locatedCentralDirOffset = updateFile.LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff); " is 174.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The length of the statement  "	long locatedEndOfCentralDir = LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseStream_.Length' ZipConstants.EndOfCentralRecordBaseSize' 0xffff); " is 170.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The length of the statement  "	if ((thisDiskNumber == 0xffff) || (startCentralDirDisk == 0xffff) || (entriesForThisDisk == 0xffff) || (entriesForWholeCentralDir == 0xffff) || (centralDirSize == 0xffffffff) || (offsetOfCentralDir == 0xffffffff)) { " is 215.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The length of the statement  "		long offset = LocateBlockWithSignature (ZipConstants.Zip64CentralDirLocatorSignature' locatedEndOfCentralDir' 0' 0x1000); " is 121.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The length of the statement  "	if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The length of the statement  "	if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The length of the statement  "		result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write); " is 132.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The length of the statement  "	if (header == ZipConstants.CentralHeaderSignature || header == ZipConstants.EndOfCentralDirectorySignature || header == ZipConstants.CentralHeaderDigitalSignature || header == ZipConstants.ArchiveExtraDataSignature || header == ZipConstants.Zip64CentralFileHeaderSignature) { " is 275.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The length of the statement  "	if (method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))) { " is 143.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "		if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) { " is 180.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) { " is 339.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateFast,The length of the statement  "		if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 175.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "			if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "				if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The length of the statement  "	int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength () + literalTree.GetEncodedLength () + distTree.GetEncodedLength () + extra_bits; " is 142.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,BitReverse,The length of the statement  "	return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]); " is 172.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The conditional expression  "(extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The conditional expression  "(thisDiskNumber == 0xffff) || (startCentralDirDisk == 0xffff) || (entriesForThisDisk == 0xffff) || (entriesForWholeCentralDir == 0xffff) || (centralDirSize == 0xffffffff) || (offsetOfCentralDir == 0xffffffff)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "header == ZipConstants.CentralHeaderSignature || header == ZipConstants.EndOfCentralDirectorySignature || header == ZipConstants.CentralHeaderDigitalSignature || header == ZipConstants.ArchiveExtraDataSignature || header == ZipConstants.Zip64CentralFileHeaderSignature"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,BodyRead,The conditional expression  "(flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full  (blockStart < WSIZE && storedLength >= MAX_DIST) || // Block may move out of window  flush"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  	// We can defer the modulo operation:  	// s1 maximally grows from 65521 to 65521 + 255 * 3800  	// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  	int n = 3800;  	if (n > count) {  		n = count;  	}  	count -= n;  	while (--n >= 0) {  		s1 = s1 + (uint)(buffer [offset++] & 0xff);  		s2 = s2 + s1;  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\CRC32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.CrcTable [(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ value) & 0xFF] ^ (crc >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\CRC32.cs,Update,The following statement contains a magic number: while (--count >= 0) {  	crc = CrcTable [(crc ^ buffer [offset++]) & 0xFF] ^ (crc >> 8);  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ buffer [offset++]) & 0xFF] ^ (crc >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: if (temp < 0) {  	temp = 256 + temp;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: temp = 256 + temp;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table [temp]));  
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  	throw new ArgumentException ("Buffer is too small"' "buffer");  }  
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  	throw new ArgumentException ("Buffer is too small"' "buffer");  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  	int index = 2;  	int elements = 2;  	// Scan for two separate elements \\machine\share\restofpath  	while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  		index++;  	}  	index++;  	if (index < path.Length) {  		result = path.Substring (index);  	}  	else {  		result = "";  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  	int index = 2;  	int elements = 2;  	// Scan for two separate elements \\machine\share\restofpath  	while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  		index++;  	}  	index++;  	if (index < path.Length) {  		result = path.Substring (index);  	}  	else {  		result = "";  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: dropCount = 3;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [1] = newKeys [1] * 134775813 + 1;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [1] = (byte)((newKeys [0] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [2] = (byte)((newKeys [0] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [2] = (byte)((newKeys [0] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [3] = (byte)((newKeys [0] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [3] = (byte)((newKeys [0] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [4] = (byte)(newKeys [1] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [5] = (byte)((newKeys [1] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [5] = (byte)((newKeys [1] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [6] = (byte)((newKeys [1] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [6] = (byte)((newKeys [1] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [7] = (byte)((newKeys [1] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [7] = (byte)((newKeys [1] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [8] = (byte)(newKeys [2] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [8] = (byte)(newKeys [2] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: return (byte)((temp * (temp ^ 1)) >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: if (keyData.Length != 12) {  	throw new InvalidOperationException ("Key length is not valid");  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys = new uint[3];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [1] = keys [1] * 134775813 + 1;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,Reset,The following statement contains a magic number: keys [2] = 0;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicManaged,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Encryption\PkzipClassic.cs,GenerateKey,The following statement contains a magic number: key_ = new byte[12];  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if (magic != (GZipConstants.GZIP_MAGIC >> 8)) {  	throw new GZipException ("Error GZIP header' first magic byte doesn't match");  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if (compressionType != 8) {  	throw new GZipException ("Error GZIP header' data not in deflate format");  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  	int readByte = inputBuffer.ReadLeByte ();  	if (readByte < 0) {  		throw new EndOfStreamException ("EOS reading GZIP header");  	}  	headCRC.Update (readByte);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FEXTRA) != 0) {  	// XLEN is total length of extra subfields' we will skip them all  	int len1' len2;  	len1 = inputBuffer.ReadLeByte ();  	len2 = inputBuffer.ReadLeByte ();  	if ((len1 < 0) || (len2 < 0)) {  		throw new EndOfStreamException ("EOS reading GZIP header");  	}  	headCRC.Update (len1);  	headCRC.Update (len2);  	int extraLen = (len2 << 8) | len1;  	// gzip is LSB first  	for (int i = 0; i < extraLen; i++) {  		int readByte = inputBuffer.ReadLeByte ();  		if (readByte < 0) {  			throw new EndOfStreamException ("EOS reading GZIP header");  		}  		headCRC.Update (readByte);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FHCRC) != 0) {  	int tempByte;  	int crcval = inputBuffer.ReadLeByte ();  	if (crcval < 0) {  		throw new EndOfStreamException ("EOS reading GZIP header");  	}  	tempByte = inputBuffer.ReadLeByte ();  	if (tempByte < 0) {  		throw new EndOfStreamException ("EOS reading GZIP header");  	}  	crcval = (crcval << 8) | tempByte;  	if (crcval != ((int)headCRC.Value & 0xffff)) {  		throw new GZipException ("Header CRC value mismatch");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: crcval = (crcval << 8) | tempByte;  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: while (needed > 0) {  	int count = inputBuffer.ReadClearTextBuffer (footer' 8 - needed' needed);  	if (count <= 0) {  		throw new EndOfStreamException ("EOS reading GZIP footer");  	}  	needed -= count;  	// Jewel Jan 16  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = 0;  	// (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = 0;  	// (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = 0;  	// (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = 0;  	// (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = 0;  	// (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: if (buffer_ == null) {  	buffer_ = new byte[4096];  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: buffer_ = new byte[4096];  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (proceed) {  	if (events_ != null) {  		continueRunning_ = events_.OnProcessFile (entry.Name);  	}  	if (continueRunning_) {  		try {  			using (FileStream outputStream = File.Create (targetName)) {  				if (buffer_ == null) {  					buffer_ = new byte[4096];  				}  				if ((events_ != null) && (events_.Progress != null)) {  					StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  				}  				else {  					StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  				}  				if (events_ != null) {  					continueRunning_ = events_.OnCompletedFile (entry.Name);  				}  			}  		}  		catch (Exception ex) {  			if (events_ != null) {  				continueRunning_ = events_.OnFileFailure (targetName' ex);  			}  			else {  				continueRunning_ = false;  				throw;  			}  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (continueRunning_) {  	try {  		using (FileStream outputStream = File.Create (targetName)) {  			if (buffer_ == null) {  				buffer_ = new byte[4096];  			}  			if ((events_ != null) && (events_.Progress != null)) {  				StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  			}  			else {  				StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  			}  			if (events_ != null) {  				continueRunning_ = events_.OnCompletedFile (entry.Name);  			}  		}  	}  	catch (Exception ex) {  		if (events_ != null) {  			continueRunning_ = events_.OnFileFailure (targetName' ex);  		}  		else {  			continueRunning_ = false;  			throw;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: try {  	using (FileStream outputStream = File.Create (targetName)) {  		if (buffer_ == null) {  			buffer_ = new byte[4096];  		}  		if ((events_ != null) && (events_.Progress != null)) {  			StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  		}  		else {  			StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  		}  		if (events_ != null) {  			continueRunning_ = events_.OnCompletedFile (entry.Name);  		}  	}  }  catch (Exception ex) {  	if (events_ != null) {  		continueRunning_ = events_.OnFileFailure (targetName' ex);  	}  	else {  		continueRunning_ = false;  		throw;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: using (FileStream outputStream = File.Create (targetName)) {  	if (buffer_ == null) {  		buffer_ = new byte[4096];  	}  	if ((events_ != null) && (events_.Progress != null)) {  		StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  	}  	else {  		StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  	}  	if (events_ != null) {  		continueRunning_ = events_.OnCompletedFile (entry.Name);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (buffer_ == null) {  	buffer_ = new byte[4096];  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: buffer_ = new byte[4096];  
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 2] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 3] = ':';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ZipEntry,The following statement contains a magic number: if ((versionRequiredToExtract != 0) && (versionRequiredToExtract < 10)) {  	throw new ArgumentOutOfRangeException ("versionRequiredToExtract");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x0001)) {  	// Version required to extract is ignored here as some archivers dont set it correctly  	// in theory it should be version 45 or higher  	// The recorded size will change but remember that this is zip64.  	forceZip64_ = true;  	if (extraData.ValueLength < 4) {  		throw new ZipException ("Extra data extended Zip64 information length is invalid");  	}  	if (localHeader || (size == uint.MaxValue)) {  		size = (ulong)extraData.ReadLong ();  	}  	if (localHeader || (compressedSize == uint.MaxValue)) {  		compressedSize = (ulong)extraData.ReadLong ();  	}  	if (!localHeader && (offset == uint.MaxValue)) {  		offset = extraData.ReadLong ();  	}  	// Disk number on which file starts is ignored  }  else {  	if (((versionToExtract & 0xff) >= ZipConstants.VersionZip64) && ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))) {  		throw new ZipException ("Zip64 Extended information required but is missing.");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.ValueLength < 4) {  	throw new ZipException ("Extra data extended Zip64 information length is invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.ValueLength < 4) {  	throw new ZipException ("NTFS Extra data invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: while (extraData.UnreadCount >= 4) {  	int ntfsTag = extraData.ReadShort ();  	int ntfsLength = extraData.ReadShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModification = extraData.ReadLong ();  			long lastAccess = extraData.ReadLong ();  			long createTime = extraData.ReadLong ();  			DateTime = System.DateTime.FromFileTime (lastModification);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		extraData.Skip (ntfsLength);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: while (extraData.UnreadCount >= 4) {  	int ntfsTag = extraData.ReadShort ();  	int ntfsLength = extraData.ReadShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModification = extraData.ReadLong ();  			long lastAccess = extraData.ReadLong ();  			long createTime = extraData.ReadLong ();  			DateTime = System.DateTime.FromFileTime (lastModification);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		extraData.Skip (ntfsLength);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (ntfsTag == 1) {  	if (ntfsLength >= 24) {  		long lastModification = extraData.ReadLong ();  		long lastAccess = extraData.ReadLong ();  		long createTime = extraData.ReadLong ();  		DateTime = System.DateTime.FromFileTime (lastModification);  	}  	break;  }  else {  	// An unknown NTFS tag so simply skip it.  	extraData.Skip (ntfsLength);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (ntfsLength >= 24) {  	long lastModification = extraData.ReadLong ();  	long lastAccess = extraData.ReadLong ();  	long createTime = extraData.ReadLong ();  	DateTime = System.DateTime.FromFileTime (lastModification);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (((flags & 1) != 0) && (length >= 5)) {  	int iTime = extraData.ReadInt ();  	DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (((flags & 1) != 0) && (length >= 5)) {  	int iTime = extraData.ReadInt ();  	DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (extraData.Find (0x9901)) {  	// Set version and flag for Zipfile.CreateAndInitDecryptionStream  	versionToExtract = ZipConstants.VERSION_AES;  	// Ver 5.1 = AES see "Version" getter  	// Set StrongEncryption flag for ZipFile.CreateAndInitDecryptionStream  	Flags = Flags | (int)GeneralBitFlags.StrongEncryption;  	//  	// Unpack AES extra data field see http://www.winzip.com/aes_info.htm  	int length = extraData.ValueLength;  	// Data size currently 7  	if (length < 7)  		throw new ZipException ("AES Extra Data Length " + length + " invalid.");  	int ver = extraData.ReadShort ();  	// Version number (1=AE-1 2=AE-2)  	int vendorId = extraData.ReadShort ();  	// 2-character vendor ID 0x4541 = "AE"  	int encrStrength = extraData.ReadByte ();  	// encryption strength 1 = 128 2 = 192 3 = 256  	int actualCompress = extraData.ReadShort ();  	// The actual compression method used to compress the file  	_aesVer = ver;  	_aesEncryptionStrength = encrStrength;  	method = (CompressionMethod)actualCompress;  }  else  	throw new ZipException ("AES Extra Data missing");  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (length < 7)  	throw new ZipException ("AES Extra Data Length " + length + " invalid.");  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,The following statement contains a magic number: externalAttributes |= (setAttributes_ | 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  	int iTime = helperStream.ReadLEInt ();  	_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  	int iTime = helperStream.ReadLEInt ();  	_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if ((_flags & Flags.AccessTime) != 0) {  	int iTime = helperStream.ReadLEInt ();  	_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if ((_flags & Flags.CreateTime) != 0) {  	int iTime = helperStream.ReadLEInt ();  	_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.ModificationTime) != 0) {  	TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.AccessTime) != 0) {  	TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.CreateTime) != 0) {  	TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.ReadLEInt ();  		// Reserved  		while (helperStream.Position < helperStream.Length) {  			int ntfsTag = helperStream.ReadLEShort ();  			int ntfsLength = helperStream.ReadLEShort ();  			if (ntfsTag == 1) {  				if (ntfsLength >= 24) {  					long lastModificationTicks = helperStream.ReadLELong ();  					_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  					long lastAccessTicks = helperStream.ReadLELong ();  					_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  					long createTimeTicks = helperStream.ReadLELong ();  					_createTime = DateTime.FromFileTime (createTimeTicks);  				}  				break;  			}  			else {  				// An unknown NTFS tag so simply skip it.  				helperStream.Seek (ntfsLength' SeekOrigin.Current);  			}  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.ReadLEInt ();  	// Reserved  	while (helperStream.Position < helperStream.Length) {  		int ntfsTag = helperStream.ReadLEShort ();  		int ntfsLength = helperStream.ReadLEShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModificationTicks = helperStream.ReadLELong ();  				_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  				long lastAccessTicks = helperStream.ReadLELong ();  				_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  				long createTimeTicks = helperStream.ReadLELong ();  				_createTime = DateTime.FromFileTime (createTimeTicks);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			helperStream.Seek (ntfsLength' SeekOrigin.Current);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: while (helperStream.Position < helperStream.Length) {  	int ntfsTag = helperStream.ReadLEShort ();  	int ntfsLength = helperStream.ReadLEShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModificationTicks = helperStream.ReadLELong ();  			_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  			long lastAccessTicks = helperStream.ReadLELong ();  			_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  			long createTimeTicks = helperStream.ReadLELong ();  			_createTime = DateTime.FromFileTime (createTimeTicks);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		helperStream.Seek (ntfsLength' SeekOrigin.Current);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (ntfsTag == 1) {  	if (ntfsLength >= 24) {  		long lastModificationTicks = helperStream.ReadLELong ();  		_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  		long lastAccessTicks = helperStream.ReadLELong ();  		_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  		long createTimeTicks = helperStream.ReadLELong ();  		_createTime = DateTime.FromFileTime (createTimeTicks);  	}  	break;  }  else {  	// An unknown NTFS tag so simply skip it.  	helperStream.Seek (ntfsLength' SeekOrigin.Current);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (ntfsLength >= 24) {  	long lastModificationTicks = helperStream.ReadLELong ();  	_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  	long lastAccessTicks = helperStream.ReadLELong ();  	_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  	long createTimeTicks = helperStream.ReadLELong ();  	_createTime = DateTime.FromFileTime (createTimeTicks);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteLEInt (0);  		// Reserved  		helperStream.WriteLEShort (1);  		// Tag  		helperStream.WriteLEShort (24);  		// Length = 3 x 8.  		helperStream.WriteLELong (_lastModificationTime.ToFileTime ());  		helperStream.WriteLELong (_lastAccessTime.ToFileTime ());  		helperStream.WriteLELong (_createTime.ToFileTime ());  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteLEInt (0);  	// Reserved  	helperStream.WriteLEShort (1);  	// Tag  	helperStream.WriteLEShort (24);  	// Length = 3 x 8.  	helperStream.WriteLELong (_lastModificationTime.ToFileTime ());  	helperStream.WriteLELong (_lastAccessTime.ToFileTime ());  	helperStream.WriteLELong (_createTime.ToFileTime ());  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: helperStream.WriteLEShort (24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,Find,The following statement contains a magic number: while ((localTag != headerID) && (_index < _data.Length - 3)) {  	localTag = ReadShortInternal ();  	localLength = ReadShortInternal ();  	if (localTag != headerID) {  		_index += localLength;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: if (Find (headerID)) {  	newLength -= (ValueLength + 4);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: newLength -= (ValueLength + 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: unchecked {  	_newEntry.WriteByte ((byte)toAdd);  	_newEntry.WriteByte ((byte)(toAdd >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: _newEntry.WriteByte ((byte)(toAdd >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: unchecked {  	AddLeShort ((short)toAdd);  	AddLeShort ((short)(toAdd >> 16));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: AddLeShort ((short)(toAdd >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: unchecked {  	AddLeInt ((int)(toAdd & 0xffffffff));  	AddLeInt ((int)(toAdd >> 32));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: AddLeInt ((int)(toAdd >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: ReadCheck (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: return (ReadInt () & 0xffffffff) | (((long)ReadInt ()) << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: ReadCheck (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: _index += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: ReadCheck (2);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: _index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if ((_readValueStart > _data.Length) || (_readValueStart < 4)) {  	throw new ZipException ("Find must be called before calling a Read method");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if (_index + length < 4) {  	throw new ZipException ("Cannot read before start of tag");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: if (_index > _data.Length - 2) {  	throw new ZipException ("End of extra data");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: _index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: _data [index + 1] = (byte)(source >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: try {  	int entryIndex = 0;  	while (testing && (entryIndex < Count)) {  		if (resultHandler != null) {  			status.SetEntry (this [entryIndex]);  			status.SetOperation (TestOperation.EntryHeader);  			resultHandler (status' null);  		}  		try {  			TestLocalHeader (this [entryIndex]' test);  		}  		catch (ZipException ex) {  			status.AddError ();  			if (resultHandler != null) {  				resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  			}  			if (strategy == TestStrategy.FindFirstError) {  				testing = false;  			}  		}  		if (testing && testData && this [entryIndex].IsFile) {  			if (resultHandler != null) {  				status.SetOperation (TestOperation.EntryData);  				resultHandler (status' null);  			}  			Crc32 crc = new Crc32 ();  			using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  				byte[] buffer = new byte[4096];  				long totalBytes = 0;  				int bytesRead;  				while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  					crc.Update (buffer' 0' bytesRead);  					if (resultHandler != null) {  						totalBytes += bytesRead;  						status.SetBytesTested (totalBytes);  						resultHandler (status' null);  					}  				}  			}  			if (this [entryIndex].Crc != crc.Value) {  				status.AddError ();  				if (resultHandler != null) {  					resultHandler (status' "CRC mismatch");  				}  				if (strategy == TestStrategy.FindFirstError) {  					testing = false;  				}  			}  			if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				ZipHelperStream helper = new ZipHelperStream (baseStream_);  				DescriptorData data = new DescriptorData ();  				helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  				if (this [entryIndex].Crc != data.Crc) {  					status.AddError ();  				}  				if (this [entryIndex].CompressedSize != data.CompressedSize) {  					status.AddError ();  				}  				if (this [entryIndex].Size != data.Size) {  					status.AddError ();  				}  			}  		}  		if (resultHandler != null) {  			status.SetOperation (TestOperation.EntryComplete);  			resultHandler (status' null);  		}  		entryIndex += 1;  	}  	if (resultHandler != null) {  		status.SetOperation (TestOperation.MiscellaneousTests);  		resultHandler (status' null);  	}  	// TODO: the 'Corrina Johns' test where local headers are missing from  	// the central directory.  They are therefore invisible to many archivers.  }  catch (Exception ex) {  	status.AddError ();  	if (resultHandler != null) {  		resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: while (testing && (entryIndex < Count)) {  	if (resultHandler != null) {  		status.SetEntry (this [entryIndex]);  		status.SetOperation (TestOperation.EntryHeader);  		resultHandler (status' null);  	}  	try {  		TestLocalHeader (this [entryIndex]' test);  	}  	catch (ZipException ex) {  		status.AddError ();  		if (resultHandler != null) {  			resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  		}  		if (strategy == TestStrategy.FindFirstError) {  			testing = false;  		}  	}  	if (testing && testData && this [entryIndex].IsFile) {  		if (resultHandler != null) {  			status.SetOperation (TestOperation.EntryData);  			resultHandler (status' null);  		}  		Crc32 crc = new Crc32 ();  		using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  			byte[] buffer = new byte[4096];  			long totalBytes = 0;  			int bytesRead;  			while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  				crc.Update (buffer' 0' bytesRead);  				if (resultHandler != null) {  					totalBytes += bytesRead;  					status.SetBytesTested (totalBytes);  					resultHandler (status' null);  				}  			}  		}  		if (this [entryIndex].Crc != crc.Value) {  			status.AddError ();  			if (resultHandler != null) {  				resultHandler (status' "CRC mismatch");  			}  			if (strategy == TestStrategy.FindFirstError) {  				testing = false;  			}  		}  		if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  			ZipHelperStream helper = new ZipHelperStream (baseStream_);  			DescriptorData data = new DescriptorData ();  			helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  			if (this [entryIndex].Crc != data.Crc) {  				status.AddError ();  			}  			if (this [entryIndex].CompressedSize != data.CompressedSize) {  				status.AddError ();  			}  			if (this [entryIndex].Size != data.Size) {  				status.AddError ();  			}  		}  	}  	if (resultHandler != null) {  		status.SetOperation (TestOperation.EntryComplete);  		resultHandler (status' null);  	}  	entryIndex += 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: if (testing && testData && this [entryIndex].IsFile) {  	if (resultHandler != null) {  		status.SetOperation (TestOperation.EntryData);  		resultHandler (status' null);  	}  	Crc32 crc = new Crc32 ();  	using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  		byte[] buffer = new byte[4096];  		long totalBytes = 0;  		int bytesRead;  		while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  			crc.Update (buffer' 0' bytesRead);  			if (resultHandler != null) {  				totalBytes += bytesRead;  				status.SetBytesTested (totalBytes);  				resultHandler (status' null);  			}  		}  	}  	if (this [entryIndex].Crc != crc.Value) {  		status.AddError ();  		if (resultHandler != null) {  			resultHandler (status' "CRC mismatch");  		}  		if (strategy == TestStrategy.FindFirstError) {  			testing = false;  		}  	}  	if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  		ZipHelperStream helper = new ZipHelperStream (baseStream_);  		DescriptorData data = new DescriptorData ();  		helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  		if (this [entryIndex].Crc != data.Crc) {  			status.AddError ();  		}  		if (this [entryIndex].CompressedSize != data.CompressedSize) {  			status.AddError ();  		}  		if (this [entryIndex].Size != data.Size) {  			status.AddError ();  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  	byte[] buffer = new byte[4096];  	long totalBytes = 0;  	int bytesRead;  	while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  		crc.Update (buffer' 0' bytesRead);  		if (resultHandler != null) {  			totalBytes += bytesRead;  			status.SetBytesTested (totalBytes);  			resultHandler (status' null);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testData) {  	if (entry.IsFile) {  		if (!entry.IsCompressionMethodSupported ()) {  			throw new ZipException ("Compression method not supported");  		}  		if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  			throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  		}  		if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  			throw new ZipException ("The library does not support the zip version required to extract this entry");  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsFile) {  	if (!entry.IsCompressionMethodSupported ()) {  		throw new ZipException ("Compression method not supported");  	}  	if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  		throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  	}  	if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  		throw new ZipException ("The library does not support the zip version required to extract this entry");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  	throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  	throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  	if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  		throw new ZipException ("Strong encryption flag set but encryption flag is not set");  	}  	if (extractVersion < 50) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (extractVersion < 50) {  	throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  	throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  	if (extractVersion < 62) {  		throw new ZipException ("Strong encryption flag set but version not high enough");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (extractVersion < 62) {  	throw new ZipException ("Strong encryption flag set but version not high enough");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	if (size > 0) {  		throw new ZipException ("Directory cannot have size");  	}  	// There may be other cases where the compressed size can be greater than this?  	// If so until details are known we will be strict.  	if (entry.IsCrypted) {  		if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	else if (compressedSize > 2) {  		// When not compressed the directory size can validly be 2 bytes  		// if the true size wasnt known when data was originally being written.  		// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  		throw new ZipException ("Directory compressed size invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	if (size > 0) {  		throw new ZipException ("Directory cannot have size");  	}  	// There may be other cases where the compressed size can be greater than this?  	// If so until details are known we will be strict.  	if (entry.IsCrypted) {  		if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	else if (compressedSize > 2) {  		// When not compressed the directory size can validly be 2 bytes  		// if the true size wasnt known when data was originally being written.  		// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  		throw new ZipException ("Directory compressed size invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsCrypted) {  	if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  		throw new ZipException ("Directory compressed size invalid");  	}  }  else if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsCrypted) {  	if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  		throw new ZipException ("Directory compressed size invalid");  	}  }  else if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteLEShort,The following statement contains a magic number: baseStream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteLEUshort,The following statement contains a magic number: baseStream_.WriteByte ((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort ((ushort)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteLeLong,The following statement contains a magic number: WriteLEInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint ((uint)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if (entry.ExternalFileAttributes != -1) {  	WriteLEInt (entry.ExternalFileAttributes);  }  else {  	if (entry.IsDirectory) {  		WriteLEUint (16);  	}  	else {  		WriteLEUint (0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	WriteLEUint (16);  }  else {  	WriteLEUint (0);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: WriteLEUint (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	result = ZipConstants.DataDescriptorSize - 4;  	if (update.Entry.LocalHeaderRequiresZip64) {  		result = ZipConstants.Zip64DataDescriptorSize - 4;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	result = ZipConstants.DataDescriptorSize - 4;  	if (update.Entry.LocalHeaderRequiresZip64) {  		result = ZipConstants.Zip64DataDescriptorSize - 4;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: result = ZipConstants.DataDescriptorSize - 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if (update.Entry.LocalHeaderRequiresZip64) {  	result = ZipConstants.Zip64DataDescriptorSize - 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: result = ZipConstants.Zip64DataDescriptorSize - 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,GetOutputStream,The following statement contains a magic number: switch (entry.CompressionMethod) {  case CompressionMethod.Stored:  	result = new UncompressedStream (result);  	break;  case CompressionMethod.Deflated:  	DeflaterOutputStream dos = new DeflaterOutputStream (result' new Deflater (9' true));  	dos.IsStreamOwner = false;  	result = dos;  	break;  default:  	throw new ZipException ("Unknown compression method " + entry.CompressionMethod);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CopyEntry,The following statement contains a magic number: if (update.Entry.CompressedSize > 0) {  	const int NameLengthOffset = 26;  	long entryDataOffset = update.Entry.Offset + NameLengthOffset;  	// TODO: This wont work for SFX files!  	baseStream_.Seek (entryDataOffset' SeekOrigin.Begin);  	uint nameLength = ReadLEUshort ();  	uint extraLength = ReadLEUshort ();  	baseStream_.Seek (nameLength + extraLength' SeekOrigin.Current);  	CopyBytes (update' workFile.baseStream_' baseStream_' update.Entry.CompressedSize' false);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,UpdateCommentOnly,The following statement contains a magic number: using (updateFile) {  	long locatedCentralDirOffset = updateFile.LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff);  	if (locatedCentralDirOffset < 0) {  		throw new ZipException ("Cannot find central directory");  	}  	const int CentralHeaderCommentSizeOffset = 16;  	updateFile.Position += CentralHeaderCommentSizeOffset;  	byte[] rawComment = newComment_.RawComment;  	updateFile.WriteLEShort (rawComment.Length);  	updateFile.Write (rawComment' 0' rawComment.Length);  	updateFile.SetLength (updateFile.Position);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadLEUshort,The following statement contains a magic number: return unchecked((ushort)((ushort)data1 | (ushort)(data2 << 8)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadLEUint,The following statement contains a magic number: return (uint)(ReadLEUshort () | (ReadLEUshort () << 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadLEUlong,The following statement contains a magic number: return ReadLEUint () | ((ulong)ReadLEUint () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize))) {  	offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  	if (offsetOfFirstEntry <= 0) {  		throw new ZipException ("Invalid embedded zip archive");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize))) {  	offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  	if (offsetOfFirstEntry <= 0) {  		throw new ZipException ("Invalid embedded zip archive");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: entry.CryptoCheckValue = (byte)(crc >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  	// which doesnt do this.  	result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write);  	if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  		WriteEncryptionHeader (result' entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (result' entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  	// which doesnt do this.  	result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write);  	if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  		WriteEncryptionHeader (result' entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (result' entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  	WriteEncryptionHeader (result' entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (result' entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  	WriteEncryptionHeader (result' entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (result' entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: WriteEncryptionHeader (result' entry.DosTime << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,MakeTemporaryCopy,The following statement contains a magic number: StreamUtils.Copy (stream' temporaryStream_' new byte[4096]);  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if ((stream == null) || !stream.CanWrite) {  	result = new MemoryStream ();  	if (stream != null) {  		stream.Position = 0;  		StreamUtils.Copy (stream' result' new byte[4096]);  		stream.Close ();  	}  }  else {  	result = stream;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if (stream != null) {  	stream.Position = 0;  	StreamUtils.Copy (stream' result' new byte[4096]);  	stream.Close ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: StreamUtils.Copy (stream' result' new byte[4096]);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteZip64EndOfCentralDirectory,The following statement contains a magic number: WriteLELong (44);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,ReadLEShort,The following statement contains a magic number: return byteValue1 | (byteValue2 << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,ReadLEInt,The following statement contains a magic number: return ReadLEShort () | (ReadLEShort () << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,ReadLELong,The following statement contains a magic number: return (uint)ReadLEInt () | ((long)ReadLEInt () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteLEShort,The following statement contains a magic number: stream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteLEUshort,The following statement contains a magic number: stream_.WriteByte ((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort ((ushort)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteLELong,The following statement contains a magic number: WriteLEInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint ((uint)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if (entry.LocalHeaderRequiresZip64) {  	WriteLELong (entry.CompressedSize);  	WriteLELong (entry.Size);  	result += 16;  }  else {  	WriteLEInt ((int)entry.CompressedSize);  	WriteLEInt ((int)entry.Size);  	result += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if (entry.LocalHeaderRequiresZip64) {  	WriteLELong (entry.CompressedSize);  	WriteLELong (entry.Size);  	result += 16;  }  else {  	WriteLEInt ((int)entry.CompressedSize);  	WriteLEInt ((int)entry.Size);  	result += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,CompleteCloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	ReadDataDescriptor ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  	if ((flags & 8) != 0) {  		// We don't know how much we must skip' read until end.  		byte[] tmp = new byte[4096];  		// Read will close this entry  		while (Read (tmp' 0' tmp.Length) > 0) {  		}  		return;  	}  	csize -= inf.TotalIn;  	inputBuffer.Available += inf.RemainingInput;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  	if ((flags & 8) != 0) {  		// We don't know how much we must skip' read until end.  		byte[] tmp = new byte[4096];  		// Read will close this entry  		while (Read (tmp' 0' tmp.Length) > 0) {  		}  		return;  	}  	csize -= inf.TotalIn;  	inputBuffer.Available += inf.RemainingInput;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	// We don't know how much we must skip' read until end.  	byte[] tmp = new byte[4096];  	// Read will close this entry  	while (Read (tmp' 0' tmp.Length) > 0) {  	}  	return;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	// We don't know how much we must skip' read until end.  	byte[] tmp = new byte[4096];  	// Read will close this entry  	while (Read (tmp' 0' tmp.Length) > 0) {  	}  	return;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: switch (method) {  case (int)CompressionMethod.Deflated:  	count = base.Read (buffer' offset' count);  	if (count <= 0) {  		if (!inf.IsFinished) {  			throw new ZipException ("Inflater not finished!");  		}  		inputBuffer.Available = inf.RemainingInput;  		// A csize of -1 is from an unpatched local header  		if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  			throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  		}  		inf.Reset ();  		finished = true;  	}  	break;  case (int)CompressionMethod.Stored:  	if ((count > csize) && (csize >= 0)) {  		count = (int)csize;  	}  	if (count > 0) {  		count = inputBuffer.ReadClearTextBuffer (buffer' offset' count);  		if (count > 0) {  			csize -= count;  			size -= count;  		}  	}  	if (csize == 0) {  		finished = true;  	}  	else {  		if (count < 0) {  			throw new ZipException ("EOF in stored block");  		}  	}  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: if (count <= 0) {  	if (!inf.IsFinished) {  		throw new ZipException ("Inflater not finished!");  	}  	inputBuffer.Available = inf.RemainingInput;  	// A csize of -1 is from an unpatched local header  	if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  		throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  	}  	inf.Reset ();  	finished = true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  	throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryCharsRelaxed [howMany - 2] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: howMany = invalidPathChars.Length + 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 2] = '\\';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 3] = '*';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 4] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: unchecked {  	baseOutputStream_.WriteByte ((byte)(value & 0xff));  	baseOutputStream_.WriteByte ((byte)((value >> 8) & 0xff));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: baseOutputStream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: unchecked {  	WriteLeShort (value);  	WriteLeShort (value >> 16);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: WriteLeShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: unchecked {  	WriteLeInt ((int)value);  	WriteLeInt ((int)(value >> 32));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: WriteLeInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (headerInfoAvailable == false) {  	if (CanPatchEntries == false) {  		// Only way to record size and compressed size is to append a data descriptor  		// after compressed data.  		// Stored entries of this form have already been converted to deflating.  		entry.Flags |= 8;  	}  	else {  		patchEntryHeader = true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (CanPatchEntries == false) {  	// Only way to record size and compressed size is to append a data descriptor  	// after compressed data.  	// Stored entries of this form have already been converted to deflating.  	entry.Flags |= 8;  }  else {  	patchEntryHeader = true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: entry.Flags |= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (Password != null) {  	entry.IsCrypted = true;  	if (entry.Crc < 0) {  		// Need to append a data descriptor as the crc isnt available for use  		// with encryption' the date is used instead.  Setting the flag  		// indicates this to the decompressor.  		entry.Flags |= 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.Crc < 0) {  	// Need to append a data descriptor as the crc isnt available for use  	// with encryption' the date is used instead.  Setting the flag  	// indicates this to the decompressor.  	entry.Flags |= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: entry.Flags |= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.IsCrypted) {  	if (entry.Crc < 0) {  		// so testing Zip will says its ok  		WriteEncryptionHeader (entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.Crc < 0) {  	// so testing Zip will says its ok  	WriteEncryptionHeader (entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: WriteEncryptionHeader (entry.DosTime << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if (curEntry.AESKeySize > 0) {  	baseOutputStream_.Write (AESAuthCode' 0' 10);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: baseOutputStream_.Write (AESAuthCode' 0' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if ((curEntry.Flags & 8) != 0) {  	WriteLeInt (ZipConstants.DataDescriptorSignature);  	WriteLeInt (unchecked((int)curEntry.Crc));  	if (curEntry.LocalHeaderRequiresZip64) {  		WriteLeLong (curEntry.CompressedSize);  		WriteLeLong (curEntry.Size);  		offset += ZipConstants.Zip64DataDescriptorSize;  	}  	else {  		WriteLeInt ((int)curEntry.CompressedSize);  		WriteLeInt ((int)curEntry.Size);  		offset += ZipConstants.DataDescriptorSize;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: foreach (ZipEntry entry in entries) {  	WriteLeInt (ZipConstants.CentralHeaderSignature);  	WriteLeShort (ZipConstants.VersionMadeBy);  	WriteLeShort (entry.Version);  	WriteLeShort (entry.Flags);  	WriteLeShort ((short)entry.CompressionMethodForHeader);  	WriteLeInt ((int)entry.DosTime);  	WriteLeInt ((int)entry.Crc);  	if (entry.IsZip64Forced () || (entry.CompressedSize >= uint.MaxValue)) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.CompressedSize);  	}  	if (entry.IsZip64Forced () || (entry.Size >= uint.MaxValue)) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.Size);  	}  	byte[] name = ZipConstants.ConvertToArray (entry.Flags' entry.Name);  	if (name.Length > 0xffff) {  		throw new ZipException ("Name too long.");  	}  	ZipExtraData ed = new ZipExtraData (entry.ExtraData);  	if (entry.CentralHeaderRequiresZip64) {  		ed.StartNewEntry ();  		if (entry.IsZip64Forced () || (entry.Size >= 0xffffffff)) {  			ed.AddLeLong (entry.Size);  		}  		if (entry.IsZip64Forced () || (entry.CompressedSize >= 0xffffffff)) {  			ed.AddLeLong (entry.CompressedSize);  		}  		if (entry.Offset >= 0xffffffff) {  			ed.AddLeLong (entry.Offset);  		}  		ed.AddNewEntry (1);  	}  	else {  		ed.Delete (1);  	}  	byte[] extra = ed.GetEntryData ();  	byte[] entryComment = (entry.Comment != null) ? ZipConstants.ConvertToArray (entry.Flags' entry.Comment) : new byte[0];  	if (entryComment.Length > 0xffff) {  		throw new ZipException ("Comment too long.");  	}  	WriteLeShort (name.Length);  	WriteLeShort (extra.Length);  	WriteLeShort (entryComment.Length);  	WriteLeShort (0);  	// disk number  	WriteLeShort (0);  	// internal file attributes  	// external file attributes  	if (entry.ExternalFileAttributes != -1) {  		WriteLeInt (entry.ExternalFileAttributes);  	}  	else {  		if (entry.IsDirectory) {  			// mark entry as directory (from nikolam.AT.perfectinfo.com)  			WriteLeInt (16);  		}  		else {  			WriteLeInt (0);  		}  	}  	if (entry.Offset >= uint.MaxValue) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.Offset);  	}  	if (name.Length > 0) {  		baseOutputStream_.Write (name' 0' name.Length);  	}  	if (extra.Length > 0) {  		baseOutputStream_.Write (extra' 0' extra.Length);  	}  	if (entryComment.Length > 0) {  		baseOutputStream_.Write (entryComment' 0' entryComment.Length);  	}  	sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: if (entry.ExternalFileAttributes != -1) {  	WriteLeInt (entry.ExternalFileAttributes);  }  else {  	if (entry.IsDirectory) {  		// mark entry as directory (from nikolam.AT.perfectinfo.com)  		WriteLeInt (16);  	}  	else {  		WriteLeInt (0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: if (entry.IsDirectory) {  	// mark entry as directory (from nikolam.AT.perfectinfo.com)  	WriteLeInt (16);  }  else {  	WriteLeInt (0);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: WriteLeInt (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: level = 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: level = 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header |= level_flags << 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if ((state & IS_SETDICT) != 0) {  	int chksum = engine.Adler;  	engine.ResetAdler ();  	pending.WriteShortMSB (chksum >> 16);  	pending.WriteShortMSB (chksum & 0xffff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (chksum >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: neededbits -= 10;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!noZlibHeaderOrFooter) {  	int adler = engine.Adler;  	pending.WriteShortMSB (adler >> 16);  	pending.WriteShortMSB (adler & 0xffff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (adler >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,SetLevel,The following statement contains a magic number: if ((level < 0) || (level > 9)) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd) {  	int more = 2 * WSIZE - lookahead - strstart;  	if (more > inputEnd - inputOff) {  		more = inputEnd - inputOff;  	}  	System.Array.Copy (inputBuf' inputOff' window' strstart + lookahead' more);  	adler.Update (inputBuf' inputOff' more);  	inputOff += more;  	totalIn += more;  	lookahead += more;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= this.goodLength) {  	chainLength >>= 2;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: chainLength >>= 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	#if DebugDeflation  	 				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) ) 				{ 					throw new InvalidOperationException("no future"); 				} #endif  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) {  		// Do nothing  	}  	if (scan > best_end) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && (ins_h == 0) ) 						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart)); #endif  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	#if DebugDeflation  	 				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) ) 				{ 					throw new InvalidOperationException("no future"); 				} #endif  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) {  		// Do nothing  	}  	if (scan > best_end) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && (ins_h == 0) ) 						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart)); #endif  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: match = curMatch + 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: scan += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		// We are flushing everything  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int hashHead;  	if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		// longestMatch sets matchStart and matchLen  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 						for (int i = 0 ; i < matchLen; i++) { 							if (window[strstart + i] != window[matchStart + i]) { 								throw new SharpZipBaseException("Match failure"); 							} 						} 					} #endif  		bool full = huffman.TallyDist (strstart - matchStart' matchLen);  		lookahead -= matchLen;  		if (matchLen <= max_lazy && lookahead >= MIN_MATCH) {  			while (--matchLen > 0) {  				++strstart;  				InsertString ();  			}  			++strstart;  		}  		else {  			strstart += matchLen;  			if (lookahead >= MIN_MATCH - 1) {  				UpdateHash ();  			}  		}  		matchLen = MIN_MATCH - 1;  		if (!full) {  			continue;  		}  	}  	else {  		// No match found  		huffman.TallyLit (window [strstart] & 0xff);  		++strstart;  		--lookahead;  	}  	if (huffman.IsFull ()) {  		bool lastBlock = finish && (lookahead == 0);  		huffman.FlushBlock (window' blockStart' strstart - blockStart' lastBlock);  		blockStart = strstart;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (lookahead >= MIN_MATCH) {  	int hashHead = InsertString ();  	if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		// longestMatch sets matchStart and matchLen  		// Discard match if too small and too far away  		if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  			matchLen = MIN_MATCH - 1;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  	// longestMatch sets matchStart and matchLen  	// Discard match if too small and too far away  	if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  		matchLen = MIN_MATCH - 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  	matchLen = MIN_MATCH - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  	#if DebugDeflation  						if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  	huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  	prevLen -= 2;  	do {  		strstart++;  		lookahead--;  		if (lookahead >= MIN_MATCH) {  			InsertString ();  		}  	}  	while (--prevLen > 0);  	strstart++;  	lookahead--;  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  }  else {  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	prevAvailable = true;  	strstart++;  	lookahead--;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: prevLen -= 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x030 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDCodes [i] = BitReverse (i << 11);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDLength [i] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree (this' DIST_NUM' 1' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (distTree.numCodes - 1' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++) {  	pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (bits > 0 && bits <= 5) {  	pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: bits = dc / 2 - 1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--) {  	if (blTree.length [BL_ORDER [i]] > 0) {  		blTreeCodes = i + 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf [last_lit++] = (byte)(length - 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += dc / 2 - 1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  	return 285;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  	return 285;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: return 285;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  	code += 4;  	length >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  	code += 4;  	length >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: code += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: code += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  	throw new SharpZipBaseException ("Header checksum illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8)) {  	throw new SharpZipBaseException ("Compression Method unknown");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) {  	// Dictionary flag?  	mode = DECODE_BLOCKS;  }  else {  	mode = DECODE_DICT;  	neededBits = 32;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: readAdler = (readAdler << 8) | dictByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  	outputWindow.Write (symbol);  	if (--free < 258) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (--free < 258) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (symbol < 257) {  	if (symbol < 0) {  		return false;  	}  	else {  		// symbol == 256: end of block  		distTree = null;  		litlenTree = null;  		mode = DECODE_BLOCKS;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: repLength = CPLENS [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: neededBits = CPLEXT [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: readAdler = (readAdler << 8) | chkByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (isLastBlock) {  	if (noHeader) {  		mode = FINISHED;  		return false;  	}  	else {  		input.SkipToByteBoundary ();  		neededBits = 32;  		mode = DECODE_CHKSUM;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (noHeader) {  	mode = FINISHED;  	return false;  }  else {  	input.SkipToByteBoundary ();  	neededBits = 32;  	mode = DECODE_CHKSUM;  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if ((uncomprLen = input.PeekBits (16)) < 0) {  	return false;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum += 257;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: dnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum = input.PeekBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blLens = new byte[19];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  	/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  	litdistLens [ptr++] = lastLen = (byte)symbol;  	if (ptr == num) {  		/* Finished */return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: if (symbol >= 17) {  	/* repeat zero *///  		  System.err.println("repeating zero");  	lastLen = 0;  }  else {  	if (ptr == 0) {  		throw new SharpZipBaseException ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: repSymbol = symbol - 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths = new byte[32];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code += blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treeSize += (end - start) >> (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code -= blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: i += 1 << 7
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treePtr += 1 << (bits - 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [revcode] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: subTree = -(subTree >> 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: nextCode [bits] = code + (1 << (16 - bits));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buffer_ [end++] = unchecked((byte)bits);  	if (bitCount > 8) {  		buffer_ [end++] = unchecked((byte)(bits >> 8));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buffer_ [end++] = unchecked((byte)bits);  	if (bitCount > 8) {  		buffer_ [end++] = unchecked((byte)(bits >> 8));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buffer_ [end++] = unchecked((byte)(bits >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buffer_ [end++] = unchecked((byte)(bits >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(bits >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(bits >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bits >>= 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bitCount -= 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(s >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bits >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bitCount -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\DeflaterOutputStream.cs,DeflaterOutputStream,The following statement contains a magic number: if (bufferSize < 512) {  	throw new ArgumentOutOfRangeException ("bufferSize");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  	bufferSize = 1024;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  	bufferSize = 1024;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: bufferSize = 1024;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte () | (ReadLeByte () << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort () | (ReadLeShort () << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeLong,The following statement contains a magic number: return (uint)ReadLeInt () | ((long)ReadLeInt () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\InflaterInputStream.cs,Skip,The following statement contains a magic number: if (baseInputStream.CanSeek) {  	baseInputStream.Seek (count' SeekOrigin.Current);  	return count;  }  else {  	int length = 2048;  	if (count < length) {  		length = (int)count;  	}  	byte[] tmp = new byte[length];  	int readCount = 1;  	long toSkip = count;  	while ((toSkip > 0) && (readCount > 0)) {  		if (toSkip < length) {  			length = (int)toSkip;  		}  		readCount = baseInputStream.Read (tmp' 0' length);  		toSkip -= readCount;  	}  	return count - toSkip;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: bitsInBuffer_ += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  	// bits_in_buffer may only be 0 or a multiple of 8  	throw new InvalidOperationException ("Bit buffer is not byte aligned!");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: buffer_ >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  	// We always want an even number of bytes in input' see peekBits  	buffer_ = (uint)(window_ [windowStart_++] & 0xff);  	bitsInBuffer_ = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  	// We always want an even number of bytes in input' see PeekBits  	buffer_ |= (uint)((buffer [offset++] & 0xff) << bitsInBuffer_);  	bitsInBuffer_ += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: bitsInBuffer_ += 8;  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,WriteLocalEntryHeader,The following switch statement is missing a default case: switch (useZip64_) {  case UseZip64.Dynamic:  	if (entry.Size < 0) {  		entry.ForceZip64 ();  	}  	break;  case UseZip64.On:  	entry.ForceZip64 ();  	break;  case UseZip64.Off:  	// Do nothing.  The entry itself may be using Zip64 independantly.  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipFile.cs,RunUpdates,The following switch statement is missing a default case: switch (update.Command) {  case UpdateCommand.Copy:  	if (directUpdate) {  		CopyEntryDirect (workFile' update' ref destinationPosition);  	}  	else {  		CopyEntry (workFile' update);  	}  	break;  case UpdateCommand.Modify:  	// TODO: Direct modifying of an entry will take some legwork.  	ModifyEntry (workFile' update);  	break;  case UpdateCommand.Add:  	if (!IsNewArchive && directUpdate) {  		workFile.baseStream_.Position = destinationPosition;  	}  	AddEntry (workFile' update);  	if (directUpdate) {  		destinationPosition = workFile.baseStream_.Position;  	}  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipInputStream.cs,BodyRead,The following switch statement is missing a default case: switch (method) {  case (int)CompressionMethod.Deflated:  	count = base.Read (buffer' offset' count);  	if (count <= 0) {  		if (!inf.IsFinished) {  			throw new ZipException ("Inflater not finished!");  		}  		inputBuffer.Available = inf.RemainingInput;  		// A csize of -1 is from an unpatched local header  		if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  			throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  		}  		inf.Reset ();  		finished = true;  	}  	break;  case (int)CompressionMethod.Stored:  	if ((count > csize) && (csize >= 0)) {  		count = (int)csize;  	}  	if (count > 0) {  		count = inputBuffer.ReadClearTextBuffer (buffer' offset' count);  		if (count > 0) {  			csize -= count;  			size -= count;  		}  	}  	if (csize == 0) {  		finished = true;  	}  	else {  		if (count < 0) {  			throw new ZipException ("EOF in stored block");  		}  	}  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\ZipOutputStream.cs,Write,The following switch statement is missing a default case: switch (curMethod) {  case CompressionMethod.Deflated:  	base.Write (buffer' offset' count);  	break;  case CompressionMethod.Stored:  	if (Password != null) {  		CopyAndEncrypt (buffer' offset' count);  	}  	else {  		baseOutputStream_.Write (buffer' offset' count);  	}  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction) {  case DEFLATE_STORED:  	if (strstart > blockStart) {  		huffman.FlushStoredBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	UpdateHash ();  	break;  case DEFLATE_FAST:  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	break;  case DEFLATE_SLOW:  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\qingfeng346_XML_Conversion\Conversion\ScorpioZip\SharpZip\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
