Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddPow,The method has 102 lines of code.
Long Method,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The method has 106 lines of code.
Long Method,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The method has 312 lines of code.
Complex Method,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,gcd,Cyclomatic complexity of the method is 8
Complex Method,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,RabinMillerTest,Cyclomatic complexity of the method is 9
Complex Method,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,Cyclomatic complexity of the method is 13
Complex Method,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,Cyclomatic complexity of the method is 16
Long Parameter List,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Multiply,The method has 8 parameters. Parameters: x' xOffset' xLen' y' yOffset' yLen' d' dOffset
Long Parameter List,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,MultiplyMod2p32pmod,The method has 9 parameters. Parameters: x' xOffset' xLen' y' yOffest' yLen' d' dOffset' mod
Long Statement,Rackspace.Cloud.Server.DiffieHellman,DiffieHellmanManaged,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\DiffieHellmanManaged.cs,Initialize,The length of the statement  "                throw new CryptographicException("Inputs p or g are not as expected. P probably isn't a prime or G is less than zero or more than P.");" is 135.
Long Statement,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BarrettReduction,The length of the statement  "				Kernel.MultiplyMod2p32pmod (q3.data' (int)kPlusOne' (int)q3.length - (int)kPlusOne' n.data' 0' (int)n.length' r2.data' 0' (int)kPlusOne);" is 137.
Long Statement,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddPow,The length of the statement  "				BigInteger tempNum = new BigInteger (Montgomery.ToMont (b' mod)' mod.length << 1);  // ensures (tempNum * tempNum) < b^ (2k)" is 124.
Complex Conditional,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The conditional expression  "(l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l))"  is complex.
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Parse,The following statement contains a magic number: for(; i < len; i++) { 				c = number[i]; 				if (c == '\0') { 					i = len; 					continue; 				} 				if (c >= '0' && c <= '9'){ 					val = val * 10 + (c - '0'); 					digits_seen = true; 				} else { 					if (Char.IsWhiteSpace(c)){ 						for (i++; i < len; i++){ 							if (!Char.IsWhiteSpace (number[i])) 								throw new FormatException(); 						} 						break; 					} else 						throw new FormatException(); 				} 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: length = (uint)inData.Length >> 2;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) { 				data [j] = (uint)( 					(inData [i-3] << (3*8)) | 					(inData [i-2] << (2*8)) | 					(inData [i-1] << (1*8)) | 					(inData [i-0] << (0*8)) 					); 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) { 			case 1: data [length-1] = (uint)inData [0]; break; 			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break; 			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break; 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) { 			case 1: data [length-1] = (uint)inData [0]; break; 			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break; 			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break; 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) { 			case 1: data [length-1] = (uint)inData [0]; break; 			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break; 			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break; 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) { 			case 1: data [length-1] = (uint)inData [0]; break; 			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break; 			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break; 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) { 			case 1: data [length-1] = (uint)inData [0]; break; 			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break; 			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break; 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) { 			case 1: data [length-1] = (uint)inData [0]; break; 			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break; 			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break; 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint [2] { (uint)ul' (uint)(ul >> 32)};
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint [2] { (uint)ul' (uint)(ul >> 32)};
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following statement contains a magic number: length = 2;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,genRandom,The following statement contains a magic number: int dwords = bits >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,genRandom,The following statement contains a magic number: byte [] random = new byte [dwords << 2];
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,genRandom,The following statement contains a magic number: Buffer.BlockCopy (random' 0' ret.data' 0' (int)dwords << 2);
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,genRandom,The following statement contains a magic number: if (remBits != 0) { 				uint mask = (uint)(0x01 << (remBits-1)); 				ret.data [dwords-1] |= mask;  				mask = (uint)(0xFFFFFFFF >> (32 - remBits)); 				ret.data [dwords-1] &= mask; 			} 			else 				ret.data [dwords-1] |= 0x80000000;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,randomize,The following statement contains a magic number: int dwords = bits >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,randomize,The following statement contains a magic number: byte [] random = new byte [dwords << 2];
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,randomize,The following statement contains a magic number: Buffer.BlockCopy (random' 0' data' 0' (int)dwords << 2);
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,randomize,The following statement contains a magic number: if (remBits != 0) { 				uint mask = (uint)(0x01 << (remBits-1)); 				data [dwords-1] |= mask;  				mask = (uint)(0xFFFFFFFF >> (32 - remBits)); 				data [dwords-1] &= mask; 			}  			else 				data [dwords-1] |= 0x80000000;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,bitCount,The following statement contains a magic number: uint bits = 32;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,bitCount,The following statement contains a magic number: bits += ((length - 1) << 5);
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,testBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,testBit,The following statement contains a magic number: uint bytePos = (uint)bitNum >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,setBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,getBytes,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,getBytes,The following statement contains a magic number: if (numBytesInWord == 0) numBytesInWord = 4;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,getBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--) { 				uint val = data [i]; 				for (int j = numBytesInWord - 1; j >= 0; j--) { 					result [pos+j] = (byte)(val & 0xFF); 					val >>= 8; 				} 				pos += numBytesInWord; 				numBytesInWord = 4; 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,getBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--) { 				uint val = data [i]; 				for (int j = numBytesInWord - 1; j >= 0; j--) { 					result [pos+j] = (byte)(val & 0xFF); 					val >>= 8; 				} 				pos += numBytesInWord; 				numBytesInWord = 4; 			}
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10);
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Incr2,The following statement contains a magic number: data [0] += 2;
Magic Number,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Incr2,The following statement contains a magic number: if (data [0] < 2) {  				// Account for the first carry 				data [++i]++;  				// Keep adding until no carry 				while (data [i++] == 0x0) 					data [i]++;  				// See if we increased the data length 				if (length == (uint)i) 					length++; 			}
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Pow,The following statement contains a magic number: if (b != 2) { 					if ((mod.data [0] & 1) == 1) return OddPow (b' exp); 					else return EvenPow (b' exp); 				} else { 					if ((mod.data [0] & 1) == 1) return OddModTwoPow (exp); 					else return EvenModTwoPow (exp); 				}
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddPow,The following statement contains a magic number: uint pos = (uint)exp.bitCount () - 2;
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddPow,The following statement contains a magic number: do { 					// 					// r = r ^ 2 % m 					// 					Kernel.SquarePositive (resultNum' ref wkspace); 					resultNum = Montgomery.Reduce (resultNum' mod' mPrime);  					if (exp.testBit (pos)) {  						// 						// r = r * b % m 						//  						// TODO: Is Unsafe really speeding things up? 						fixed (uint* u = resultNum.data) {  							uint i = 0; 							ulong mc = 0;  							do { 								mc += (ulong)u [i] * (ulong)b; 								u [i] = (uint)mc; 								mc >>= 32; 							} while (++i < resultNum.length);  							if (resultNum.length < mod.length) { 								if (mc != 0) { 									u [i] = (uint)mc; 									resultNum.length++; 									while (resultNum >= mod) 										Kernel.MinusEq (resultNum' mod); 								} 							} else if (mc != 0) {  								// 								// First' we estimate the quotient by dividing 								// the first part of each of the numbers. Then 								// we correct this' if necessary' with a subtraction. 								//  								uint cc = (uint)mc;  								// We would rather have this estimate overshoot' 								// so we add one to the divisor 								uint divEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) / 									(mod.data [mod.length-1] + 1));  								uint t;  								i = 0; 								mc = 0; 								do { 									mc += (ulong)mod.data [i] * (ulong)divEstimate; 									t = u [i]; 									u [i] -= (uint)mc; 									mc >>= 32; 									if (u [i] > t) mc++; 									i++; 								} while (i < resultNum.length); 								cc -= (uint)mc;  								if (cc != 0) {  									uint sc = 0' j = 0; 									uint [] s = mod.data; 									do { 										uint a = s [j]; 										if (((a += sc) < sc) | ((u [j] -= a) > ~a)) sc = 1; 										else sc = 0; 										j++; 									} while (j < resultNum.length); 									cc -= sc; 								} 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} else { 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} 						} 					} 				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddPow,The following statement contains a magic number: do { 					// 					// r = r ^ 2 % m 					// 					Kernel.SquarePositive (resultNum' ref wkspace); 					resultNum = Montgomery.Reduce (resultNum' mod' mPrime);  					if (exp.testBit (pos)) {  						// 						// r = r * b % m 						//  						// TODO: Is Unsafe really speeding things up? 						fixed (uint* u = resultNum.data) {  							uint i = 0; 							ulong mc = 0;  							do { 								mc += (ulong)u [i] * (ulong)b; 								u [i] = (uint)mc; 								mc >>= 32; 							} while (++i < resultNum.length);  							if (resultNum.length < mod.length) { 								if (mc != 0) { 									u [i] = (uint)mc; 									resultNum.length++; 									while (resultNum >= mod) 										Kernel.MinusEq (resultNum' mod); 								} 							} else if (mc != 0) {  								// 								// First' we estimate the quotient by dividing 								// the first part of each of the numbers. Then 								// we correct this' if necessary' with a subtraction. 								//  								uint cc = (uint)mc;  								// We would rather have this estimate overshoot' 								// so we add one to the divisor 								uint divEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) / 									(mod.data [mod.length-1] + 1));  								uint t;  								i = 0; 								mc = 0; 								do { 									mc += (ulong)mod.data [i] * (ulong)divEstimate; 									t = u [i]; 									u [i] -= (uint)mc; 									mc >>= 32; 									if (u [i] > t) mc++; 									i++; 								} while (i < resultNum.length); 								cc -= (uint)mc;  								if (cc != 0) {  									uint sc = 0' j = 0; 									uint [] s = mod.data; 									do { 										uint a = s [j]; 										if (((a += sc) < sc) | ((u [j] -= a) > ~a)) sc = 1; 										else sc = 0; 										j++; 									} while (j < resultNum.length); 									cc -= sc; 								} 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} else { 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} 						} 					} 				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddPow,The following statement contains a magic number: do { 					// 					// r = r ^ 2 % m 					// 					Kernel.SquarePositive (resultNum' ref wkspace); 					resultNum = Montgomery.Reduce (resultNum' mod' mPrime);  					if (exp.testBit (pos)) {  						// 						// r = r * b % m 						//  						// TODO: Is Unsafe really speeding things up? 						fixed (uint* u = resultNum.data) {  							uint i = 0; 							ulong mc = 0;  							do { 								mc += (ulong)u [i] * (ulong)b; 								u [i] = (uint)mc; 								mc >>= 32; 							} while (++i < resultNum.length);  							if (resultNum.length < mod.length) { 								if (mc != 0) { 									u [i] = (uint)mc; 									resultNum.length++; 									while (resultNum >= mod) 										Kernel.MinusEq (resultNum' mod); 								} 							} else if (mc != 0) {  								// 								// First' we estimate the quotient by dividing 								// the first part of each of the numbers. Then 								// we correct this' if necessary' with a subtraction. 								//  								uint cc = (uint)mc;  								// We would rather have this estimate overshoot' 								// so we add one to the divisor 								uint divEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) / 									(mod.data [mod.length-1] + 1));  								uint t;  								i = 0; 								mc = 0; 								do { 									mc += (ulong)mod.data [i] * (ulong)divEstimate; 									t = u [i]; 									u [i] -= (uint)mc; 									mc >>= 32; 									if (u [i] > t) mc++; 									i++; 								} while (i < resultNum.length); 								cc -= (uint)mc;  								if (cc != 0) {  									uint sc = 0' j = 0; 									uint [] s = mod.data; 									do { 										uint a = s [j]; 										if (((a += sc) < sc) | ((u [j] -= a) > ~a)) sc = 1; 										else sc = 0; 										j++; 									} while (j < resultNum.length); 									cc -= sc; 								} 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} else { 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} 						} 					} 				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,EvenPow,The following statement contains a magic number: uint pos = (uint)exp.bitCount () - 2;
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,EvenPow,The following statement contains a magic number: do { 					// 					// r = r ^ 2 % m 					// 					Kernel.SquarePositive (resultNum' ref wkspace); 					if (!(resultNum.length < mod.length)) 						BarrettReduction (resultNum);  					if (exp.testBit (pos)) {  						// 						// r = r * b % m 						//  						// TODO: Is Unsafe really speeding things up? 						fixed (uint* u = resultNum.data) {  							uint i = 0; 							ulong mc = 0;  							do { 								mc += (ulong)u [i] * (ulong)b; 								u [i] = (uint)mc; 								mc >>= 32; 							} while (++i < resultNum.length);  							if (resultNum.length < mod.length) { 								if (mc != 0) { 									u [i] = (uint)mc; 									resultNum.length++; 									while (resultNum >= mod) 										Kernel.MinusEq (resultNum' mod); 								} 							} else if (mc != 0) {  								// 								// First' we estimate the quotient by dividing 								// the first part of each of the numbers. Then 								// we correct this' if necessary' with a subtraction. 								//  								uint cc = (uint)mc;  								// We would rather have this estimate overshoot' 								// so we add one to the divisor 								uint divEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) / 									(mod.data [mod.length-1] + 1));  								uint t;  								i = 0; 								mc = 0; 								do { 									mc += (ulong)mod.data [i] * (ulong)divEstimate; 									t = u [i]; 									u [i] -= (uint)mc; 									mc >>= 32; 									if (u [i] > t) mc++; 									i++; 								} while (i < resultNum.length); 								cc -= (uint)mc;  								if (cc != 0) {  									uint sc = 0' j = 0; 									uint [] s = mod.data; 									do { 										uint a = s [j]; 										if (((a += sc) < sc) | ((u [j] -= a) > ~a)) sc = 1; 										else sc = 0; 										j++; 									} while (j < resultNum.length); 									cc -= sc; 								} 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} else { 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} 						} 					} 				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,EvenPow,The following statement contains a magic number: do { 					// 					// r = r ^ 2 % m 					// 					Kernel.SquarePositive (resultNum' ref wkspace); 					if (!(resultNum.length < mod.length)) 						BarrettReduction (resultNum);  					if (exp.testBit (pos)) {  						// 						// r = r * b % m 						//  						// TODO: Is Unsafe really speeding things up? 						fixed (uint* u = resultNum.data) {  							uint i = 0; 							ulong mc = 0;  							do { 								mc += (ulong)u [i] * (ulong)b; 								u [i] = (uint)mc; 								mc >>= 32; 							} while (++i < resultNum.length);  							if (resultNum.length < mod.length) { 								if (mc != 0) { 									u [i] = (uint)mc; 									resultNum.length++; 									while (resultNum >= mod) 										Kernel.MinusEq (resultNum' mod); 								} 							} else if (mc != 0) {  								// 								// First' we estimate the quotient by dividing 								// the first part of each of the numbers. Then 								// we correct this' if necessary' with a subtraction. 								//  								uint cc = (uint)mc;  								// We would rather have this estimate overshoot' 								// so we add one to the divisor 								uint divEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) / 									(mod.data [mod.length-1] + 1));  								uint t;  								i = 0; 								mc = 0; 								do { 									mc += (ulong)mod.data [i] * (ulong)divEstimate; 									t = u [i]; 									u [i] -= (uint)mc; 									mc >>= 32; 									if (u [i] > t) mc++; 									i++; 								} while (i < resultNum.length); 								cc -= (uint)mc;  								if (cc != 0) {  									uint sc = 0' j = 0; 									uint [] s = mod.data; 									do { 										uint a = s [j]; 										if (((a += sc) < sc) | ((u [j] -= a) > ~a)) sc = 1; 										else sc = 0; 										j++; 									} while (j < resultNum.length); 									cc -= sc; 								} 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} else { 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} 						} 					} 				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,EvenPow,The following statement contains a magic number: do { 					// 					// r = r ^ 2 % m 					// 					Kernel.SquarePositive (resultNum' ref wkspace); 					if (!(resultNum.length < mod.length)) 						BarrettReduction (resultNum);  					if (exp.testBit (pos)) {  						// 						// r = r * b % m 						//  						// TODO: Is Unsafe really speeding things up? 						fixed (uint* u = resultNum.data) {  							uint i = 0; 							ulong mc = 0;  							do { 								mc += (ulong)u [i] * (ulong)b; 								u [i] = (uint)mc; 								mc >>= 32; 							} while (++i < resultNum.length);  							if (resultNum.length < mod.length) { 								if (mc != 0) { 									u [i] = (uint)mc; 									resultNum.length++; 									while (resultNum >= mod) 										Kernel.MinusEq (resultNum' mod); 								} 							} else if (mc != 0) {  								// 								// First' we estimate the quotient by dividing 								// the first part of each of the numbers. Then 								// we correct this' if necessary' with a subtraction. 								//  								uint cc = (uint)mc;  								// We would rather have this estimate overshoot' 								// so we add one to the divisor 								uint divEstimate = (uint) ((((ulong)cc << 32) | (ulong) u [i -1]) / 									(mod.data [mod.length-1] + 1));  								uint t;  								i = 0; 								mc = 0; 								do { 									mc += (ulong)mod.data [i] * (ulong)divEstimate; 									t = u [i]; 									u [i] -= (uint)mc; 									mc >>= 32; 									if (u [i] > t) mc++; 									i++; 								} while (i < resultNum.length); 								cc -= (uint)mc;  								if (cc != 0) {  									uint sc = 0' j = 0; 									uint [] s = mod.data; 									do { 										uint a = s [j]; 										if (((a += sc) < sc) | ((u [j] -= a) > ~a)) sc = 1; 										else sc = 0; 										j++; 									} while (j < resultNum.length); 									cc -= sc; 								} 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} else { 								while (resultNum >= mod) 									Kernel.MinusEq (resultNum' mod); 							} 						} 					} 				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,EvenModTwoPow,The following statement contains a magic number: BigInteger resultNum = new BigInteger (2' mod.length << 1 +1);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,EvenModTwoPow,The following statement contains a magic number: do { 					value = exp.data [wPos]; 					do { 						Kernel.SquarePositive (resultNum' ref wkspace); 						if (resultNum.length >= mod.length) 							BarrettReduction (resultNum);  						if ((value & mask) != 0) { 							// 							// resultNum = (resultNum * 2) % mod 							//  							fixed (uint* u = resultNum.data) { 								// 								// Double 								// 								uint* uu = u; 								uint* uuE = u + resultNum.length; 								uint x' carry = 0; 								while (uu < uuE) { 									x = *uu; 									*uu = (x << 1) | carry; 									carry = x >> (32 - 1); 									uu++; 								}  								// subtraction inlined because we know it is square 								if (carry != 0 || resultNum >= mod) { 									uu = u; 									uint c = 0; 									uint [] s = mod.data; 									uint i = 0; 									do { 										uint a = s [i]; 										if (((a += c) < c) | ((* (uu++) -= a) > ~a)) 											c = 1; 										else 											c = 0; 										i++; 									} while (uu < uuE); 								} 							} 						} 					} while ((mask >>= 1) > 0); 					mask = 0x80000000; 				} while (wPos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddModTwoPow,The following statement contains a magic number: BigInteger resultNum = Montgomery.ToMont ((BigInteger)2' this.mod);
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddModTwoPow,The following statement contains a magic number: uint pos = (uint)exp.bitCount () - 2;
Magic Number,Mono.Math,ModulusRing,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,OddModTwoPow,The following statement contains a magic number: do { 					Kernel.SquarePositive (resultNum' ref wkspace); 					resultNum = Montgomery.Reduce (resultNum' mod' mPrime);  					if (exp.testBit (pos)) { 						// 						// resultNum = (resultNum * 2) % mod 						//  						fixed (uint* u = resultNum.data) { 							// 							// Double 							// 							uint* uu = u; 							uint* uuE = u + resultNum.length; 							uint x' carry = 0; 							while (uu < uuE) { 								x = *uu; 								*uu = (x << 1) | carry; 								carry = x >> (32 - 1); 								uu++; 							}  							// subtraction inlined because we know it is square 							if (carry != 0 || resultNum >= mod) { 								fixed (uint* s = mod.data) { 									uu = u; 									uint c = 0; 									uint* ss = s; 									do { 										uint a = *ss++; 										if (((a += c) < c) | ((* (uu++) -= a) > ~a)) 											c = 1; 										else 											c = 0; 									} while (uu < uuE); 								} 							} 						} 					} 				} while (pos-- > 0);
Magic Number,Mono.Math,Montgomery,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Inverse,The following statement contains a magic number: while ((z = n * y) != 1) 					y *= 2 - z;
Magic Number,Mono.Math,Montgomery,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,ToMont,The following statement contains a magic number: n <<= (int)m.length * 32;
Magic Number,Mono.Math,Montgomery,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Reduce,The following statement contains a magic number: fixed (uint* a = A.data' mm = m.data) { 					for (uint i = 0; i < m.length; i++) { 						// The mod here is taken care of by the CPU' 						// since the multiply will overflow. 						uint u_i = a [0] * mPrime /* % 2^32 */;  						// 						// A += u_i * m; 						// A >>= 32 						//  						// mP = Position in mod 						// aSP = the source of bits from a 						// aDP = destination for bits 						uint* mP = mm' aSP = a' aDP = a;  						ulong c = (ulong)u_i * (ulong)*(mP++) + *(aSP++); 						c >>= 32; 						uint j = 1;  						// Multiply and add 						for (; j < m.length; j++) { 							c += (ulong)u_i * (ulong)*(mP++) + *(aSP++); 							*(aDP++) = (uint)c; 							c >>= 32; 						}  						// Account for carry 						// TODO: use a better loop here' we dont need the ulong stuff 						for (; j < A.length; j++) { 							c += *(aSP++); 							*(aDP++) = (uint)c; 							c >>= 32; 							if (c == 0) {j++; break;} 						} 						// Copy the rest 						for (; j < A.length; j++) { 							*(aDP++) = *(aSP++); 						}  						*(aDP++) = (uint)c; 					}  					while (A.length > 1 && a [A.length-1] == 0) A.length--;  				}
Magic Number,Mono.Math,Montgomery,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Reduce,The following statement contains a magic number: fixed (uint* a = A.data' mm = m.data) { 					for (uint i = 0; i < m.length; i++) { 						// The mod here is taken care of by the CPU' 						// since the multiply will overflow. 						uint u_i = a [0] * mPrime /* % 2^32 */;  						// 						// A += u_i * m; 						// A >>= 32 						//  						// mP = Position in mod 						// aSP = the source of bits from a 						// aDP = destination for bits 						uint* mP = mm' aSP = a' aDP = a;  						ulong c = (ulong)u_i * (ulong)*(mP++) + *(aSP++); 						c >>= 32; 						uint j = 1;  						// Multiply and add 						for (; j < m.length; j++) { 							c += (ulong)u_i * (ulong)*(mP++) + *(aSP++); 							*(aDP++) = (uint)c; 							c >>= 32; 						}  						// Account for carry 						// TODO: use a better loop here' we dont need the ulong stuff 						for (; j < A.length; j++) { 							c += *(aSP++); 							*(aDP++) = (uint)c; 							c >>= 32; 							if (c == 0) {j++; break;} 						} 						// Copy the rest 						for (; j < A.length; j++) { 							*(aDP++) = *(aSP++); 						}  						*(aDP++) = (uint)c; 					}  					while (A.length > 1 && a [A.length-1] == 0) A.length--;  				}
Magic Number,Mono.Math,Montgomery,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Reduce,The following statement contains a magic number: fixed (uint* a = A.data' mm = m.data) { 					for (uint i = 0; i < m.length; i++) { 						// The mod here is taken care of by the CPU' 						// since the multiply will overflow. 						uint u_i = a [0] * mPrime /* % 2^32 */;  						// 						// A += u_i * m; 						// A >>= 32 						//  						// mP = Position in mod 						// aSP = the source of bits from a 						// aDP = destination for bits 						uint* mP = mm' aSP = a' aDP = a;  						ulong c = (ulong)u_i * (ulong)*(mP++) + *(aSP++); 						c >>= 32; 						uint j = 1;  						// Multiply and add 						for (; j < m.length; j++) { 							c += (ulong)u_i * (ulong)*(mP++) + *(aSP++); 							*(aDP++) = (uint)c; 							c >>= 32; 						}  						// Account for carry 						// TODO: use a better loop here' we dont need the ulong stuff 						for (; j < A.length; j++) { 							c += *(aSP++); 							*(aDP++) = (uint)c; 							c >>= 32; 							if (c == 0) {j++; break;} 						} 						// Copy the rest 						for (; j < A.length; j++) { 							*(aDP++) = *(aSP++); 						}  						*(aDP++) = (uint)c; 					}  					while (A.length > 1 && a [A.length-1] == 0) A.length--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,AddSameSign,The following statement contains a magic number: do { 					sum = ((ulong)x [i]) + ((ulong)y [i]) + sum; 					r [i] = (uint)sum; 					sum >>= 32; 				} while (++i < yMax);
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,PlusEq,The following statement contains a magic number: do { 					sum += ((ulong)x [i]) + ((ulong)y [i]); 					r [i] = (uint)sum; 					sum >>= 32; 				} while (++i < yMax);
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,SingleByteDivideInPlace,The following statement contains a magic number: while (i-- > 0) { 					r <<= 32; 					r |= n.data [i]; 					n.data [i] = (uint)(r / d); 					r %= d; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,DwordMod,The following statement contains a magic number: while (i-- > 0) { 					r <<= 32; 					r |= n.data [i]; 					r %= d; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,DwordDiv,The following statement contains a magic number: while (i-- > 0) { 					r <<= 32; 					r |= n.data [i]; 					ret.data [i] = (uint)(r / d); 					r %= d; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,DwordDivMod,The following statement contains a magic number: while (i-- > 0) { 					r <<= 32; 					r |= n.data [i]; 					ret.data [i] = (uint)(r / d); 					r %= d; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: if (Kernel.Compare (bi1' bi2) == Sign.Negative) 					return new BigInteger [2] { 0' new BigInteger (bi1) };
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2.data [bi2.length-2];
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) { 					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];  					ulong q_hat = dividend / (ulong)firstDivisorByte; 					ulong r_hat = dividend % (ulong)firstDivisorByte;  					do {  						if (q_hat == 0x100000000 || 							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) { 							q_hat--; 							r_hat += (ulong)firstDivisorByte;  							if (r_hat < 0x100000000) 								continue; 						} 						break; 					} while (true);  					// 					// At this point' q_hat is either exact' or one too large 					// (more likely to be exact) so' we attempt to multiply the 					// divisor by q_hat' if we get a borrow' we just subtract 					// one from q_hat and add the divisor back. 					//  					uint t; 					uint dPos = 0; 					int nPos = pos - divisorLen + 1; 					ulong mc = 0; 					uint uint_q_hat = (uint)q_hat; 					do { 						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat; 						t = remainder [nPos]; 						remainder [nPos] -= (uint)mc; 						mc >>= 32; 						if (remainder [nPos] > t) mc++; 						dPos++; nPos++; 					} while (dPos < divisorLen);  					nPos = pos - divisorLen + 1; 					dPos = 0;  					// Overestimate 					if (mc != 0) { 						uint_q_hat--; 						ulong sum = 0;  						do { 							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum; 							remainder [nPos] = (uint)sum; 							sum >>= 32; 							dPos++; nPos++; 						} while (dPos < divisorLen);  					}  					quot.data [resultPos--] = (uint)uint_q_hat;  					pos--; 					j--; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) { 					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];  					ulong q_hat = dividend / (ulong)firstDivisorByte; 					ulong r_hat = dividend % (ulong)firstDivisorByte;  					do {  						if (q_hat == 0x100000000 || 							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) { 							q_hat--; 							r_hat += (ulong)firstDivisorByte;  							if (r_hat < 0x100000000) 								continue; 						} 						break; 					} while (true);  					// 					// At this point' q_hat is either exact' or one too large 					// (more likely to be exact) so' we attempt to multiply the 					// divisor by q_hat' if we get a borrow' we just subtract 					// one from q_hat and add the divisor back. 					//  					uint t; 					uint dPos = 0; 					int nPos = pos - divisorLen + 1; 					ulong mc = 0; 					uint uint_q_hat = (uint)q_hat; 					do { 						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat; 						t = remainder [nPos]; 						remainder [nPos] -= (uint)mc; 						mc >>= 32; 						if (remainder [nPos] > t) mc++; 						dPos++; nPos++; 					} while (dPos < divisorLen);  					nPos = pos - divisorLen + 1; 					dPos = 0;  					// Overestimate 					if (mc != 0) { 						uint_q_hat--; 						ulong sum = 0;  						do { 							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum; 							remainder [nPos] = (uint)sum; 							sum >>= 32; 							dPos++; nPos++; 						} while (dPos < divisorLen);  					}  					quot.data [resultPos--] = (uint)uint_q_hat;  					pos--; 					j--; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) { 					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];  					ulong q_hat = dividend / (ulong)firstDivisorByte; 					ulong r_hat = dividend % (ulong)firstDivisorByte;  					do {  						if (q_hat == 0x100000000 || 							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) { 							q_hat--; 							r_hat += (ulong)firstDivisorByte;  							if (r_hat < 0x100000000) 								continue; 						} 						break; 					} while (true);  					// 					// At this point' q_hat is either exact' or one too large 					// (more likely to be exact) so' we attempt to multiply the 					// divisor by q_hat' if we get a borrow' we just subtract 					// one from q_hat and add the divisor back. 					//  					uint t; 					uint dPos = 0; 					int nPos = pos - divisorLen + 1; 					ulong mc = 0; 					uint uint_q_hat = (uint)q_hat; 					do { 						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat; 						t = remainder [nPos]; 						remainder [nPos] -= (uint)mc; 						mc >>= 32; 						if (remainder [nPos] > t) mc++; 						dPos++; nPos++; 					} while (dPos < divisorLen);  					nPos = pos - divisorLen + 1; 					dPos = 0;  					// Overestimate 					if (mc != 0) { 						uint_q_hat--; 						ulong sum = 0;  						do { 							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum; 							remainder [nPos] = (uint)sum; 							sum >>= 32; 							dPos++; nPos++; 						} while (dPos < divisorLen);  					}  					quot.data [resultPos--] = (uint)uint_q_hat;  					pos--; 					j--; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) { 					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];  					ulong q_hat = dividend / (ulong)firstDivisorByte; 					ulong r_hat = dividend % (ulong)firstDivisorByte;  					do {  						if (q_hat == 0x100000000 || 							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) { 							q_hat--; 							r_hat += (ulong)firstDivisorByte;  							if (r_hat < 0x100000000) 								continue; 						} 						break; 					} while (true);  					// 					// At this point' q_hat is either exact' or one too large 					// (more likely to be exact) so' we attempt to multiply the 					// divisor by q_hat' if we get a borrow' we just subtract 					// one from q_hat and add the divisor back. 					//  					uint t; 					uint dPos = 0; 					int nPos = pos - divisorLen + 1; 					ulong mc = 0; 					uint uint_q_hat = (uint)q_hat; 					do { 						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat; 						t = remainder [nPos]; 						remainder [nPos] -= (uint)mc; 						mc >>= 32; 						if (remainder [nPos] > t) mc++; 						dPos++; nPos++; 					} while (dPos < divisorLen);  					nPos = pos - divisorLen + 1; 					dPos = 0;  					// Overestimate 					if (mc != 0) { 						uint_q_hat--; 						ulong sum = 0;  						do { 							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum; 							remainder [nPos] = (uint)sum; 							sum >>= 32; 							dPos++; nPos++; 						} while (dPos < divisorLen);  					}  					quot.data [resultPos--] = (uint)uint_q_hat;  					pos--; 					j--; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) { 					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];  					ulong q_hat = dividend / (ulong)firstDivisorByte; 					ulong r_hat = dividend % (ulong)firstDivisorByte;  					do {  						if (q_hat == 0x100000000 || 							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) { 							q_hat--; 							r_hat += (ulong)firstDivisorByte;  							if (r_hat < 0x100000000) 								continue; 						} 						break; 					} while (true);  					// 					// At this point' q_hat is either exact' or one too large 					// (more likely to be exact) so' we attempt to multiply the 					// divisor by q_hat' if we get a borrow' we just subtract 					// one from q_hat and add the divisor back. 					//  					uint t; 					uint dPos = 0; 					int nPos = pos - divisorLen + 1; 					ulong mc = 0; 					uint uint_q_hat = (uint)q_hat; 					do { 						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat; 						t = remainder [nPos]; 						remainder [nPos] -= (uint)mc; 						mc >>= 32; 						if (remainder [nPos] > t) mc++; 						dPos++; nPos++; 					} while (dPos < divisorLen);  					nPos = pos - divisorLen + 1; 					dPos = 0;  					// Overestimate 					if (mc != 0) { 						uint_q_hat--; 						ulong sum = 0;  						do { 							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum; 							remainder [nPos] = (uint)sum; 							sum >>= 32; 							dPos++; nPos++; 						} while (dPos < divisorLen);  					}  					quot.data [resultPos--] = (uint)uint_q_hat;  					pos--; 					j--; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: BigInteger [] ret = new BigInteger [2] { quot' rem };
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,LeftShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,LeftShift,The following statement contains a magic number: n &= ((1 << 5) - 1);
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,LeftShift,The following statement contains a magic number: if (n != 0) { 					uint x' carry = 0; 					while (i < l) { 						x = bi.data [i]; 						ret.data [i + w] = (x << n) | carry; 						carry = x >> (32 - n); 						i++; 					} 					ret.data [i + w] = carry; 				} else { 					while (i < l) { 						ret.data [i + w] = bi.data [i]; 						i++; 					} 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,RightShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,RightShift,The following statement contains a magic number: int s = n & ((1 << 5) - 1);
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,RightShift,The following statement contains a magic number: if (s != 0) {  					uint x' carry = 0;  					while (l-- > 0) { 						x = bi.data [l + w]; 						ret.data [l] = (x >> n) | carry; 						carry = x << (32 - n); 					} 				} else { 					while (l-- > 0) 						ret.data [l] = bi.data [l + w];  				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,MultiplyByDword,The following statement contains a magic number: do { 					c += (ulong)n.data [i] * (ulong)f; 					ret.data [i] = (uint)c; 					c >>= 32; 				} while (++i < n.length);
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Multiply,The following statement contains a magic number: fixed (uint* xx = x' yy = y' dd = d) { 					uint* xP = xx + xOffset' 						xE = xP + xLen' 						yB = yy + yOffset' 						yE = yB + yLen' 						dB = dd + dOffset;  					for (; xP < xE; xP++' dB++) {  						if (*xP == 0) continue;  						ulong mcarry = 0;  						uint* dP = dB; 						for (uint* yP = yB; yP < yE; yP++' dP++) { 							mcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;  							*dP = (uint)mcarry; 							mcarry >>= 32; 						}  						if (mcarry != 0) 							*dP = (uint)mcarry; 					} 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,MultiplyMod2p32pmod,The following statement contains a magic number: fixed (uint* xx = x' yy = y' dd = d) { 					uint* xP = xx + xOffset' 						xE = xP + xLen' 						yB = yy + yOffest' 						yE = yB + yLen' 						dB = dd + dOffset' 						dE = dB + mod;  					for (; xP < xE; xP++' dB++) {  						if (*xP == 0) continue;  						ulong mcarry = 0; 						uint* dP = dB; 						for (uint* yP = yB; yP < yE && dP < dE; yP++' dP++) { 							mcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;  							*dP = (uint)mcarry; 							mcarry >>= 32; 						}  						if (mcarry != 0 && dP < dE) 							*dP = (uint)mcarry; 					} 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,SquarePositive,The following statement contains a magic number: fixed (uint* dd = d' tt = t) {  					uint* ttE = tt + t.Length; 					// Clear the dest 					for (uint* ttt = tt; ttt < ttE; ttt++) 						*ttt = 0;  					uint* dP = dd' tP = tt;  					for (uint i = 0; i < dl; i++' dP++) { 						if (*dP == 0) 							continue;  						ulong mcarry = 0; 						uint bi1val = *dP;  						uint* dP2 = dP + 1' tP2 = tP + 2*i + 1;  						for (uint j = i + 1; j < dl; j++' tP2++' dP2++) { 							// k = i + j 							mcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;  							*tP2 = (uint)mcarry; 							mcarry >>= 32; 						}  						if (mcarry != 0) 							*tP2 = (uint)mcarry; 					}  					// Double t. Inlined for speed.  					tP = tt;  					uint x' carry = 0; 					while (tP < ttE) { 						x = *tP; 						*tP = (x << 1) | carry; 						carry = x >> (32 - 1); 						tP++; 					} 					if (carry != 0) *tP = carry;  					// Add in the diagnals  					dP = dd; 					tP = tt; 					for (uint* dE = dP + dl; (dP < dE); dP++' tP++) { 						ulong val = (ulong)*dP * (ulong)*dP + *tP; 						*tP = (uint)val; 						val >>= 32; 						*(++tP) += (uint)val; 						if (*tP < (uint)val) { 							uint* tP3 = tP; 							// Account for the first carry 							(*++tP3)++;  							// Keep adding until no carry 							while ((*tP3++) == 0x0) 								(*tP3)++; 						}  					}  					bi.length <<= 1;  					// Normalize length 					while (tt [bi.length-1] == 0 && bi.length > 1) bi.length--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,SquarePositive,The following statement contains a magic number: fixed (uint* dd = d' tt = t) {  					uint* ttE = tt + t.Length; 					// Clear the dest 					for (uint* ttt = tt; ttt < ttE; ttt++) 						*ttt = 0;  					uint* dP = dd' tP = tt;  					for (uint i = 0; i < dl; i++' dP++) { 						if (*dP == 0) 							continue;  						ulong mcarry = 0; 						uint bi1val = *dP;  						uint* dP2 = dP + 1' tP2 = tP + 2*i + 1;  						for (uint j = i + 1; j < dl; j++' tP2++' dP2++) { 							// k = i + j 							mcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;  							*tP2 = (uint)mcarry; 							mcarry >>= 32; 						}  						if (mcarry != 0) 							*tP2 = (uint)mcarry; 					}  					// Double t. Inlined for speed.  					tP = tt;  					uint x' carry = 0; 					while (tP < ttE) { 						x = *tP; 						*tP = (x << 1) | carry; 						carry = x >> (32 - 1); 						tP++; 					} 					if (carry != 0) *tP = carry;  					// Add in the diagnals  					dP = dd; 					tP = tt; 					for (uint* dE = dP + dl; (dP < dE); dP++' tP++) { 						ulong val = (ulong)*dP * (ulong)*dP + *tP; 						*tP = (uint)val; 						val >>= 32; 						*(++tP) += (uint)val; 						if (*tP < (uint)val) { 							uint* tP3 = tP; 							// Account for the first carry 							(*++tP3)++;  							// Keep adding until no carry 							while ((*tP3++) == 0x0) 								(*tP3)++; 						}  					}  					bi.length <<= 1;  					// Normalize length 					while (tt [bi.length-1] == 0 && bi.length > 1) bi.length--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,SquarePositive,The following statement contains a magic number: fixed (uint* dd = d' tt = t) {  					uint* ttE = tt + t.Length; 					// Clear the dest 					for (uint* ttt = tt; ttt < ttE; ttt++) 						*ttt = 0;  					uint* dP = dd' tP = tt;  					for (uint i = 0; i < dl; i++' dP++) { 						if (*dP == 0) 							continue;  						ulong mcarry = 0; 						uint bi1val = *dP;  						uint* dP2 = dP + 1' tP2 = tP + 2*i + 1;  						for (uint j = i + 1; j < dl; j++' tP2++' dP2++) { 							// k = i + j 							mcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;  							*tP2 = (uint)mcarry; 							mcarry >>= 32; 						}  						if (mcarry != 0) 							*tP2 = (uint)mcarry; 					}  					// Double t. Inlined for speed.  					tP = tt;  					uint x' carry = 0; 					while (tP < ttE) { 						x = *tP; 						*tP = (x << 1) | carry; 						carry = x >> (32 - 1); 						tP++; 					} 					if (carry != 0) *tP = carry;  					// Add in the diagnals  					dP = dd; 					tP = tt; 					for (uint* dE = dP + dl; (dP < dE); dP++' tP++) { 						ulong val = (ulong)*dP * (ulong)*dP + *tP; 						*tP = (uint)val; 						val >>= 32; 						*(++tP) += (uint)val; 						if (*tP < (uint)val) { 							uint* tP3 = tP; 							// Account for the first carry 							(*++tP3)++;  							// Keep adding until no carry 							while ((*tP3++) == 0x0) 								(*tP3)++; 						}  					}  					bi.length <<= 1;  					// Normalize length 					while (tt [bi.length-1] == 0 && bi.length > 1) bi.length--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,SquarePositive,The following statement contains a magic number: fixed (uint* dd = d' tt = t) {  					uint* ttE = tt + t.Length; 					// Clear the dest 					for (uint* ttt = tt; ttt < ttE; ttt++) 						*ttt = 0;  					uint* dP = dd' tP = tt;  					for (uint i = 0; i < dl; i++' dP++) { 						if (*dP == 0) 							continue;  						ulong mcarry = 0; 						uint bi1val = *dP;  						uint* dP2 = dP + 1' tP2 = tP + 2*i + 1;  						for (uint j = i + 1; j < dl; j++' tP2++' dP2++) { 							// k = i + j 							mcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;  							*tP2 = (uint)mcarry; 							mcarry >>= 32; 						}  						if (mcarry != 0) 							*tP2 = (uint)mcarry; 					}  					// Double t. Inlined for speed.  					tP = tt;  					uint x' carry = 0; 					while (tP < ttE) { 						x = *tP; 						*tP = (x << 1) | carry; 						carry = x >> (32 - 1); 						tP++; 					} 					if (carry != 0) *tP = carry;  					// Add in the diagnals  					dP = dd; 					tP = tt; 					for (uint* dE = dP + dl; (dP < dE); dP++' tP++) { 						ulong val = (ulong)*dP * (ulong)*dP + *tP; 						*tP = (uint)val; 						val >>= 32; 						*(++tP) += (uint)val; 						if (*tP < (uint)val) { 							uint* tP3 = tP; 							// Account for the first carry 							(*++tP3)++;  							// Keep adding until no carry 							while ((*tP3++) == 0x0) 								(*tP3)++; 						}  					}  					bi.length <<= 1;  					// Normalize length 					while (tt [bi.length-1] == 0 && bi.length > 1) bi.length--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,Double,The following statement contains a magic number: while (i < l) { 					x = u [i]; 					u [i] = (x << 1) | carry; 					carry = x >> (32 - 1); 					i++; 				}
Magic Number,Mono.Math,Kernel,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,modInverse,The following statement contains a magic number: BigInteger [] q = new BigInteger [2];
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27; 			else if (bc <= 150 ) Rounds = 18; 			else if (bc <= 200 ) Rounds = 15; 			else if (bc <= 250 ) Rounds = 12; 			else if (bc <= 300 ) Rounds =  9; 			else if (bc <= 350 ) Rounds =  8; 			else if (bc <= 400 ) Rounds =  7; 			else if (bc <= 500 ) Rounds =  6; 			else if (bc <= 600 ) Rounds =  5; 			else if (bc <= 800 ) Rounds =  4; 			else if (bc <= 1250) Rounds =  3; 			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: switch (confidence) { 				case ConfidenceFactor.ExtraLow: 					Rounds >>= 2; 					return Rounds != 0 ? Rounds : 1; 				case ConfidenceFactor.Low: 					Rounds >>= 1; 					return Rounds != 0 ? Rounds : 1; 				case ConfidenceFactor.Medium: 					return Rounds; 				case ConfidenceFactor.High: 					return Rounds <<= 1; 				case ConfidenceFactor.ExtraHigh: 					return Rounds <<= 2; 				case ConfidenceFactor.Provable: 					throw new Exception ("The Rabin-Miller test can not be executed in a way such that its results are provable"); 				default: 					throw new ArgumentOutOfRangeException ("confidence"); 			}
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: switch (confidence) { 				case ConfidenceFactor.ExtraLow: 					Rounds >>= 2; 					return Rounds != 0 ? Rounds : 1; 				case ConfidenceFactor.Low: 					Rounds >>= 1; 					return Rounds != 0 ? Rounds : 1; 				case ConfidenceFactor.Medium: 					return Rounds; 				case ConfidenceFactor.High: 					return Rounds <<= 1; 				case ConfidenceFactor.ExtraHigh: 					return Rounds <<= 2; 				case ConfidenceFactor.Provable: 					throw new Exception ("The Rabin-Miller test can not be executed in a way such that its results are provable"); 				default: 					throw new ArgumentOutOfRangeException ("confidence"); 			}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,MiniParser,The following statement contains a magic number: twoCharBuff = new int[2];
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Xlat,The following statement contains a magic number: for (;--n >= 0;) { 			ushort code = tbl[p]; 			if (charCode == (code >> 12)) return (code & 0xFFF); 			p++; 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Xml,MiniParser,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\MiniParser.cs,Parse,The following statement contains a magic number: while (true) { 			++this.col; 			int prevCh = currCh;  			currCh = reader.Read();  			if (currCh == -1) { 				if (stateCode != 0) { 					FatalErr("Unexpected EOF"); 				} 				break; 			}  			int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf((char)currCh) & 0xF; 			if (charCode == (int)CharKind.CR) continue; // ignore 			// whitepace ::= (#x20 | #x9 | #xd | #xa)+ 			if (charCode == (int)CharKind.TAB) charCode = (int)CharKind.SPACE; // tab == space 			if (charCode == (int)CharKind.EOL) { 				this.col = 0; 				this.line++; 				charCode = (int)CharKind.SPACE; 			}  			int actionCode = MiniParser.Xlat(charCode' stateCode); 			stateCode = actionCode & 0xFF; 			// Ignore newline inside attribute value. 			if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF)) continue; 			actionCode >>= 8;  			if (stateCode >= 0x80) { 				if (stateCode == 0xFF) { 					FatalErr("State dispatch error."); 				} else { 					FatalErr(errors[stateCode ^ 0x80]); 				} 			}  			switch (actionCode) { 				case (int)ActionCode.START_ELEM: 					handler.OnStartElement(elementName' attrList); 					if (currCh != '/') { 						tagStack.Push(elementName); 					} else { 						handler.OnEndElement(elementName); 					} 					attrList.Clear(); 					break;  				case (int)ActionCode.END_ELEM: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					string endName = null; 					if (tagStack.Count == 0 || 						elementName != (endName = tagStack.Pop() as string)) { 						if (endName == null) { 							FatalErr("Tag stack underflow"); 						} else { 							FatalErr(String.Format("Expected end tag '{0}' but found '{1}'"' elementName' endName)); 						} 					} 					handler.OnEndElement(elementName); 					break;  				case (int)ActionCode.END_NAME: 					elementName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					if (currCh != '/' && currCh != '>') break; 					goto case (int)ActionCode.START_ELEM;  				case (int)ActionCode.SET_ATTR_NAME: 					lastAttrName = sbChars.ToString(); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.SET_ATTR_VAL: 					if (lastAttrName == null) FatalErr("Internal error."); 					attrList.Add(lastAttrName' sbChars.ToString()); 					sbChars = new StringBuilder(); 					lastAttrName = null; 					break;  				case (int)ActionCode.SEND_CHARS: 					handler.OnChars(sbChars.ToString()); 					sbChars = new StringBuilder(); 					break;  				case (int)ActionCode.START_CDATA: 					string cdata = "CDATA["; 					isComment = false; 					isDTD = false;  					if (currCh == '-') { 						currCh = reader.Read();  						if (currCh != '-') FatalErr("Invalid comment");  						this.col++; 						isComment = true; 						twoCharBuff[0] = -1; 						twoCharBuff[1] = -1; 					} else { 						if (currCh != '[') { 							isDTD = true; 							bracketSwitch = 0; 							break; 						}  						for (int i = 0; i < cdata.Length; i++) { 							if (reader.Read() != cdata[i]) { 								this.col += i+1; 								break; 							} 						} 						this.col += cdata.Length; 						seenCData = true; 					} 					break;  				case (int)ActionCode.END_CDATA: 					int n = 0; 					currCh = ']';  					while (currCh == ']') { 						currCh = reader.Read(); 						n++; 					}  					if (currCh != '>') { 						for (int i = 0; i < n; i++) sbChars.Append(']'); 						sbChars.Append((char)currCh); 						stateCode = 0x12; 					} else { 						for (int i = 0; i < n-2; i++) sbChars.Append(']'); 						seenCData = false; 					}  					this.col += n; 					break;  				case (int)ActionCode.ERROR: 					FatalErr(String.Format("Error {0}"' stateCode)); 					break;  				case (int)ActionCode.STATE_CHANGE: 					break;  				case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE: 					sbChars = new StringBuilder(); 					if (currCh != '<') goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE; 					break;  				case (int)ActionCode.ACC_CHARS_STATE_CHANGE: 					sbChars.Append((char)currCh); 					break;  				case (int)ActionCode.ACC_CDATA: 					if (isComment) { 						if (currCh == '>' 							&& twoCharBuff[0] == '-' 							&& twoCharBuff[1] == '-') { 							isComment = false; 							stateCode = 0; 						} else { 							twoCharBuff[0] = twoCharBuff[1]; 							twoCharBuff[1] = currCh; 						} 					} else if (isDTD) { 						if (currCh == '<' || currCh == '>') bracketSwitch ^= 1; 						if (currCh == '>' && bracketSwitch != 0) { 							isDTD = false; 							stateCode = 0; 						} 					} else { 						if (this.splitCData 							&& sbChars.Length > 0 							&& seenCData) { 							handler.OnChars(sbChars.ToString()); 							sbChars = new StringBuilder(); 						} 						seenCData = false; 						sbChars.Append((char)currCh); 					} 					break;  				case (int)ActionCode.PROC_CHAR_REF: 					currCh = reader.Read(); 					int cl = this.col + 1; 					if (currCh == '#') {    // character reference 						int r = 10; 						int chCode = 0; 						int nDigits = 0; 						currCh = reader.Read(); 						cl++;  						if (currCh == 'x') { 							currCh = reader.Read(); 							cl++; 							r=16; 						}  						NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  						while (true) { 							int x = -1; 							if (Char.IsNumber((char)currCh) || "abcdef".IndexOf(Char.ToLower((char)currCh)) != -1) { 								try { 									x = Int32.Parse(new string((char)currCh' 1)' style); 								} catch (FormatException) {x = -1;} 							} 							if (x == -1) break; 							chCode *= r; 							chCode += x; 							nDigits++; 							currCh = reader.Read(); 							cl++; 						}  						if (currCh == ';' && nDigits > 0) { 							sbChars.Append((char)chCode); 						} else { 							FatalErr("Bad char ref"); 						} 					} else { 						// entity reference 						string entityRefChars = "aglmopqstu"; // amp | apos | quot | gt | lt 						string entities = "&'\"><";  						int pos = 0; 						int entIdx = 0xF; 						int pred = 0; 						int predShift = 0;  						int sbLen = sbChars.Length;  						while (true) { 							if (pos != 0xF) pos = entityRefChars.IndexOf((char)currCh) & 0xF; 							if (pos == 0xF) FatalErr(errors[7]); 							sbChars.Append((char)currCh);  							int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F"[pos]; 							int lBr = (path >> 4) & 0xF; 							int rBr = path & 0xF; 							int lPred = path >> 12; 							int rPred = (path >> 8) & 0xF; 							currCh = reader.Read(); 							cl++; 							pos = 0xF; 							if (lBr != 0xF && currCh == entityRefChars[lBr]) { 								if (lPred < 0xE) entIdx = lPred; 								pred = lPred; 								predShift = 12; // left 							} else if (rBr != 0xF && currCh == entityRefChars[rBr]) { 								if (rPred < 0xE) entIdx = rPred; 								pred = rPred; 								predShift = 8; // right 							} else if (currCh == ';') { 								if (entIdx != 0xF 									&& predShift != 0 									&& ((path >> predShift) & 0xF) == 0xE) break; 								continue; // pos == 0xF 							}  							pos=0;  						}  						int l = cl - this.col - 1;  						if ((l > 0 && l < 5) 							&&(StrEquals("amp"' sbChars' sbLen' l) 							|| StrEquals("apos"' sbChars' sbLen' l) 							|| StrEquals("quot"' sbChars' sbLen' l) 							|| StrEquals("lt"' sbChars' sbLen' l) 							|| StrEquals("gt"' sbChars' sbLen' l)) 							) { 								sbChars.Length = sbLen; 								sbChars.Append(entities[entIdx]); 						} else FatalErr(errors[7]); 					}  					this.col = cl; 					break;  				default: 					FatalErr(String.Format("Unexpected action code - {0}."' actionCode)); 					break; 			} 		}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  				// 				// STEP 2.1 Sieve out numbers divisible by the first 9 primes 				// 				if (pMod1 %  3 == 0) goto biNotPrime; 				if (pMod1 %  5 == 0) goto biNotPrime; 				if (pMod1 %  7 == 0) goto biNotPrime; 				if (pMod1 % 11 == 0) goto biNotPrime; 				if (pMod1 % 13 == 0) goto biNotPrime; 				if (pMod1 % 17 == 0) goto biNotPrime; 				if (pMod1 % 19 == 0) goto biNotPrime; 				if (pMod1 % 23 == 0) goto biNotPrime; 				if (pMod1 % 29 == 0) goto biNotPrime;  				// 				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound 				// 				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) { 					if (curVal % SmallPrimes [p] == 0) 						goto biNotPrime; 				}  				// 				// STEP 2.3 Is the potential prime acceptable? 				// 				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;  				// 				// STEP 2.4 Filter out all primes that pass this step with a primality test 				// 				if (PrimalityTest (curVal' Confidence)) return curVal;   				// 				// STEP 2.4 				// 			biNotPrime: 				pMod1 += 2; 				if (pMod1 >= primeProd1) pMod1 -= primeProd1; 				curVal.Incr2 (); 			}
Missing Default,Mono.Math,BigInteger,C:\repos\rackerlabs_openstack-guest-agents-windows-xenserver\src\Rackspace.Cloud.Server.Agent.DiffieHellman\mono\BigInteger.cs,BigInteger,The following switch statement is missing a default case: switch (leftOver) { 			case 1: data [length-1] = (uint)inData [0]; break; 			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break; 			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break; 			}
