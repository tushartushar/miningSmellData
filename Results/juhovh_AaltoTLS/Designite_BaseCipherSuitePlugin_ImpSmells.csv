Implementation smell,Namespace,Class,File,Method,Description
Complex Method,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeSignature,Cyclomatic complexity of the method is 9
Long Parameter List,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,VerifyData,The method has 5 parameters. Parameters: version' data' hashAlgorithm' publicKey' signature
Long Parameter List,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeVector,The method has 5 parameters. Parameters: vector' idx1' length' output' idx2
Complex Conditional,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The conditional expression  "tagSize != 96 && tagSize != 104 && tagSize != 112 && tagSize != 120 && tagSize != 128"  is complex.
Empty Catch Block,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,ImportPrivateKey,The method has an empty catch block.
Magic Number,BaseCipherSuitePlugin,AesBlockCipher,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\AesBlockCipher.cs,AesBlockCipher,The following statement contains a magic number: csp.KeySize = key.Length*8;
Magic Number,BaseCipherSuitePlugin,AesBlockCipher,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\AesBlockCipher.cs,AesBlockCipher,The following statement contains a magic number: csp.BlockSize = BLOCK_SIZE*8;
Magic Number,BaseCipherSuitePlugin,BaseCipherSuitePlugin,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BaseCipherSuitePlugin.cs,GetBulkCipherAlgorithm,The following statement contains a magic number: if (name.Equals("DES_CBC")) {  				return new BulkCipherAlgorithmDES();  			} else if (name.Equals("3DES_EDE_CBC")) {  				return new BulkCipherAlgorithm3DES();  			} else if (name.Equals("AES_128_CBC")) {  				return new BulkCipherAlgorithmAES(128);  			} else if (name.Equals("AES_256_CBC")) {  				return new BulkCipherAlgorithmAES(256);  			} else if (name.Equals("AES_128_GCM")) {  				return new BulkCipherAlgorithmAesGcm(128);  			} else if (name.Equals("AES_256_GCM")) {  				return new BulkCipherAlgorithmAesGcm(256);  			} else {  				return null;  			}
Magic Number,BaseCipherSuitePlugin,BaseCipherSuitePlugin,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BaseCipherSuitePlugin.cs,GetBulkCipherAlgorithm,The following statement contains a magic number: if (name.Equals("DES_CBC")) {  				return new BulkCipherAlgorithmDES();  			} else if (name.Equals("3DES_EDE_CBC")) {  				return new BulkCipherAlgorithm3DES();  			} else if (name.Equals("AES_128_CBC")) {  				return new BulkCipherAlgorithmAES(128);  			} else if (name.Equals("AES_256_CBC")) {  				return new BulkCipherAlgorithmAES(256);  			} else if (name.Equals("AES_128_GCM")) {  				return new BulkCipherAlgorithmAesGcm(128);  			} else if (name.Equals("AES_256_GCM")) {  				return new BulkCipherAlgorithmAesGcm(256);  			} else {  				return null;  			}
Magic Number,BaseCipherSuitePlugin,BaseCipherSuitePlugin,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BaseCipherSuitePlugin.cs,GetBulkCipherAlgorithm,The following statement contains a magic number: if (name.Equals("DES_CBC")) {  				return new BulkCipherAlgorithmDES();  			} else if (name.Equals("3DES_EDE_CBC")) {  				return new BulkCipherAlgorithm3DES();  			} else if (name.Equals("AES_128_CBC")) {  				return new BulkCipherAlgorithmAES(128);  			} else if (name.Equals("AES_256_CBC")) {  				return new BulkCipherAlgorithmAES(256);  			} else if (name.Equals("AES_128_GCM")) {  				return new BulkCipherAlgorithmAesGcm(128);  			} else if (name.Equals("AES_256_GCM")) {  				return new BulkCipherAlgorithmAesGcm(256);  			} else {  				return null;  			}
Magic Number,BaseCipherSuitePlugin,BaseCipherSuitePlugin,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BaseCipherSuitePlugin.cs,GetBulkCipherAlgorithm,The following statement contains a magic number: if (name.Equals("DES_CBC")) {  				return new BulkCipherAlgorithmDES();  			} else if (name.Equals("3DES_EDE_CBC")) {  				return new BulkCipherAlgorithm3DES();  			} else if (name.Equals("AES_128_CBC")) {  				return new BulkCipherAlgorithmAES(128);  			} else if (name.Equals("AES_256_CBC")) {  				return new BulkCipherAlgorithmAES(256);  			} else if (name.Equals("AES_128_GCM")) {  				return new BulkCipherAlgorithmAesGcm(128);  			} else if (name.Equals("AES_256_GCM")) {  				return new BulkCipherAlgorithmAesGcm(256);  			} else {  				return null;  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithm3DES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithm3DES.cs,BulkCipherAlgorithm3DES,The following statement contains a magic number: _csp.KeySize = 192;
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithm3DES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithm3DES.cs,BulkCipherAlgorithm3DES,The following statement contains a magic number: _csp.BlockSize = 64;
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAES.cs,BulkCipherAlgorithmAES,The following statement contains a magic number: if (keySize != 128 && keySize != 192 && keySize != 256) {  				throw new CryptographicException("Invalid AES key size: " + keySize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAES.cs,BulkCipherAlgorithmAES,The following statement contains a magic number: if (keySize != 128 && keySize != 192 && keySize != 256) {  				throw new CryptographicException("Invalid AES key size: " + keySize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAES.cs,BulkCipherAlgorithmAES,The following statement contains a magic number: if (keySize != 128 && keySize != 192 && keySize != 256) {  				throw new CryptographicException("Invalid AES key size: " + keySize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAES.cs,BulkCipherAlgorithmAES,The following statement contains a magic number: _csp.BlockSize = 128;
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAES.cs,CreateEncryptor,The following statement contains a magic number: if (rgbKey.Length != _csp.KeySize/8)  				throw new CryptographicException("rgbKey");
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAES.cs,CreateDecryptor,The following statement contains a magic number: if (rgbKey.Length != _csp.KeySize/8)  				throw new CryptographicException("rgbKey");
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: if (keySize != 128 && keySize != 192 && keySize != 256) {  				throw new CryptographicException("Invalid AES key size: " + keySize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: if (keySize != 128 && keySize != 192 && keySize != 256) {  				throw new CryptographicException("Invalid AES key size: " + keySize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: if (keySize != 128 && keySize != 192 && keySize != 256) {  				throw new CryptographicException("Invalid AES key size: " + keySize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: if (tagSize != 96 && tagSize != 104 && tagSize != 112 && tagSize != 120 && tagSize != 128) {  				throw new CryptographicException("Unsupported tag size: " + tagSize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: if (tagSize != 96 && tagSize != 104 && tagSize != 112 && tagSize != 120 && tagSize != 128) {  				throw new CryptographicException("Unsupported tag size: " + tagSize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: if (tagSize != 96 && tagSize != 104 && tagSize != 112 && tagSize != 120 && tagSize != 128) {  				throw new CryptographicException("Unsupported tag size: " + tagSize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: if (tagSize != 96 && tagSize != 104 && tagSize != 112 && tagSize != 120 && tagSize != 128) {  				throw new CryptographicException("Unsupported tag size: " + tagSize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: if (tagSize != 96 && tagSize != 104 && tagSize != 112 && tagSize != 120 && tagSize != 128) {  				throw new CryptographicException("Unsupported tag size: " + tagSize);  			}
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: _keySize = keySize/8;
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmAesGcm,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmAesGcm.cs,BulkCipherAlgorithmAesGcm,The following statement contains a magic number: _tagSize = tagSize/8;
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmDES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmDES.cs,BulkCipherAlgorithmDES,The following statement contains a magic number: _csp.KeySize = 64;
Magic Number,BaseCipherSuitePlugin,BulkCipherAlgorithmDES,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\BulkCipherAlgorithmDES.cs,BulkCipherAlgorithmDES,The following statement contains a magic number: _csp.BlockSize = 64;
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,GetClientKeys,The following statement contains a magic number: _preMasterSecret = new byte[48];
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,GetClientKeys,The following statement contains a magic number: if (version != ProtocolVersion.SSL3_0) {  				// TLS 1.0 and later require a useless vector length  				ret = new byte[2+encryptedBytes.Length];  				ret[0] = (byte) (encryptedBytes.Length >> 8);  				ret[1] = (byte) (encryptedBytes.Length);  				Buffer.BlockCopy(encryptedBytes' 0' ret' 2' encryptedBytes.Length);  			} else {  				ret = encryptedBytes;  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,GetClientKeys,The following statement contains a magic number: if (version != ProtocolVersion.SSL3_0) {  				// TLS 1.0 and later require a useless vector length  				ret = new byte[2+encryptedBytes.Length];  				ret[0] = (byte) (encryptedBytes.Length >> 8);  				ret[1] = (byte) (encryptedBytes.Length);  				Buffer.BlockCopy(encryptedBytes' 0' ret' 2' encryptedBytes.Length);  			} else {  				ret = encryptedBytes;  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,GetClientKeys,The following statement contains a magic number: if (version != ProtocolVersion.SSL3_0) {  				// TLS 1.0 and later require a useless vector length  				ret = new byte[2+encryptedBytes.Length];  				ret[0] = (byte) (encryptedBytes.Length >> 8);  				ret[1] = (byte) (encryptedBytes.Length);  				Buffer.BlockCopy(encryptedBytes' 0' ret' 2' encryptedBytes.Length);  			} else {  				ret = encryptedBytes;  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,ProcessClientKeys,The following statement contains a magic number: try {  				// TLS 1.0 and later require a useless vector length  				if (version != ProtocolVersion.SSL3_0) {  					if (((data[0] << 8) | data[1]) != data.Length-2) {  						throw new Exception("Client key exchange vector length incorrect");  					}    					// Remove vector length from the data bytes  					byte[] tmpArray = new byte[data.Length-2];  					Buffer.BlockCopy(data' 2' tmpArray' 0' tmpArray.Length);  					data = tmpArray;  				}  			  				data = rsa.Decrypt(data' false);  				if (data.Length != 48) {  					throw new Exception("Invalid premaster secret length");  				}  				if (data[0] != clientVersion.Major || data[1] != clientVersion.Minor) {  					throw new Exception("RSA client key version mismatch");  				}  				_preMasterSecret = data;  			} catch (Exception) {  				// Randomize the pre-master secret in case of an error  				RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();  				_preMasterSecret = new byte[48];  				rngCsp.GetBytes(_preMasterSecret);  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,ProcessClientKeys,The following statement contains a magic number: try {  				// TLS 1.0 and later require a useless vector length  				if (version != ProtocolVersion.SSL3_0) {  					if (((data[0] << 8) | data[1]) != data.Length-2) {  						throw new Exception("Client key exchange vector length incorrect");  					}    					// Remove vector length from the data bytes  					byte[] tmpArray = new byte[data.Length-2];  					Buffer.BlockCopy(data' 2' tmpArray' 0' tmpArray.Length);  					data = tmpArray;  				}  			  				data = rsa.Decrypt(data' false);  				if (data.Length != 48) {  					throw new Exception("Invalid premaster secret length");  				}  				if (data[0] != clientVersion.Major || data[1] != clientVersion.Minor) {  					throw new Exception("RSA client key version mismatch");  				}  				_preMasterSecret = data;  			} catch (Exception) {  				// Randomize the pre-master secret in case of an error  				RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();  				_preMasterSecret = new byte[48];  				rngCsp.GetBytes(_preMasterSecret);  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,ProcessClientKeys,The following statement contains a magic number: try {  				// TLS 1.0 and later require a useless vector length  				if (version != ProtocolVersion.SSL3_0) {  					if (((data[0] << 8) | data[1]) != data.Length-2) {  						throw new Exception("Client key exchange vector length incorrect");  					}    					// Remove vector length from the data bytes  					byte[] tmpArray = new byte[data.Length-2];  					Buffer.BlockCopy(data' 2' tmpArray' 0' tmpArray.Length);  					data = tmpArray;  				}  			  				data = rsa.Decrypt(data' false);  				if (data.Length != 48) {  					throw new Exception("Invalid premaster secret length");  				}  				if (data[0] != clientVersion.Major || data[1] != clientVersion.Minor) {  					throw new Exception("RSA client key version mismatch");  				}  				_preMasterSecret = data;  			} catch (Exception) {  				// Randomize the pre-master secret in case of an error  				RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();  				_preMasterSecret = new byte[48];  				rngCsp.GetBytes(_preMasterSecret);  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,ProcessClientKeys,The following statement contains a magic number: try {  				// TLS 1.0 and later require a useless vector length  				if (version != ProtocolVersion.SSL3_0) {  					if (((data[0] << 8) | data[1]) != data.Length-2) {  						throw new Exception("Client key exchange vector length incorrect");  					}    					// Remove vector length from the data bytes  					byte[] tmpArray = new byte[data.Length-2];  					Buffer.BlockCopy(data' 2' tmpArray' 0' tmpArray.Length);  					data = tmpArray;  				}  			  				data = rsa.Decrypt(data' false);  				if (data.Length != 48) {  					throw new Exception("Invalid premaster secret length");  				}  				if (data[0] != clientVersion.Major || data[1] != clientVersion.Minor) {  					throw new Exception("RSA client key version mismatch");  				}  				_preMasterSecret = data;  			} catch (Exception) {  				// Randomize the pre-master secret in case of an error  				RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();  				_preMasterSecret = new byte[48];  				rngCsp.GetBytes(_preMasterSecret);  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,ProcessClientKeys,The following statement contains a magic number: try {  				// TLS 1.0 and later require a useless vector length  				if (version != ProtocolVersion.SSL3_0) {  					if (((data[0] << 8) | data[1]) != data.Length-2) {  						throw new Exception("Client key exchange vector length incorrect");  					}    					// Remove vector length from the data bytes  					byte[] tmpArray = new byte[data.Length-2];  					Buffer.BlockCopy(data' 2' tmpArray' 0' tmpArray.Length);  					data = tmpArray;  				}  			  				data = rsa.Decrypt(data' false);  				if (data.Length != 48) {  					throw new Exception("Invalid premaster secret length");  				}  				if (data[0] != clientVersion.Major || data[1] != clientVersion.Minor) {  					throw new Exception("RSA client key version mismatch");  				}  				_preMasterSecret = data;  			} catch (Exception) {  				// Randomize the pre-master secret in case of an error  				RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();  				_preMasterSecret = new byte[48];  				rngCsp.GetBytes(_preMasterSecret);  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,ProcessClientKeys,The following statement contains a magic number: try {  				// TLS 1.0 and later require a useless vector length  				if (version != ProtocolVersion.SSL3_0) {  					if (((data[0] << 8) | data[1]) != data.Length-2) {  						throw new Exception("Client key exchange vector length incorrect");  					}    					// Remove vector length from the data bytes  					byte[] tmpArray = new byte[data.Length-2];  					Buffer.BlockCopy(data' 2' tmpArray' 0' tmpArray.Length);  					data = tmpArray;  				}  			  				data = rsa.Decrypt(data' false);  				if (data.Length != 48) {  					throw new Exception("Invalid premaster secret length");  				}  				if (data[0] != clientVersion.Major || data[1] != clientVersion.Minor) {  					throw new Exception("RSA client key version mismatch");  				}  				_preMasterSecret = data;  			} catch (Exception) {  				// Randomize the pre-master secret in case of an error  				RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();  				_preMasterSecret = new byte[48];  				rngCsp.GetBytes(_preMasterSecret);  			}
Magic Number,BaseCipherSuitePlugin,KeyExchangeAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\KeyExchangeAlgorithmRSA.cs,GetMasterSecret,The following statement contains a magic number: return prf.CreateDeriveBytes(_preMasterSecret' "master secret"' seed).GetBytes(48);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\MACAlgorithmSSLv3.cs,HMACSSLv3,The following statement contains a magic number: if (useSHA1) {  				_hashAlgorithm = new SHA1CryptoServiceProvider();  				_padSize = 40;  			} else {  				_hashAlgorithm = new MD5CryptoServiceProvider();  				_padSize = 48;  			}
Magic Number,BaseCipherSuitePlugin,HMACSSLv3,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\MACAlgorithmSSLv3.cs,HMACSSLv3,The following statement contains a magic number: if (useSHA1) {  				_hashAlgorithm = new SHA1CryptoServiceProvider();  				_padSize = 40;  			} else {  				_hashAlgorithm = new MD5CryptoServiceProvider();  				_padSize = 48;  			}
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HMACSSLv3Verify,The following statement contains a magic number: this.HashSizeValue = 288;
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: byte[] pad1 = new byte[48];
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: byte[] pad2 = new byte[48];
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: for (int i=0; i<48; i++) {  				pad1[i] = 0x36;  				pad2[i] = 0x5C;  			}
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: _md5.TransformFinalBlock(pad1' 0' 48);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: _sha1.TransformFinalBlock(pad1' 0' 40);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: _md5.TransformBlock(pad2' 0' 48' pad2' 0);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: _md5.TransformFinalBlock(md5Hash' 0' 16);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: _sha1.TransformBlock(pad2' 0' 40' pad2' 0);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: _sha1.TransformFinalBlock(sha1Hash' 0' 20);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: byte[] verifyData = new byte[36];
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: Buffer.BlockCopy(md5Hash' 0' verifyData' 0' 16);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: Buffer.BlockCopy(sha1Hash' 0' verifyData' 16' 20);
Magic Number,BaseCipherSuitePlugin,HMACSSLv3Verify,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,HashFinal,The following statement contains a magic number: Buffer.BlockCopy(sha1Hash' 0' verifyData' 16' 20);
Magic Number,BaseCipherSuitePlugin,SSLv3DeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,GetBytes,The following statement contains a magic number: while (filled < count) {  				if (filled + _hash.Length < count) {  					/* Copy current hash into results */  					Array.Copy(_hash' 0' ret' filled' _hash.Length);  					filled += _hash.Length;    					/* Calculate the next hash */  					if (_iteration > 26) {  						throw new Exception("SSL3 pseudorandom function can't output more bytes");  					}  					  					byte[] header = new byte[_iteration];  					for (int i=0; i<header.Length; i++) {  						header[i] = (byte)(64 + _iteration);  					}    					_sha1.Initialize();  					_sha1.TransformBlock(header' 0' header.Length' header' 0);  					_sha1.TransformBlock(_secret' 0' _secret.Length' _secret' 0);  					_sha1.TransformFinalBlock(_seed' 0' _seed.Length);  					byte[] sha1Hash = _sha1.Hash;  					  					_md5.Initialize();  					_md5.TransformBlock(_secret' 0' _secret.Length' _secret' 0);  					_md5.TransformFinalBlock(sha1Hash' 0' sha1Hash.Length);  					_hash = _md5.Hash;    					_iteration++;  				} else {  					/* Count how many bytes to consume */  					int consumed = count - filled;    					/* Make a partial copy of the current hash */  					Array.Copy(_hash' 0' ret' filled' consumed);  					filled += consumed;    					/* Remove read bytes from the current hash */  					byte[] tmp = new byte[_hash.Length - consumed];  					Array.Copy(_hash' _hash.Length - tmp.Length' tmp' 0' tmp.Length);  					_hash = tmp;  				}  			}
Magic Number,BaseCipherSuitePlugin,SSLv3DeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionSSLv3.cs,GetBytes,The following statement contains a magic number: while (filled < count) {  				if (filled + _hash.Length < count) {  					/* Copy current hash into results */  					Array.Copy(_hash' 0' ret' filled' _hash.Length);  					filled += _hash.Length;    					/* Calculate the next hash */  					if (_iteration > 26) {  						throw new Exception("SSL3 pseudorandom function can't output more bytes");  					}  					  					byte[] header = new byte[_iteration];  					for (int i=0; i<header.Length; i++) {  						header[i] = (byte)(64 + _iteration);  					}    					_sha1.Initialize();  					_sha1.TransformBlock(header' 0' header.Length' header' 0);  					_sha1.TransformBlock(_secret' 0' _secret.Length' _secret' 0);  					_sha1.TransformFinalBlock(_seed' 0' _seed.Length);  					byte[] sha1Hash = _sha1.Hash;  					  					_md5.Initialize();  					_md5.TransformBlock(_secret' 0' _secret.Length' _secret' 0);  					_md5.TransformFinalBlock(sha1Hash' 0' sha1Hash.Length);  					_hash = _md5.Hash;    					_iteration++;  				} else {  					/* Count how many bytes to consume */  					int consumed = count - filled;    					/* Make a partial copy of the current hash */  					Array.Copy(_hash' 0' ret' filled' consumed);  					filled += consumed;    					/* Remove read bytes from the current hash */  					byte[] tmp = new byte[_hash.Length - consumed];  					Array.Copy(_hash' _hash.Length - tmp.Length' tmp' 0' tmp.Length);  					_hash = tmp;  				}  			}
Magic Number,BaseCipherSuitePlugin,TLSGenericDeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSGeneric.cs,TLSGenericDeriveBytes,The following statement contains a magic number: switch (type) {  			case TLSGenericType.MD5:  				_hmac = new HMACGeneric(secret' "MD5"' 64);  				break;  			case TLSGenericType.SHA1:  				_hmac = new HMACGeneric(secret' "SHA1"' 64);  				break;  			case TLSGenericType.SHA256:  				_hmac = new HMACGeneric(secret' "SHA256"' 64);  				break;  			case TLSGenericType.SHA384:  				_hmac = new HMACGeneric(secret' "SHA384"' 128);  				break;  			case TLSGenericType.SHA512:  				_hmac = new HMACGeneric(secret' "SHA512"' 128);  				break;  			default:  				throw new Exception("Unsupported TLSGenericType");  			}
Magic Number,BaseCipherSuitePlugin,TLSGenericDeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSGeneric.cs,TLSGenericDeriveBytes,The following statement contains a magic number: switch (type) {  			case TLSGenericType.MD5:  				_hmac = new HMACGeneric(secret' "MD5"' 64);  				break;  			case TLSGenericType.SHA1:  				_hmac = new HMACGeneric(secret' "SHA1"' 64);  				break;  			case TLSGenericType.SHA256:  				_hmac = new HMACGeneric(secret' "SHA256"' 64);  				break;  			case TLSGenericType.SHA384:  				_hmac = new HMACGeneric(secret' "SHA384"' 128);  				break;  			case TLSGenericType.SHA512:  				_hmac = new HMACGeneric(secret' "SHA512"' 128);  				break;  			default:  				throw new Exception("Unsupported TLSGenericType");  			}
Magic Number,BaseCipherSuitePlugin,TLSGenericDeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSGeneric.cs,TLSGenericDeriveBytes,The following statement contains a magic number: switch (type) {  			case TLSGenericType.MD5:  				_hmac = new HMACGeneric(secret' "MD5"' 64);  				break;  			case TLSGenericType.SHA1:  				_hmac = new HMACGeneric(secret' "SHA1"' 64);  				break;  			case TLSGenericType.SHA256:  				_hmac = new HMACGeneric(secret' "SHA256"' 64);  				break;  			case TLSGenericType.SHA384:  				_hmac = new HMACGeneric(secret' "SHA384"' 128);  				break;  			case TLSGenericType.SHA512:  				_hmac = new HMACGeneric(secret' "SHA512"' 128);  				break;  			default:  				throw new Exception("Unsupported TLSGenericType");  			}
Magic Number,BaseCipherSuitePlugin,TLSGenericDeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSGeneric.cs,TLSGenericDeriveBytes,The following statement contains a magic number: switch (type) {  			case TLSGenericType.MD5:  				_hmac = new HMACGeneric(secret' "MD5"' 64);  				break;  			case TLSGenericType.SHA1:  				_hmac = new HMACGeneric(secret' "SHA1"' 64);  				break;  			case TLSGenericType.SHA256:  				_hmac = new HMACGeneric(secret' "SHA256"' 64);  				break;  			case TLSGenericType.SHA384:  				_hmac = new HMACGeneric(secret' "SHA384"' 128);  				break;  			case TLSGenericType.SHA512:  				_hmac = new HMACGeneric(secret' "SHA512"' 128);  				break;  			default:  				throw new Exception("Unsupported TLSGenericType");  			}
Magic Number,BaseCipherSuitePlugin,TLSGenericDeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSGeneric.cs,TLSGenericDeriveBytes,The following statement contains a magic number: switch (type) {  			case TLSGenericType.MD5:  				_hmac = new HMACGeneric(secret' "MD5"' 64);  				break;  			case TLSGenericType.SHA1:  				_hmac = new HMACGeneric(secret' "SHA1"' 64);  				break;  			case TLSGenericType.SHA256:  				_hmac = new HMACGeneric(secret' "SHA256"' 64);  				break;  			case TLSGenericType.SHA384:  				_hmac = new HMACGeneric(secret' "SHA384"' 128);  				break;  			case TLSGenericType.SHA512:  				_hmac = new HMACGeneric(secret' "SHA512"' 128);  				break;  			default:  				throw new Exception("Unsupported TLSGenericType");  			}
Magic Number,BaseCipherSuitePlugin,MD5SHA1CryptoServiceProvider,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSv1.cs,MD5SHA1CryptoServiceProvider,The following statement contains a magic number: this.HashSizeValue = 288;
Magic Number,BaseCipherSuitePlugin,MD5SHA1CryptoServiceProvider,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSv1.cs,HashFinal,The following statement contains a magic number: byte[] hash = new byte[36];
Magic Number,BaseCipherSuitePlugin,MD5SHA1CryptoServiceProvider,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSv1.cs,HashFinal,The following statement contains a magic number: Array.Copy(_md5.Hash' 0' hash' 0' 16);
Magic Number,BaseCipherSuitePlugin,MD5SHA1CryptoServiceProvider,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSv1.cs,HashFinal,The following statement contains a magic number: Array.Copy(_sha1.Hash' 0' hash' 16' 20);
Magic Number,BaseCipherSuitePlugin,MD5SHA1CryptoServiceProvider,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSv1.cs,HashFinal,The following statement contains a magic number: Array.Copy(_sha1.Hash' 0' hash' 16' 20);
Magic Number,BaseCipherSuitePlugin,TLSv1DeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSv1.cs,TLSv1DeriveBytes,The following statement contains a magic number: int secretLength = (secret.Length + 1) / 2;
Magic Number,BaseCipherSuitePlugin,TLSv1DeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSv1.cs,GetMD5Bytes,The following statement contains a magic number: while (filled < count) {  				if (filled + _md5Hash.Length < count) {  					/* Copy current hash into results */  					Array.Copy(_md5Hash' 0' ret' filled' _md5Hash.Length);  					filled += _md5Hash.Length;    					/* Calculate the next hash */  					_md5HMAC.Initialize();  					_md5HMAC.TransformBlock(_md5Ai' 0' _md5HMAC.HashSize/8' _md5Ai' 0);  					_md5HMAC.TransformFinalBlock(_seed' 0' _seed.Length);  					_md5Hash = _md5HMAC.Hash;    					_md5HMAC.Initialize();  					_md5Ai = _md5HMAC.ComputeHash(_md5Ai);  				} else {  					/* Count how many bytes to consume */  					int consumed = count - filled;    					/* Make a partial copy of the current hash */  					Array.Copy(_md5Hash' 0' ret' filled' consumed);  					filled += consumed;    					/* Remove read bytes from the current hash */  					byte[] tmp = new byte[_md5Hash.Length - consumed];  					Array.Copy(_md5Hash' _md5Hash.Length - tmp.Length' tmp' 0' tmp.Length);  					_md5Hash = tmp;  				}  			}
Magic Number,BaseCipherSuitePlugin,TLSv1DeriveBytes,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\PseudoRandomFunctionTLSv1.cs,GetSHA1Bytes,The following statement contains a magic number: while (filled < ret.Length) {  				if (filled + _sha1Hash.Length < count) {  					/* Copy current hash into results */  					Array.Copy(_sha1Hash' 0' ret' filled' _sha1Hash.Length);  					filled += _sha1Hash.Length;    					/* Calculate the next hash */  					_sha1HMAC.Initialize();  					_sha1HMAC.TransformBlock(_sha1Ai' 0' _sha1HMAC.HashSize/8' _sha1Ai' 0);  					_sha1HMAC.TransformFinalBlock(_seed' 0' _seed.Length);  					_sha1Hash = _sha1HMAC.Hash;    					_sha1HMAC.Initialize();  					_sha1Ai = _sha1HMAC.ComputeHash(_sha1Ai);  				} else {  					/* Count how many bytes to consume */  					int consumed = count - filled;    					/* Make a partial copy of the current hash */  					Array.Copy(_sha1Hash' 0' ret' filled' consumed);  					filled += consumed;    					/* Remove read bytes from the current hash */  					byte[] tmp = new byte[_sha1Hash.Length - consumed];  					Array.Copy(_sha1Hash' _sha1Hash.Length - tmp.Length' tmp' 0' tmp.Length);  					_sha1Hash = tmp;  				}  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,SupportsHashAlgorithmType,The following statement contains a magic number: if (hashAlgorithm == 2) {  				return true;  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: if (signature.Length > 65526 || (signature.Length%2) != 0) {  				throw new Exception("Invalid signature length");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: if (signature.Length > 65526 || (signature.Length%2) != 0) {  				throw new Exception("Invalid signature length");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int vectorLength = (signature.Length/2 < 128) ? 2+(signature.Length/2) :  			                   (signature.Length/2 < 256) ? 3+(signature.Length/2) :  			                   4+(signature.Length/2);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: byte[] encoded = new byte[2*vectorLength];
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: DEREncodeVector(signature' 0' signature.Length/2' encoded' 1);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: DEREncodeVector(signature' signature.Length/2' signature.Length/2' encoded' vectorLength+1);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: DEREncodeVector(signature' signature.Length/2' signature.Length/2' encoded' vectorLength+1);
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int retLength = (encoded.Length < 128) ? 2+encoded.Length :  			                (encoded.Length < 256) ? 3+encoded.Length :  			                4+encoded.Length;
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int retLength = (encoded.Length < 128) ? 2+encoded.Length :  			                (encoded.Length < 256) ? 3+encoded.Length :  			                4+encoded.Length;
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int retLength = (encoded.Length < 128) ? 2+encoded.Length :  			                (encoded.Length < 256) ? 3+encoded.Length :  			                4+encoded.Length;
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int retLength = (encoded.Length < 128) ? 2+encoded.Length :  			                (encoded.Length < 256) ? 3+encoded.Length :  			                4+encoded.Length;
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeSignature,The following statement contains a magic number: int retLength = (encoded.Length < 128) ? 2+encoded.Length :  			                (encoded.Length < 256) ? 3+encoded.Length :  			                4+encoded.Length;
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeSignature,The following statement contains a magic number: int sigLength = 20;
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeSignature,The following statement contains a magic number: if (data.Length > 65538 || data[0] != 0x30) {  				throw new Exception("Invalid signature");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeSignature,The following statement contains a magic number: byte[] ret = new byte[sigLength*2];
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeVector,The following statement contains a magic number: if (length < 128) {  				output[idx2++] = (byte) length;  			} else if (length < 256) {  				output[idx2++] = 0x81;  				output[idx2++] = (byte) length;  			} else {  				output[idx2++] = 0x82;  				output[idx2++] = (byte) (length >> 8);  				output[idx2++] = (byte) (length);  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeVector,The following statement contains a magic number: if (length < 128) {  				output[idx2++] = (byte) length;  			} else if (length < 256) {  				output[idx2++] = 0x81;  				output[idx2++] = (byte) length;  			} else {  				output[idx2++] = 0x82;  				output[idx2++] = (byte) (length >> 8);  				output[idx2++] = (byte) (length);  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DEREncodeVector,The following statement contains a magic number: if (length < 128) {  				output[idx2++] = (byte) length;  			} else if (length < 256) {  				output[idx2++] = 0x81;  				output[idx2++] = (byte) length;  			} else {  				output[idx2++] = 0x82;  				output[idx2++] = (byte) (length >> 8);  				output[idx2++] = (byte) (length);  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeVector,The following statement contains a magic number: if (input[idx] < 128) {  				length = input[idx];  				consumed = 1+length;  				idx += 1;  			} else if (input[idx] == 0x81) {  				length = input[idx+1];  				consumed = 2+length;  				idx += 2;  			} else if (input[idx] == 0x82) {  				length = (input[idx+1] << 8) | input[idx+2];  				consumed = 3+length;  				idx += 3;  			} else {  				throw new Exception("Unsupported DER vector length");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeVector,The following statement contains a magic number: if (input[idx] < 128) {  				length = input[idx];  				consumed = 1+length;  				idx += 1;  			} else if (input[idx] == 0x81) {  				length = input[idx+1];  				consumed = 2+length;  				idx += 2;  			} else if (input[idx] == 0x82) {  				length = (input[idx+1] << 8) | input[idx+2];  				consumed = 3+length;  				idx += 3;  			} else {  				throw new Exception("Unsupported DER vector length");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeVector,The following statement contains a magic number: if (input[idx] < 128) {  				length = input[idx];  				consumed = 1+length;  				idx += 1;  			} else if (input[idx] == 0x81) {  				length = input[idx+1];  				consumed = 2+length;  				idx += 2;  			} else if (input[idx] == 0x82) {  				length = (input[idx+1] << 8) | input[idx+2];  				consumed = 3+length;  				idx += 3;  			} else {  				throw new Exception("Unsupported DER vector length");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeVector,The following statement contains a magic number: if (input[idx] < 128) {  				length = input[idx];  				consumed = 1+length;  				idx += 1;  			} else if (input[idx] == 0x81) {  				length = input[idx+1];  				consumed = 2+length;  				idx += 2;  			} else if (input[idx] == 0x82) {  				length = (input[idx+1] << 8) | input[idx+2];  				consumed = 3+length;  				idx += 3;  			} else {  				throw new Exception("Unsupported DER vector length");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeVector,The following statement contains a magic number: if (input[idx] < 128) {  				length = input[idx];  				consumed = 1+length;  				idx += 1;  			} else if (input[idx] == 0x81) {  				length = input[idx+1];  				consumed = 2+length;  				idx += 2;  			} else if (input[idx] == 0x82) {  				length = (input[idx+1] << 8) | input[idx+2];  				consumed = 3+length;  				idx += 3;  			} else {  				throw new Exception("Unsupported DER vector length");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeVector,The following statement contains a magic number: if (input[idx] < 128) {  				length = input[idx];  				consumed = 1+length;  				idx += 1;  			} else if (input[idx] == 0x81) {  				length = input[idx+1];  				consumed = 2+length;  				idx += 2;  			} else if (input[idx] == 0x82) {  				length = (input[idx+1] << 8) | input[idx+2];  				consumed = 3+length;  				idx += 3;  			} else {  				throw new Exception("Unsupported DER vector length");  			}
Magic Number,BaseCipherSuitePlugin,SignatureAlgorithmDSA,C:\repos\juhovh_AaltoTLS\Plugins\BaseCipherSuitePlugin\SignatureAlgorithmDSA.cs,DERDecodeVector,The following statement contains a magic number: if (input[idx] < 128) {  				length = input[idx];  				consumed = 1+length;  				idx += 1;  			} else if (input[idx] == 0x81) {  				length = input[idx+1];  				consumed = 2+length;  				idx += 2;  			} else if (input[idx] == 0x82) {  				length = (input[idx+1] << 8) | input[idx+2];  				consumed = 3+length;  				idx += 3;  			} else {  				throw new Exception("Unsupported DER vector length");  			}
