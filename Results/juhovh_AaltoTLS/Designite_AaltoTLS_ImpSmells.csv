Implementation smell,Namespace,Class,File,Method,Description
Complex Method,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,TransformRecordBytes,Cyclomatic complexity of the method is 8
Complex Method,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,SelectCipherSuite,Cyclomatic complexity of the method is 10
Complex Method,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,ProcessClientHello,Cyclomatic complexity of the method is 12
Complex Method,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,EncodeDataBytes,Cyclomatic complexity of the method is 10
Complex Method,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,EncodeDataBytes,Cyclomatic complexity of the method is 10
Long Parameter List,AaltoTLS,TLSStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\TLSStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,AaltoTLS,TLSStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\TLSStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,AaltoTLS,TLSStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\TLSStream.cs,BeginAuthenticateAsClient,The method has 6 parameters. Parameters: targetHost' clientCertificates' enabledSslProtocols' checkCertificateRevocation' asyncCallback' asyncState
Long Parameter List,AaltoTLS,TLSStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\TLSStream.cs,BeginAuthenticateAsServer,The method has 6 parameters. Parameters: serverCertificate' clientCertificateRequired' enabledSslProtocols' checkCertificateRevocation' asyncCallback' asyncState
Long Parameter List,AaltoTLS,TLSStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\TLSStream.cs,DefaultCertificateSelectionCallback,The method has 5 parameters. Parameters: sender' targetHost' localCertificates' remoteCertificate' acceptableIssuers
Long Parameter List,AaltoTLS,SecureSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\SecureSession.cs,BeginSend,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,CreateAEADEncryptor,The method has 7 parameters. Parameters: cipherSuite' record' key' fixedIV' recordIV' seqNum' nonceExplicit
Long Parameter List,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,CreateAEADDecryptor,The method has 5 parameters. Parameters: cipherSuite' record' key' fixedIV' seqNum
Long Parameter List,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,SelectCipherSuite,The method has 8 parameters. Parameters: pluginManager' clientVersion' minVersion' maxVersion' clientSuites' serverSuites' certificateSelectionCallback' availableCertificates
Long Identifier,AaltoTLS,SecurityParameters,C:\repos\juhovh_AaltoTLS\AaltoTLS\SecurityParameters.cs,,The length of the parameter ServerCertificateValidationCallback is 35.
Long Identifier,AaltoTLS,SecurityParameters,C:\repos\juhovh_AaltoTLS\AaltoTLS\SecurityParameters.cs,,The length of the parameter ClientCertificateSelectionCallback is 34.
Long Identifier,AaltoTLS,SecurityParameters,C:\repos\juhovh_AaltoTLS\AaltoTLS\SecurityParameters.cs,,The length of the parameter ServerCertificateSelectionCallback is 34.
Long Identifier,AaltoTLS,TLSStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\TLSStream.cs,TLSStream,The length of the parameter userCertificateValidationCallback is 33.
Long Identifier,AaltoTLS,TLSStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\TLSStream.cs,TLSStream,The length of the parameter userCertificateValidationCallback is 33.
Long Identifier,AaltoTLS,TLSStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\TLSStream.cs,TLSStream,The length of the parameter userCertificateSelectionCallback is 32.
Long Identifier,AaltoTLS.HandshakeLayer,ClientHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ClientHandshakeSession.cs,,The length of the parameter _certificateValidationCallback is 30.
Long Statement,AaltoTLS,SecureSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\SecureSession.cs,ProcessSendHandshakePacket,The length of the statement  "			Record[] records = _handshakePacketizer.ProcessHandshakeMessages(_handshakeSession.NegotiatedVersion' messages' _recordStream.MaximumFragmentLength); " is 149.
Long Statement,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,ProcessOutputRecord,The length of the statement  "				_encryptor = CreateAEADEncryptor(_outputCipherSuite' output' _outputKey' _outputFixedIV' _outputRecordIV' seqNum' out nonceExplicit); " is 133.
Long Statement,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,BeginSend,The length of the statement  "					asyncSendResult.SetComplete(new RecordTooLargeException("Trying to send a too large fragment: " + record.Fragment.Length)); " is 123.
Long Statement,AaltoTLS.HandshakeLayer,ClientHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ClientHandshakeSession.cs,ProcessServerKeyExchange,The length of the statement  "				byte[] signedData = new byte[_connectionState.ClientRandom.Length + _connectionState.ServerRandom.Length + serverKeys.Length]; " is 126.
Long Statement,AaltoTLS.HandshakeLayer,ClientHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ClientHandshakeSession.cs,ProcessServerKeyExchange,The length of the statement  "				Buffer.BlockCopy(_connectionState.ServerRandom' 0' signedData' _connectionState.ClientRandom.Length' _connectionState.ServerRandom.Length); " is 139.
Long Statement,AaltoTLS.HandshakeLayer,ClientHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ClientHandshakeSession.cs,ProcessServerKeyExchange,The length of the statement  "				Buffer.BlockCopy(serverKeys' 0' signedData' _connectionState.ClientRandom.Length + _connectionState.ServerRandom.Length' serverKeys.Length); " is 140.
Long Statement,AaltoTLS.HandshakeLayer,ClientHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ClientHandshakeSession.cs,ProcessLocalChangeCipherSpec,The length of the statement  "				verifyData = _cipherSuite.PseudoRandomFunction.GetBytes(_connectionState.MasterSecret' "client finished"' hash' length); " is 120.
Long Statement,AaltoTLS.HandshakeLayer,ClientHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ClientHandshakeSession.cs,ProcessFinished,The length of the statement  "				ourVerifyData = _cipherSuite.PseudoRandomFunction.GetBytes(_connectionState.MasterSecret' "server finished"' hash' length); " is 123.
Long Statement,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,ProcessClientHello,The length of the statement  "			_cipherSuite = SelectCipherSuite(_pluginManager' _clientVersion' _minVersion' _maxVersion' clientHello.CipherSuites' new List<UInt16>(_supportedCipherSuites)' _certificateSelectionCallback' _availableCertificates); " is 214.
Long Statement,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,ProcessClientHello,The length of the statement  "				byte[] dataToSign = new byte[_connectionState.ClientRandom.Length + _connectionState.ServerRandom.Length + serverKeys.Length]; " is 126.
Long Statement,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,ProcessClientHello,The length of the statement  "				Buffer.BlockCopy(_connectionState.ServerRandom' 0' dataToSign' _connectionState.ClientRandom.Length' _connectionState.ServerRandom.Length); " is 139.
Long Statement,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,ProcessClientHello,The length of the statement  "				Buffer.BlockCopy(serverKeys' 0' dataToSign' _connectionState.ClientRandom.Length + _connectionState.ServerRandom.Length' serverKeys.Length); " is 140.
Long Statement,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,ProcessFinished,The length of the statement  "				ourVerifyData = _cipherSuite.PseudoRandomFunction.GetBytes(_connectionState.MasterSecret' "client finished"' hash' length); " is 123.
Long Statement,AaltoTLS.HandshakeLayer,ServerHandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\ServerHandshakeSession.cs,ProcessLocalChangeCipherSpec,The length of the statement  "				verifyData = _cipherSuite.PseudoRandomFunction.GetBytes(_connectionState.MasterSecret' "server finished"' hash' length); " is 120.
Virtual Method Call from Constructor,AaltoTLS,KeyBlock,C:\repos\juhovh_AaltoTLS\AaltoTLS\KeyBlock.cs,KeyBlock,The constructor "KeyBlock" calls a virtual method "CreateDeriveBytes".
Empty Catch Block,AaltoTLS,SecureSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\SecureSession.cs,ProcessSendFatalAlert,The method has an empty catch block.
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,SetCipherSuite,The following statement contains a magic number: byte[] seed = new byte[64];
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,SetCipherSuite,The following statement contains a magic number: Array.Copy(connectionState.ServerRandom' 0' seed' 0' 32);
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,SetCipherSuite,The following statement contains a magic number: Array.Copy(connectionState.ClientRandom' 0' seed' 32' 32);
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,SetCipherSuite,The following statement contains a magic number: Array.Copy(connectionState.ClientRandom' 0' seed' 32' 32);
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,ProcessOutputRecord,The following statement contains a magic number: if (output.Version.IsUsingDatagrams) {  				if ((_outputSequenceNumber >> 48) != 0) {  					// TODO: need renegotiation' throw Exception?  				}  				seqNum = (((UInt64)_outputEpoch) << 48) | _outputSequenceNumber;  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,ProcessOutputRecord,The following statement contains a magic number: if (output.Version.IsUsingDatagrams) {  				if ((_outputSequenceNumber >> 48) != 0) {  					// TODO: need renegotiation' throw Exception?  				}  				seqNum = (((UInt64)_outputEpoch) << 48) | _outputSequenceNumber;  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,ProcessInputRecord,The following statement contains a magic number: if (input.Version.IsUsingDatagrams) {  				seqNum = (((UInt64)input.Epoch) << 48) | input.SequenceNumber;  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GeneratePadding,The following statement contains a magic number: if (cipherType == BulkCipherAlgorithmType.Block) {  				int blockSize = cipherSuite.BulkCipherAlgorithm.BlockSize;    				// Add the required padding to the end of fragment if necessary'  				// minimum padding 1 bytes' the length byte of padding itself  				int paddingLength = blockSize - (record.Fragment.Length % blockSize);  				if (record.Version.HasVariablePadding) {  					// Add 0-1 additional blocks  					int extra = (new System.Random()).Next(2);  					if (paddingLength + extra*blockSize < 256) {  						paddingLength += extra*blockSize;  					}  				}    				// Add the actual padding bytes here  				byte[] padding = new byte[paddingLength];  				if (record.Version == ProtocolVersion.SSL3_0) {  					RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();  					rngCsp.GetBytes(padding);  					padding[padding.Length-1] = (byte) (padding.Length-1);  				} else {  					for (int i=1; i<=padding.Length; i++) {  						padding[padding.Length-i] = (byte) (padding.Length-1);  					}  				}    				byte[] fragment = new byte[record.Fragment.Length + padding.Length];  				Buffer.BlockCopy(record.Fragment' 0' fragment' 0' record.Fragment.Length);  				Buffer.BlockCopy(padding' 0' fragment' record.Fragment.Length' padding.Length);  				record.Fragment = fragment;  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GeneratePadding,The following statement contains a magic number: if (cipherType == BulkCipherAlgorithmType.Block) {  				int blockSize = cipherSuite.BulkCipherAlgorithm.BlockSize;    				// Add the required padding to the end of fragment if necessary'  				// minimum padding 1 bytes' the length byte of padding itself  				int paddingLength = blockSize - (record.Fragment.Length % blockSize);  				if (record.Version.HasVariablePadding) {  					// Add 0-1 additional blocks  					int extra = (new System.Random()).Next(2);  					if (paddingLength + extra*blockSize < 256) {  						paddingLength += extra*blockSize;  					}  				}    				// Add the actual padding bytes here  				byte[] padding = new byte[paddingLength];  				if (record.Version == ProtocolVersion.SSL3_0) {  					RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();  					rngCsp.GetBytes(padding);  					padding[padding.Length-1] = (byte) (padding.Length-1);  				} else {  					for (int i=1; i<=padding.Length; i++) {  						padding[padding.Length-i] = (byte) (padding.Length-1);  					}  				}    				byte[] fragment = new byte[record.Fragment.Length + padding.Length];  				Buffer.BlockCopy(record.Fragment' 0' fragment' 0' record.Fragment.Length);  				Buffer.BlockCopy(padding' 0' fragment' record.Fragment.Length' padding.Length);  				record.Fragment = fragment;  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,RecordHandler,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\RecordHandler.cs,GetAdditionalBytes,The following statement contains a magic number: if (version == ProtocolVersion.SSL3_0) {  				// With SSL3 should not include version information  				additional = new byte[11];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = (byte) (length >> 8);  				additional[10] = (byte) (length);  			} else {  				// Normal TLS additional bytes to be used  				additional = new byte[13];  				Buffer.BlockCopy(seqData' 0' additional' 0' 8);  				additional[8]  = (byte) (type);  				additional[9]  = version.Major;  				additional[10] = version.Minor;  				additional[11] = (byte) (length >> 8);  				additional[12] = (byte) (length);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,ReadCallback,The following statement contains a magic number: try {  				int readBytes = _innerStream.EndRead(asyncResult);  				if (readBytes == 0) {  					throw new EndOfStreamException("Connection closed while reading TLS record");  				}  				_inputBufferCount += readBytes;  				  				// We require at least 5 bytes of header  				if (_inputBufferCount < 5) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// We require the fragment bytes  				int fragmentLength = (_inputBuffer[3] << 8) | _inputBuffer[4];  				if (5+fragmentLength > _inputBuffer.Length) {  					throw new RecordTooLargeException("Received TLS record fragment size too large");  				} else if (_inputBufferCount < 5+fragmentLength) {  					_innerStream.BeginRead(_inputBuffer'  					                       _inputBufferCount'  					                       5+fragmentLength-_inputBufferCount'  					                       new AsyncCallback(ReadCallback)'  					                       asyncReadResult);  					return;  				}  				  				// Construct the TLSRecord returned as result  				Record record = new Record(_inputBuffer);  				Buffer.BlockCopy(_inputBuffer' 5' record.Fragment' 0' fragmentLength);  				_inputBufferCount = 0;  				  				// Complete the asynchronous read  				FinishReceive(true);  				asyncReadResult.AddRecord(record);  				asyncReadResult.SetComplete();  			} catch (Exception e) {  				FinishReceive(false);  				asyncReadResult.SetComplete(e);  			}
Magic Number,AaltoTLS.RecordLayer,TLSRecordStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\TLSRecordStream.cs,StartReceive,The following statement contains a magic number: lock (_receiveLock) {  				if (_receiving) {  					// Receive in progress' add to queue  					if (asyncReceiveResult != null) {  						_receiveQueue.Add(asyncReceiveResult);  					}  					return;  				}  				  				if (asyncReceiveResult == null && _receiveQueue.Count > 0) {  					// Get first asyncReceiveResult in queue  					asyncReceiveResult = _receiveQueue[0];  					_receiveQueue.Remove(asyncReceiveResult);  				}  				  				if (asyncReceiveResult != null) {  					// Start reading the header  					_innerStream.BeginRead(_inputBuffer' 0' 5' new AsyncCallback(ReadCallback)' asyncReceiveResult);  					_receiving = true;  				}  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: _version = new ProtocolVersion(header[1]' header[2]);
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,Record,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				_epoch = (UInt16) ((header[3] << 8) | header[4]);  				for (int i=0; i<6; i++) {  					_seqNum <<= 8;  					_seqNum |= header[5+i];  				}  				_fragment = new byte[(header[11] << 8) | header[12]];  			} else {  				_fragment = new byte[(header[3] << 8) | header[4]];  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.RecordLayer,Record,C:\repos\juhovh_AaltoTLS\AaltoTLS\RecordLayer\Record.cs,GetBytes,The following statement contains a magic number: if (_version.IsUsingDatagrams) {  				ret = new byte[13+fragment.Length];  				  				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (_epoch >> 8);  				ret[4] = (byte) (_epoch);  				for (int i=0; i<6; i++) {  					ret[5+i] = (byte) (_seqNum >> (5-i));  				}  				ret[11] = (byte) (fragment.Length >> 8);  				ret[12] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 12' fragment.Length);  			} else {  				ret = new byte[5+fragment.Length];    				ret[0] = Type;  				ret[1] = Version.Major;  				ret[2] = Version.Minor;  				ret[3] = (byte) (fragment.Length >> 8);  				ret[4] = (byte) (fragment.Length);  				Array.Copy(fragment' 0' ret' 5' fragment.Length);  			}
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateMasterSecret,The following statement contains a magic number: byte[] seed = new byte[64];
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateMasterSecret,The following statement contains a magic number: Array.Copy(connectionState.ClientRandom' 0' seed' 0' 32);
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateMasterSecret,The following statement contains a magic number: Array.Copy(connectionState.ServerRandom' 0' seed' 32' 32);
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateMasterSecret,The following statement contains a magic number: Array.Copy(connectionState.ServerRandom' 0' seed' 32' 32);
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GetSignatureHashAlgorithm,The following statement contains a magic number: switch (hashAlgorithmType) {  			case 1:  				hashAlgorithm = new MD5CryptoServiceProvider();  				break;  			case 2:  				hashAlgorithm = new SHA1CryptoServiceProvider();  				break;  			case 4:  				hashAlgorithm = new SHA256Managed();  				break;  			case 5:  				hashAlgorithm = new SHA384Managed();  				break;  			case 6:  				hashAlgorithm = new SHA512Managed();  				break;  			default:  				throw new AlertException(AlertDescription.InternalError'  				                         "Unsupported hash algorithm type: " + hashAlgorithmType);  			}
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GetSignatureHashAlgorithm,The following statement contains a magic number: switch (hashAlgorithmType) {  			case 1:  				hashAlgorithm = new MD5CryptoServiceProvider();  				break;  			case 2:  				hashAlgorithm = new SHA1CryptoServiceProvider();  				break;  			case 4:  				hashAlgorithm = new SHA256Managed();  				break;  			case 5:  				hashAlgorithm = new SHA384Managed();  				break;  			case 6:  				hashAlgorithm = new SHA512Managed();  				break;  			default:  				throw new AlertException(AlertDescription.InternalError'  				                         "Unsupported hash algorithm type: " + hashAlgorithmType);  			}
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GetSignatureHashAlgorithm,The following statement contains a magic number: switch (hashAlgorithmType) {  			case 1:  				hashAlgorithm = new MD5CryptoServiceProvider();  				break;  			case 2:  				hashAlgorithm = new SHA1CryptoServiceProvider();  				break;  			case 4:  				hashAlgorithm = new SHA256Managed();  				break;  			case 5:  				hashAlgorithm = new SHA384Managed();  				break;  			case 6:  				hashAlgorithm = new SHA512Managed();  				break;  			default:  				throw new AlertException(AlertDescription.InternalError'  				                         "Unsupported hash algorithm type: " + hashAlgorithmType);  			}
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GetSignatureHashAlgorithm,The following statement contains a magic number: switch (hashAlgorithmType) {  			case 1:  				hashAlgorithm = new MD5CryptoServiceProvider();  				break;  			case 2:  				hashAlgorithm = new SHA1CryptoServiceProvider();  				break;  			case 4:  				hashAlgorithm = new SHA256Managed();  				break;  			case 5:  				hashAlgorithm = new SHA384Managed();  				break;  			case 6:  				hashAlgorithm = new SHA512Managed();  				break;  			default:  				throw new AlertException(AlertDescription.InternalError'  				                         "Unsupported hash algorithm type: " + hashAlgorithmType);  			}
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateSignature,The following statement contains a magic number: if (_version.HasSelectableSighash) {  				// FIXME: Not checked to be same as negotiated' but SHA-1 should be safe  				byte hashAlgorithmType = 2; // SHA-1  				byte signAlgorithmType = sigAlg.SignatureAlgorithmType;  				hashAlgorithm = GetSignatureHashAlgorithm(sigAlg' hashAlgorithmType);  				  				// Update signed parameters  				temp = new byte[signedParams.Length + 2];  				Buffer.BlockCopy(signedParams' 0' temp' 0' signedParams.Length);  				temp[signedParams.Length]   = hashAlgorithmType;  				temp[signedParams.Length+1] = signAlgorithmType;  				signedParams = temp;  			}
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateSignature,The following statement contains a magic number: if (_version.HasSelectableSighash) {  				// FIXME: Not checked to be same as negotiated' but SHA-1 should be safe  				byte hashAlgorithmType = 2; // SHA-1  				byte signAlgorithmType = sigAlg.SignatureAlgorithmType;  				hashAlgorithm = GetSignatureHashAlgorithm(sigAlg' hashAlgorithmType);  				  				// Update signed parameters  				temp = new byte[signedParams.Length + 2];  				Buffer.BlockCopy(signedParams' 0' temp' 0' signedParams.Length);  				temp[signedParams.Length]   = hashAlgorithmType;  				temp[signedParams.Length+1] = signAlgorithmType;  				signedParams = temp;  			}
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateSignature,The following statement contains a magic number: temp = new byte[signedParams.Length + 2 + signature.Length];
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateSignature,The following statement contains a magic number: temp[signedParams.Length]   = (byte) (signature.Length >> 8);
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,GenerateSignature,The following statement contains a magic number: Buffer.BlockCopy(signature' 0' temp' signedParams.Length+2' signature.Length);
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,VerifySignature,The following statement contains a magic number: int len = (signedParams[position] << 8) | signedParams[position+1];
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,VerifySignature,The following statement contains a magic number: if (len != signedParams.Length-position-2) {  				throw new AlertException(AlertDescription.DecodeError'  				                         "Signature length not valid");  			}
Magic Number,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,VerifySignature,The following statement contains a magic number: position += 2;
Magic Number,AaltoTLS.HandshakeLayer,TLSHandshakePacketizer,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\TLSHandshakePacketizer.cs,ProcessHandshakeRecord,The following statement contains a magic number: while (_inputStream.Length-_inputtedBytes >= 4) {  				byte[] inputBuffer = _inputStream.GetBuffer();  				  				int dataLength = (inputBuffer[_inputtedBytes+1] << 16) |  				                 (inputBuffer[_inputtedBytes+2] << 8)  |  				                  inputBuffer[_inputtedBytes+3];  				  				// Check that if we have enough data to read message now  				if (4+dataLength > _inputStream.Length-_inputtedBytes)  					break;  				  				byte[] msgData = new byte[4+dataLength];  				long writePosition = _inputStream.Position;  				  				// Read message data from inputStream  				_inputStream.Position = _inputtedBytes;  				_inputStream.Read(msgData' 0' msgData.Length);  				_inputStream.Position = writePosition;  				_inputtedBytes += msgData.Length;  				  				// Add resulting handshake message to the results  				ret.Add(HandshakeMessage.GetInstance(version' msgData));  			}
Magic Number,AaltoTLS.HandshakeLayer,TLSHandshakePacketizer,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\TLSHandshakePacketizer.cs,ProcessHandshakeRecord,The following statement contains a magic number: while (_inputStream.Length-_inputtedBytes >= 4) {  				byte[] inputBuffer = _inputStream.GetBuffer();  				  				int dataLength = (inputBuffer[_inputtedBytes+1] << 16) |  				                 (inputBuffer[_inputtedBytes+2] << 8)  |  				                  inputBuffer[_inputtedBytes+3];  				  				// Check that if we have enough data to read message now  				if (4+dataLength > _inputStream.Length-_inputtedBytes)  					break;  				  				byte[] msgData = new byte[4+dataLength];  				long writePosition = _inputStream.Position;  				  				// Read message data from inputStream  				_inputStream.Position = _inputtedBytes;  				_inputStream.Read(msgData' 0' msgData.Length);  				_inputStream.Position = writePosition;  				_inputtedBytes += msgData.Length;  				  				// Add resulting handshake message to the results  				ret.Add(HandshakeMessage.GetInstance(version' msgData));  			}
Magic Number,AaltoTLS.HandshakeLayer,TLSHandshakePacketizer,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\TLSHandshakePacketizer.cs,ProcessHandshakeRecord,The following statement contains a magic number: while (_inputStream.Length-_inputtedBytes >= 4) {  				byte[] inputBuffer = _inputStream.GetBuffer();  				  				int dataLength = (inputBuffer[_inputtedBytes+1] << 16) |  				                 (inputBuffer[_inputtedBytes+2] << 8)  |  				                  inputBuffer[_inputtedBytes+3];  				  				// Check that if we have enough data to read message now  				if (4+dataLength > _inputStream.Length-_inputtedBytes)  					break;  				  				byte[] msgData = new byte[4+dataLength];  				long writePosition = _inputStream.Position;  				  				// Read message data from inputStream  				_inputStream.Position = _inputtedBytes;  				_inputStream.Read(msgData' 0' msgData.Length);  				_inputStream.Position = writePosition;  				_inputtedBytes += msgData.Length;  				  				// Add resulting handshake message to the results  				ret.Add(HandshakeMessage.GetInstance(version' msgData));  			}
Magic Number,AaltoTLS.HandshakeLayer,TLSHandshakePacketizer,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\TLSHandshakePacketizer.cs,ProcessHandshakeRecord,The following statement contains a magic number: while (_inputStream.Length-_inputtedBytes >= 4) {  				byte[] inputBuffer = _inputStream.GetBuffer();  				  				int dataLength = (inputBuffer[_inputtedBytes+1] << 16) |  				                 (inputBuffer[_inputtedBytes+2] << 8)  |  				                  inputBuffer[_inputtedBytes+3];  				  				// Check that if we have enough data to read message now  				if (4+dataLength > _inputStream.Length-_inputtedBytes)  					break;  				  				byte[] msgData = new byte[4+dataLength];  				long writePosition = _inputStream.Position;  				  				// Read message data from inputStream  				_inputStream.Position = _inputtedBytes;  				_inputStream.Read(msgData' 0' msgData.Length);  				_inputStream.Position = writePosition;  				_inputtedBytes += msgData.Length;  				  				// Add resulting handshake message to the results  				ret.Add(HandshakeMessage.GetInstance(version' msgData));  			}
Magic Number,AaltoTLS.HandshakeLayer,TLSHandshakePacketizer,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\TLSHandshakePacketizer.cs,ProcessHandshakeRecord,The following statement contains a magic number: while (_inputStream.Length-_inputtedBytes >= 4) {  				byte[] inputBuffer = _inputStream.GetBuffer();  				  				int dataLength = (inputBuffer[_inputtedBytes+1] << 16) |  				                 (inputBuffer[_inputtedBytes+2] << 8)  |  				                  inputBuffer[_inputtedBytes+3];  				  				// Check that if we have enough data to read message now  				if (4+dataLength > _inputStream.Length-_inputtedBytes)  					break;  				  				byte[] msgData = new byte[4+dataLength];  				long writePosition = _inputStream.Position;  				  				// Read message data from inputStream  				_inputStream.Position = _inputtedBytes;  				_inputStream.Read(msgData' 0' msgData.Length);  				_inputStream.Position = writePosition;  				_inputtedBytes += msgData.Length;  				  				// Add resulting handshake message to the results  				ret.Add(HandshakeMessage.GetInstance(version' msgData));  			}
Magic Number,AaltoTLS.HandshakeLayer,TLSHandshakePacketizer,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\TLSHandshakePacketizer.cs,ProcessHandshakeRecord,The following statement contains a magic number: while (_inputStream.Length-_inputtedBytes >= 4) {  				byte[] inputBuffer = _inputStream.GetBuffer();  				  				int dataLength = (inputBuffer[_inputtedBytes+1] << 16) |  				                 (inputBuffer[_inputtedBytes+2] << 8)  |  				                  inputBuffer[_inputtedBytes+3];  				  				// Check that if we have enough data to read message now  				if (4+dataLength > _inputStream.Length-_inputtedBytes)  					break;  				  				byte[] msgData = new byte[4+dataLength];  				long writePosition = _inputStream.Position;  				  				// Read message data from inputStream  				_inputStream.Position = _inputtedBytes;  				_inputStream.Read(msgData' 0' msgData.Length);  				_inputStream.Position = writePosition;  				_inputtedBytes += msgData.Length;  				  				// Add resulting handshake message to the results  				ret.Add(HandshakeMessage.GetInstance(version' msgData));  			}
Magic Number,AaltoTLS.HandshakeLayer,TLSHandshakePacketizer,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\TLSHandshakePacketizer.cs,ProcessHandshakeRecord,The following statement contains a magic number: while (_inputStream.Length-_inputtedBytes >= 4) {  				byte[] inputBuffer = _inputStream.GetBuffer();  				  				int dataLength = (inputBuffer[_inputtedBytes+1] << 16) |  				                 (inputBuffer[_inputtedBytes+2] << 8)  |  				                  inputBuffer[_inputtedBytes+3];  				  				// Check that if we have enough data to read message now  				if (4+dataLength > _inputStream.Length-_inputtedBytes)  					break;  				  				byte[] msgData = new byte[4+dataLength];  				long writePosition = _inputStream.Position;  				  				// Read message data from inputStream  				_inputStream.Position = _inputtedBytes;  				_inputStream.Read(msgData' 0' msgData.Length);  				_inputStream.Position = writePosition;  				_inputtedBytes += msgData.Length;  				  				// Add resulting handshake message to the results  				ret.Add(HandshakeMessage.GetInstance(version' msgData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificate,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificate.cs,EncodeDataBytes,The following statement contains a magic number: foreach (X509Certificate cert in CertificateList) {  				certsLength += 3;  				certsLength += cert.GetRawCertData().Length;  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificate,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificate.cs,DecodeDataBytes,The following statement contains a magic number: while (readBytes<certsLength) {  				int certLength = (int) stream.ReadUInt24();  				byte[] certBytes = stream.ReadBytes(certLength);  				readBytes += 3+certLength;    				CertificateList.Add(new X509Certificate(certBytes));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,EncodeDataBytes,The following statement contains a magic number: if (CertificateTypes.Count > 255) {  				throw new Exception("Number of certificate types too large: " + CertificateTypes.Count);  			} else {  				typesLength = CertificateTypes.Count;  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,EncodeDataBytes,The following statement contains a magic number: if (version.HasSelectableSighash) {  				if (SignatureAndHashAlgorithms.Count > 65535) {  					throw new Exception("Number of sighash values too large: " + SignatureAndHashAlgorithms.Count);  				} else {  					sighashLength = 2*SignatureAndHashAlgorithms.Count;  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,EncodeDataBytes,The following statement contains a magic number: if (version.HasSelectableSighash) {  				if (SignatureAndHashAlgorithms.Count > 65535) {  					throw new Exception("Number of sighash values too large: " + SignatureAndHashAlgorithms.Count);  				} else {  					sighashLength = 2*SignatureAndHashAlgorithms.Count;  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,EncodeDataBytes,The following statement contains a magic number: foreach (string name in CertificateAuthorities) {  				// TODO: Should support punycode as well?  				authsLength += 2;  				authsLength += Encoding.ASCII.GetBytes(name).Length;  				if (authsLength > 65535) {  					throw new Exception("Certificate authorities length too large");  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,EncodeDataBytes,The following statement contains a magic number: foreach (string name in CertificateAuthorities) {  				// TODO: Should support punycode as well?  				authsLength += 2;  				authsLength += Encoding.ASCII.GetBytes(name).Length;  				if (authsLength > 65535) {  					throw new Exception("Certificate authorities length too large");  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,DecodeDataBytes,The following statement contains a magic number: if (version.HasSelectableSighash) {  				int sighashLength = stream.ReadUInt16();  				if ((sighashLength%2) != 0) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "SianatureAndHashAlgorithms length invalid: " + sighashLength);  				}  				  				byte[] sighashData = stream.ReadBytes(sighashLength);  				for (int i=0; i<sighashLength; i+=2) {  					SignatureAndHashAlgorithms.Add((UInt16)((sighashData[i] << 8) | sighashData[i+1]));  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,DecodeDataBytes,The following statement contains a magic number: if (version.HasSelectableSighash) {  				int sighashLength = stream.ReadUInt16();  				if ((sighashLength%2) != 0) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "SianatureAndHashAlgorithms length invalid: " + sighashLength);  				}  				  				byte[] sighashData = stream.ReadBytes(sighashLength);  				for (int i=0; i<sighashLength; i+=2) {  					SignatureAndHashAlgorithms.Add((UInt16)((sighashData[i] << 8) | sighashData[i+1]));  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,DecodeDataBytes,The following statement contains a magic number: if (version.HasSelectableSighash) {  				int sighashLength = stream.ReadUInt16();  				if ((sighashLength%2) != 0) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "SianatureAndHashAlgorithms length invalid: " + sighashLength);  				}  				  				byte[] sighashData = stream.ReadBytes(sighashLength);  				for (int i=0; i<sighashLength; i+=2) {  					SignatureAndHashAlgorithms.Add((UInt16)((sighashData[i] << 8) | sighashData[i+1]));  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,DecodeDataBytes,The following statement contains a magic number: while (position < authData.Length) {  				int authLength = (authData[position] << 8) | authData[position+1];  				position += 2;  				  				if (position > authData.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "Authorities total length doesn't match contents");  				}  				  				string name = Encoding.ASCII.GetString(authData' position' authLength);  				position += authLength;  				  				CertificateAuthorities.Add(name);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeCertificateRequest,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeCertificateRequest.cs,DecodeDataBytes,The following statement contains a magic number: while (position < authData.Length) {  				int authLength = (authData[position] << 8) | authData[position+1];  				position += 2;  				  				if (position > authData.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "Authorities total length doesn't match contents");  				}  				  				string name = Encoding.ASCII.GetString(authData' position' authLength);  				position += authLength;  				  				CertificateAuthorities.Add(name);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,EncodeDataBytes,The following statement contains a magic number: stream.WriteUInt16((UInt16) (2*CipherSuites.Count));
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,EncodeDataBytes,The following statement contains a magic number: if (Extensions.Count > 0) {  				int length = 0;  				foreach (HelloExtension ext in Extensions) {  					if (!ext.SupportsProtocolVersion(ClientVersion))  						continue;  					length += 4 + ext.Data.Length;  				}  				stream.WriteUInt16((UInt16) length);  				foreach (HelloExtension ext in Extensions) {  					if (!ext.SupportsProtocolVersion(ClientVersion))  						continue;  					  					UInt16 type = ext.Type;  					byte[] data = ext.Data;  					  					stream.WriteUInt16(type);  					stream.WriteUInt16((UInt16) data.Length);  					stream.WriteBytes(data);  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,DecodeDataBytes,The following statement contains a magic number: byte[] randomBytes = stream.ReadBytes(32);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,DecodeDataBytes,The following statement contains a magic number: for (int i=0; i<cipherLength; i+=2) {  				CipherSuites.Add(stream.ReadUInt16());  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ClientHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ClientHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ClientHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ClientHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ClientHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeClientHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeClientHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ClientHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: TimeSpan ts = (DateTime.UtcNow - new DateTime(1970' 1' 1' 0' 0' 0' 0));
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: byte[] randomBytes = new byte[28];
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: unix_time |= ((UInt32) data[0]) << 24;
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: unix_time |= ((UInt32) data[1]) << 16;
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: unix_time |= ((UInt32) data[2]) << 8;
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: unix_time |= ((UInt32) data[2]) << 8;
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: unix_time |= (UInt32) data[3];
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: byte[] randomBytes = new byte[28];
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: Array.Copy(data' 4' randomBytes' 0' 28);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,HandshakeRandom,The following statement contains a magic number: Array.Copy(data' 4' randomBytes' 0' 28);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,GetBytes,The following statement contains a magic number: byte[] data = new byte[32];
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,GetBytes,The following statement contains a magic number: data[0] = (byte) ((gmt_unix_time >> 24) & 0xff);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,GetBytes,The following statement contains a magic number: data[1] = (byte) ((gmt_unix_time >> 16) & 0xff);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,GetBytes,The following statement contains a magic number: data[2] = (byte) ((gmt_unix_time >>  8) & 0xff);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,GetBytes,The following statement contains a magic number: data[2] = (byte) ((gmt_unix_time >>  8) & 0xff);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,GetBytes,The following statement contains a magic number: data[3] = (byte) (gmt_unix_time & 0xff);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,GetBytes,The following statement contains a magic number: Array.Copy(random_bytes' 0' data' 4' 28);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeRandom,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeRandom.cs,GetBytes,The following statement contains a magic number: Array.Copy(random_bytes' 0' data' 4' 28);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeServerHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeServerHello.cs,EncodeDataBytes,The following statement contains a magic number: if (Extensions.Count > 0) {  				int length = 0;  				foreach (HelloExtension ext in Extensions) {  					if (!ext.SupportsProtocolVersion(ServerVersion))  						continue;  					length += 4 + ext.Data.Length;  				}  				stream.WriteUInt16((UInt16) length);  				foreach (HelloExtension ext in Extensions) {  					if (!ext.SupportsProtocolVersion(ServerVersion))  						continue;  					  					UInt16 type = ext.Type;  					byte[] data = ext.Data;  					  					stream.WriteUInt16(type);  					stream.WriteUInt16((UInt16) data.Length);  					stream.WriteBytes(data);  				}  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeServerHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeServerHello.cs,DecodeDataBytes,The following statement contains a magic number: byte[] randomBytes = stream.ReadBytes(32);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeServerHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeServerHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ServerHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeServerHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeServerHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ServerHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeServerHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeServerHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ServerHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeServerHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeServerHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ServerHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeServerHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeServerHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ServerHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeServerHello,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeServerHello.cs,DecodeDataBytes,The following statement contains a magic number: while (pos+4 <= extensionList.Length) {  				UInt16 extensionType = (UInt16) ((extensionList[pos] << 8) | extensionList[pos+1]);  				UInt16 extensionDataLength = (UInt16) ((extensionList[pos+2] << 8) | extensionList[pos+3]);  				pos += 4;  				  				if (pos+extensionDataLength > extensionList.Length) {  					throw new AlertException(AlertDescription.IllegalParameter'  					                         "ServerHello extension data length too large: " + extensionDataLength);  				}    				byte[] extensionData = new byte[extensionDataLength];  				Buffer.BlockCopy(extensionList' pos' extensionData' 0' extensionData.Length);  				pos += extensionData.Length;    				Extensions.Add(new HelloExtension(extensionType' extensionData));  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeStream.cs,ReadUInt16,The following statement contains a magic number: try {  				data = _reader.ReadBytes(2);  				if (data.Length != 2) {  					throw new EndOfStreamException();  				}  			} catch (Exception) {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "Error reading UInt16 in HandshakeStream");  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeStream.cs,ReadUInt16,The following statement contains a magic number: try {  				data = _reader.ReadBytes(2);  				if (data.Length != 2) {  					throw new EndOfStreamException();  				}  			} catch (Exception) {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "Error reading UInt16 in HandshakeStream");  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeStream.cs,ReadUInt24,The following statement contains a magic number: try {  				idata = _reader.ReadBytes(3);  				if (idata.Length != 3) {  					throw new EndOfStreamException();  				}  			} catch (Exception) {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "Error reading UInt24 in HandshakeStream");  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeStream.cs,ReadUInt24,The following statement contains a magic number: try {  				idata = _reader.ReadBytes(3);  				if (idata.Length != 3) {  					throw new EndOfStreamException();  				}  			} catch (Exception) {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "Error reading UInt24 in HandshakeStream");  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeStream.cs,ReadUInt24,The following statement contains a magic number: byte[] odata = new byte[4];
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeStream.cs,ReadUInt32,The following statement contains a magic number: try {  				data = _reader.ReadBytes(4);  				if (data.Length != 4) {  					throw new EndOfStreamException();  				}  			} catch (Exception) {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "Error reading UInt24 in HandshakeStream");  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeStream.cs,ReadUInt32,The following statement contains a magic number: try {  				data = _reader.ReadBytes(4);  				if (data.Length != 4) {  					throw new EndOfStreamException();  				}  			} catch (Exception) {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "Error reading UInt24 in HandshakeStream");  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HandshakeStream,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeStream.cs,WriteUInt24,The following statement contains a magic number: _writer.Write(data' 1' 3);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: byte[] data = new byte[2+2*count];
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: byte[] data = new byte[2+2*count];
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: data[0] = (byte)((2*count)>>8);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: data[0] = (byte)((2*count)>>8);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: data[1] = (byte)(2*count);
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: for (int i=0; i<count; i++) {  				data[2+i*2] = (byte)(SupportedSignatureAlgorithms[i]>>8);  				data[2+i*2+1] = (byte)(SupportedSignatureAlgorithms[i]);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: for (int i=0; i<count; i++) {  				data[2+i*2] = (byte)(SupportedSignatureAlgorithms[i]>>8);  				data[2+i*2+1] = (byte)(SupportedSignatureAlgorithms[i]);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: for (int i=0; i<count; i++) {  				data[2+i*2] = (byte)(SupportedSignatureAlgorithms[i]>>8);  				data[2+i*2+1] = (byte)(SupportedSignatureAlgorithms[i]);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: for (int i=0; i<count; i++) {  				data[2+i*2] = (byte)(SupportedSignatureAlgorithms[i]>>8);  				data[2+i*2+1] = (byte)(SupportedSignatureAlgorithms[i]);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,EncodeDataBytes,The following statement contains a magic number: for (int i=0; i<count; i++) {  				data[2+i*2] = (byte)(SupportedSignatureAlgorithms[i]>>8);  				data[2+i*2+1] = (byte)(SupportedSignatureAlgorithms[i]);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: if (data.Length < 2 || (data.Length % 2) != 0)  {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "SignatureAlgorithms extension data length invalid: " + data.Length);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: if (data.Length < 2 || (data.Length % 2) != 0)  {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "SignatureAlgorithms extension data length invalid: " + data.Length);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: int len = (data[0] << 8) | data[1];
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: if (len != data.Length-2) {  				throw new AlertException(AlertDescription.IllegalParameter'  				                         "SignatureAlgorithms extension data invalid");  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: for (int i=0; i<len/2; i++) {  				UInt16 sighash = (UInt16)((data[2+i*2] << 8) | data[2+i*2]);  				SupportedSignatureAlgorithms.Add(sighash);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: for (int i=0; i<len/2; i++) {  				UInt16 sighash = (UInt16)((data[2+i*2] << 8) | data[2+i*2]);  				SupportedSignatureAlgorithms.Add(sighash);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: for (int i=0; i<len/2; i++) {  				UInt16 sighash = (UInt16)((data[2+i*2] << 8) | data[2+i*2]);  				SupportedSignatureAlgorithms.Add(sighash);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: for (int i=0; i<len/2; i++) {  				UInt16 sighash = (UInt16)((data[2+i*2] << 8) | data[2+i*2]);  				SupportedSignatureAlgorithms.Add(sighash);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: for (int i=0; i<len/2; i++) {  				UInt16 sighash = (UInt16)((data[2+i*2] << 8) | data[2+i*2]);  				SupportedSignatureAlgorithms.Add(sighash);  			}
Magic Number,AaltoTLS.HandshakeLayer.Protocol,HelloSignatureAlgorithmsExtension,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HelloSignatureAlgorithmsExtension.cs,DecodeDataBytes,The following statement contains a magic number: for (int i=0; i<len/2; i++) {  				UInt16 sighash = (UInt16)((data[2+i*2] << 8) | data[2+i*2]);  				SupportedSignatureAlgorithms.Add(sighash);  			}
Magic Number,AaltoTLS.Alerts,Alert,C:\repos\juhovh_AaltoTLS\AaltoTLS\Alerts\Alert.cs,Alert,The following statement contains a magic number: if (data.Length == 2) {  				Level = (AlertLevel) data[0];  				Description = (AlertDescription) data[1];  			}
Magic Number,AaltoTLS.Alerts,Alert,C:\repos\juhovh_AaltoTLS\AaltoTLS\Alerts\Alert.cs,GetBytes,The following statement contains a magic number: byte[] ret = new byte[2];
Missing Default,AaltoTLS.HandshakeLayer,HandshakeSession,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\HandshakeSession.cs,ProcessMessage,The following switch statement is missing a default case: switch (message.Type) {  			case HandshakeMessageType.HelloRequest:  				ProcessHelloRequest();  				break;  			case HandshakeMessageType.ClientHello:  				ProcessClientHello((HandshakeClientHello) message);  				break;  			case HandshakeMessageType.ServerHello:  				ProcessServerHello((HandshakeServerHello) message);  				break;  			case HandshakeMessageType.NewSessionTicket:  				ProcessNewSessionTicket(message);  				break;  			case HandshakeMessageType.Certificate:  				ProcessCertificate((HandshakeCertificate) message);  				break;  			case HandshakeMessageType.ServerKeyExchange:  				ProcessServerKeyExchange(message);  				break;  			case HandshakeMessageType.CertificateRequest:  				ProcessCertificateRequest((HandshakeCertificateRequest)message);  				break;  			case HandshakeMessageType.ServerHelloDone:  				ProcessServerHelloDone(message);  				break;  			case HandshakeMessageType.CertificateVerify:  				ProcessCertificateVerify(message);  				break;  			case HandshakeMessageType.ClientKeyExchange:  				ProcessClientKeyExchange(message);  				break;  			case HandshakeMessageType.Finished:  				ProcessFinished(message);  				break;  			}
Missing Default,AaltoTLS.HandshakeLayer.Protocol,HandshakeMessage,C:\repos\juhovh_AaltoTLS\AaltoTLS\HandshakeLayer\Protocol\HandshakeMessage.cs,GetInstance,The following switch statement is missing a default case: switch ((HandshakeMessageType) data[0]) {  			case HandshakeMessageType.HelloRequest:  				ret = new HandshakeMessage(HandshakeMessageType.HelloRequest' version);  				break;  			case HandshakeMessageType.ClientHello:  				ret = new HandshakeClientHello();  				break;  			case HandshakeMessageType.ServerHello:  				ret = new HandshakeServerHello();  				break;  			case HandshakeMessageType.HelloVerifyRequest:  				ret = new HandshakeMessage(HandshakeMessageType.HelloVerifyRequest' version);  				break;  			case HandshakeMessageType.NewSessionTicket:  				ret = new HandshakeMessage(HandshakeMessageType.NewSessionTicket' version);  				break;  			case HandshakeMessageType.Certificate:  				ret = new HandshakeCertificate(version);  				break;  			case HandshakeMessageType.ServerKeyExchange:  				ret = new HandshakeMessage(HandshakeMessageType.ServerKeyExchange' version);  				break;  			case HandshakeMessageType.CertificateRequest:  				ret = new HandshakeCertificateRequest(version);  				break;  			case HandshakeMessageType.ServerHelloDone:  				ret = new HandshakeMessage(HandshakeMessageType.ServerHelloDone' version);  				break;  			case HandshakeMessageType.CertificateVerify:  				ret = new HandshakeMessage(HandshakeMessageType.CertificateVerify' version);  				break;  			case HandshakeMessageType.ClientKeyExchange:  				ret = new HandshakeMessage(HandshakeMessageType.ClientKeyExchange' version);  				break;  			case HandshakeMessageType.Finished:  				ret = new HandshakeMessage(HandshakeMessageType.Finished' version);  				break;  			}
Missing Default,AaltoTLS.Alerts,Alert,C:\repos\juhovh_AaltoTLS\AaltoTLS\Alerts\Alert.cs,ValidateForProtocolVersion,The following switch statement is missing a default case: switch (Description) {  			// Warning alerts that are SSLv3 only  			case AlertDescription.NoCertificate:  				Level = AlertLevel.Warning;  				if (version != ProtocolVersion.SSL3_0)  					Level = AlertLevel.None;  				break;  				  			// Warning alerts supported in all versions  			case AlertDescription.CloseNotify:  				Level = AlertLevel.Warning;  				break;    			// Fatal alerts supported in all versions  			case AlertDescription.UnexpectedMessage:  			case AlertDescription.BadRecordMAC:  			case AlertDescription.DecompressionFailure:  			case AlertDescription.HandshakeFailure:  			case AlertDescription.IllegalParameter:  				Level = AlertLevel.Fatal;  				break;  				  			// Other alerts supported in all versions  			case AlertDescription.BadCertificate:  			case AlertDescription.UnsupportedCertificate:  			case AlertDescription.CertificateRevoked:  			case AlertDescription.CertificateExpired:  			case AlertDescription.CertificateUnknown:  				break;    			// Fatal alerts that are TLS only  			case AlertDescription.UnknownCA:  			case AlertDescription.AccessDenied:  				Level = AlertLevel.Fatal;  				if (version == ProtocolVersion.SSL3_0)  					Description = AlertDescription.CertificateUnknown;  				break;  			case AlertDescription.RecordOverflow:  			case AlertDescription.DecodeError:  			case AlertDescription.DecryptError:  			case AlertDescription.InternalError:  				Level = AlertLevel.Fatal;  				if (version == ProtocolVersion.SSL3_0)  					Description = AlertDescription.IllegalParameter;  				break;  			case AlertDescription.ProtocolVersion:  			case AlertDescription.InsufficientSecurity:  				Level = AlertLevel.Fatal;  				if (version == ProtocolVersion.SSL3_0)  					Description = AlertDescription.HandshakeFailure;  				break;  			  			// Warning alerts that are TLS only  			case AlertDescription.UserCanceled:  			case AlertDescription.NoRenegotiation:  				Level = AlertLevel.Warning;  				if (version == ProtocolVersion.SSL3_0)  					Level = AlertLevel.None;  				break;  			  			// Fatal alerts that are TLSv1.2 only  			case AlertDescription.UnsupportedExtension:  				Level = AlertLevel.Fatal;  				if (version != ProtocolVersion.TLS1_2)  					Description = AlertDescription.IllegalParameter;  				break;  			}
