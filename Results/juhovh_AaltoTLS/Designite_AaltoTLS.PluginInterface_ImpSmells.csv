Implementation smell,Namespace,Class,File,Method,Description
Long Method,AaltoTLS.PluginInterface,CipherSuitePluginManager,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuitePluginManager.cs,GetCipherSuite,The method has 108 lines of code.
Complex Method,AaltoTLS.PluginInterface,CipherSuitePluginManager,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuitePluginManager.cs,GetSupportedCipherSuiteIDs,Cyclomatic complexity of the method is 8
Complex Method,AaltoTLS.PluginInterface,CipherSuitePluginManager,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuitePluginManager.cs,GetCipherSuite,Cyclomatic complexity of the method is 23
Complex Method,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformBlock,Cyclomatic complexity of the method is 11
Complex Method,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformFinalBlock,Cyclomatic complexity of the method is 13
Complex Method,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GaloisMultiply,Cyclomatic complexity of the method is 8
Complex Method,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GHASH,Cyclomatic complexity of the method is 9
Complex Method,AaltoTLS.PluginInterface,GenericCbcModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericCbcModeCryptoTransform.cs,TransformBlock,Cyclomatic complexity of the method is 11
Long Parameter List,AaltoTLS.PluginInterface,NullCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\BulkCipherAlgorithmNull.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,AaltoTLS.PluginInterface,CipherSuiteInfo,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuiteInfo.cs,CipherSuiteInfo,The method has 6 parameters. Parameters: id' csName' kName' sName' cName' macName
Long Parameter List,AaltoTLS.PluginInterface,CipherSuiteInfo,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuiteInfo.cs,CipherSuiteInfo,The method has 7 parameters. Parameters: id' csName' kName' sName' prfName' cName' macName
Long Parameter List,AaltoTLS.PluginInterface,SignatureAlgorithm,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\SignatureAlgorithm.cs,VerifyData,The method has 5 parameters. Parameters: version' data' hashAlgorithm' publicKey' signature
Long Parameter List,AaltoTLS.PluginInterface,SignatureAlgorithmNull,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\SignatureAlgorithmNull.cs,VerifyData,The method has 5 parameters. Parameters: version' data' hashAlgorithm' key' signature
Long Parameter List,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GenericGcmModeCryptoTransform,The method has 5 parameters. Parameters: cipher' forEncryption' iv' additional' tagLength
Long Parameter List,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GHASH,The method has 5 parameters. Parameters: Y0' inputBuffer' inputOffset' inputCount' outputBuffer
Long Parameter List,AaltoTLS.PluginInterface,GenericCbcModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericCbcModeCryptoTransform.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Magic Number,AaltoTLS.PluginInterface,CipherSuitePluginManager,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuitePluginManager.cs,GetSupportedSignatureAndHashAlgorithms,The following statement contains a magic number: foreach (CipherSuitePlugin plugin in _plugins) {  				string[] sigIDs = plugin.SupportedSignatureAlgorithms;  				foreach (string sigID in sigIDs) {  					SignatureAlgorithm sig = plugin.GetSignatureAlgorithm(sigID);  					if (sig == null)  						continue;  					  					byte sigType = sig.SignatureAlgorithmType;  					if (sigType == 0) {  						// Ignore anonymous  						continue;  					}  					  					// TODO: Now scans from sha512 to md5' should be configurable?  					for (byte b=6; b>0; b--) {  						if (!sig.SupportsHashAlgorithmType(b))  							continue;  						sighashes.Add((UInt16)((b << 8) | sigType));  					}  				}  			}
Magic Number,AaltoTLS.PluginInterface,CipherSuitePluginManager,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuitePluginManager.cs,GetSupportedSignatureAndHashAlgorithms,The following statement contains a magic number: foreach (CipherSuitePlugin plugin in _plugins) {  				string[] sigIDs = plugin.SupportedSignatureAlgorithms;  				foreach (string sigID in sigIDs) {  					SignatureAlgorithm sig = plugin.GetSignatureAlgorithm(sigID);  					if (sig == null)  						continue;  					  					byte sigType = sig.SignatureAlgorithmType;  					if (sigType == 0) {  						// Ignore anonymous  						continue;  					}  					  					// TODO: Now scans from sha512 to md5' should be configurable?  					for (byte b=6; b>0; b--) {  						if (!sig.SupportsHashAlgorithmType(b))  							continue;  						sighashes.Add((UInt16)((b << 8) | sigType));  					}  				}  			}
Magic Number,AaltoTLS.PluginInterface,CipherSuitePluginManager,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuitePluginManager.cs,GetCipherSuite,The following statement contains a magic number: if (cipherSuiteInfo == null) {  				Console.WriteLine("CipherSuite ID 0x" + id.ToString("x").PadLeft(2' '0') + " not found");  				return null;  			}
Magic Number,AaltoTLS.PluginInterface,CipherSuitePluginManager,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\CipherSuitePluginManager.cs,GetCipherSuite,The following statement contains a magic number: foreach (CipherSuitePlugin plugin in _plugins) {  				if (cipherSuite.KeyExchangeAlgorithm == null) {  					cipherSuite.KeyExchangeAlgorithm =  						plugin.GetKeyExchangeAlgorithm(cipherSuiteInfo.KeyExchangeAlgorithmName);  				}  				if (cipherSuite.SignatureAlgorithm == null) {  					cipherSuite.SignatureAlgorithm =  						plugin.GetSignatureAlgorithm(cipherSuiteInfo.SignatureAlgorithmName);  				}  				if (cipherSuite.PseudoRandomFunction == null) {  					cipherSuite.PseudoRandomFunction =  						plugin.GetPseudoRandomFunction(prfName);  					  					/* Check that the PRF is valid as per RFC 5246 section 7.4.9 */  					if (cipherSuite.PseudoRandomFunction != null && cipherSuite.PseudoRandomFunction.VerifyDataLength < 12) {  						Console.WriteLine("Invalid PseudoRandomFunction' verify data less than 12' ignored");  						cipherSuite.PseudoRandomFunction = null;  					}  				}  				if (cipherSuite.BulkCipherAlgorithm == null) {  					cipherSuite.BulkCipherAlgorithm =  						plugin.GetBulkCipherAlgorithm(cipherSuiteInfo.BulkCipherAlgorithmName);  				}  				if (cipherSuite.MACAlgorithm == null) {  					cipherSuite.MACAlgorithm =  						plugin.GetMACAlgorithm(macName);  				}  			}
Magic Number,AaltoTLS.PluginInterface,ProtocolVersion,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\ProtocolVersion.cs,ToString,The following statement contains a magic number: if (this == ProtocolVersion.NULL) {  				ret = "NULL";  			} else if (this < ProtocolVersion.TLS1_0) {  				ret = "SSLv" + this.Major + "." + this.Minor;  			} else if (this.Major == 3) {  				ret = "TLSv1." + (this.Minor - 1);  			} else if (!this.IsUsingDatagrams) {  				ret = "TLSv" + (this.Major - 2) + "." + this.Minor;  			} else {  				ret = "DTLSv" + (255 - this.Major) + "." + (255 - this.Minor);  			}
Magic Number,AaltoTLS.PluginInterface,ProtocolVersion,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\ProtocolVersion.cs,ToString,The following statement contains a magic number: if (this == ProtocolVersion.NULL) {  				ret = "NULL";  			} else if (this < ProtocolVersion.TLS1_0) {  				ret = "SSLv" + this.Major + "." + this.Minor;  			} else if (this.Major == 3) {  				ret = "TLSv1." + (this.Minor - 1);  			} else if (!this.IsUsingDatagrams) {  				ret = "TLSv" + (this.Major - 2) + "." + this.Minor;  			} else {  				ret = "DTLSv" + (255 - this.Major) + "." + (255 - this.Minor);  			}
Magic Number,AaltoTLS.PluginInterface,ProtocolVersion,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\ProtocolVersion.cs,ToString,The following statement contains a magic number: if (this == ProtocolVersion.NULL) {  				ret = "NULL";  			} else if (this < ProtocolVersion.TLS1_0) {  				ret = "SSLv" + this.Major + "." + this.Minor;  			} else if (this.Major == 3) {  				ret = "TLSv1." + (this.Minor - 1);  			} else if (!this.IsUsingDatagrams) {  				ret = "TLSv" + (this.Major - 2) + "." + this.Minor;  			} else {  				ret = "DTLSv" + (255 - this.Major) + "." + (255 - this.Minor);  			}
Magic Number,AaltoTLS.PluginInterface,ProtocolVersion,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\ProtocolVersion.cs,ToString,The following statement contains a magic number: if (this == ProtocolVersion.NULL) {  				ret = "NULL";  			} else if (this < ProtocolVersion.TLS1_0) {  				ret = "SSLv" + this.Major + "." + this.Minor;  			} else if (this.Major == 3) {  				ret = "TLSv1." + (this.Minor - 1);  			} else if (!this.IsUsingDatagrams) {  				ret = "TLSv" + (this.Major - 2) + "." + this.Minor;  			} else {  				ret = "DTLSv" + (255 - this.Major) + "." + (255 - this.Minor);  			}
Magic Number,AaltoTLS.PluginInterface,ProtocolVersion,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\ProtocolVersion.cs,GetHashCode,The following statement contains a magic number: return ((this.Major << 8) | this.Minor);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GenericGcmModeCryptoTransform,The following statement contains a magic number: if (tagLength < 12 || tagLength > 16)  				throw new ArgumentException("tagLength " + tagLength);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GenericGcmModeCryptoTransform,The following statement contains a magic number: if (tagLength < 12 || tagLength > 16)  				throw new ArgumentException("tagLength " + tagLength);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GenericGcmModeCryptoTransform,The following statement contains a magic number: if (iv.Length == 12) {  				Buffer.BlockCopy(iv' 0' _J0' 0' 12);  				_J0[_J0.Length-1] = 0x01;  			} else {  				// Construct last hashed block from IV length  				byte[] lengthBytes = BitConverter.GetBytes((UInt64)iv.Length*8);  				if (BitConverter.IsLittleEndian) {  					Array.Reverse(lengthBytes);  				}  				byte[] lastBlock = new byte[BLOCK_SIZE];  				Buffer.BlockCopy(lengthBytes' 0' lastBlock' 8' 8);  				  				// Hash the IV and length block to get J0  				GHASH(iv' _J0);  				GHASH(_J0' lastBlock' 0' lastBlock.Length' _J0);  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GenericGcmModeCryptoTransform,The following statement contains a magic number: if (iv.Length == 12) {  				Buffer.BlockCopy(iv' 0' _J0' 0' 12);  				_J0[_J0.Length-1] = 0x01;  			} else {  				// Construct last hashed block from IV length  				byte[] lengthBytes = BitConverter.GetBytes((UInt64)iv.Length*8);  				if (BitConverter.IsLittleEndian) {  					Array.Reverse(lengthBytes);  				}  				byte[] lastBlock = new byte[BLOCK_SIZE];  				Buffer.BlockCopy(lengthBytes' 0' lastBlock' 8' 8);  				  				// Hash the IV and length block to get J0  				GHASH(iv' _J0);  				GHASH(_J0' lastBlock' 0' lastBlock.Length' _J0);  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GenericGcmModeCryptoTransform,The following statement contains a magic number: if (iv.Length == 12) {  				Buffer.BlockCopy(iv' 0' _J0' 0' 12);  				_J0[_J0.Length-1] = 0x01;  			} else {  				// Construct last hashed block from IV length  				byte[] lengthBytes = BitConverter.GetBytes((UInt64)iv.Length*8);  				if (BitConverter.IsLittleEndian) {  					Array.Reverse(lengthBytes);  				}  				byte[] lastBlock = new byte[BLOCK_SIZE];  				Buffer.BlockCopy(lengthBytes' 0' lastBlock' 8' 8);  				  				// Hash the IV and length block to get J0  				GHASH(iv' _J0);  				GHASH(_J0' lastBlock' 0' lastBlock.Length' _J0);  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GenericGcmModeCryptoTransform,The following statement contains a magic number: if (iv.Length == 12) {  				Buffer.BlockCopy(iv' 0' _J0' 0' 12);  				_J0[_J0.Length-1] = 0x01;  			} else {  				// Construct last hashed block from IV length  				byte[] lengthBytes = BitConverter.GetBytes((UInt64)iv.Length*8);  				if (BitConverter.IsLittleEndian) {  					Array.Reverse(lengthBytes);  				}  				byte[] lastBlock = new byte[BLOCK_SIZE];  				Buffer.BlockCopy(lengthBytes' 0' lastBlock' 8' 8);  				  				// Hash the IV and length block to get J0  				GHASH(iv' _J0);  				GHASH(_J0' lastBlock' 0' lastBlock.Length' _J0);  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GenericGcmModeCryptoTransform,The following statement contains a magic number: if (iv.Length == 12) {  				Buffer.BlockCopy(iv' 0' _J0' 0' 12);  				_J0[_J0.Length-1] = 0x01;  			} else {  				// Construct last hashed block from IV length  				byte[] lengthBytes = BitConverter.GetBytes((UInt64)iv.Length*8);  				if (BitConverter.IsLittleEndian) {  					Array.Reverse(lengthBytes);  				}  				byte[] lastBlock = new byte[BLOCK_SIZE];  				Buffer.BlockCopy(lengthBytes' 0' lastBlock' 8' 8);  				  				// Hash the IV and length block to get J0  				GHASH(iv' _J0);  				GHASH(_J0' lastBlock' 0' lastBlock.Length' _J0);  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,Reset,The following statement contains a magic number: Increment(32' _counter);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformBlock,The following statement contains a magic number: for (int i=0; i<inputCount; i+=BLOCK_SIZE) {  				// Encrypt the next counter to the output buffer  				_cipher.Encrypt(_counter' 0' outputBuffer' outputOffset+i);  				Increment(32' _counter);  				  				// XOR input with the counter and place it in output  				for (int j=0; j<BLOCK_SIZE; j++) {  					outputBuffer[outputOffset+i+j] ^= inputBuffer[inputOffset+i+j];  				}  				  				if (_encrypting) {  					GHASH(_currentS' outputBuffer' outputOffset+i' BLOCK_SIZE' _currentS);  				} else {  					GHASH(_currentS' inputBuffer' inputOffset+i' BLOCK_SIZE' _currentS);  				}  				_ciphertextLength += BLOCK_SIZE;  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformFinalBlock,The following statement contains a magic number: for (int i=0; i<datalen; i+=BLOCK_SIZE) {  				// Encrypt the next counter to the counter block  				byte[] counterBlock = new byte[BLOCK_SIZE];  				_cipher.Encrypt(_counter' 0' counterBlock' 0);  				Increment(32' _counter);  				  				int bytesleft = System.Math.Min(BLOCK_SIZE' datalen-i);  				for (int j=0; j<bytesleft; j++) {  					outputBuffer[i+j] = (byte)(inputBuffer[inputOffset+i+j] ^ counterBlock[j]);  				}  				if (_encrypting) {  					GHASH(_currentS' outputBuffer' i' bytesleft' _currentS);  				} else {  					GHASH(_currentS' inputBuffer' inputOffset+i' bytesleft' _currentS);  				}  				_ciphertextLength += (UInt64)bytesleft;  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformFinalBlock,The following statement contains a magic number: byte[] adLengthBytes = BitConverter.GetBytes((UInt64)_additionalLength*8);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformFinalBlock,The following statement contains a magic number: byte[] cLengthBytes = BitConverter.GetBytes((UInt64)_ciphertextLength*8);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformFinalBlock,The following statement contains a magic number: Buffer.BlockCopy(adLengthBytes' 0' lastBlock' 0' 8);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformFinalBlock,The following statement contains a magic number: Buffer.BlockCopy(cLengthBytes' 0' lastBlock' 8' 8);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,TransformFinalBlock,The following statement contains a magic number: Buffer.BlockCopy(cLengthBytes' 0' lastBlock' 8' 8);
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,Increment,The following statement contains a magic number: if (s%8 != 0 || s/8 > block.Length)  				throw new ArgumentOutOfRangeException("s");
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,Increment,The following statement contains a magic number: if (s%8 != 0 || s/8 > block.Length)  				throw new ArgumentOutOfRangeException("s");
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,Increment,The following statement contains a magic number: for (int i=block.Length-1; i>=block.Length-s/8; i--) {  				block[i] += 1;  				if (block[i] != 0)  					break;  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GaloisMultiply,The following statement contains a magic number: for (int i=0; i<BLOCK_SIZE*8; i++) {  				// Calculate the x_i value  				bool xi = (x[i/8] & (1 << (7-i%8))) != 0;  				if (xi) {  					// Z_i+1 = Z_i ^ V_i  					for (int j=0; j<BLOCK_SIZE; j++) {  						Zi[j] ^= Vi[j];  					}  				}  				  				// Store the value of LSB(V_i)  				bool lsb_Vi = (Vi[BLOCK_SIZE-1] & 1) != 0;  				  				// V_i+1 = V_i >> 1  				for (int j=BLOCK_SIZE-1; j>0; j--) {  					Vi[j] = (byte) ((Vi[j] >> 1) | (Vi[j-1] << 7));  				}  				Vi[0] >>= 1;  				  				// If LSB(V_i) is 1' V_i+1 = (V_i >> 1) ^ R  				if (lsb_Vi) {  					Vi[0] ^= 0xe1;  				}  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GaloisMultiply,The following statement contains a magic number: for (int i=0; i<BLOCK_SIZE*8; i++) {  				// Calculate the x_i value  				bool xi = (x[i/8] & (1 << (7-i%8))) != 0;  				if (xi) {  					// Z_i+1 = Z_i ^ V_i  					for (int j=0; j<BLOCK_SIZE; j++) {  						Zi[j] ^= Vi[j];  					}  				}  				  				// Store the value of LSB(V_i)  				bool lsb_Vi = (Vi[BLOCK_SIZE-1] & 1) != 0;  				  				// V_i+1 = V_i >> 1  				for (int j=BLOCK_SIZE-1; j>0; j--) {  					Vi[j] = (byte) ((Vi[j] >> 1) | (Vi[j-1] << 7));  				}  				Vi[0] >>= 1;  				  				// If LSB(V_i) is 1' V_i+1 = (V_i >> 1) ^ R  				if (lsb_Vi) {  					Vi[0] ^= 0xe1;  				}  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GaloisMultiply,The following statement contains a magic number: for (int i=0; i<BLOCK_SIZE*8; i++) {  				// Calculate the x_i value  				bool xi = (x[i/8] & (1 << (7-i%8))) != 0;  				if (xi) {  					// Z_i+1 = Z_i ^ V_i  					for (int j=0; j<BLOCK_SIZE; j++) {  						Zi[j] ^= Vi[j];  					}  				}  				  				// Store the value of LSB(V_i)  				bool lsb_Vi = (Vi[BLOCK_SIZE-1] & 1) != 0;  				  				// V_i+1 = V_i >> 1  				for (int j=BLOCK_SIZE-1; j>0; j--) {  					Vi[j] = (byte) ((Vi[j] >> 1) | (Vi[j-1] << 7));  				}  				Vi[0] >>= 1;  				  				// If LSB(V_i) is 1' V_i+1 = (V_i >> 1) ^ R  				if (lsb_Vi) {  					Vi[0] ^= 0xe1;  				}  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GaloisMultiply,The following statement contains a magic number: for (int i=0; i<BLOCK_SIZE*8; i++) {  				// Calculate the x_i value  				bool xi = (x[i/8] & (1 << (7-i%8))) != 0;  				if (xi) {  					// Z_i+1 = Z_i ^ V_i  					for (int j=0; j<BLOCK_SIZE; j++) {  						Zi[j] ^= Vi[j];  					}  				}  				  				// Store the value of LSB(V_i)  				bool lsb_Vi = (Vi[BLOCK_SIZE-1] & 1) != 0;  				  				// V_i+1 = V_i >> 1  				for (int j=BLOCK_SIZE-1; j>0; j--) {  					Vi[j] = (byte) ((Vi[j] >> 1) | (Vi[j-1] << 7));  				}  				Vi[0] >>= 1;  				  				// If LSB(V_i) is 1' V_i+1 = (V_i >> 1) ^ R  				if (lsb_Vi) {  					Vi[0] ^= 0xe1;  				}  			}
Magic Number,AaltoTLS.PluginInterface,GenericGcmModeCryptoTransform,C:\repos\juhovh_AaltoTLS\AaltoTLS.PluginInterface\CipherSuitePluginInterface\GenericGcmModeCryptoTransform.cs,GaloisMultiply,The following statement contains a magic number: for (int i=0; i<BLOCK_SIZE*8; i++) {  				// Calculate the x_i value  				bool xi = (x[i/8] & (1 << (7-i%8))) != 0;  				if (xi) {  					// Z_i+1 = Z_i ^ V_i  					for (int j=0; j<BLOCK_SIZE; j++) {  						Zi[j] ^= Vi[j];  					}  				}  				  				// Store the value of LSB(V_i)  				bool lsb_Vi = (Vi[BLOCK_SIZE-1] & 1) != 0;  				  				// V_i+1 = V_i >> 1  				for (int j=BLOCK_SIZE-1; j>0; j--) {  					Vi[j] = (byte) ((Vi[j] >> 1) | (Vi[j-1] << 7));  				}  				Vi[0] >>= 1;  				  				// If LSB(V_i) is 1' V_i+1 = (V_i >> 1) ^ R  				if (lsb_Vi) {  					Vi[0] ^= 0xe1;  				}  			}
