Implementation smell,Namespace,Class,File,Method,Description
Complex Method,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 10
Complex Method,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Parse,Cyclomatic complexity of the method is 14
Complex Method,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,DivRem,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GreatestCommonDivisor,Cyclomatic complexity of the method is 12
Complex Method,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Log,Cyclomatic complexity of the method is 9
Long Parameter List,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,VerifyData,The method has 5 parameters. Parameters: version' data' hashAlgorithm' publicKey' signature
Complex Conditional,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The conditional expression  "sign == 1 && radix > 10 && (last < '0' || last > '9')"  is complex.
Complex Conditional,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Log,The conditional expression  "value.sign == -1 || baseValue == 1.0d || baseValue == -1.0d ||  					baseValue == Double.NegativeInfinity || double.IsNaN (baseValue)"  is complex.
Empty Catch Block,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,ImportPrivateKey,The method has an empty catch block.
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else if (value > 0) {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			} else {  				sign = -1;  				value = -value;  				uint low = (uint)value;  				uint high = (uint)((ulong)value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else if (value > 0) {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			} else {  				sign = -1;  				value = -value;  				uint low = (uint)value;  				uint high = (uint)((ulong)value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else if (value > 0) {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			} else {  				sign = -1;  				value = -value;  				uint low = (uint)value;  				uint high = (uint)((ulong)value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else if (value > 0) {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			} else {  				sign = -1;  				value = -value;  				uint low = (uint)value;  				uint high = (uint)((ulong)value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Negative,The following statement contains a magic number: return ((v[7] & 0x80) != 0);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Mantissa,The following statement contains a magic number: return (ulong)((ulong)i1 | ((ulong)i2 << 32));
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: int size = 3;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: sign = (short) ((bits [3] & DecimalSignMask) != 0 ? -1 : 1);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  				data [2] = (uint)bits [2];
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  				data [2] = (uint)bits [2];
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  				data [2] = (uint)bits [2];
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = (x + (x >> 4)) & 0x0F0F0F0F;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = x + (x >> 8);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = x + (x >> 16);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,BitScanBackward,The following statement contains a magic number: for (int i = 31; i >= 0; --i) {  				uint mask = 1u << i;  				if ((word & mask) == mask)  					return i;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10' null);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: if (format == null || format == "")  				return ToString (10' provider);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: switch (format[0]) {  			case 'd':  			case 'D':  			case 'g':  			case 'G':  			case 'r':  			case 'R':  				return ToStringWithPadding (format' 10' provider);  			case 'x':  			case 'X':  				return ToStringWithPadding (format' 16' null);  			default:  				throw new FormatException (string.Format ("format '{0}' not implemented"' format));  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: switch (format[0]) {  			case 'd':  			case 'D':  			case 'g':  			case 'G':  			case 'r':  			case 'R':  				return ToStringWithPadding (format' 10' provider);  			case 'x':  			case 'X':  				return ToStringWithPadding (format' 16' null);  			default:  				throw new FormatException (string.Format ("format '{0}' not implemented"' format));  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,MakeTwoComplement,The following statement contains a magic number: for (int i = 0; i < v.Length; ++i) {  				uint word = v [i];  				carry = (ulong)~word + carry;  				word = (uint)carry;  				carry = (uint)(carry >> 32);  				res [i] = word;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,MakeTwoComplement,The following statement contains a magic number: for (int i = 1; i < idx; ++i)  				mask = (mask << 8) | 0xFF;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: List<char> digits = new List<char> (1 + data.Length * 3 / 10);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: List<char> digits = new List<char> (1 + data.Length * 3 / 10);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == 1)  				a = this;  			else {  				uint[] dt = data;  				if (radix > 10)  					dt = MakeTwoComplement (dt);  				a = new BigInteger (1' dt);  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == -1 && radix == 10) {  				NumberFormatInfo info = null;  				if (provider != null)  					info = provider.GetFormat (typeof (NumberFormatInfo)) as NumberFormatInfo;  				if (info != null) {  					string str = info.NegativeSign;  					for (int i = str.Length - 1; i >= 0; --i)  						digits.Add (str [i]);  				} else {  					digits.Add ('-');  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == 1 && radix > 10 && (last < '0' || last > '9'))  				digits.Add ('0');
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Parse,The following statement contains a magic number: for (; i < len; i++){  				c = s [i];    				if (c == '\0') {  					i = len;  					continue;  				}    				if (c >= '0' && c <= '9'){  					byte d = (byte) (c - '0');    					val = val * 10 + d;    					digits_seen = true;  				} else if (!ProcessTrailingWhitespace (tryParse' s' i' ref exc))  					return false;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Log,The following statement contains a magic number: for (int curBit = 31; curBit >= 0; curBit--) {  				if ((value.data [length] & (1 << curBit)) != 0) {  					bitCount = curBit + length * 32;  					break;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Log,The following statement contains a magic number: for (int curBit = 31; curBit >= 0; curBit--) {  				if ((value.data [length] & (1 << curBit)) != 0) {  					bitCount = curBit + length * 32;  					break;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Log,The following statement contains a magic number: for (long curbit = bitlen; curbit >= 0; --curbit) {  				if ((value & testBit).sign != 0)  					c += d;  				d *= 0.5;  				testBit = testBit >> 1;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Log,The following statement contains a magic number: return (System.Math.Log (c) + System.Math.Log (2) * bitlen) / System.Math.Log (baseValue);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Log10,The following statement contains a magic number: return Log (value' 10);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CompareTo,The following statement contains a magic number: if (data.Length > 2)  				return 1;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CompareTo,The following statement contains a magic number: uint high = (uint)(other >> 32);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CompareTo,The following statement contains a magic number: if (data.Length > 2)  				return -sign;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CompareTo,The following statement contains a magic number: uint high = (uint)((ulong)other >> 32);
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFFFF0000u) != 0) {  				if ((x & 0xFF000000u) != 0)  					return 4;  				return 3;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFFFF0000u) != 0) {  				if ((x & 0xFF000000u) != 0)  					return 4;  				return 3;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFF00u) != 0)  				return 2;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  				return 4;  			else if ((word & 0xFF0000u) != 0xFF0000u)  				return 3;  			else if ((word & 0xFF00u) != 0xFF00u)  				return 2;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  				return 4;  			else if ((word & 0xFF0000u) != 0xFF0000u)  				return 3;  			else if ((word & 0xFF00u) != 0xFF00u)  				return 2;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  				return 4;  			else if ((word & 0xFF0000u) != 0xFF0000u)  				return 3;  			else if ((word & 0xFF00u) != 0xFF00u)  				return 2;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: int bytes = (data.Length - 1) * 4;
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				extra = TopByte (topWord);  				uint mask = 0x80u << ((extra - 1) * 8);  				if ((topWord & mask) != 0) {  					needExtraZero = true;  				}  			} else {  				extra = TopByte (topWord);  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (; i < sl; i++) {  				sum = sum + a [i] + b [i];  				res [i] = (uint)sum;  				sum >>= 32;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (; i < bl; i++) {  				sum = sum + a [i];  				res [i] = (uint)sum;  				sum >>= 32;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CoreSub,The following statement contains a magic number: for (i = 0; i < sl; ++i) {  				borrow = (ulong)a [i] - b [i] - borrow;    				res [i] = (uint)borrow;  				borrow = (borrow >> 32) & 0x1;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CoreSub,The following statement contains a magic number: for (; i < bl; i++) {  				borrow = (ulong)a [i] - borrow;  				res [i] = (uint)borrow;  				borrow = (borrow >> 32) & 0x1;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (i = 0; i < len; i++) {  				sum = sum + a [i];  				res [i] = (uint)sum;  				sum >>= 32;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,CoreSub,The following statement contains a magic number: for (i = 0; i < len; i++) {  				borrow = (ulong)a [i] - borrow;  				res [i] = (uint)borrow;  				borrow = (borrow >> 32) & 0x1;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) { value <<= 16; shift += 16; }
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) { value <<= 16; shift += 16; }
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) { value <<= 8; shift += 8; }
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) { value <<= 8; shift += 8; }
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) { value <<= 4; shift += 4; }
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) { value <<= 4; shift += 4; }
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) { value <<= 2; shift += 2; }
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) { value <<= 2; shift += 2; }
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Normalize,The following statement contains a magic number: if (shift > 0) {  				int rshift = 32 - shift;  				for (i = 0; i < l; i++) {  					uint ui = u [i];  					un [i] = (ui << shift) | carry;  					carry = ui >> rshift;  				}  			} else {  				for (i = 0; i < l; i++) {  					un [i] = u [i];  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,Unnormalize,The following statement contains a magic number: if (shift > 0) {  				int lshift = 32 - shift;  				uint carry = 0;  				for (int i = length - 1; i >= 0; i--) {  					uint uni = un [i];  					r [i] = (uni >> shift) | carry;  					carry = (uni << lshift);  				}  			} else {  				for (int i = 0; i < length; i++) {  					r [i] = un [i];  				}  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,System.Numerics,BigInteger,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: _pLength = 1024/8;
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: _pLength = 1024/8;
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: GenerateKey(_pLength*8' out p' out g);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: byte[] data = new byte[2+_dh_p.Length + 2+_dh_g.Length + 2+_dh_Ys.Length];
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: byte[] data = new byte[2+_dh_p.Length + 2+_dh_g.Length + 2+_dh_Ys.Length];
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: byte[] data = new byte[2+_dh_p.Length + 2+_dh_g.Length + 2+_dh_Ys.Length];
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: data[idx++] = (byte) (_dh_p.Length >> 8);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: data[idx++] = (byte) (_dh_g.Length >> 8);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetServerKeys,The following statement contains a magic number: data[idx++] = (byte) (_dh_Ys.Length >> 8);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: int pLen = (data[pos] << 8) | data[pos+1];
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: pos += 2+pLen;
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: int gLen = (data[pos] << 8) | data[pos+1];
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: pos += 2+gLen;
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: int YsLen = (data[pos] << 8) | data[pos+1];
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: pos += 2+YsLen;
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: Buffer.BlockCopy(data' 2' _dh_p' 0' pLen);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: Buffer.BlockCopy(data' 4+pLen' _dh_g' 0' gLen);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessServerKeys,The following statement contains a magic number: Buffer.BlockCopy(data' 6+pLen+gLen' _dh_Ys' 0' YsLen);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetClientKeys,The following statement contains a magic number: byte[] ret = new byte[2+_dh_Yc.Length];
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetClientKeys,The following statement contains a magic number: ret[0] = (byte) (_dh_Yc.Length >> 8);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetClientKeys,The following statement contains a magic number: Buffer.BlockCopy(_dh_Yc' 0' ret' 2' _dh_Yc.Length);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessClientKeys,The following statement contains a magic number: if (((data[0] << 8) | data[1]) != data.Length-2)  				throw new Exception("Client key exchange vector length incorrect");
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessClientKeys,The following statement contains a magic number: if (((data[0] << 8) | data[1]) != data.Length-2)  				throw new Exception("Client key exchange vector length incorrect");
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessClientKeys,The following statement contains a magic number: byte[] _dh_Yc = new byte[data.Length-2];
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessClientKeys,The following statement contains a magic number: Buffer.BlockCopy(data' 2' _dh_Yc' 0' data.Length-2);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,ProcessClientKeys,The following statement contains a magic number: Buffer.BlockCopy(data' 2' _dh_Yc' 0' data.Length-2);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GetMasterSecret,The following statement contains a magic number: return prf.CreateDeriveBytes(_preMasterSecret' "master secret"' seed).GetBytes(48);
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GenerateKey,The following statement contains a magic number: if (bitLength == 768) {  				p = ByteArrayToBigInteger(OAKLEY768P);  			} else if (bitLength == 1024) {  				p = ByteArrayToBigInteger(OAKLEY1024P);  			} else if (bitLength == 1536) {  				p = ByteArrayToBigInteger(OAKLEY1536P);  			} else {  				throw new Exception("Bit length of " + bitLength + " not supported in DH key");  			}
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GenerateKey,The following statement contains a magic number: if (bitLength == 768) {  				p = ByteArrayToBigInteger(OAKLEY768P);  			} else if (bitLength == 1024) {  				p = ByteArrayToBigInteger(OAKLEY1024P);  			} else if (bitLength == 1536) {  				p = ByteArrayToBigInteger(OAKLEY1536P);  			} else {  				throw new Exception("Bit length of " + bitLength + " not supported in DH key");  			}
Magic Number,BigIntegerCipherSuitePlugin,KeyExchangeAlgorithmDHE,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\KeyExchangeAlgorithmDHE.cs,GenerateKey,The following statement contains a magic number: if (bitLength == 768) {  				p = ByteArrayToBigInteger(OAKLEY768P);  			} else if (bitLength == 1024) {  				p = ByteArrayToBigInteger(OAKLEY1024P);  			} else if (bitLength == 1536) {  				p = ByteArrayToBigInteger(OAKLEY1536P);  			} else {  				throw new Exception("Bit length of " + bitLength + " not supported in DH key");  			}
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,SupportsHashAlgorithmType,The following statement contains a magic number: switch (hashAlgorithm) {  			case 1: // HashAlgorithm.md5  			case 2: // HashAlgorithm.sha1  			case 4: // HashAlgorithm.sha256  			case 5: // HashAlgorithm.sha384  			case 6: // HashAlgorithm.sha512  				return true;  			default:  				return false;  			}
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,SupportsHashAlgorithmType,The following statement contains a magic number: switch (hashAlgorithm) {  			case 1: // HashAlgorithm.md5  			case 2: // HashAlgorithm.sha1  			case 4: // HashAlgorithm.sha256  			case 5: // HashAlgorithm.sha384  			case 6: // HashAlgorithm.sha512  				return true;  			default:  				return false;  			}
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,SupportsHashAlgorithmType,The following statement contains a magic number: switch (hashAlgorithm) {  			case 1: // HashAlgorithm.md5  			case 2: // HashAlgorithm.sha1  			case 4: // HashAlgorithm.sha256  			case 5: // HashAlgorithm.sha384  			case 6: // HashAlgorithm.sha512  				return true;  			default:  				return false;  			}
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,SupportsHashAlgorithmType,The following statement contains a magic number: switch (hashAlgorithm) {  			case 1: // HashAlgorithm.md5  			case 2: // HashAlgorithm.sha1  			case 4: // HashAlgorithm.sha256  			case 5: // HashAlgorithm.sha384  			case 6: // HashAlgorithm.sha512  				return true;  			default:  				return false;  			}
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,TLSv1SignData,The following statement contains a magic number: int keySize = (rsaKey.KeySize/8);
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,TLSv1VerifyData,The following statement contains a magic number: int keySize = (rsaKey.KeySize/8);
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,EncodeSignatureHash,The following statement contains a magic number: int padLength = length - hash.Length - 3;
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,EncodeSignatureHash,The following statement contains a magic number: if (padLength < 8) {  				throw new Exception("Too large hash value to encode");  			}
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,EncodeSignatureHash,The following statement contains a magic number: for (int i=0; i<padLength; i++) {  				message[2+i] = 0xff;  			}
Magic Number,BigIntegerCipherSuitePlugin,SignatureAlgorithmRSA,C:\repos\juhovh_AaltoTLS\Plugins\BigIntegerCipherSuitePlugin\SignatureAlgorithmRSA.cs,EncodeSignatureHash,The following statement contains a magic number: Buffer.BlockCopy(hash' 0' message' 3+padLength' hash.Length);
