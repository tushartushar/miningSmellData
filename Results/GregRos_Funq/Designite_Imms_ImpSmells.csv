Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Imms.Implementation,TreeIterator,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\OrderedAvlTree\TreeIterator.cs,SeekForwardCloseTo,Cyclomatic complexity of the method is 15
Complex Method,Imms.Implementation,TreeIterator,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\OrderedAvlTree\TreeIterator.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,Imms.Implementation,TreeIterator,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\OrderedAvlTree\TreeIterator.cs,SeekForwardCloseTo,Cyclomatic complexity of the method is 15
Complex Method,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,Cyclomatic complexity of the method is 10
Complex Method,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,Cyclomatic complexity of the method is 18
Complex Method,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,Cyclomatic complexity of the method is 10
Complex Method,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,RemoveAt,Cyclomatic complexity of the method is 11
Complex Method,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,WhereIsThisIndex,Cyclomatic complexity of the method is 8
Complex Method,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,Cyclomatic complexity of the method is 17
Complex Method,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,Cyclomatic complexity of the method is 13
Complex Method,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,Cyclomatic complexity of the method is 9
Complex Method,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Remove,Cyclomatic complexity of the method is 10
Complex Method,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,WhereIsThisIndex,Cyclomatic complexity of the method is 11
Long Parameter List,Imms.Implementation,Measured<TObject>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Measured.cs,Insert,The method has 5 parameters. Parameters: index' leaf' value' rightmost1' lineage
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Node,The method has 6 parameters. Parameters: hash' bucket' left' right' eq' lin
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Root_Add,The method has 5 parameters. Parameters: k' v' lin' eq' overwrite
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlAdd,The method has 5 parameters. Parameters: hash' key' value' lineage' overwrite
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Split,The method has 5 parameters. Parameters: pivot' leftBranch' central' rightBranch' lin
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Node,The method has 6 parameters. Parameters: key' value' left' right' comparer' lineage
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Root_Add,The method has 5 parameters. Parameters: k' v' comparer' overwrite' lin
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Split,The method has 5 parameters. Parameters: pivot' leftBranch' central' rightBranch' lin
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedList,The method has 5 parameters. Parameters: sorted' startIndex' endIndex' comparer' lineage
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedArray,The method has 5 parameters. Parameters: sorted' startIndex' endIndex' comparer' lineage
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedArraySet,The method has 5 parameters. Parameters: sorted' startIndex' endIndex' comparer' lineage
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Node,The method has 5 parameters. Parameters: height' length' isFull' lineage' arrSize
Long Parameter List,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AddRange,The method has 5 parameters. Parameters: arr' lineage' maxHeight' count' i
Long Parameter List,Imms.Implementation,Bucket,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Bucket.cs,Bucket,The method has 5 parameters. Parameters: k' v' next' eq' lin
Long Parameter List,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The method has 5 parameters. Parameters: arr' lineage' maxHeight' start' count
Long Parameter List,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The method has 5 parameters. Parameters: height' length' arr' lineage' arrSize
Long Parameter List,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddRange,The method has 5 parameters. Parameters: arr' lineage' maxHeight' start' count
Long Parameter List,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Split,The method has 5 parameters. Parameters: index' left' child' right' lineage
Long Parameter List,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Split,The method has 5 parameters. Parameters: index' left' child' right' lineage
Long Parameter List,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Digit,The method has 5 parameters. Parameters: one' two' three' four' lineage
Long Parameter List,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The method has 5 parameters. Parameters: lineage' item1' item2' item3' item4
Long Parameter List,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The method has 5 parameters. Parameters: other' leftmost' middle' rightmost' lineage
Long Parameter List,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,_mutate,The method has 6 parameters. Parameters: measure' size' a' b' c' d
Long Parameter List,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,MutateOrCreate,The method has 5 parameters. Parameters: a' b' c' d' lineage
Long Parameter List,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The method has 5 parameters. Parameters: index' leaf' leftmost' rightmost' lineage
Long Parameter List,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Split,The method has 5 parameters. Parameters: index' left' center' right' lineage
Long Parameter List,Imms.Implementation,EmptyTree,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Empty.cs,Split,The method has 5 parameters. Parameters: index' left' child' right' lineage
Long Parameter List,Imms.Implementation,Single,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Single.cs,Split,The method has 5 parameters. Parameters: index' left' center' right' lineage
Long Parameter List,Imms.Implementation,Leaf<TValue>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Leaf.cs,Insert,The method has 5 parameters. Parameters: index' leaf' leftmost' rightmost' lineage
Long Parameter List,Imms,ImmList<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\List\Boilerplate.cs,GroupJoin,The method has 5 parameters. Parameters: inner' outerKeySelector' innerKeySelector' resultSelector' eq
Long Parameter List,Imms,ImmList<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\List\Boilerplate.cs,Join,The method has 5 parameters. Parameters: inner' oKeySelector' iKeySelector' rSelector' eq
Long Parameter List,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,GroupJoin,The method has 5 parameters. Parameters: inner' outerKeySelector' innerKeySelector' resultSelector' eq
Long Parameter List,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,Join,The method has 5 parameters. Parameters: inner' oKeySelector' iKeySelector' rSelector' eq
Long Statement,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Intersect,The length of the statement  "				var duplicates = list.Select(x => new {x' count = list.Count(y => y.First.Equals(x.First))}).OrderByDescending(x => x.count); " is 125.
Long Statement,Imms.Implementation,Bucket,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Bucket.cs,Apply,The length of the statement  "				for (var cur = this; !cur.IsEmpty; cur = cur.Next) newBucket = new HashedAvlTree<TKey' TValue2>.Bucket(cur.Key' selector(cur.Key' cur.Value)' newBucket' Eq' lineage); " is 166.
Long Statement,Imms.Implementation,ImplErrors,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\Common\Errors.cs,Invalid_digit_size,The length of the statement  "			return new ImplementationException(string.Format("This operation cannot be performed on a digit with this size. It was: {0}. More info: {1}"' size' message)); " is 158.
Long Statement,Imms.Implementation,ImplErrors,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\Common\Errors.cs,Invalid_execution_path,The length of the statement  "			return new ImplementationException(string.Format("An execution has reached a block never meant to be executed. More info: {0}"' info)); " is 135.
Long Statement,Imms.Implementation,ImplErrors,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\Common\Errors.cs,Invalid_invocation,The length of the statement  "			return new ImplementationException(string.Format("This operation cannot be executed on this kind of object. It was of the kind: {0}"' objectKind)); " is 147.
Long Statement,Imms.Implementation,ImplErrors,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\Common\Errors.cs,Arg_out_of_range,The length of the statement  "			return new ImplementationException(string.Format("An argument was out of range.\r\nName: {0}\t Value: {1}"' name' value)); " is 122.
Long Statement,Imms.Implementation,FingerTreeIterator<TValue>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\FingerTreeIterator.cs,MoveNext,The length of the statement  "			AssertEx.AssertTrue(top.Object.ChildCount > 0 || top.Object.IsLeaf || _future.Count == 1); //only possible if tree is empty " is 123.
Long Statement,Imms,ImmMap<TKey;TValue>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\ImmMap\Debugging.cs,RemoveRange,The length of the statement  "			if (set != null && _equality.Equals(set.EqualityComparer)) return _root.Except(set.Root' Lineage.Mutable()).WrapMap(_equality); " is 127.
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor.AssertBetween(-2' 2);
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor.AssertBetween(-2' 2);
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor == -2
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Concat,The following statement contains a magic number: newFactor >= 2
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedList,The following statement contains a magic number: var pivotIndex = startIndex + (endIndex - startIndex) / 2;
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor.AssertBetween(-2' 2);
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor.AssertBetween(-2' 2);
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor == -2
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Concat,The following statement contains a magic number: newFactor >= 2
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedList,The following statement contains a magic number: var pivotIndex = startIndex + (endIndex - startIndex) / 2;
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedArray,The following statement contains a magic number: var pivotIndex = startIndex + (endIndex - startIndex) / 2;
Magic Number,Imms.Implementation,Node,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedArraySet,The following statement contains a magic number: var pivotIndex = startIndex + (endIndex - startIndex) / 2;
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,UpdateStore,The following statement contains a magic number: Arr = Arr.Resize(32);
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,UpdateStore,The following statement contains a magic number: Arr.Length < 32
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddToStore,The following statement contains a magic number: Arr = Arr.Resize(32);
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddToStore,The following statement contains a magic number: Arr.Length < 32
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,_mutate,The following statement contains a magic number: IsFull = arrSize == 32;
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,Add,The following statement contains a magic number: ArrSize < 32
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The following statement contains a magic number: var len = ArrSize + count > 32 ? 32 - ArrSize : count;
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The following statement contains a magic number: var len = ArrSize + count > 32 ? 32 - ArrSize : count;
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The following statement contains a magic number: var parentArr = ArrayExt.OfItems(32' ret' Empty);
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The following statement contains a magic number: var myParent = new Parent(1' ret.Length' parentArr' lineage' 2);
Magic Number,Imms.Implementation,Leaf,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,RemoveLast,The following statement contains a magic number: var beforeLast = Length > 1 ? Optional.Some(this[Length - 2]) : Optional.None;
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The following statement contains a magic number: _offs = height * 5;
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The following statement contains a magic number: _myBlock = ((1 << 5) - 1) << _offs;
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The following statement contains a magic number: _offs = Height * 5;
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The following statement contains a magic number: _myBlock = ((1 << 5) - 1) << _offs;
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,_mutate,The following statement contains a magic number: IsFull = arrSize == 32 && arr[arrSize-1].Height == Height - 1 && arr[arrSize - 1].IsFull;
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,UpdateStore,The following statement contains a magic number: Arr = Arr.Resize(32);
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,UpdateStore,The following statement contains a magic number: Arr.Length < 32
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddToStore,The following statement contains a magic number: Arr = Arr.Resize(32);
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddToStore,The following statement contains a magic number: Arr.Length < 32
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddRange,The following statement contains a magic number: var newArr = Arr.Resize(32);
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddRange,The following statement contains a magic number: i < 32 && count > 0
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,RemoveLast,The following statement contains a magic number: var expectedLast = Length > 1 ? Optional.Some(this[Length - 2]) : Optional.None;
Magic Number,Imms.Implementation,Parent,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,RemoveLast,The following statement contains a magic number: ArrSize == 2 && Arr[1].Length == 1
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: var myChildSize = FastMath.PowN(3' Nesting - 1);
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: divRem == 0 && (number = count / myChildSize) <= 8
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: var status = first._kind << 3 | last._kind;
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: memberPermutation |= right != null ? 1 << 2 : 0;
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,AddFirst,The following statement contains a magic number: LeftDigit.Size < 4
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,AddLast,The following statement contains a magic number: RightDigit.Size < 4
Magic Number,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,GetChild,The following statement contains a magic number: switch (index) {  						case 0:  							return LeftDigit;  						case 1:  							return DeepTree;  						case 2:  							return RightDigit;  						default:  							throw ImplErrors.Arg_out_of_range("index"' index);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Digit,The following statement contains a magic number: Size = 2;
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Digit,The following statement contains a magic number: Size = 3;
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Digit,The following statement contains a magic number: Size = 4;
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,ConstructMult,The following statement contains a magic number: switch (mult) {  						case 1:  							return new Digit(c.Construct3(arr' ref index' lin)' lin);  						case 2:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						case 3:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' lin);  						case 4:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						default:  							throw ImplErrors.Bad_digit_size(mult);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,ConstructMult,The following statement contains a magic number: switch (mult) {  						case 1:  							return new Digit(c.Construct3(arr' ref index' lin)' lin);  						case 2:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						case 3:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' lin);  						case 4:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						default:  							throw ImplErrors.Bad_digit_size(mult);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,ConstructMult,The following statement contains a magic number: switch (mult) {  						case 1:  							return new Digit(c.Construct3(arr' ref index' lin)' lin);  						case 2:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						case 3:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' lin);  						case 4:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						default:  							throw ImplErrors.Bad_digit_size(mult);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Print,The following statement contains a magic number: switch (Size) {  						case 1:  							rest = new[] { First.Print() };  							break;  						case 2:  							rest = new[] { First.Print()' Second.Print() };  							break;  						case 3:  							rest = new[] { First.Print()' Second.Print()' Third.Print() };  							break;  						case 4:  							rest = new[] { First.Print()' Second.Print()' Third.Print()' Fourth.Print() };  							break;  						default:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Print,The following statement contains a magic number: switch (Size) {  						case 1:  							rest = new[] { First.Print() };  							break;  						case 2:  							rest = new[] { First.Print()' Second.Print() };  							break;  						case 3:  							rest = new[] { First.Print()' Second.Print()' Third.Print() };  							break;  						case 4:  							rest = new[] { First.Print()' Second.Print()' Third.Print()' Fourth.Print() };  							break;  						default:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Print,The following statement contains a magic number: switch (Size) {  						case 1:  							rest = new[] { First.Print() };  							break;  						case 2:  							rest = new[] { First.Print()' Second.Print() };  							break;  						case 3:  							rest = new[] { First.Print()' Second.Print()' Third.Print() };  							break;  						case 4:  							rest = new[] { First.Print()' Second.Print()' Third.Print()' Fourth.Print() };  							break;  						default:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,GetChild,The following statement contains a magic number: switch (index) {  						case 0:  							return First;  						case 1:  							return Second;  						case 2:  							return Third;  						case 3:  							return Fourth;  						default:  							throw ImplErrors.Arg_out_of_range("index"' index);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,GetChild,The following statement contains a magic number: switch (index) {  						case 0:  							return First;  						case 1:  							return Second;  						case 2:  							return Third;  						case 3:  							return Fourth;  						default:  							throw ImplErrors.Arg_out_of_range("index"' index);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: itemsPresent |= item2 != null ? 2 : 0;
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: itemsPresent |= item3 != null ? 4 : 0;
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: itemsPresent |= item4 != null ? 8 : 0;
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: var match = (Size << 3) | other.Size;
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,_mutate,The following statement contains a magic number: notNull.Length != 2
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,MutateOrCreate,The following statement contains a magic number: return Lineage.AllowMutation(lineage) ? _mutate(a.Measure + b.Measure' 2' a' b) : new Digit(a' b' lineage);
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,MutateOrCreate,The following statement contains a magic number: return Lineage.AllowMutation(lineage)  						? _mutate(a.Measure + b.Measure + c.Measure' 3' a' b' c) : new Digit(a' b' c' lineage);
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,MutateOrCreate,The following statement contains a magic number: return Lineage.AllowMutation(lineage)  						? _mutate(a.Measure + b.Measure + c.Measure + d.Measure' 4' a' b' c' d) : new Digit(a' b' c' d' lineage);
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(item' First' lineage);  						case 2:  							return MutateOrCreate(item' First' Second' lineage);  						case 3:  							return MutateOrCreate(item' First' Second' Third' lineage);  						case 4:  							throw ImplErrors.Digit_too_large(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(item' First' lineage);  						case 2:  							return MutateOrCreate(item' First' Second' lineage);  						case 3:  							return MutateOrCreate(item' First' Second' Third' lineage);  						case 4:  							throw ImplErrors.Digit_too_large(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(item' First' lineage);  						case 2:  							return MutateOrCreate(item' First' Second' lineage);  						case 3:  							return MutateOrCreate(item' First' Second' Third' lineage);  						case 4:  							throw ImplErrors.Digit_too_large(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddLast,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First' item' lineage);  						case 2:  							return MutateOrCreate(First' Second' item' lineage);  						case 3:  							return MutateOrCreate(First' Second' Third' item' lineage);  						case 4:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddLast,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First' item' lineage);  						case 2:  							return MutateOrCreate(First' Second' item' lineage);  						case 3:  							return MutateOrCreate(First' Second' Third' item' lineage);  						case 4:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddLast,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First' item' lineage);  						case 2:  							return MutateOrCreate(First' Second' item' lineage);  						case 3:  							return MutateOrCreate(First' Second' Third' item' lineage);  						case 4:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The following statement contains a magic number: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_1:  							First.Insert(index' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {    								leftmost = new Digit(myLeftmost' myRightmost' Second' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' myLeftmost' myRightmost' Second' Third)  								: CreateCheckNull(lineage' myLeftmost' Second' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_2:  						case IN_MIDDLE_OF_2:  							Second.Insert(index - First.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' myLeftmost' myRightmost' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' First' myLeftmost' myRightmost' Third)  								: CreateCheckNull(lineage' First' myLeftmost' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_3:  						case IN_MIDDLE_OF_3:  							Third.Insert(index - First.Measure - Second.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' myLeftmost' lineage);  								rightmost = MutateOrCreate(myRightmost' Fourth' lineage);  								return;  							}  							leftmost =  								myRightmost != null  									? CreateCheckNull(lineage' First' Second' myLeftmost' myRightmost)  									: CreateCheckNull(lineage' First' Second' myLeftmost' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_4:  						case IN_MIDDLE_OF_4:  							Fourth.Insert(index - Measure + Fourth.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' Third' lineage);  								rightmost = MutateOrCreate(myLeftmost' myRightmost' lineage);  								return;  							}  							leftmost = MutateOrCreate(First' Second' Third' myLeftmost' lineage);  							rightmost = null;  							return;						  						default:  							throw ImplErrors.Invalid_execution_path("");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The following statement contains a magic number: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_1:  							First.Insert(index' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {    								leftmost = new Digit(myLeftmost' myRightmost' Second' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' myLeftmost' myRightmost' Second' Third)  								: CreateCheckNull(lineage' myLeftmost' Second' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_2:  						case IN_MIDDLE_OF_2:  							Second.Insert(index - First.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' myLeftmost' myRightmost' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' First' myLeftmost' myRightmost' Third)  								: CreateCheckNull(lineage' First' myLeftmost' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_3:  						case IN_MIDDLE_OF_3:  							Third.Insert(index - First.Measure - Second.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' myLeftmost' lineage);  								rightmost = MutateOrCreate(myRightmost' Fourth' lineage);  								return;  							}  							leftmost =  								myRightmost != null  									? CreateCheckNull(lineage' First' Second' myLeftmost' myRightmost)  									: CreateCheckNull(lineage' First' Second' myLeftmost' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_4:  						case IN_MIDDLE_OF_4:  							Fourth.Insert(index - Measure + Fourth.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' Third' lineage);  								rightmost = MutateOrCreate(myLeftmost' myRightmost' lineage);  								return;  							}  							leftmost = MutateOrCreate(First' Second' Third' myLeftmost' lineage);  							rightmost = null;  							return;						  						default:  							throw ImplErrors.Invalid_execution_path("");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The following statement contains a magic number: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_1:  							First.Insert(index' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {    								leftmost = new Digit(myLeftmost' myRightmost' Second' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' myLeftmost' myRightmost' Second' Third)  								: CreateCheckNull(lineage' myLeftmost' Second' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_2:  						case IN_MIDDLE_OF_2:  							Second.Insert(index - First.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' myLeftmost' myRightmost' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' First' myLeftmost' myRightmost' Third)  								: CreateCheckNull(lineage' First' myLeftmost' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_3:  						case IN_MIDDLE_OF_3:  							Third.Insert(index - First.Measure - Second.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' myLeftmost' lineage);  								rightmost = MutateOrCreate(myRightmost' Fourth' lineage);  								return;  							}  							leftmost =  								myRightmost != null  									? CreateCheckNull(lineage' First' Second' myLeftmost' myRightmost)  									: CreateCheckNull(lineage' First' Second' myLeftmost' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_4:  						case IN_MIDDLE_OF_4:  							Fourth.Insert(index - Measure + Fourth.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' Third' lineage);  								rightmost = MutateOrCreate(myLeftmost' myRightmost' lineage);  								return;  							}  							leftmost = MutateOrCreate(First' Second' Third' myLeftmost' lineage);  							rightmost = null;  							return;						  						default:  							throw ImplErrors.Invalid_execution_path("");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The following statement contains a magic number: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_1:  							First.Insert(index' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {    								leftmost = new Digit(myLeftmost' myRightmost' Second' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' myLeftmost' myRightmost' Second' Third)  								: CreateCheckNull(lineage' myLeftmost' Second' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_2:  						case IN_MIDDLE_OF_2:  							Second.Insert(index - First.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' myLeftmost' myRightmost' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' First' myLeftmost' myRightmost' Third)  								: CreateCheckNull(lineage' First' myLeftmost' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_3:  						case IN_MIDDLE_OF_3:  							Third.Insert(index - First.Measure - Second.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' myLeftmost' lineage);  								rightmost = MutateOrCreate(myRightmost' Fourth' lineage);  								return;  							}  							leftmost =  								myRightmost != null  									? CreateCheckNull(lineage' First' Second' myLeftmost' myRightmost)  									: CreateCheckNull(lineage' First' Second' myLeftmost' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_4:  						case IN_MIDDLE_OF_4:  							Fourth.Insert(index - Measure + Fourth.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' Third' lineage);  								rightmost = MutateOrCreate(myLeftmost' myRightmost' lineage);  								return;  							}  							leftmost = MutateOrCreate(First' Second' Third' myLeftmost' lineage);  							rightmost = null;  							return;						  						default:  							throw ImplErrors.Invalid_execution_path("");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Iter,The following statement contains a magic number: switch (Size) {  						case 1:  							First.Iter(action);  							return;  						case 2:  							First.Iter(action);  							Second.Iter(action);  							return;  						case 3:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							return;  						case 4:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							Fourth.Iter(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Iter,The following statement contains a magic number: switch (Size) {  						case 1:  							First.Iter(action);  							return;  						case 2:  							First.Iter(action);  							Second.Iter(action);  							return;  						case 3:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							return;  						case 4:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							Fourth.Iter(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Iter,The following statement contains a magic number: switch (Size) {  						case 1:  							First.Iter(action);  							return;  						case 2:  							First.Iter(action);  							Second.Iter(action);  							return;  						case 3:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							return;  						case 4:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							Fourth.Iter(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,IterBack,The following statement contains a magic number: switch (Size) {  						case 1:  							First.IterBack(action);  							return;  						case 2:  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 3:  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 4:  							Fourth.IterBack(action);  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,IterBack,The following statement contains a magic number: switch (Size) {  						case 1:  							First.IterBack(action);  							return;  						case 2:  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 3:  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 4:  							Fourth.IterBack(action);  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,IterBack,The following statement contains a magic number: switch (Size) {  						case 1:  							First.IterBack(action);  							return;  						case 2:  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 3:  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 4:  							Fourth.IterBack(action);  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Digit_too_small(Size);  						case 2:  							return MutateOrCreate(Second' lineage);  						case 3:  							return MutateOrCreate(Second' Third' lineage);  						case 4:  							return MutateOrCreate(Second' Third' Fourth' lineage);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Digit_too_small(Size);  						case 2:  							return MutateOrCreate(Second' lineage);  						case 3:  							return MutateOrCreate(Second' Third' lineage);  						case 4:  							return MutateOrCreate(Second' Third' Fourth' lineage);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Digit_too_small(Size);  						case 2:  							return MutateOrCreate(Second' lineage);  						case 3:  							return MutateOrCreate(Second' Third' lineage);  						case 4:  							return MutateOrCreate(Second' Third' Fourth' lineage);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveLast,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Bad_digit_size(Size);  						case 2:  							return MutateOrCreate(First' lineage);  						case 3:  							return MutateOrCreate(First' Second' lineage);  						case 4:  							return MutateOrCreate(First' Second' Third' lineage);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveLast,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Bad_digit_size(Size);  						case 2:  							return MutateOrCreate(First' lineage);  						case 3:  							return MutateOrCreate(First' Second' lineage);  						case 4:  							return MutateOrCreate(First' Second' Third' lineage);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveLast,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Bad_digit_size(Size);  						case 2:  							return MutateOrCreate(First' lineage);  						case 3:  							return MutateOrCreate(First' Second' lineage);  						case 4:  							return MutateOrCreate(First' Second' Third' lineage);  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Reverse,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First.Reverse(lineage)' lineage);  						case 2:  							return MutateOrCreate(Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 3:  							return MutateOrCreate(Third.Reverse(lineage)' Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 4:  							return MutateOrCreate(Fourth.Reverse(lineage)' Third.Reverse(lineage)' Second.Reverse(lineage)'  								First.Reverse(lineage)' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Reverse,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First.Reverse(lineage)' lineage);  						case 2:  							return MutateOrCreate(Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 3:  							return MutateOrCreate(Third.Reverse(lineage)' Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 4:  							return MutateOrCreate(Fourth.Reverse(lineage)' Third.Reverse(lineage)' Second.Reverse(lineage)'  								First.Reverse(lineage)' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes");  					}
Magic Number,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Reverse,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First.Reverse(lineage)' lineage);  						case 2:  							return MutateOrCreate(Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 3:  							return MutateOrCreate(Third.Reverse(lineage)' Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 4:  							return MutateOrCreate(Fourth.Reverse(lineage)' Third.Reverse(lineage)' Second.Reverse(lineage)'  								First.Reverse(lineage)' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes");  					}
Magic Number,Imms.Implementation,FingerTreeIterator<TValue>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\FingerTreeIterator.cs,MoveNext,The following statement contains a magic number: obj.ChildCount.AssertEqual(3);
Magic Number,Imms.Implementation,FingerTreeIterator<TValue>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\FingerTreeIterator.cs,MoveNext,The following statement contains a magic number: top.SetMark(2);
Magic Number,Imms.Implementation,FingerTreeIterator<TValue>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\FingerTreeIterator.cs,MoveNext,The following statement contains a magic number: nextObj = obj.GetChild(2);
Magic Number,Imms.Implementation,Single,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Single.cs,AddFirst,The following statement contains a magic number: CenterDigit.Size < 4
Magic Number,Imms.Implementation,Single,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Single.cs,AddLast,The following statement contains a magic number: CenterDigit.Size < 4
Magic Number,Imms,Builder,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\ImmSortedMap\ImmBindings.cs,AddRange,The following statement contains a magic number: _inner = _inner.AddRange(arr' _lineage' 6' ref s' ref len);
Magic Number,Imms,ImmList<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\List\Boilerplate.cs,RemoveLast,The following statement contains a magic number: ret.Last.AssertEqual(this[-2]);
Magic Number,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,InsertRange,The following statement contains a magic number: start = start.AddRange(arrInsert' lineage' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,InsertRange,The following statement contains a magic number: start = start.AddRange(arrAfter' lineage' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,RemoveAt,The following statement contains a magic number: var ret = take.AddRange(arr' lineage' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,Insert,The following statement contains a magic number: var ret = take.AddRange(arr' lineage' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,AddLastRange,The following statement contains a magic number: ImmVector<T> ret = Root.AddRange(arr' Lineage.Mutable()' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,CopyFrom,The following statement contains a magic number: var ret = Root.AddRange(arr' lineage' 6' ref startIndex' ref count);
Magic Number,Imms,ImmVector<T>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,RemoveLast,The following statement contains a magic number: ret.Last.AssertEqual(this[-2]);
Missing Default,Imms.Implementation,FTree<TChild>,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following switch statement is missing a default case: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Missing Default,Imms.Implementation,Compound,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Insert,The following switch statement is missing a default case: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_LEFT:  							Digit leftL' leftR;  							LeftDigit.Insert(index' leaf' out leftL' out leftR' lineage);  							newDeep = leftR != null ? DeepTree.AddFirst(leftR' lineage) : DeepTree;  							res = MutateOrCreate(leftL' newDeep' RightDigit' lineage);  							break;  						case IN_START_OF_DEEP:  						case IN_MIDDLE_OF_DEEP:  							if (DeepTree.Measure == 0) goto case IN_START_OF_RIGHT;  							newDeep = DeepTree.Insert(index - LeftDigit.Measure' leaf' lineage);  							res = MutateOrCreate(LeftDigit' newDeep' RightDigit' lineage);  							break;  						case IN_START_OF_RIGHT:  						case IN_MIDDLE_OF_RIGHT:  							Digit rightR;  							Digit rightL;  							RightDigit.Insert(index - LeftDigit.Measure - DeepTree.Measure' leaf' out rightL' out rightR' lineage);  							newDeep = rightR != null ? DeepTree.AddLast(rightL' lineage) : DeepTree;  							rightR = rightR ?? rightL;  							res = MutateOrCreate(LeftDigit' newDeep' rightR' lineage);  							break;  					}
Missing Default,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddFirst,The following switch statement is missing a default case: switch (Size) {  						case 1:  							return MutateOrCreate(item' First' lineage);  						case 2:  							return MutateOrCreate(item' First' Second' lineage);  						case 3:  							return MutateOrCreate(item' First' Second' Third' lineage);  						case 4:  							throw ImplErrors.Digit_too_large(Size);  					}
Missing Default,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddLast,The following switch statement is missing a default case: switch (Size) {  						case 1:  							return MutateOrCreate(First' item' lineage);  						case 2:  							return MutateOrCreate(First' Second' item' lineage);  						case 3:  							return MutateOrCreate(First' Second' Third' item' lineage);  						case 4:  							throw ImplErrors.Bad_digit_size(Size);  					}
Missing Default,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveFirst,The following switch statement is missing a default case: switch (Size) {  						case 1:  							throw ImplErrors.Digit_too_small(Size);  						case 2:  							return MutateOrCreate(Second' lineage);  						case 3:  							return MutateOrCreate(Second' Third' lineage);  						case 4:  							return MutateOrCreate(Second' Third' Fourth' lineage);  					}
Missing Default,Imms.Implementation,Digit,D:\research\architectureSmells\repos\GregRos_Funq\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveLast,The following switch statement is missing a default case: switch (Size) {  						case 1:  							throw ImplErrors.Bad_digit_size(Size);  						case 2:  							return MutateOrCreate(First' lineage);  						case 3:  							return MutateOrCreate(First' Second' lineage);  						case 4:  							return MutateOrCreate(First' Second' Third' lineage);  					}
