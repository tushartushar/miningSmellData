Implementation smell,Namespace,Class,File,Method,Description
Long Method,Unclassified.TxEditor,App,C:\repos\dg9ngf_TxTranslation\TxEditor\App.xaml.cs,OnStartup,The method has 108 lines of code.
Long Method,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The method has 268 lines of code.
Long Method,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The method has 220 lines of code.
Long Method,Unclassified.Util,CommandLineHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\CommandLineHelper.cs,Parse,The method has 106 lines of code.
Long Method,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Load,The method has 254 lines of code.
Long Method,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Save,The method has 252 lines of code.
Long Method,Unclassified.Util,NaturalSort,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\NaturalSort.cs,NatCompare,The method has 186 lines of code.
Long Method,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateType,The method has 105 lines of code.
Long Method,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateConstructor,The method has 111 lines of code.
Long Method,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateOnPropertyChanged,The method has 146 lines of code.
Long Method,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateStoreGetter,The method has 171 lines of code.
Long Method,Unclassified.Util,WinApi,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\WinApi_Input.cs,KeyToVk,The method has 179 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,Save,The method has 113 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnRenameTextKey,The method has 172 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnDuplicateTextKey,The method has 110 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXmlFile,The method has 184 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXml,The method has 109 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The method has 197 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The method has 109 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,UpdateSuggestions,The method has 375 lines of code.
Long Method,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Validate,The method has 284 lines of code.
Long Method,Unclassified.TxEditor.Views,DateTimeWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\DateTimeWindow.xaml.cs,UpdateView,The method has 120 lines of code.
Long Method,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,OKButton_Click,The method has 145 lines of code.
Long Method,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The method has 435 lines of code.
Complex Method,Unclassified.TxEditor,App,C:\repos\dg9ngf_TxTranslation\TxEditor\App.xaml.cs,OnStartup,Cyclomatic complexity of the method is 10
Complex Method,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,Cyclomatic complexity of the method is 23
Complex Method,Unclassified.TxEditor.Converters,TreeNodesConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Converters\TreeNodesConverter.cs,Convert,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.UI,MenuExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\MenuExtensions.cs,ReduceSeparators,Cyclomatic complexity of the method is 13
Complex Method,Unclassified.UI,ViewModelBase,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ViewModelBase.cs,GetErrors,Cyclomatic complexity of the method is 11
Complex Method,Unclassified.UI,ViewModelBase,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ViewModelBase.cs,OnPropertyChanged,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.UI,NegationConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\NegationConverter.cs,Convert,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.UI,OpenFolderDialog,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\OpenFolderDialog.cs,ShowVistaDialog,Cyclomatic complexity of the method is 10
Complex Method,Unclassified.UI,TextHighlightConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\TextHighlightConverter.cs,Convert,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.UI,ViewCommandManager,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ViewCommand.cs,Invoke,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Text_PreviewKeyDown,Cyclomatic complexity of the method is 11
Complex Method,Unclassified.Util,NaturalSort,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\NaturalSort.cs,NatCompare,Cyclomatic complexity of the method is 9
Complex Method,Unclassified.Util,PropertyExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\PropertyExtensions.cs,BindProperty,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateType,Cyclomatic complexity of the method is 10
Complex Method,Unclassified.Util,SettingsStoreBoundList<T>,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,GetItems,Cyclomatic complexity of the method is 9
Complex Method,Unclassified.Util,StringExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\StringExtensions.cs,SafeSubstring,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,DoLoadFolder,Cyclomatic complexity of the method is 14
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,DoLoadFiles,Cyclomatic complexity of the method is 10
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnDeleteTextKey,Cyclomatic complexity of the method is 10
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnRenameTextKey,Cyclomatic complexity of the method is 15
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnDuplicateTextKey,Cyclomatic complexity of the method is 13
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXmlFile,Cyclomatic complexity of the method is 18
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXml,Cyclomatic complexity of the method is 15
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,FindOrCreateTextKey,Cyclomatic complexity of the method is 13
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,Cyclomatic complexity of the method is 11
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,Cyclomatic complexity of the method is 19
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToDictionary,Cyclomatic complexity of the method is 13
Complex Method,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,UpdateSuggestions,Cyclomatic complexity of the method is 27
Complex Method,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Validate,Cyclomatic complexity of the method is 33
Complex Method,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,ValidateName,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,CheckPlaceholdersConsistency,Cyclomatic complexity of the method is 11
Complex Method,Unclassified.TxEditor.Views,CultureWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\CultureWindow.xaml.cs,LoadCultures,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,OKButton_Click,Cyclomatic complexity of the method is 24
Complex Method,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,Cyclomatic complexity of the method is 24
Complex Method,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,AutoCollapseItems,Cyclomatic complexity of the method is 8
Long Parameter List,Unclassified.UI,WindowExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\WindowExtensions.cs,SetWindowPos,The method has 7 parameters. Parameters: hwnd' hwndInsertAfter' x' y' width' height' flags
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,Animate,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,Animate,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEaseIn,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEaseIn,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEaseOut,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEaseOut,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,Animate,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,Animate,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEaseIn,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEaseIn,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEaseOut,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEaseOut,The method has 5 parameters. Parameters: obj' property' fromValue' toValue' duration
Long Parameter List,Unclassified.Util,DelayedCall<T1;T2;T3>,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\DelayedCall.cs,Create,The method has 5 parameters. Parameters: cb' data1' data2' data3' milliseconds
Long Parameter List,Unclassified.Util,DelayedCall<T1;T2;T3>,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\DelayedCall.cs,CreateAsync,The method has 5 parameters. Parameters: cb' data1' data2' data3' milliseconds
Long Parameter List,Unclassified.Util,DelayedCall<T1;T2;T3>,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\DelayedCall.cs,Start,The method has 5 parameters. Parameters: cb' data1' data2' data3' milliseconds
Long Parameter List,Unclassified.Util,DelayedCall<T1;T2;T3>,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\DelayedCall.cs,StartAsync,The method has 5 parameters. Parameters: cb' data1' data2' data3' milliseconds
Long Parameter List,Unclassified.Util,PropertyExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\PropertyExtensions.cs,BindProperty,The method has 5 parameters. Parameters: target' targetExpr' source' sourceExpr' direction
Long Parameter List,Unclassified.Util,WinApi,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\WinApi_Input.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Identifier,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,,The length of the parameter TextBoxExtraBorderCompensation is 30.
Long Statement,Unclassified.TxEditor,FileNameHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\FileNameHelper.cs,FindOtherCultures,The length of the statement  "				foreach (string otherFile in Directory.GetFiles(Path.GetDirectoryName(filesToLoad[0])' FileNameHelper.GetPrefix(filesToLoad[0]) + ".*.xml")) " is 140.
Long Statement,Unclassified.TxEditor,FileNameHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\FileNameHelper.cs,FindOtherCultures,The length of the statement  "						customButtons: new string[] { Tx.T("task dialog.button.load all")' Tx.T("task dialog.button.load one")' Tx.T("task dialog.button.cancel") }' " is 140.
Long Statement,Unclassified.TxEditor,Program,C:\repos\dg9ngf_TxTranslation\TxEditor\Program.cs,InitializeLocalisation,The length of the statement  "					App.ErrorMessage("The configured application UI culture cannot be set."' ex' "Setting application culture from configuration"); " is 127.
Long Statement,Unclassified.TxEditor,App,C:\repos\dg9ngf_TxTranslation\TxEditor\App.xaml.cs,OnStartup,The length of the statement  "			//                if (App.YesNoQuestion("Other Tx dictionary files are located in the same directory as the selected file. Should they also be loaded?")) " is 153.
Long Statement,Unclassified.TxEditor.Controls,AcceptProblemButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\AcceptProblemButton.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/TxEditor;component/controls/acceptproblembutton.xaml"' System.UriKind.Relative); " is 126.
Long Statement,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The length of the statement  "					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1); " is 200.
Long Statement,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/TxEditor;component/controls/decoratedtextbox.xaml"' System.UriKind.Relative); " is 123.
Long Statement,Unclassified.TxEditor.Converters,TreeNodesConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Converters\TreeNodesConverter.cs,Convert,The length of the statement  "					return new DetailsMessageViewModel(Tx.T("msg.incomplete key selected")' Tx.T("msg.incomplete key selected.desc")' "ArrowLeft"); " is 127.
Long Statement,Unclassified.TxEditor.Converters,TreeNodesConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Converters\TreeNodesConverter.cs,Convert,The length of the statement  "					return new DetailsMessageViewModel("Inconsistent selection"' "Multiple items of different types are selected. Only elements of the same type can be displayed and edited concurrently."' "Flash"); " is 194.
Long Statement,Unclassified.UI,WindowExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\WindowExtensions.cs,HideIcon,The length of the statement  "				SendMessage(hwnd' WM_SETICON' new IntPtr(1)' IntPtr.Zero);   // Important if there's a native icon resource in the .exe file " is 124.
Long Statement,Unclassified.UI,IconButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconButton.xaml.cs,OnContentChanged,The length of the statement  "			ContentVisibility = (newContent is string ? !string.IsNullOrEmpty((string)newContent) : newContent != null) ? Visibility.Visible : Visibility.Collapsed; " is 152.
Long Statement,Unclassified.UI,IconButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconButton.xaml.cs,UpdateToolTip,The length of the statement  "			bool showToolTip = ContentVisibility == Visibility.Collapsed || !string.IsNullOrEmpty(HotkeyText) || !string.IsNullOrEmpty(ExtendedToolTipText); " is 144.
Long Statement,Unclassified.UI,IconButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconButton.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/TxEditor;component/unclassified/ui/iconbutton.xaml"' System.UriKind.Relative); " is 124.
Long Statement,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,OnContentChanged,The length of the statement  "			ContentVisibility = (newContent is string ? !string.IsNullOrEmpty((string)newContent) : newContent != null) ? Visibility.Visible : Visibility.Collapsed; " is 152.
Long Statement,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,UpdateToolTip,The length of the statement  "			bool showToolTip = ContentVisibility == Visibility.Collapsed || !string.IsNullOrEmpty(HotkeyText) || !string.IsNullOrEmpty(ExtendedToolTipText); " is 144.
Long Statement,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/TxEditor;component/unclassified/ui/icontogglebutton.xaml"' System.UriKind.Relative); " is 130.
Long Statement,Unclassified.UI,OpenFolderDialog,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\OpenFolderDialog.cs,ShowVistaDialog,The length of the statement  "				if (NativeMethods.SHCreateItemFromParsingName(InitialFolder' IntPtr.Zero' ref riid' out directoryShellItem) == NativeMethods.S_OK) " is 130.
Long Statement,Unclassified.UI,OpenFolderDialog,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\OpenFolderDialog.cs,ShowVistaDialog,The length of the statement  "				if (NativeMethods.SHCreateItemFromParsingName(DefaultFolder' IntPtr.Zero' ref riid' out directoryShellItem) == NativeMethods.S_OK) " is 130.
Long Statement,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The length of the statement  "				p.Data = Geometry.Parse("M" + ts(x0) + "'" + ts(y0) + " A" + ts(radius) + "'" + ts(radius) + " " + ts(step) + " 0 1 " + ts(x1) + "'" + ts(y1)); " is 143.
Long Statement,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/TxEditor;component/unclassified/ui/progressspinner.xaml"' System.UriKind.Relative); " is 129.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,SetTimeComponent,The length of the statement  "				selectedTime = new DateTime(value' selectedTime.Month' day' selectedTime.Hour' selectedTime.Minute' selectedTime.Second); " is 121.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,SetTimeComponent,The length of the statement  "				selectedTime = new DateTime(selectedTime.Year' value' day' selectedTime.Hour' selectedTime.Minute' selectedTime.Second); " is 120.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,SetTimeComponent,The length of the statement  "				selectedTime = new DateTime(selectedTime.Year' selectedTime.Month' value' selectedTime.Hour' selectedTime.Minute' selectedTime.Second); " is 135.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,SetTimeComponent,The length of the statement  "				selectedTime = new DateTime(selectedTime.Year' selectedTime.Month' selectedTime.Day' value' selectedTime.Minute' selectedTime.Second); " is 134.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,SetTimeComponent,The length of the statement  "				selectedTime = new DateTime(selectedTime.Year' selectedTime.Month' selectedTime.Day' selectedTime.Hour' value' selectedTime.Second); " is 132.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,SetTimeComponent,The length of the statement  "				selectedTime = new DateTime(selectedTime.Year' selectedTime.Month' selectedTime.Day' selectedTime.Hour' selectedTime.Minute' value); " is 132.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/TxEditor;component/unclassified/ui/datetimetextbox.xaml"' System.UriKind.Relative); " is 129.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The length of the statement  "            this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting)); " is 134.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The length of the statement  "            this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting)); " is 135.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The length of the statement  "            this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting)); " is 133.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The length of the statement  "            this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting)); " is 134.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The length of the statement  "            this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting)); " is 136.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The length of the statement  "            this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting)); " is 136.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The length of the statement  "            ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click); " is 128.
Long Statement,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The length of the statement  "            ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click); " is 130.
Long Statement,Unclassified.Util,DelayedCall,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\DelayedCall.cs,PrepareDCObject,The length of the statement  "					throw new InvalidOperationException("Cannot delay calls synchronously on a non-UI thread. Use the *Async methods instead."); " is 124.
Long Statement,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,CheckType,The length of the statement  "			// TODO: Enum and Array handling should not be done here but only in the code generation of SettingsAdapterFactory (see also Set method below) " is 142.
Long Statement,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Load,The length of the statement  "										else if (long.TryParse(itemNode.InnerText' NumberStyles.Integer' CultureInfo.InvariantCulture' out lng))   // Old format: Ticks as long integer " is 143.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateType,The length of the statement  "			FieldBuilder settingsStoreField = typeBuilder.DefineField("settingsStore"' typeof(ISettingsStore)' FieldAttributes.Private); " is 124.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateType,The length of the statement  "					FieldBuilder backingField = typeBuilder.DefineField("_" + propertyInfo.Name' propertyInfo.PropertyType' FieldAttributes.Private); " is 129.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateConstructor,The length of the statement  "#pragma warning disable 1720   // Expression will always cause a System.NullReferenceException because the default value of 'generic type' is null " is 146.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateConstructor,The length of the statement  "#pragma warning disable 1720   // Expression will always cause a System.NullReferenceException because the default value of 'generic type' is null " is 146.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateConstructor,The length of the statement  "					ilGen.Emit(OpCodes.Newobj' generatedTypes[field.FieldType].GetConstructor(new[] { typeof(ISettingsStore)' typeof(string) })); " is 125.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateConstructor,The length of the statement  "			ilGen.Emit(OpCodes.Newobj' typeof(PropertyChangedEventHandler).GetConstructor(new[] { typeof(object)' typeof(IntPtr) })); " is 121.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateOnPropertyChanged,The length of the statement  "			//         var subHandler = propVal.GetType().GetMethod("OnPropertyChanged"' BindingFlags.Instance | BindingFlags.NonPublic); " is 125.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateOnPropertyChanged,The length of the statement  "			//         subHandler.Invoke(propVal' new object[] { this' new PropertyChangedEventArgs(args.PropertyName.Substring(pointIndex + 1)) }); " is 136.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateOnPropertyChanged,The length of the statement  "			// subHandler.Invoke(propVal' new object[] { this' new PropertyChangedEventArgs(args.PropertyName.Substring(pointIndex + 1)) }); " is 128.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,GenerateCall,The length of the statement  "			ilGen.EmitCall(OpCodes.Call' typeof(TType).GetMethod(methodName' new[] { typeof(TArg1)' typeof(TArg2)' typeof(TArg3) })' null); " is 127.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,GenerateCall,The length of the statement  "			ilGen.EmitCall(OpCodes.Call' typeof(TType).GetMethod(methodName' new[] { typeof(TArg1)' typeof(TArg2)' typeof(TArg3)' typeof(TArg4) })' null); " is 142.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,GenerateCallVirt,The length of the statement  "			ilGen.EmitCall(OpCodes.Callvirt' typeof(TType).GetMethod(methodName' new[] { typeof(TArg1)' typeof(TArg2)' typeof(TArg3) })' null); " is 131.
Long Statement,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,GenerateCallVirt,The length of the statement  "			ilGen.EmitCall(OpCodes.Callvirt' typeof(TType).GetMethod(methodName' new[] { typeof(TArg1)' typeof(TArg2)' typeof(TArg3)' typeof(TArg4) })' null); " is 146.
Long Statement,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The length of the statement  "					bool thisPrimary = string.Compare(CultureName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0; " is 136.
Long Statement,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The length of the statement  "					bool otherPrimary = string.Compare(otherName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0; " is 135.
Long Statement,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The length of the statement  "				if (string.Compare(CultureName.Substring(0' 2)' otherName.Substring(0' 2)' StringComparison.InvariantCultureIgnoreCase) == 0) " is 125.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,CheckModifiedSaved,The length of the statement  "					customButtons: new string[] { Tx.T("task dialog.button.save")' Tx.T("task dialog.button.dont save")' Tx.T("task dialog.button.cancel") }' " is 137.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,DoLoadFiles,The length of the statement  "				App.WarningMessage(Tx.T("msg.load file.multiple primary cultures"' "list"' string.Join("' "' primaryCultureFiles)' "name"' PrimaryCulture)); " is 140.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,DoLoadFiles,The length of the statement  "			StatusText = Tx.T("statusbar.n files loaded"' filesToLoad.Count) + Tx.T("statusbar.n text keys defined"' TextKeys.Count); " is 121.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnDeleteTextKey,The length of the statement  "				// TODO: Check whether any selected key is a child of another selected key -> don't count them additionally - collect all selected keys in a HashSet' then count " is 160.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnDeleteTextKey,The length of the statement  "					radioButtons: new string[] { Tx.T("msg.delete text key.multiple.also subkeys")' Tx.T("msg.delete text key.multiple.only selected") }' " is 133.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnDeleteTextKey,The length of the statement  "				var remainingItem = lastSelectedTk.FindRemainingItem(t => !selectedTextKeys.Contains(t) && !selectedTextKeys.Any(s => s.IsAParentOf(t))); " is 137.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The length of the statement  "				new WinApi.INPUT() { type = WinApi.INPUT_KEYBOARD' ki = new WinApi.KEYBDINPUT() { wVk = (short) WinApi.VK.CONTROL' dwFlags = WinApi.KEYEVENTF_KEYUP } }' " is 152.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The length of the statement  "				new WinApi.INPUT() { type = WinApi.INPUT_KEYBOARD' ki = new WinApi.KEYBDINPUT() { wVk = (short) WinApi.VK.SHIFT' dwFlags = WinApi.KEYEVENTF_KEYUP } }' " is 150.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The length of the statement  "				new WinApi.INPUT() { type = WinApi.INPUT_KEYBOARD' ki = new WinApi.KEYBDINPUT() { wVk = (short) WinApi.KeyToVk(System.Windows.Forms.Keys.C) } }' " is 144.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The length of the statement  "				new WinApi.INPUT() { type = WinApi.INPUT_KEYBOARD' ki = new WinApi.KEYBDINPUT() { wVk = (short) WinApi.KeyToVk(System.Windows.Forms.Keys.C)' dwFlags = WinApi.KEYEVENTF_KEYUP } }' " is 178.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The length of the statement  "				new WinApi.INPUT() { type = WinApi.INPUT_KEYBOARD' ki = new WinApi.KEYBDINPUT() { wVk = (short) WinApi.VK.CONTROL' dwFlags = WinApi.KEYEVENTF_KEYUP } }' " is 152.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The length of the statement  "			uint ret = WinApi.SendInput((uint)inputs.Length' inputs' System.Runtime.InteropServices.Marshal.SizeOf(typeof(WinApi.INPUT))); " is 126.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The length of the statement  "					new WinApi.INPUT() { type = WinApi.INPUT_KEYBOARD' ki = new WinApi.KEYBDINPUT() { wVk = (short) WinApi.KeyToVk(System.Windows.Forms.Keys.V) } }' " is 144.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The length of the statement  "					new WinApi.INPUT() { type = WinApi.INPUT_KEYBOARD' ki = new WinApi.KEYBDINPUT() { wVk = (short) WinApi.KeyToVk(System.Windows.Forms.Keys.V)' dwFlags = WinApi.KEYEVENTF_KEYUP } }' " is 178.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The length of the statement  "					new WinApi.INPUT() { type = WinApi.INPUT_KEYBOARD' ki = new WinApi.KEYBDINPUT() { wVk = (short) WinApi.VK.CONTROL' dwFlags = WinApi.KEYEVENTF_KEYUP } }' " is 152.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The length of the statement  "				uint ret = WinApi.SendInput((uint)inputs.Length' inputs' System.Runtime.InteropServices.Marshal.SizeOf(typeof(WinApi.INPUT))); " is 126.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFiles,The length of the statement  "				App.WarningMessage(Tx.T("msg.load file.multiple primary cultures"' "list"' string.Join("' "' primaryCultureFiles)' "name"' PrimaryCulture)); " is 140.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXmlFile,The length of the statement  "			Match m = Regex.Match(Path.GetFileName(fileName)' @"^(.+?)\.(([a-z]{2})([-][a-z]{2})?)\.(?:txd|xml)$"' RegexOptions.IgnoreCase); " is 128.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXmlFile,The length of the statement  "						customButtons: new string[] { Tx.T("task dialog.button.add culture")' Tx.T("task dialog.button.skip culture")' Tx.T("task dialog.button.cancel") }); " is 148.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXmlFile,The length of the statement  "							customButtons: new string[] { Tx.T("task dialog.button.add culture")' Tx.T("task dialog.button.skip culture")' Tx.T("task dialog.button.cancel") }' " is 147.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The length of the statement  "							App.ErrorMessage(Tx.T("msg.cannot delete backup file"' "name"' cultureFileName + ".bak")' ex' "Saving file' deleting old backups"); " is 131.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The length of the statement  "						App.ErrorMessage(Tx.T("msg.cannot write file.v1"' "name"' fileNamePrefix + "." + cultureName + ".xml")' ex' "Saving file"); " is 123.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The length of the statement  "						App.ErrorMessage(Tx.T("msg.cannot delete backup file"' "name"' fileNamePrefix + ".txd.bak")' ex' "Saving file' deleting old backup"); " is 133.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The length of the statement  "						App.ErrorMessage(Tx.T("msg.cannot backup file.v2"' "name"' fileNamePrefix + ".txd")' ex' "Saving file' creating backup"); " is 121.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The length of the statement  "				xmlDoc.AppendChild(xmlDoc.CreateComment(" TxTranslation dictionary file. Use TxEditor to edit this file. http://unclassified.software/txtranslation ")); " is 152.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The length of the statement  "							App.ErrorMessage(Tx.T("msg.cannot write file.v2"' "name"' fileNamePrefix + ".txd"' "firstmsg"' ex.Message)' ex2' "Saving file' restoring backup"); " is 146.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The length of the statement  "					App.ErrorMessage(Tx.T("msg.cannot delete new backup file.v2"' "name"' fileNamePrefix + ".txd.bak")' ex' "Saving file' deleting new backup"); " is 140.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The length of the statement  "						textKeyVM.IsEmpty() && cultureName == PrimaryCulture && !textKeyVM.TextKey.StartsWith("Tx:") ||   // Save empty text keys in the primary culture at least (not for system keys) " is 175.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The length of the statement  "						cultureName == PrimaryCulture && !string.IsNullOrWhiteSpace(textKeyVM.Comment) ||   // Always keep comments in the primary culture " is 130.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The length of the statement  "						cultureTextVM.AcceptMissing || cultureTextVM.AcceptPlaceholders || cultureTextVM.AcceptPunctuation)   // Keep accept flags " is 122.
Long Statement,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,InsertSystemKeys,The length of the statement  "				Stream templateStream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream("Unclassified.TxEditor.Template.txd"); " is 138.
Long Statement,Unclassified.TxEditor.Views,CultureWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\CultureWindow.xaml.cs,CodeText_TextChanged,The length of the statement  "				.FirstOrDefault(ci => ci.CultureInfo.IetfLanguageTag.Equals(CodeText.Text' StringComparison.InvariantCultureIgnoreCase)); " is 121.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Window_Loaded,The length of the statement  "				TranslationText.FontFamily = monospaceFontConverter.Convert(App.Settings.View.MonospaceFont' null' null' null) as FontFamily; " is 125.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) && " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) && " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)) " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)) " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)) " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)) " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)) " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)) " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)) " is 130.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "			suggestions.Sort((a' b) => a.ScoreNum != b.ScoreNum ? -a.ScoreNum.CompareTo(b.ScoreNum) : a.TextKey.CompareTo(b.TextKey)); " is 122.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The length of the statement  "				suggestions.Insert(0' new SuggestionViewModel(null) { TextKey = prevTextKey' BaseText = "(previous text key)"' IsDummy = true }); " is 129.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ScanAllTexts,The length of the statement  "				suggestions.Add(new SuggestionViewModel(null) { TextKey = tk.TextKey' BaseText = tk.CultureTextVMs[0].Text' ScoreNum = 1000' IsExactMatch = true }); " is 148.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ScanAllTexts,The length of the statement  "				// TODO: Maybe we should split both strings in words and compare them separately' only accepting if at least one word has a small distance " is 138.
Long Statement,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ScanAllTexts,The length of the statement  "					suggestions.Add(new SuggestionViewModel(null) { TextKey = tk.TextKey' BaseText = tk.CultureTextVMs[0].Text' ScoreNum = score }); " is 128.
Long Statement,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,AutoCollapseItems,The length of the statement  "			Dispatcher.BeginInvoke((Action)(() => { collapsingItems = false; })' System.Windows.Threading.DispatcherPriority.Loaded); " is 121.
Long Statement,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,TextKeysTreeView_ContextMenuOpening,The length of the statement  "					menuItem.Visibility = menuItem.Command != null && menuItem.Command.CanExecute(null) ? Visibility.Visible : Visibility.Collapsed; " is 128.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\obj\x86\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,Unclassified.Util,ClipboardHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\ClipboardHelper.cs,GetDataObject,The conditional expression  "format == "Bitmap" ||  					format == "FileDrop" ||  					format == "FileName" ||  					format == "FileNameW" ||  					format == "HTML Format" ||  					format == "Rich Text Format" ||  					format == "Text" ||  					format == "UnicodeText""  is complex.
Complex Conditional,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,CheckType,The conditional expression  "newValue is string ||  				newValue is string[] ||  				newValue is int ||  				newValue is int[] ||  				newValue is long ||  				newValue is long[] ||  				newValue is double ||  				newValue is double[] ||  				newValue is decimal ||  				newValue is decimal[] ||  				newValue is bool ||  				newValue is bool[] ||  				newValue is DateTime ||  				newValue is DateTime[] ||  				newValue is TimeSpan ||  				newValue is TimeSpan[] ||  				newValue is NameValueCollection"  is complex.
Complex Conditional,Unclassified.Util,SettingsHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsHelper.cs,BindWindowState,The conditional expression  "settings.Left != int.MinValue &&  				settings.Top != int.MinValue &&  				settings.Width != int.MinValue &&  				settings.Height != int.MinValue"  is complex.
Complex Conditional,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The conditional expression  "parent != null &&  							(parent.Current.ControlType != System.Windows.Automation.ControlType.Pane ||  							parent.Current.ClassName != "ViewPresenter" ||  							string.IsNullOrEmpty(parent.Current.Name))"  is complex.
Complex Conditional,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXmlFile,The conditional expression  "fileIsTemplate && !IsTemplateFile && LoadedCultureNames.Count > 0 ||  					!fileIsTemplate && IsTemplateFile"  is complex.
Complex Conditional,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The conditional expression  "textKeyVM.IsFullKey && textKeyVM.TextKey != null &&  				(!exporting || textKeyVM.IsSelectedRecursive())"  is complex.
Complex Conditional,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The conditional expression  "!string.IsNullOrEmpty(cultureTextVM.Text) ||  						textKeyVM.IsEmpty() && cultureName == PrimaryCulture && !textKeyVM.TextKey.StartsWith("Tx:") ||   // Save empty text keys in the primary culture at least (not for system keys)  						cultureName == PrimaryCulture && !string.IsNullOrWhiteSpace(textKeyVM.Comment) ||   // Always keep comments in the primary culture  						cultureTextVM.AcceptMissing || cultureTextVM.AcceptPlaceholders || cultureTextVM.AcceptPunctuation"  is complex.
Complex Conditional,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The conditional expression  "PrimaryCulture != null && cultureName == PrimaryCulture ||  								PrimaryCulture == null && cultureName == textKeyVM.CultureTextVMs[0].CultureName"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Window_Loaded,The conditional expression  "App.Settings != null &&  				App.Settings.Wizard.RememberLocation &&  				App.Settings.Wizard.WindowLeft != int.MinValue &&  				App.Settings.Wizard.WindowTop != int.MinValue"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "(initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\"")"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "(initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\"")"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The conditional expression  "ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString)"  is complex.
Complex Conditional,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ComputeEditDistance,The conditional expression  "i > 1 && j > 1 && original[i - 1] == modified[j - 2] && original[i - 2] == modified[j - 1]"  is complex.
Virtual Method Call from Constructor,Unclassified.UI,ViewModelBase,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ViewModelBase.cs,ViewModelBase,The constructor "ViewModelBase" calls a virtual method "InitializeCommands".
Empty Catch Block,Unclassified.Util,SettingsStoreBoundDictionary<TKey;TValue>,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,ReadFromStore,The method has an empty catch block.
Empty Catch Block,Unclassified.TxEditor.ViewModels,SelectFileViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\SelectFileViewModel.cs,ScanDirectory,The method has an empty catch block.
Empty Catch Block,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,UpdateSuggestions,The method has an empty catch block.
Magic Number,Unclassified.TxEditor,App,C:\repos\dg9ngf_TxTranslation\TxEditor\App.xaml.cs,InitializeSettings,The following statement contains a magic number: if (string.IsNullOrEmpty(Settings.LastStartedAppVersion))  			{  				Settings.SettingsStore.Rename("app-culture"' "AppCulture");  				Settings.SettingsStore.Rename("file.ask-save-upgrade"' "File.AskSaveUpgrade");  				Settings.SettingsStore.Rename("input.charmap"' "Input.CharacterMap");  				Settings.SettingsStore.Rename("view.comments"' "View.ShowComments");  				Settings.SettingsStore.Rename("view.monospace-font"' "View.MonospaceFont");  				Settings.SettingsStore.Rename("view.hidden-chars"' "View.ShowHiddenChars");  				Settings.SettingsStore.Rename("view.charmap"' "View.ShowCharacterMap");  				Settings.SettingsStore.Rename("view.font-scale"' "View.FontScale");  				Settings.SettingsStore.Rename("view.native-culture-names"' "View.NativeCultureNames");  				Settings.SettingsStore.Rename("view.suggestions"' "View.ShowSuggestions");  				Settings.SettingsStore.Rename("view.suggestions.horizontal-layout"' "View.SuggestionsHorizontalLayout");  				Settings.SettingsStore.Rename("view.suggestions.width"' "View.SuggestionsWidth");  				Settings.SettingsStore.Rename("view.suggestions.height"' "View.SuggestionsHeight");  				Settings.SettingsStore.Rename("wizard.source-code"' "Wizard.SourceCode");  				Settings.SettingsStore.Rename("wizard.remember-location"' "Wizard.RememberLocation");  				Settings.SettingsStore.Rename("wizard.hotkey-in-visual-studio-only"' "Wizard.HotkeyInVisualStudioOnly");  				Settings.SettingsStore.Rename("window.left"' "View.MainWindowState.Left");  				Settings.SettingsStore.Rename("window.top"' "View.MainWindowState.Top");  				Settings.SettingsStore.Rename("window.width"' "View.MainWindowState.Width");  				Settings.SettingsStore.Rename("window.height"' "View.MainWindowState.Height");  				Settings.View.MainWindowState.IsMaximized = Settings.SettingsStore.GetInt("window.state") == 2;  				Settings.SettingsStore.Remove("window.state");  				Settings.SettingsStore.Rename("wizard.window.left"' "Wizard.WindowLeft");  				Settings.SettingsStore.Rename("wizard.window.top"' "Wizard.WindowTop");  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(242' 245' 225));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(242' 245' 225));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(242' 245' 225));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: while (m.Success)  			{  				Rect startRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index);  				Rect endRect = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + m.Groups[0].Length);    				string refKey = m.Groups[1].Value;  				if (!TextKeyReferences.Contains(refKey))  					TextKeyReferences.Add(refKey);    				bool isValidKey = true;  				if (!IsEditing)  					isValidKey = DoValidateKey(refKey);    				if (!startRect.IsEmpty && !endRect.IsEmpty)  				{  					if ((int)startRect.Top == (int)endRect.Top)  					{  						// Single line  						Rectangle rect = new Rectangle();  						rect.HorizontalAlignment = HorizontalAlignment.Left;  						rect.VerticalAlignment = VerticalAlignment.Top;  						rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  						rect.Width = endRect.Left - startRect.Left;  						rect.Height = startRect.Height;  						rect.Fill = new SolidColorBrush(Color.FromRgb(232' 246' 248));  						grid1.Children.Insert(0' rect);  						decos.Add(rect);    						if (!isValidKey)  						{  							Rect startRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2);  							Rect endRectKey = textBox1.GetRectFromCharacterIndex(m.Groups[0].Index + 2 + m.Groups[1].Length);    							rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRectKey.Left' startRectKey.Bottom - 2' 0' -2);  							rect.Width = endRectKey.Left - startRectKey.Left;  							if (rect.Width < 5)  								rect.Width = 5;  							rect.Height = 3;  							rect.Fill = Resources["SquiggleBrush"] as Brush;  							grid1.Children.Insert(grid1.Children.Count - 2' rect);  							decos.Add(rect);  						}  					}  					else  					{  						// Spanning multiple lines  						// Need more rectangles  						// TODO  					}  				}  				m = m.NextMatch();  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (!string.IsNullOrEmpty(SearchText))  			{  				int start = -1;  				while ((start = textBox1.Text.ToLower().IndexOf(SearchText.ToLower()' start + 1)) != -1)  				{  					Rect startRect = textBox1.GetRectFromCharacterIndex(start);  					Rect endRect = textBox1.GetRectFromCharacterIndex(start + SearchText.Length);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							Rectangle rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  							rect.Width = endRect.Left - startRect.Left;  							rect.Height = startRect.Height;  							rect.Fill = new SolidColorBrush(Color.FromArgb(128' 255' 255' 0));  							grid1.Children.Insert(0' rect);  							decos.Add(rect);  						}  						else  						{  							// Spanning multiple lines  							// Need more rectangles  							// TODO  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (!string.IsNullOrEmpty(SearchText))  			{  				int start = -1;  				while ((start = textBox1.Text.ToLower().IndexOf(SearchText.ToLower()' start + 1)) != -1)  				{  					Rect startRect = textBox1.GetRectFromCharacterIndex(start);  					Rect endRect = textBox1.GetRectFromCharacterIndex(start + SearchText.Length);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							Rectangle rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  							rect.Width = endRect.Left - startRect.Left;  							rect.Height = startRect.Height;  							rect.Fill = new SolidColorBrush(Color.FromArgb(128' 255' 255' 0));  							grid1.Children.Insert(0' rect);  							decos.Add(rect);  						}  						else  						{  							// Spanning multiple lines  							// Need more rectangles  							// TODO  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (!string.IsNullOrEmpty(SearchText))  			{  				int start = -1;  				while ((start = textBox1.Text.ToLower().IndexOf(SearchText.ToLower()' start + 1)) != -1)  				{  					Rect startRect = textBox1.GetRectFromCharacterIndex(start);  					Rect endRect = textBox1.GetRectFromCharacterIndex(start + SearchText.Length);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							Rectangle rect = new Rectangle();  							rect.HorizontalAlignment = HorizontalAlignment.Left;  							rect.VerticalAlignment = VerticalAlignment.Top;  							rect.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  							rect.Width = endRect.Left - startRect.Left;  							rect.Height = startRect.Height;  							rect.Fill = new SolidColorBrush(Color.FromArgb(128' 255' 255' 0));  							grid1.Children.Insert(0' rect);  							decos.Add(rect);  						}  						else  						{  							// Spanning multiple lines  							// Need more rectangles  							// TODO  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (HiddenChars)  			{  				int pos = -1;  				while (true)  				{  					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1);  					if (pos < 0) break;    					Rect startRect = textBox1.GetRectFromCharacterIndex(pos);  					Rect endRect = textBox1.GetRectFromCharacterIndex(pos + 1);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						TextBlock tb;  						double width = double.NaN;  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							width = endRect.X - startRect.X;  						}  						else  						{  							// Spanning multiple lines  						}    						switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (HiddenChars)  			{  				int pos = -1;  				while (true)  				{  					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1);  					if (pos < 0) break;    					Rect startRect = textBox1.GetRectFromCharacterIndex(pos);  					Rect endRect = textBox1.GetRectFromCharacterIndex(pos + 1);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						TextBlock tb;  						double width = double.NaN;  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							width = endRect.X - startRect.X;  						}  						else  						{  							// Spanning multiple lines  						}    						switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (HiddenChars)  			{  				int pos = -1;  				while (true)  				{  					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1);  					if (pos < 0) break;    					Rect startRect = textBox1.GetRectFromCharacterIndex(pos);  					Rect endRect = textBox1.GetRectFromCharacterIndex(pos + 1);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						TextBlock tb;  						double width = double.NaN;  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							width = endRect.X - startRect.X;  						}  						else  						{  							// Spanning multiple lines  						}    						switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (HiddenChars)  			{  				int pos = -1;  				while (true)  				{  					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1);  					if (pos < 0) break;    					Rect startRect = textBox1.GetRectFromCharacterIndex(pos);  					Rect endRect = textBox1.GetRectFromCharacterIndex(pos + 1);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						TextBlock tb;  						double width = double.NaN;  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							width = endRect.X - startRect.X;  						}  						else  						{  							// Spanning multiple lines  						}    						switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (HiddenChars)  			{  				int pos = -1;  				while (true)  				{  					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1);  					if (pos < 0) break;    					Rect startRect = textBox1.GetRectFromCharacterIndex(pos);  					Rect endRect = textBox1.GetRectFromCharacterIndex(pos + 1);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						TextBlock tb;  						double width = double.NaN;  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							width = endRect.X - startRect.X;  						}  						else  						{  							// Spanning multiple lines  						}    						switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (HiddenChars)  			{  				int pos = -1;  				while (true)  				{  					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1);  					if (pos < 0) break;    					Rect startRect = textBox1.GetRectFromCharacterIndex(pos);  					Rect endRect = textBox1.GetRectFromCharacterIndex(pos + 1);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						TextBlock tb;  						double width = double.NaN;  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							width = endRect.X - startRect.X;  						}  						else  						{  							// Spanning multiple lines  						}    						switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (HiddenChars)  			{  				int pos = -1;  				while (true)  				{  					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1);  					if (pos < 0) break;    					Rect startRect = textBox1.GetRectFromCharacterIndex(pos);  					Rect endRect = textBox1.GetRectFromCharacterIndex(pos + 1);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						TextBlock tb;  						double width = double.NaN;  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							width = endRect.X - startRect.X;  						}  						else  						{  							// Spanning multiple lines  						}    						switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following statement contains a magic number: if (HiddenChars)  			{  				int pos = -1;  				while (true)  				{  					pos = textBox1.Text.IndexOfAny(new char[] { ' '' '\n'' '\t'' '\xa0'' '\x2002'' '\x2003'' '\x2004'' '\x2005'' '\x2006'' '\x2007'' '\x2008'' '\x2009'' '\x200a'' '\x200b'' '\x202f'' '\x205f' }' pos + 1);  					if (pos < 0) break;    					Rect startRect = textBox1.GetRectFromCharacterIndex(pos);  					Rect endRect = textBox1.GetRectFromCharacterIndex(pos + 1);    					if (!startRect.IsEmpty && !endRect.IsEmpty)  					{  						TextBlock tb;  						double width = double.NaN;  						if ((int)startRect.Top == (int)endRect.Top)  						{  							// Single line  							width = endRect.X - startRect.X;  						}  						else  						{  							// Spanning multiple lines  						}    						switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.root = ((Unclassified.TxEditor.Controls.DecoratedTextBox)(target));              return;              case 2:              this.grid1 = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.textBox1 = ((System.Windows.Controls.TextBox)(target));                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.textBox1_TextChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.SelectionChanged += new System.Windows.RoutedEventHandler(this.textBox1_SelectionChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.textBox1_KeyDown);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.GotFocus += new System.Windows.RoutedEventHandler(this.textBox1_GotFocus);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.LostFocus += new System.Windows.RoutedEventHandler(this.textBox1_LostFocus);                            #line default              #line hidden              return;              case 4:              this.TextBoxExtraBorderCompensation = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.TextBoxBorderEquivalent = ((System.Windows.Controls.Border)(target));              return;              case 6:              this.placeholder = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.root = ((Unclassified.TxEditor.Controls.DecoratedTextBox)(target));              return;              case 2:              this.grid1 = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.textBox1 = ((System.Windows.Controls.TextBox)(target));                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.textBox1_TextChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.SelectionChanged += new System.Windows.RoutedEventHandler(this.textBox1_SelectionChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.textBox1_KeyDown);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.GotFocus += new System.Windows.RoutedEventHandler(this.textBox1_GotFocus);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.LostFocus += new System.Windows.RoutedEventHandler(this.textBox1_LostFocus);                            #line default              #line hidden              return;              case 4:              this.TextBoxExtraBorderCompensation = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.TextBoxBorderEquivalent = ((System.Windows.Controls.Border)(target));              return;              case 6:              this.placeholder = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.root = ((Unclassified.TxEditor.Controls.DecoratedTextBox)(target));              return;              case 2:              this.grid1 = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.textBox1 = ((System.Windows.Controls.TextBox)(target));                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.textBox1_TextChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.SelectionChanged += new System.Windows.RoutedEventHandler(this.textBox1_SelectionChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.textBox1_KeyDown);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.GotFocus += new System.Windows.RoutedEventHandler(this.textBox1_GotFocus);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.LostFocus += new System.Windows.RoutedEventHandler(this.textBox1_LostFocus);                            #line default              #line hidden              return;              case 4:              this.TextBoxExtraBorderCompensation = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.TextBoxBorderEquivalent = ((System.Windows.Controls.Border)(target));              return;              case 6:              this.placeholder = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.root = ((Unclassified.TxEditor.Controls.DecoratedTextBox)(target));              return;              case 2:              this.grid1 = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.textBox1 = ((System.Windows.Controls.TextBox)(target));                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.textBox1_TextChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.SelectionChanged += new System.Windows.RoutedEventHandler(this.textBox1_SelectionChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.textBox1_KeyDown);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.GotFocus += new System.Windows.RoutedEventHandler(this.textBox1_GotFocus);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.LostFocus += new System.Windows.RoutedEventHandler(this.textBox1_LostFocus);                            #line default              #line hidden              return;              case 4:              this.TextBoxExtraBorderCompensation = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.TextBoxBorderEquivalent = ((System.Windows.Controls.Border)(target));              return;              case 6:              this.placeholder = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.root = ((Unclassified.TxEditor.Controls.DecoratedTextBox)(target));              return;              case 2:              this.grid1 = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.textBox1 = ((System.Windows.Controls.TextBox)(target));                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.textBox1_TextChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.SelectionChanged += new System.Windows.RoutedEventHandler(this.textBox1_SelectionChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.textBox1_KeyDown);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.GotFocus += new System.Windows.RoutedEventHandler(this.textBox1_GotFocus);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.LostFocus += new System.Windows.RoutedEventHandler(this.textBox1_LostFocus);                            #line default              #line hidden              return;              case 4:              this.TextBoxExtraBorderCompensation = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.TextBoxBorderEquivalent = ((System.Windows.Controls.Border)(target));              return;              case 6:              this.placeholder = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,Unclassified.TxEditor.Converters,TreeNodesConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Converters\TreeNodesConverter.cs,Convert,The following statement contains a magic number: int itemsCount = (int)values[2];
Magic Number,Unclassified.UI,MenuIconImage,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\MenuIconImage.cs,MenuIconImage,The following statement contains a magic number: Setter setter = new Setter(Image.OpacityProperty' 0.5);
Magic Number,Unclassified.UI,WindowExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\WindowExtensions.cs,Flash,The following statement contains a magic number: if (hWnd.ToInt64() != 0)  			{  				FLASHWINFO fInfo = new FLASHWINFO();  				fInfo.cbSize = Convert.ToUInt32(Marshal.SizeOf(fInfo));  				fInfo.hwnd = hWnd;  				fInfo.dwFlags = FLASHW_TIMER | FLASHW_TRAY;  				fInfo.uCount = 3;  				fInfo.dwTimeout = 0;  				return FlashWindowEx(ref fInfo);  			}
Magic Number,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The following statement contains a magic number: anim.AccelerationRatio = 0.5;
Magic Number,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The following statement contains a magic number: anim.DecelerationRatio = 0.5;
Magic Number,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The following statement contains a magic number: anim.AccelerationRatio = 0.5;
Magic Number,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The following statement contains a magic number: anim.DecelerationRatio = 0.5;
Magic Number,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The following statement contains a magic number: anim.AccelerationRatio = 0.5;
Magic Number,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The following statement contains a magic number: anim.DecelerationRatio = 0.5;
Magic Number,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The following statement contains a magic number: anim.AccelerationRatio = 0.5;
Magic Number,Unclassified.UI,AnimationHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\AnimationHelper.cs,AnimateEase,The following statement contains a magic number: anim.DecelerationRatio = 0.5;
Magic Number,Unclassified.UI,ColorMath,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ColorMath.cs,ProvideValue,The following statement contains a magic number: if (Lighten != 0)  			{  				byte r = (byte)Math.Round(c.R * (1 - Lighten) + 255 * Lighten);  				byte g = (byte)Math.Round(c.G * (1 - Lighten) + 255 * Lighten);  				byte b = (byte)Math.Round(c.B * (1 - Lighten) + 255 * Lighten);  				c = Color.FromArgb(c.A' r' g' b);  			}
Magic Number,Unclassified.UI,ColorMath,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ColorMath.cs,ProvideValue,The following statement contains a magic number: if (Lighten != 0)  			{  				byte r = (byte)Math.Round(c.R * (1 - Lighten) + 255 * Lighten);  				byte g = (byte)Math.Round(c.G * (1 - Lighten) + 255 * Lighten);  				byte b = (byte)Math.Round(c.B * (1 - Lighten) + 255 * Lighten);  				c = Color.FromArgb(c.A' r' g' b);  			}
Magic Number,Unclassified.UI,ColorMath,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ColorMath.cs,ProvideValue,The following statement contains a magic number: if (Lighten != 0)  			{  				byte r = (byte)Math.Round(c.R * (1 - Lighten) + 255 * Lighten);  				byte g = (byte)Math.Round(c.G * (1 - Lighten) + 255 * Lighten);  				byte b = (byte)Math.Round(c.B * (1 - Lighten) + 255 * Lighten);  				c = Color.FromArgb(c.A' r' g' b);  			}
Magic Number,Unclassified.UI,IconButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconButton.xaml.cs,UpdateToolTip,The following statement contains a magic number: if (showToolTip)  			{  				if (!string.IsNullOrEmpty(HotkeyText) || !string.IsNullOrEmpty(ExtendedToolTipText))  				{  					Grid tipGrid = new Grid();  					tipGrid.RowDefinitions.Add(new RowDefinition());  					tipGrid.RowDefinitions.Add(new RowDefinition());  					tipGrid.ColumnDefinitions.Add(new ColumnDefinition());  					tipGrid.MaxWidth = 250;    					TextBlock contentText = new TextBlock();  					contentText.Text = Content as string;  					contentText.Margin = new Thickness(0' 1' 0' 0);  					if (!string.IsNullOrEmpty(HotkeyText))  					{  						contentText.Text += " (" + HotkeyText + ")";  					}  					if (!string.IsNullOrEmpty(ExtendedToolTipText))  					{  						contentText.FontWeight = FontWeights.Bold;  					}  					contentText.TextWrapping = TextWrapping.Wrap;  					tipGrid.Children.Add(contentText);    					if (!string.IsNullOrEmpty(ExtendedToolTipText))  					{  						TextBlock extText = new TextBlock();  						extText.Text = ExtendedToolTipText;  						extText.Margin = new Thickness(0' 6' 0' 0);  						extText.TextWrapping = TextWrapping.Wrap;  						tipGrid.Children.Add(extText);  						Grid.SetRow(extText' 1);  					}    					ToolTip = tipGrid;  				}  				else  				{  					ToolTip = Content;  				}  			}  			else  			{  				ToolTip = null;  			}
Magic Number,Unclassified.UI,IconButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconButton.xaml.cs,UpdateToolTip,The following statement contains a magic number: if (showToolTip)  			{  				if (!string.IsNullOrEmpty(HotkeyText) || !string.IsNullOrEmpty(ExtendedToolTipText))  				{  					Grid tipGrid = new Grid();  					tipGrid.RowDefinitions.Add(new RowDefinition());  					tipGrid.RowDefinitions.Add(new RowDefinition());  					tipGrid.ColumnDefinitions.Add(new ColumnDefinition());  					tipGrid.MaxWidth = 250;    					TextBlock contentText = new TextBlock();  					contentText.Text = Content as string;  					contentText.Margin = new Thickness(0' 1' 0' 0);  					if (!string.IsNullOrEmpty(HotkeyText))  					{  						contentText.Text += " (" + HotkeyText + ")";  					}  					if (!string.IsNullOrEmpty(ExtendedToolTipText))  					{  						contentText.FontWeight = FontWeights.Bold;  					}  					contentText.TextWrapping = TextWrapping.Wrap;  					tipGrid.Children.Add(contentText);    					if (!string.IsNullOrEmpty(ExtendedToolTipText))  					{  						TextBlock extText = new TextBlock();  						extText.Text = ExtendedToolTipText;  						extText.Margin = new Thickness(0' 6' 0' 0);  						extText.TextWrapping = TextWrapping.Wrap;  						tipGrid.Children.Add(extText);  						Grid.SetRow(extText' 1);  					}    					ToolTip = tipGrid;  				}  				else  				{  					ToolTip = Content;  				}  			}  			else  			{  				ToolTip = null;  			}
Magic Number,Unclassified.UI,IconButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconButton.xaml.cs,OnToolTipOpening,The following statement contains a magic number: ToolTipService.SetShowDuration(this' 20000);
Magic Number,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,UpdateToolTip,The following statement contains a magic number: if (showToolTip)  			{  				if (!string.IsNullOrEmpty(HotkeyText) || !string.IsNullOrEmpty(ExtendedToolTipText))  				{  					Grid tipGrid = new Grid();  					tipGrid.RowDefinitions.Add(new RowDefinition());  					tipGrid.RowDefinitions.Add(new RowDefinition());  					tipGrid.ColumnDefinitions.Add(new ColumnDefinition());  					tipGrid.MaxWidth = 250;    					TextBlock contentText = new TextBlock();  					contentText.Text = Content as string;  					contentText.Margin = new Thickness(0' 1' 0' 0);  					if (!string.IsNullOrEmpty(HotkeyText))  					{  						contentText.Text += " (" + HotkeyText + ")";  					}  					if (!string.IsNullOrEmpty(ExtendedToolTipText))  					{  						contentText.FontWeight = FontWeights.Bold;  					}  					contentText.TextWrapping = TextWrapping.Wrap;  					tipGrid.Children.Add(contentText);    					if (!string.IsNullOrEmpty(ExtendedToolTipText))  					{  						TextBlock extText = new TextBlock();  						extText.Text = ExtendedToolTipText;  						extText.Margin = new Thickness(0' 6' 0' 0);  						extText.TextWrapping = TextWrapping.Wrap;  						tipGrid.Children.Add(extText);  						Grid.SetRow(extText' 1);  					}    					ToolTip = tipGrid;  				}  				else  				{  					ToolTip = Content;  				}  			}  			else  			{  				ToolTip = null;  			}
Magic Number,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,UpdateToolTip,The following statement contains a magic number: if (showToolTip)  			{  				if (!string.IsNullOrEmpty(HotkeyText) || !string.IsNullOrEmpty(ExtendedToolTipText))  				{  					Grid tipGrid = new Grid();  					tipGrid.RowDefinitions.Add(new RowDefinition());  					tipGrid.RowDefinitions.Add(new RowDefinition());  					tipGrid.ColumnDefinitions.Add(new ColumnDefinition());  					tipGrid.MaxWidth = 250;    					TextBlock contentText = new TextBlock();  					contentText.Text = Content as string;  					contentText.Margin = new Thickness(0' 1' 0' 0);  					if (!string.IsNullOrEmpty(HotkeyText))  					{  						contentText.Text += " (" + HotkeyText + ")";  					}  					if (!string.IsNullOrEmpty(ExtendedToolTipText))  					{  						contentText.FontWeight = FontWeights.Bold;  					}  					contentText.TextWrapping = TextWrapping.Wrap;  					tipGrid.Children.Add(contentText);    					if (!string.IsNullOrEmpty(ExtendedToolTipText))  					{  						TextBlock extText = new TextBlock();  						extText.Text = ExtendedToolTipText;  						extText.Margin = new Thickness(0' 6' 0' 0);  						extText.TextWrapping = TextWrapping.Wrap;  						tipGrid.Children.Add(extText);  						Grid.SetRow(extText' 1);  					}    					ToolTip = tipGrid;  				}  				else  				{  					ToolTip = Content;  				}  			}  			else  			{  				ToolTip = null;  			}
Magic Number,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,OnToolTipOpening,The following statement contains a magic number: ToolTipService.SetShowDuration(this' 20000);
Magic Number,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,OnPreviewMouseLeftButtonDown,The following statement contains a magic number: if (ShowMenu && ContextMenu != null)  			{  				justPressed = true;  				DelayedCall.Start(() => { justPressed = false; }' 50);  			}
Magic Number,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,OnChecked,The following statement contains a magic number: if (ShowMenu && ContextMenu != null)  			{  				base.OnChecked(args);  				if (cancelOpen)  				{  					DelayedCall.Start(() => { cancelOpen = false; }' 50);  					IsChecked = false;  					return;  				}    				ContextMenu.Closed += ContextMenu_Closed;    				ContextMenu.Placement = System.Windows.Controls.Primitives.PlacementMode.Bottom;  				ContextMenu.PlacementTarget = this;  				ContextMenu.IsOpen = true;  			}
Magic Number,Unclassified.UI,OpenFolderDialog,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\OpenFolderDialog.cs,ShowDialog,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6)  			{  				return ShowVistaDialog(owner);  			}  			else  			{  				return ShowLegacyDialog(owner);  			}
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,OnRenderSizeChanged,The following statement contains a magic number: MainGridRotateTransform.CenterX = sizeInfo.NewSize.Width / 2;
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,OnRenderSizeChanged,The following statement contains a magic number: MainGridRotateTransform.CenterY = sizeInfo.NewSize.Width / 2;
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The following statement contains a magic number: double thickness = length / 5;
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The following statement contains a magic number: double margin = thickness / 2;
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The following statement contains a magic number: double radius = length / 2;
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The following statement contains a magic number: int count = (int)circumference / 2;
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The following statement contains a magic number: double step = 360 / count;
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The following statement contains a magic number: double extraAngle = 1 / circumference * (Math.PI * 2);
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The following statement contains a magic number: for (int index = 0; index < count; index++)  			{  				// Compute start and end angles  				double startAngle = Math.PI * 2 / count * index - extraAngle;  				double endAngle = Math.PI * 2 / count * (index + 1);    				// Compute start and end coordinates of the arc segment  				double x0 = margin + radius + Math.Cos(startAngle) * radius;  				double y0 = margin + radius + Math.Sin(startAngle) * radius;  				double x1 = margin + radius + Math.Cos(endAngle) * radius;  				double y1 = margin + radius + Math.Sin(endAngle) * radius;    				// Determine the path's colour  				Color c = BlendColors(Color' Colors.White' (float)index / (count - 1));  				//byte opacity = (byte) Math.Round(255 - (double) index / (count - 1) * 255);    				// Create the path object  				Path p = new Path();  				p.StrokeThickness = thickness;  				//p.Stroke = new SolidColorBrush(Color.FromArgb(255' opacity' opacity' opacity));  				p.Stroke = new SolidColorBrush(c);  				p.Data = Geometry.Parse("M" + ts(x0) + "'" + ts(y0) + " A" + ts(radius) + "'" + ts(radius) + " " + ts(step) + " 0 1 " + ts(x1) + "'" + ts(y1));  				MainGrid.Children.Add(p);  			}
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Recreate,The following statement contains a magic number: for (int index = 0; index < count; index++)  			{  				// Compute start and end angles  				double startAngle = Math.PI * 2 / count * index - extraAngle;  				double endAngle = Math.PI * 2 / count * (index + 1);    				// Compute start and end coordinates of the arc segment  				double x0 = margin + radius + Math.Cos(startAngle) * radius;  				double y0 = margin + radius + Math.Sin(startAngle) * radius;  				double x1 = margin + radius + Math.Cos(endAngle) * radius;  				double y1 = margin + radius + Math.Sin(endAngle) * radius;    				// Determine the path's colour  				Color c = BlendColors(Color' Colors.White' (float)index / (count - 1));  				//byte opacity = (byte) Math.Round(255 - (double) index / (count - 1) * 255);    				// Create the path object  				Path p = new Path();  				p.StrokeThickness = thickness;  				//p.Stroke = new SolidColorBrush(Color.FromArgb(255' opacity' opacity' opacity));  				p.Stroke = new SolidColorBrush(c);  				p.Data = Geometry.Parse("M" + ts(x0) + "'" + ts(y0) + " A" + ts(radius) + "'" + ts(radius) + " " + ts(step) + " 0 1 " + ts(x1) + "'" + ts(y1));  				MainGrid.Children.Add(p);  			}
Magic Number,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MainGrid = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.MainGridRotateTransform = ((System.Windows.Media.RotateTransform)(target));              return;              }
Magic Number,Unclassified.UI,TextHighlightConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\TextHighlightConverter.cs,Convert,The following statement contains a magic number: if (text != null && search != null && search.Length > 0)  			{  				// Split search string into chunks to highlight any of them  				string[] searches = search.Split('.'' ':').Where(s => s.Length > 0).OrderByDescending(s => s.Length).ToArray();  				// TODO: Configure split characters through property or constructor parameter or something    				// Scan text for matches  				while (true)  				{  					string nextString = null;  					int nextIndex = int.MaxValue;  					foreach (var s in searches)  					{  						int next = text.IndexOf(s' start' StringComparison.CurrentCultureIgnoreCase);  						if (next != -1 && next < nextIndex)  						{  							nextIndex = next;  							nextString = s;  						}  					}  					if (nextIndex == int.MaxValue) break;   // Nothing more found    					if (nextIndex > start)  					{  						// Add unmatched text until the next match  						run = new Run(text.Substring(start' nextIndex - start));  						textblock.Inlines.Add(run);  					}    					// Add next match with hightlighted style  					run = new Run(text.Substring(nextIndex' nextString.Length));  					run.Background = new SolidColorBrush(Color.FromArgb(128' 255' 255' 0));  					textblock.Inlines.Add(run);    					start = nextIndex + nextString.Length;  				}  			}
Magic Number,Unclassified.UI,TextHighlightConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\TextHighlightConverter.cs,Convert,The following statement contains a magic number: if (text != null && search != null && search.Length > 0)  			{  				// Split search string into chunks to highlight any of them  				string[] searches = search.Split('.'' ':').Where(s => s.Length > 0).OrderByDescending(s => s.Length).ToArray();  				// TODO: Configure split characters through property or constructor parameter or something    				// Scan text for matches  				while (true)  				{  					string nextString = null;  					int nextIndex = int.MaxValue;  					foreach (var s in searches)  					{  						int next = text.IndexOf(s' start' StringComparison.CurrentCultureIgnoreCase);  						if (next != -1 && next < nextIndex)  						{  							nextIndex = next;  							nextString = s;  						}  					}  					if (nextIndex == int.MaxValue) break;   // Nothing more found    					if (nextIndex > start)  					{  						// Add unmatched text until the next match  						run = new Run(text.Substring(start' nextIndex - start));  						textblock.Inlines.Add(run);  					}    					// Add next match with hightlighted style  					run = new Run(text.Substring(nextIndex' nextString.Length));  					run.Background = new SolidColorBrush(Color.FromArgb(128' 255' 255' 0));  					textblock.Inlines.Add(run);    					start = nextIndex + nextString.Length;  				}  			}
Magic Number,Unclassified.UI,TextHighlightConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\TextHighlightConverter.cs,Convert,The following statement contains a magic number: if (text != null && search != null && search.Length > 0)  			{  				// Split search string into chunks to highlight any of them  				string[] searches = search.Split('.'' ':').Where(s => s.Length > 0).OrderByDescending(s => s.Length).ToArray();  				// TODO: Configure split characters through property or constructor parameter or something    				// Scan text for matches  				while (true)  				{  					string nextString = null;  					int nextIndex = int.MaxValue;  					foreach (var s in searches)  					{  						int next = text.IndexOf(s' start' StringComparison.CurrentCultureIgnoreCase);  						if (next != -1 && next < nextIndex)  						{  							nextIndex = next;  							nextString = s;  						}  					}  					if (nextIndex == int.MaxValue) break;   // Nothing more found    					if (nextIndex > start)  					{  						// Add unmatched text until the next match  						run = new Run(text.Substring(start' nextIndex - start));  						textblock.Inlines.Add(run);  					}    					// Add next match with hightlighted style  					run = new Run(text.Substring(nextIndex' nextString.Length));  					run.Background = new SolidColorBrush(Color.FromArgb(128' 255' 255' 0));  					textblock.Inlines.Add(run);    					start = nextIndex + nextString.Length;  				}  			}
Magic Number,Unclassified.UI,TextHighlightConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\TextHighlightConverter.cs,Convert,The following statement contains a magic number: if (values.Length > 2 && values[2] is bool && (bool)values[2] == false)  			{  				// Highlighting disabled for this item  				return values[0];  			}
Magic Number,Unclassified.UI,TextHighlightConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\TextHighlightConverter.cs,Convert,The following statement contains a magic number: if (values.Length > 2 && values[2] is bool && (bool)values[2] == false)  			{  				// Highlighting disabled for this item  				return values[0];  			}
Magic Number,Unclassified.UI,TextHighlightConverter,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\TextHighlightConverter.cs,Convert,The following statement contains a magic number: if (values.Length > 2 && values[2] is bool && (bool)values[2] == false)  			{  				// Highlighting disabled for this item  				return values[0];  			}
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,GetFieldInfo,The following statement contains a magic number: if (source == YearText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 9999;  			}  			else if (source == MonthText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 12;  			}  			else if (source == DayText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = DateTime.DaysInMonth(selectedTime.Year' selectedTime.Month);  			}  			else if (source == HourText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 23;  			}  			else if (source == MinuteText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else if (source == SecondText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else  			{  				// Invalid state  				value = 0;  				min = 0;  				max = 0;  			}
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,GetFieldInfo,The following statement contains a magic number: if (source == YearText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 9999;  			}  			else if (source == MonthText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 12;  			}  			else if (source == DayText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = DateTime.DaysInMonth(selectedTime.Year' selectedTime.Month);  			}  			else if (source == HourText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 23;  			}  			else if (source == MinuteText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else if (source == SecondText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else  			{  				// Invalid state  				value = 0;  				min = 0;  				max = 0;  			}
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,GetFieldInfo,The following statement contains a magic number: if (source == YearText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 9999;  			}  			else if (source == MonthText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 12;  			}  			else if (source == DayText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = DateTime.DaysInMonth(selectedTime.Year' selectedTime.Month);  			}  			else if (source == HourText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 23;  			}  			else if (source == MinuteText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else if (source == SecondText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else  			{  				// Invalid state  				value = 0;  				min = 0;  				max = 0;  			}
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,GetFieldInfo,The following statement contains a magic number: if (source == YearText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 9999;  			}  			else if (source == MonthText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 12;  			}  			else if (source == DayText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = DateTime.DaysInMonth(selectedTime.Year' selectedTime.Month);  			}  			else if (source == HourText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 23;  			}  			else if (source == MinuteText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else if (source == SecondText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else  			{  				// Invalid state  				value = 0;  				min = 0;  				max = 0;  			}
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,GetFieldInfo,The following statement contains a magic number: if (source == YearText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 9999;  			}  			else if (source == MonthText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = 12;  			}  			else if (source == DayText)  			{  				int.TryParse(source.Text' out value);  				min = 1;  				max = DateTime.DaysInMonth(selectedTime.Year' selectedTime.Month);  			}  			else if (source == HourText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 23;  			}  			else if (source == MinuteText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else if (source == SecondText)  			{  				int.TryParse(source.Text' out value);  				min = 0;  				max = 59;  			}  			else  			{  				// Invalid state  				value = 0;  				min = 0;  				max = 0;  			}
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.YearText = ((System.Windows.Controls.TextBox)(target));                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 19 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 2:              this.MonthText = ((System.Windows.Controls.TextBox)(target));                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 26 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 3:              this.DayText = ((System.Windows.Controls.TextBox)(target));                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 33 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 4:              this.HourText = ((System.Windows.Controls.TextBox)(target));                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 40 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 5:              this.MinuteText = ((System.Windows.Controls.TextBox)(target));                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 47 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 6:              this.SecondText = ((System.Windows.Controls.TextBox)(target));                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 54 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 7:                            #line 80 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click);                            #line default              #line hidden              return;              case 8:                            #line 86 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.YearText = ((System.Windows.Controls.TextBox)(target));                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 19 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 2:              this.MonthText = ((System.Windows.Controls.TextBox)(target));                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 26 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 3:              this.DayText = ((System.Windows.Controls.TextBox)(target));                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 33 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 4:              this.HourText = ((System.Windows.Controls.TextBox)(target));                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 40 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 5:              this.MinuteText = ((System.Windows.Controls.TextBox)(target));                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 47 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 6:              this.SecondText = ((System.Windows.Controls.TextBox)(target));                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 54 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 7:                            #line 80 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click);                            #line default              #line hidden              return;              case 8:                            #line 86 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.YearText = ((System.Windows.Controls.TextBox)(target));                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 19 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 2:              this.MonthText = ((System.Windows.Controls.TextBox)(target));                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 26 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 3:              this.DayText = ((System.Windows.Controls.TextBox)(target));                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 33 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 4:              this.HourText = ((System.Windows.Controls.TextBox)(target));                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 40 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 5:              this.MinuteText = ((System.Windows.Controls.TextBox)(target));                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 47 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 6:              this.SecondText = ((System.Windows.Controls.TextBox)(target));                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 54 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 7:                            #line 80 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click);                            #line default              #line hidden              return;              case 8:                            #line 86 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.YearText = ((System.Windows.Controls.TextBox)(target));                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 19 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 2:              this.MonthText = ((System.Windows.Controls.TextBox)(target));                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 26 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 3:              this.DayText = ((System.Windows.Controls.TextBox)(target));                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 33 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 4:              this.HourText = ((System.Windows.Controls.TextBox)(target));                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 40 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 5:              this.MinuteText = ((System.Windows.Controls.TextBox)(target));                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 47 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 6:              this.SecondText = ((System.Windows.Controls.TextBox)(target));                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 54 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 7:                            #line 80 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click);                            #line default              #line hidden              return;              case 8:                            #line 86 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.YearText = ((System.Windows.Controls.TextBox)(target));                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 19 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 2:              this.MonthText = ((System.Windows.Controls.TextBox)(target));                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 26 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 3:              this.DayText = ((System.Windows.Controls.TextBox)(target));                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 33 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 4:              this.HourText = ((System.Windows.Controls.TextBox)(target));                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 40 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 5:              this.MinuteText = ((System.Windows.Controls.TextBox)(target));                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 47 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 6:              this.SecondText = ((System.Windows.Controls.TextBox)(target));                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 54 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 7:                            #line 80 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click);                            #line default              #line hidden              return;              case 8:                            #line 86 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.YearText = ((System.Windows.Controls.TextBox)(target));                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 19 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 2:              this.MonthText = ((System.Windows.Controls.TextBox)(target));                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 26 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 3:              this.DayText = ((System.Windows.Controls.TextBox)(target));                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 33 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 4:              this.HourText = ((System.Windows.Controls.TextBox)(target));                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 40 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 5:              this.MinuteText = ((System.Windows.Controls.TextBox)(target));                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 47 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 6:              this.SecondText = ((System.Windows.Controls.TextBox)(target));                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 54 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 7:                            #line 80 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click);                            #line default              #line hidden              return;              case 8:                            #line 86 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.YearText = ((System.Windows.Controls.TextBox)(target));                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 19 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 2:              this.MonthText = ((System.Windows.Controls.TextBox)(target));                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 26 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 3:              this.DayText = ((System.Windows.Controls.TextBox)(target));                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 33 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 4:              this.HourText = ((System.Windows.Controls.TextBox)(target));                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 40 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 5:              this.MinuteText = ((System.Windows.Controls.TextBox)(target));                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 47 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 6:              this.SecondText = ((System.Windows.Controls.TextBox)(target));                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 54 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 7:                            #line 80 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click);                            #line default              #line hidden              return;              case 8:                            #line 86 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Unclassified.Util,CommandLineHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\CommandLineHelper.cs,Parse,The following statement contains a magic number: foreach (string arg in aw)  			{  				if (arg == "--")  				{  					optMode = false;  				}  				else if (optMode && (arg.StartsWith("/") || arg.StartsWith("-")))  				{  					string optName = arg.Substring(arg.StartsWith("--") ? 2 : 1);    					// Split option value if separated with : or = instead of whitespace  					int separatorIndex = optName.IndexOfAny(new[] { ':'' '=' });  					string optValue = null;  					if (separatorIndex != -1)  					{  						optValue = optName.Substring(separatorIndex + 1);  						optName = optName.Substring(0' separatorIndex);  					}    					// Find the option with complete name match  					var option = options.FirstOrDefault(o => o.Names.Any(n => n.Equals(optName' strComp)));  					if (option == null)  					{  						// Try to complete the name to a unique registered option  						var matchingOptions = options.Where(o => o.Names.Any(n => n.StartsWith(optName' strComp))).ToList();  						if (AutoCompleteOptions && matchingOptions.Count > 1)  						{  							throw new Exception("Invalid option' completion is not unique: " + arg);  						}  						if (!AutoCompleteOptions || matchingOptions.Count == 0)  						{  							throw new Exception("Unknown option: " + arg);  						}  						// Accept the single auto-completed option  						option = matchingOptions[0];  					}    					// Check for single usage  					if (option.IsSingle && option.IsSet)  					{  						throw new Exception("Option cannot be set multiple times: " + arg);  					}    					// Collect option values from next argument strings  					string[] values = new string[option.ParameterCount];  					for (int i = 0; i < option.ParameterCount; i++)  					{  						if (optValue != null)  						{  							// The first value was included in this argument string  							values[i] = optValue;  							optValue = null;  						}  						else  						{  							// Fetch another argument string  							values[i] = aw.GetNext();  						}  						if (values[i] == null)  						{  							throw new Exception("Missing argument " + (i + 1) + " for option: " + arg);  						}  					}  					var argument = new Argument(option' values);    					// Set usage data on the option instance for quick access  					option.IsSet = true;  					option.SetCount++;  					option.Argument = argument;    					if (option.Action != null)  					{  						option.Action(argument);  					}  					else  					{  						parsedArguments.Add(argument);  					}  				}  				else  				{  					parsedArguments.Add(new Argument(null' new[] { arg }));  				}  			}
Magic Number,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Load,The following statement contains a magic number: lock (syncLock)  			{  				if (!Path.IsPathRooted(fileName))  				{  					fileName = Path.GetFullPath(fileName);  				}  				this.fileName = fileName;    				// Run the following code at most two times.  				// First with the regular file' second with a restored backup if it exists.  				int tryCount = 2;  				while (tryCount-- > 0)  				{  					try  					{  						store.Clear();  						XmlDocument xdoc = new XmlDocument();    						if (!string.IsNullOrEmpty(this.password))  						{  #if WITH_FIELDLOG  							FL.Trace("FileSettingsStore.Load"' "fileName = " + fileName + "\nWith password");  #endif  							using (FileStream fs = new FileStream(fileName' FileMode.Open' FileAccess.Read))  							{  								byte[] salt = new byte[8];  								fs.Read(salt' 0' salt.Length);  								Rfc2898DeriveBytes keyGenerator = new Rfc2898DeriveBytes(this.password' salt);    								using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())  								{  									aes.Key = keyGenerator.GetBytes(aes.KeySize / 8);  									aes.IV = keyGenerator.GetBytes(aes.BlockSize / 8);    									using (CryptoStream cs = new CryptoStream(fs' aes.CreateDecryptor()' CryptoStreamMode.Read))  									using (StreamReader sr = new StreamReader(cs))  									{  										xdoc.Load(sr);  										// DEBUG:  										//string data = sr.ReadToEnd();  										//xdoc.LoadXml(data);  									}  								}  							}  						}  						else  						{  #if WITH_FIELDLOG  							FL.Trace("FileSettingsStore.Load"' "fileName = " + fileName + "\nNo password");  #endif  							using (StreamReader sr = new StreamReader(fileName))  							{  								xdoc.Load(sr);  							}  						}    						if (xdoc.DocumentElement.Name != "settings") throw new XmlException("Invalid XML root element");  						foreach (XmlNode xn in xdoc.DocumentElement.ChildNodes)  						{  							if (xn.Name == "entry")  							{  								string key = xn.Attributes["key"].Value.Trim();  								string type = xn.Attributes["type"].Value.Trim();    								if (key == "") throw new XmlException("Empty entry key");    								if (type == "string")  								{  									store.Add(key' xn.InnerText);  								}  								else if (type == "string[]" ||  									type == "string-array")  								{  									List<string> list = new List<string>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										list.Add(itemNode.InnerText);  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "int")  								{  									store.Add(key' int.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "int[]" ||  									type == "int-array")  								{  									List<int> list = new List<int>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(int.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "long")  								{  									store.Add(key' long.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "long[]" ||  									type == "long-array")  								{  									List<long> list = new List<long>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(long.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "double")  								{  									store.Add(key' double.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "double[]" ||  									type == "double-array")  								{  									List<double> list = new List<double>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(double.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "decimal")  								{  									store.Add(key' decimal.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "decimal[]" ||  									type == "decimal-array")  								{  									List<decimal> list = new List<decimal>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0m);  										else  											list.Add(decimal.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "bool")  								{  									if (xn.InnerText.ToString().Trim() == "1" ||  										xn.InnerText.ToString().Trim().ToLower() == "true")  										store.Add(key' true);  									else if (xn.InnerText.ToString().Trim() == "0" ||  										xn.InnerText.ToString().Trim().ToLower() == "false")  										store.Add(key' false);  									else throw new FormatException("Invalid bool value");  								}  								else if (type == "bool[]" ||  									type == "bool-array")  								{  									List<bool> list = new List<bool>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText.ToString().Trim() == "1" ||  											itemNode.InnerText.ToString().Trim().ToLower() == "true")  											list.Add(true);  										else if (itemNode.InnerText.ToString().Trim() == "0" ||  											itemNode.InnerText.ToString().Trim().ToLower() == "false")  											list.Add(false);  										else throw new FormatException("Invalid bool value");  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "DateTime")  								{  									store.Add(key' DateTime.Parse(xn.InnerText' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind));  								}  								else if (type == "DateTime[]")  								{  									List<DateTime> list = new List<DateTime>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										long lng;  										if (itemNode.InnerText == "")  											list.Add(DateTime.MinValue);  										else if (long.TryParse(itemNode.InnerText' NumberStyles.Integer' CultureInfo.InvariantCulture' out lng))   // Old format: Ticks as long integer  											list.Add(new DateTime(lng));  										else  											list.Add(DateTime.Parse(itemNode.InnerText' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "TimeSpan")  								{  									store.Add(key' new TimeSpan(long.Parse(xn.InnerText' CultureInfo.InvariantCulture)));  								}  								else if (type == "TimeSpan[]")  								{  									List<TimeSpan> list = new List<TimeSpan>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(TimeSpan.Zero);  										else  											list.Add(new TimeSpan(long.Parse(itemNode.InnerText' CultureInfo.InvariantCulture)));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "map")  								{  									NameValueCollection collection = new NameValueCollection();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										string itemName = itemNode.Attributes["name"].Value;  										string itemValue = itemNode.InnerText;  										collection[itemName] = itemValue;  									}  									store.Add(key' collection);  								}  								else  								{  									throw new XmlException("Invalid type value");  								}  							}  						}  						return;  					}  					catch (DirectoryNotFoundException)  					{  #if WITH_FIELDLOG  						FL.Trace("FileSettingsStore.Load: DirectoryNotFoundException' no settings loaded");  #endif  					}  					catch (FileNotFoundException)  					{  #if WITH_FIELDLOG  						FL.Trace("FileSettingsStore.Load: FileNotFoundException' no settings loaded");  #endif  					}  					catch (FormatException ex)  					{  						HandleBrokenFile(ex);  					}  					catch (XmlException ex)  					{  						HandleBrokenFile(ex);  					}  					hadProblem = true;    					// Try and use the backup file (once) if the file wasn't loaded  					string backupFileName = fileName + ".bak";  					if (!File.Exists(backupFileName)) return;  #if WITH_FIELDLOG  					FL.Info("Restoring backup settings file and retrying"' "backupFileName = " + backupFileName);  #endif  					File.Copy(backupFileName' fileName' true);    					// Read the restored backup file in a second iteration.  				}  			}
Magic Number,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Load,The following statement contains a magic number: lock (syncLock)  			{  				if (!Path.IsPathRooted(fileName))  				{  					fileName = Path.GetFullPath(fileName);  				}  				this.fileName = fileName;    				// Run the following code at most two times.  				// First with the regular file' second with a restored backup if it exists.  				int tryCount = 2;  				while (tryCount-- > 0)  				{  					try  					{  						store.Clear();  						XmlDocument xdoc = new XmlDocument();    						if (!string.IsNullOrEmpty(this.password))  						{  #if WITH_FIELDLOG  							FL.Trace("FileSettingsStore.Load"' "fileName = " + fileName + "\nWith password");  #endif  							using (FileStream fs = new FileStream(fileName' FileMode.Open' FileAccess.Read))  							{  								byte[] salt = new byte[8];  								fs.Read(salt' 0' salt.Length);  								Rfc2898DeriveBytes keyGenerator = new Rfc2898DeriveBytes(this.password' salt);    								using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())  								{  									aes.Key = keyGenerator.GetBytes(aes.KeySize / 8);  									aes.IV = keyGenerator.GetBytes(aes.BlockSize / 8);    									using (CryptoStream cs = new CryptoStream(fs' aes.CreateDecryptor()' CryptoStreamMode.Read))  									using (StreamReader sr = new StreamReader(cs))  									{  										xdoc.Load(sr);  										// DEBUG:  										//string data = sr.ReadToEnd();  										//xdoc.LoadXml(data);  									}  								}  							}  						}  						else  						{  #if WITH_FIELDLOG  							FL.Trace("FileSettingsStore.Load"' "fileName = " + fileName + "\nNo password");  #endif  							using (StreamReader sr = new StreamReader(fileName))  							{  								xdoc.Load(sr);  							}  						}    						if (xdoc.DocumentElement.Name != "settings") throw new XmlException("Invalid XML root element");  						foreach (XmlNode xn in xdoc.DocumentElement.ChildNodes)  						{  							if (xn.Name == "entry")  							{  								string key = xn.Attributes["key"].Value.Trim();  								string type = xn.Attributes["type"].Value.Trim();    								if (key == "") throw new XmlException("Empty entry key");    								if (type == "string")  								{  									store.Add(key' xn.InnerText);  								}  								else if (type == "string[]" ||  									type == "string-array")  								{  									List<string> list = new List<string>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										list.Add(itemNode.InnerText);  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "int")  								{  									store.Add(key' int.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "int[]" ||  									type == "int-array")  								{  									List<int> list = new List<int>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(int.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "long")  								{  									store.Add(key' long.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "long[]" ||  									type == "long-array")  								{  									List<long> list = new List<long>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(long.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "double")  								{  									store.Add(key' double.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "double[]" ||  									type == "double-array")  								{  									List<double> list = new List<double>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(double.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "decimal")  								{  									store.Add(key' decimal.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "decimal[]" ||  									type == "decimal-array")  								{  									List<decimal> list = new List<decimal>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0m);  										else  											list.Add(decimal.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "bool")  								{  									if (xn.InnerText.ToString().Trim() == "1" ||  										xn.InnerText.ToString().Trim().ToLower() == "true")  										store.Add(key' true);  									else if (xn.InnerText.ToString().Trim() == "0" ||  										xn.InnerText.ToString().Trim().ToLower() == "false")  										store.Add(key' false);  									else throw new FormatException("Invalid bool value");  								}  								else if (type == "bool[]" ||  									type == "bool-array")  								{  									List<bool> list = new List<bool>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText.ToString().Trim() == "1" ||  											itemNode.InnerText.ToString().Trim().ToLower() == "true")  											list.Add(true);  										else if (itemNode.InnerText.ToString().Trim() == "0" ||  											itemNode.InnerText.ToString().Trim().ToLower() == "false")  											list.Add(false);  										else throw new FormatException("Invalid bool value");  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "DateTime")  								{  									store.Add(key' DateTime.Parse(xn.InnerText' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind));  								}  								else if (type == "DateTime[]")  								{  									List<DateTime> list = new List<DateTime>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										long lng;  										if (itemNode.InnerText == "")  											list.Add(DateTime.MinValue);  										else if (long.TryParse(itemNode.InnerText' NumberStyles.Integer' CultureInfo.InvariantCulture' out lng))   // Old format: Ticks as long integer  											list.Add(new DateTime(lng));  										else  											list.Add(DateTime.Parse(itemNode.InnerText' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "TimeSpan")  								{  									store.Add(key' new TimeSpan(long.Parse(xn.InnerText' CultureInfo.InvariantCulture)));  								}  								else if (type == "TimeSpan[]")  								{  									List<TimeSpan> list = new List<TimeSpan>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(TimeSpan.Zero);  										else  											list.Add(new TimeSpan(long.Parse(itemNode.InnerText' CultureInfo.InvariantCulture)));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "map")  								{  									NameValueCollection collection = new NameValueCollection();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										string itemName = itemNode.Attributes["name"].Value;  										string itemValue = itemNode.InnerText;  										collection[itemName] = itemValue;  									}  									store.Add(key' collection);  								}  								else  								{  									throw new XmlException("Invalid type value");  								}  							}  						}  						return;  					}  					catch (DirectoryNotFoundException)  					{  #if WITH_FIELDLOG  						FL.Trace("FileSettingsStore.Load: DirectoryNotFoundException' no settings loaded");  #endif  					}  					catch (FileNotFoundException)  					{  #if WITH_FIELDLOG  						FL.Trace("FileSettingsStore.Load: FileNotFoundException' no settings loaded");  #endif  					}  					catch (FormatException ex)  					{  						HandleBrokenFile(ex);  					}  					catch (XmlException ex)  					{  						HandleBrokenFile(ex);  					}  					hadProblem = true;    					// Try and use the backup file (once) if the file wasn't loaded  					string backupFileName = fileName + ".bak";  					if (!File.Exists(backupFileName)) return;  #if WITH_FIELDLOG  					FL.Info("Restoring backup settings file and retrying"' "backupFileName = " + backupFileName);  #endif  					File.Copy(backupFileName' fileName' true);    					// Read the restored backup file in a second iteration.  				}  			}
Magic Number,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Load,The following statement contains a magic number: lock (syncLock)  			{  				if (!Path.IsPathRooted(fileName))  				{  					fileName = Path.GetFullPath(fileName);  				}  				this.fileName = fileName;    				// Run the following code at most two times.  				// First with the regular file' second with a restored backup if it exists.  				int tryCount = 2;  				while (tryCount-- > 0)  				{  					try  					{  						store.Clear();  						XmlDocument xdoc = new XmlDocument();    						if (!string.IsNullOrEmpty(this.password))  						{  #if WITH_FIELDLOG  							FL.Trace("FileSettingsStore.Load"' "fileName = " + fileName + "\nWith password");  #endif  							using (FileStream fs = new FileStream(fileName' FileMode.Open' FileAccess.Read))  							{  								byte[] salt = new byte[8];  								fs.Read(salt' 0' salt.Length);  								Rfc2898DeriveBytes keyGenerator = new Rfc2898DeriveBytes(this.password' salt);    								using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())  								{  									aes.Key = keyGenerator.GetBytes(aes.KeySize / 8);  									aes.IV = keyGenerator.GetBytes(aes.BlockSize / 8);    									using (CryptoStream cs = new CryptoStream(fs' aes.CreateDecryptor()' CryptoStreamMode.Read))  									using (StreamReader sr = new StreamReader(cs))  									{  										xdoc.Load(sr);  										// DEBUG:  										//string data = sr.ReadToEnd();  										//xdoc.LoadXml(data);  									}  								}  							}  						}  						else  						{  #if WITH_FIELDLOG  							FL.Trace("FileSettingsStore.Load"' "fileName = " + fileName + "\nNo password");  #endif  							using (StreamReader sr = new StreamReader(fileName))  							{  								xdoc.Load(sr);  							}  						}    						if (xdoc.DocumentElement.Name != "settings") throw new XmlException("Invalid XML root element");  						foreach (XmlNode xn in xdoc.DocumentElement.ChildNodes)  						{  							if (xn.Name == "entry")  							{  								string key = xn.Attributes["key"].Value.Trim();  								string type = xn.Attributes["type"].Value.Trim();    								if (key == "") throw new XmlException("Empty entry key");    								if (type == "string")  								{  									store.Add(key' xn.InnerText);  								}  								else if (type == "string[]" ||  									type == "string-array")  								{  									List<string> list = new List<string>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										list.Add(itemNode.InnerText);  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "int")  								{  									store.Add(key' int.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "int[]" ||  									type == "int-array")  								{  									List<int> list = new List<int>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(int.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "long")  								{  									store.Add(key' long.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "long[]" ||  									type == "long-array")  								{  									List<long> list = new List<long>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(long.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "double")  								{  									store.Add(key' double.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "double[]" ||  									type == "double-array")  								{  									List<double> list = new List<double>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(double.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "decimal")  								{  									store.Add(key' decimal.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "decimal[]" ||  									type == "decimal-array")  								{  									List<decimal> list = new List<decimal>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0m);  										else  											list.Add(decimal.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "bool")  								{  									if (xn.InnerText.ToString().Trim() == "1" ||  										xn.InnerText.ToString().Trim().ToLower() == "true")  										store.Add(key' true);  									else if (xn.InnerText.ToString().Trim() == "0" ||  										xn.InnerText.ToString().Trim().ToLower() == "false")  										store.Add(key' false);  									else throw new FormatException("Invalid bool value");  								}  								else if (type == "bool[]" ||  									type == "bool-array")  								{  									List<bool> list = new List<bool>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText.ToString().Trim() == "1" ||  											itemNode.InnerText.ToString().Trim().ToLower() == "true")  											list.Add(true);  										else if (itemNode.InnerText.ToString().Trim() == "0" ||  											itemNode.InnerText.ToString().Trim().ToLower() == "false")  											list.Add(false);  										else throw new FormatException("Invalid bool value");  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "DateTime")  								{  									store.Add(key' DateTime.Parse(xn.InnerText' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind));  								}  								else if (type == "DateTime[]")  								{  									List<DateTime> list = new List<DateTime>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										long lng;  										if (itemNode.InnerText == "")  											list.Add(DateTime.MinValue);  										else if (long.TryParse(itemNode.InnerText' NumberStyles.Integer' CultureInfo.InvariantCulture' out lng))   // Old format: Ticks as long integer  											list.Add(new DateTime(lng));  										else  											list.Add(DateTime.Parse(itemNode.InnerText' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "TimeSpan")  								{  									store.Add(key' new TimeSpan(long.Parse(xn.InnerText' CultureInfo.InvariantCulture)));  								}  								else if (type == "TimeSpan[]")  								{  									List<TimeSpan> list = new List<TimeSpan>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(TimeSpan.Zero);  										else  											list.Add(new TimeSpan(long.Parse(itemNode.InnerText' CultureInfo.InvariantCulture)));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "map")  								{  									NameValueCollection collection = new NameValueCollection();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										string itemName = itemNode.Attributes["name"].Value;  										string itemValue = itemNode.InnerText;  										collection[itemName] = itemValue;  									}  									store.Add(key' collection);  								}  								else  								{  									throw new XmlException("Invalid type value");  								}  							}  						}  						return;  					}  					catch (DirectoryNotFoundException)  					{  #if WITH_FIELDLOG  						FL.Trace("FileSettingsStore.Load: DirectoryNotFoundException' no settings loaded");  #endif  					}  					catch (FileNotFoundException)  					{  #if WITH_FIELDLOG  						FL.Trace("FileSettingsStore.Load: FileNotFoundException' no settings loaded");  #endif  					}  					catch (FormatException ex)  					{  						HandleBrokenFile(ex);  					}  					catch (XmlException ex)  					{  						HandleBrokenFile(ex);  					}  					hadProblem = true;    					// Try and use the backup file (once) if the file wasn't loaded  					string backupFileName = fileName + ".bak";  					if (!File.Exists(backupFileName)) return;  #if WITH_FIELDLOG  					FL.Info("Restoring backup settings file and retrying"' "backupFileName = " + backupFileName);  #endif  					File.Copy(backupFileName' fileName' true);    					// Read the restored backup file in a second iteration.  				}  			}
Magic Number,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Load,The following statement contains a magic number: lock (syncLock)  			{  				if (!Path.IsPathRooted(fileName))  				{  					fileName = Path.GetFullPath(fileName);  				}  				this.fileName = fileName;    				// Run the following code at most two times.  				// First with the regular file' second with a restored backup if it exists.  				int tryCount = 2;  				while (tryCount-- > 0)  				{  					try  					{  						store.Clear();  						XmlDocument xdoc = new XmlDocument();    						if (!string.IsNullOrEmpty(this.password))  						{  #if WITH_FIELDLOG  							FL.Trace("FileSettingsStore.Load"' "fileName = " + fileName + "\nWith password");  #endif  							using (FileStream fs = new FileStream(fileName' FileMode.Open' FileAccess.Read))  							{  								byte[] salt = new byte[8];  								fs.Read(salt' 0' salt.Length);  								Rfc2898DeriveBytes keyGenerator = new Rfc2898DeriveBytes(this.password' salt);    								using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())  								{  									aes.Key = keyGenerator.GetBytes(aes.KeySize / 8);  									aes.IV = keyGenerator.GetBytes(aes.BlockSize / 8);    									using (CryptoStream cs = new CryptoStream(fs' aes.CreateDecryptor()' CryptoStreamMode.Read))  									using (StreamReader sr = new StreamReader(cs))  									{  										xdoc.Load(sr);  										// DEBUG:  										//string data = sr.ReadToEnd();  										//xdoc.LoadXml(data);  									}  								}  							}  						}  						else  						{  #if WITH_FIELDLOG  							FL.Trace("FileSettingsStore.Load"' "fileName = " + fileName + "\nNo password");  #endif  							using (StreamReader sr = new StreamReader(fileName))  							{  								xdoc.Load(sr);  							}  						}    						if (xdoc.DocumentElement.Name != "settings") throw new XmlException("Invalid XML root element");  						foreach (XmlNode xn in xdoc.DocumentElement.ChildNodes)  						{  							if (xn.Name == "entry")  							{  								string key = xn.Attributes["key"].Value.Trim();  								string type = xn.Attributes["type"].Value.Trim();    								if (key == "") throw new XmlException("Empty entry key");    								if (type == "string")  								{  									store.Add(key' xn.InnerText);  								}  								else if (type == "string[]" ||  									type == "string-array")  								{  									List<string> list = new List<string>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										list.Add(itemNode.InnerText);  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "int")  								{  									store.Add(key' int.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "int[]" ||  									type == "int-array")  								{  									List<int> list = new List<int>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(int.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "long")  								{  									store.Add(key' long.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "long[]" ||  									type == "long-array")  								{  									List<long> list = new List<long>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(long.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "double")  								{  									store.Add(key' double.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "double[]" ||  									type == "double-array")  								{  									List<double> list = new List<double>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0);  										else  											list.Add(double.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "decimal")  								{  									store.Add(key' decimal.Parse(xn.InnerText' CultureInfo.InvariantCulture));  								}  								else if (type == "decimal[]" ||  									type == "decimal-array")  								{  									List<decimal> list = new List<decimal>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(0m);  										else  											list.Add(decimal.Parse(itemNode.InnerText' CultureInfo.InvariantCulture));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "bool")  								{  									if (xn.InnerText.ToString().Trim() == "1" ||  										xn.InnerText.ToString().Trim().ToLower() == "true")  										store.Add(key' true);  									else if (xn.InnerText.ToString().Trim() == "0" ||  										xn.InnerText.ToString().Trim().ToLower() == "false")  										store.Add(key' false);  									else throw new FormatException("Invalid bool value");  								}  								else if (type == "bool[]" ||  									type == "bool-array")  								{  									List<bool> list = new List<bool>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText.ToString().Trim() == "1" ||  											itemNode.InnerText.ToString().Trim().ToLower() == "true")  											list.Add(true);  										else if (itemNode.InnerText.ToString().Trim() == "0" ||  											itemNode.InnerText.ToString().Trim().ToLower() == "false")  											list.Add(false);  										else throw new FormatException("Invalid bool value");  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "DateTime")  								{  									store.Add(key' DateTime.Parse(xn.InnerText' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind));  								}  								else if (type == "DateTime[]")  								{  									List<DateTime> list = new List<DateTime>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										long lng;  										if (itemNode.InnerText == "")  											list.Add(DateTime.MinValue);  										else if (long.TryParse(itemNode.InnerText' NumberStyles.Integer' CultureInfo.InvariantCulture' out lng))   // Old format: Ticks as long integer  											list.Add(new DateTime(lng));  										else  											list.Add(DateTime.Parse(itemNode.InnerText' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "TimeSpan")  								{  									store.Add(key' new TimeSpan(long.Parse(xn.InnerText' CultureInfo.InvariantCulture)));  								}  								else if (type == "TimeSpan[]")  								{  									List<TimeSpan> list = new List<TimeSpan>();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										if (itemNode.InnerText == "")  											list.Add(TimeSpan.Zero);  										else  											list.Add(new TimeSpan(long.Parse(itemNode.InnerText' CultureInfo.InvariantCulture)));  									}  									store.Add(key' list.ToArray());  								}  								else if (type == "map")  								{  									NameValueCollection collection = new NameValueCollection();  									foreach (XmlNode itemNode in xn.SelectNodes("item"))  									{  										string itemName = itemNode.Attributes["name"].Value;  										string itemValue = itemNode.InnerText;  										collection[itemName] = itemValue;  									}  									store.Add(key' collection);  								}  								else  								{  									throw new XmlException("Invalid type value");  								}  							}  						}  						return;  					}  					catch (DirectoryNotFoundException)  					{  #if WITH_FIELDLOG  						FL.Trace("FileSettingsStore.Load: DirectoryNotFoundException' no settings loaded");  #endif  					}  					catch (FileNotFoundException)  					{  #if WITH_FIELDLOG  						FL.Trace("FileSettingsStore.Load: FileNotFoundException' no settings loaded");  #endif  					}  					catch (FormatException ex)  					{  						HandleBrokenFile(ex);  					}  					catch (XmlException ex)  					{  						HandleBrokenFile(ex);  					}  					hadProblem = true;    					// Try and use the backup file (once) if the file wasn't loaded  					string backupFileName = fileName + ".bak";  					if (!File.Exists(backupFileName)) return;  #if WITH_FIELDLOG  					FL.Info("Restoring backup settings file and retrying"' "backupFileName = " + backupFileName);  #endif  					File.Copy(backupFileName' fileName' true);    					// Read the restored backup file in a second iteration.  				}  			}
Magic Number,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Save,The following statement contains a magic number: lock (syncLock)  			{  				savePending = false;  				if (isDisposed) return;  				if (readOnly) throw new InvalidOperationException("This SettingsStore instance is created in read-only mode.");    				List<string> listKeys = new List<string>(store.Keys);  				listKeys.Sort();    				XmlDocument xdoc = new XmlDocument();  				XmlNode root = xdoc.CreateElement("settings");  				xdoc.AppendChild(root);  				foreach (string key in listKeys)  				{  					XmlNode xn;  					XmlAttribute xa;    					xn = xdoc.CreateElement("entry");  					xa = xdoc.CreateAttribute("key");  					xa.Value = key;  					xn.Attributes.Append(xa);    					if (store[key] is string)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "string";  						xn.Attributes.Append(xa);  						xn.InnerText = GetString(key);  					}  					else if (store[key] is string[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "string[]";  						xn.Attributes.Append(xa);  						string[] sa = (string[])store[key];  						foreach (string s in sa)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = s;  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is int)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "int";  						xn.Attributes.Append(xa);  						xn.InnerText = GetInt(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is int[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "int[]";  						xn.Attributes.Append(xa);  						int[] ia = (int[])store[key];  						foreach (int i in ia)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = i.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is long)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "long";  						xn.Attributes.Append(xa);  						xn.InnerText = GetLong(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is long[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "long[]";  						xn.Attributes.Append(xa);  						long[] la = (long[])store[key];  						foreach (long l in la)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = l.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is double)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "double";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDouble(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is double[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "double[]";  						xn.Attributes.Append(xa);  						double[] da = (double[])store[key];  						foreach (double d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is decimal)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "decimal";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDecimal(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is decimal[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "decimal[]";  						xn.Attributes.Append(xa);  						decimal[] da = (decimal[])store[key];  						foreach (decimal d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is bool)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "bool";  						xn.Attributes.Append(xa);  						xn.InnerText = GetBool(key) ? "true" : "false";  					}  					else if (store[key] is bool[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "bool[]";  						xn.Attributes.Append(xa);  						bool[] ba = (bool[])store[key];  						foreach (bool b in ba)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = b ? "true" : "false";  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is DateTime)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "DateTime";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDateTime(key).ToString("o"' CultureInfo.InvariantCulture);  					}  					else if (store[key] is DateTime[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "DateTime[]";  						xn.Attributes.Append(xa);  						DateTime[] da = (DateTime[])store[key];  						foreach (DateTime d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString("o");  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is TimeSpan)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "TimeSpan";  						xn.Attributes.Append(xa);  						xn.InnerText = GetTimeSpan(key).Ticks.ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is TimeSpan[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "TimeSpan[]";  						xn.Attributes.Append(xa);  						TimeSpan[] ta = (TimeSpan[])store[key];  						foreach (TimeSpan t in ta)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = t.Ticks.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is NameValueCollection)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "map";  						xn.Attributes.Append(xa);  						NameValueCollection collection = (NameValueCollection)store[key];  						for (int i = 0; i < collection.Count; i++)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							xa = xdoc.CreateAttribute("name");  							xa.Value = collection.GetKey(i);  							itemNode.Attributes.Append(xa);  							itemNode.InnerText = collection[i];  							xn.AppendChild(itemNode);  						}  					}  					else  					{  						// Internal error' cannot save this store entry  						continue;  					}    					root.AppendChild(xn);  				}    #if WITH_FIELDLOG  				FL.Trace("FileSettingsStore.Save"' "fileName = " + fileName);  #endif  				if (!Directory.Exists(Path.GetDirectoryName(fileName)))  				{  #if WITH_FIELDLOG  					FL.Trace("FileSettingsStore.Save: Creating directory");  #endif  					Directory.CreateDirectory(Path.GetDirectoryName(fileName));  				}    				// Create a backup of the existing file. This backup will be permanently kept and  				// can be restored when a load error occurs.  				string backupFileName = fileName + ".bak";  				if (File.Exists(fileName))  				{  					File.Copy(fileName' backupFileName' true);  				}    				XmlWriterSettings xws = new XmlWriterSettings();  				xws.Encoding = Encoding.UTF8;  				xws.Indent = true;  				xws.IndentChars = "\t";  				xws.OmitXmlDeclaration = false;    				if (!string.IsNullOrEmpty(this.password))  				{  					byte[] salt = new byte[8];  					new RNGCryptoServiceProvider().GetBytes(salt);  					Rfc2898DeriveBytes keyGenerator = new Rfc2898DeriveBytes(this.password' salt);    					using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())  					{  						aes.Key = keyGenerator.GetBytes(aes.KeySize / 8);  						aes.IV = keyGenerator.GetBytes(aes.BlockSize / 8);    						using (FileStream fs = new FileStream(fileName' FileMode.Create' FileAccess.Write))  						using (CryptoStream cs = new CryptoStream(fs' aes.CreateEncryptor()' CryptoStreamMode.Write))  						using (StreamWriter sw = new StreamWriter(cs' Encoding.UTF8))  						{  							fs.Write(salt' 0' salt.Length);    							XmlWriter writer = XmlWriter.Create(sw' xws);  							xdoc.Save(writer);  							writer.Close();  						}  					}  				}  				else  				{  					XmlWriter writer = XmlWriter.Create(fileName' xws);  					xdoc.Save(writer);  					writer.Close();  				}  			}
Magic Number,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Save,The following statement contains a magic number: lock (syncLock)  			{  				savePending = false;  				if (isDisposed) return;  				if (readOnly) throw new InvalidOperationException("This SettingsStore instance is created in read-only mode.");    				List<string> listKeys = new List<string>(store.Keys);  				listKeys.Sort();    				XmlDocument xdoc = new XmlDocument();  				XmlNode root = xdoc.CreateElement("settings");  				xdoc.AppendChild(root);  				foreach (string key in listKeys)  				{  					XmlNode xn;  					XmlAttribute xa;    					xn = xdoc.CreateElement("entry");  					xa = xdoc.CreateAttribute("key");  					xa.Value = key;  					xn.Attributes.Append(xa);    					if (store[key] is string)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "string";  						xn.Attributes.Append(xa);  						xn.InnerText = GetString(key);  					}  					else if (store[key] is string[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "string[]";  						xn.Attributes.Append(xa);  						string[] sa = (string[])store[key];  						foreach (string s in sa)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = s;  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is int)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "int";  						xn.Attributes.Append(xa);  						xn.InnerText = GetInt(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is int[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "int[]";  						xn.Attributes.Append(xa);  						int[] ia = (int[])store[key];  						foreach (int i in ia)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = i.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is long)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "long";  						xn.Attributes.Append(xa);  						xn.InnerText = GetLong(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is long[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "long[]";  						xn.Attributes.Append(xa);  						long[] la = (long[])store[key];  						foreach (long l in la)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = l.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is double)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "double";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDouble(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is double[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "double[]";  						xn.Attributes.Append(xa);  						double[] da = (double[])store[key];  						foreach (double d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is decimal)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "decimal";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDecimal(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is decimal[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "decimal[]";  						xn.Attributes.Append(xa);  						decimal[] da = (decimal[])store[key];  						foreach (decimal d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is bool)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "bool";  						xn.Attributes.Append(xa);  						xn.InnerText = GetBool(key) ? "true" : "false";  					}  					else if (store[key] is bool[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "bool[]";  						xn.Attributes.Append(xa);  						bool[] ba = (bool[])store[key];  						foreach (bool b in ba)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = b ? "true" : "false";  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is DateTime)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "DateTime";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDateTime(key).ToString("o"' CultureInfo.InvariantCulture);  					}  					else if (store[key] is DateTime[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "DateTime[]";  						xn.Attributes.Append(xa);  						DateTime[] da = (DateTime[])store[key];  						foreach (DateTime d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString("o");  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is TimeSpan)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "TimeSpan";  						xn.Attributes.Append(xa);  						xn.InnerText = GetTimeSpan(key).Ticks.ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is TimeSpan[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "TimeSpan[]";  						xn.Attributes.Append(xa);  						TimeSpan[] ta = (TimeSpan[])store[key];  						foreach (TimeSpan t in ta)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = t.Ticks.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is NameValueCollection)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "map";  						xn.Attributes.Append(xa);  						NameValueCollection collection = (NameValueCollection)store[key];  						for (int i = 0; i < collection.Count; i++)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							xa = xdoc.CreateAttribute("name");  							xa.Value = collection.GetKey(i);  							itemNode.Attributes.Append(xa);  							itemNode.InnerText = collection[i];  							xn.AppendChild(itemNode);  						}  					}  					else  					{  						// Internal error' cannot save this store entry  						continue;  					}    					root.AppendChild(xn);  				}    #if WITH_FIELDLOG  				FL.Trace("FileSettingsStore.Save"' "fileName = " + fileName);  #endif  				if (!Directory.Exists(Path.GetDirectoryName(fileName)))  				{  #if WITH_FIELDLOG  					FL.Trace("FileSettingsStore.Save: Creating directory");  #endif  					Directory.CreateDirectory(Path.GetDirectoryName(fileName));  				}    				// Create a backup of the existing file. This backup will be permanently kept and  				// can be restored when a load error occurs.  				string backupFileName = fileName + ".bak";  				if (File.Exists(fileName))  				{  					File.Copy(fileName' backupFileName' true);  				}    				XmlWriterSettings xws = new XmlWriterSettings();  				xws.Encoding = Encoding.UTF8;  				xws.Indent = true;  				xws.IndentChars = "\t";  				xws.OmitXmlDeclaration = false;    				if (!string.IsNullOrEmpty(this.password))  				{  					byte[] salt = new byte[8];  					new RNGCryptoServiceProvider().GetBytes(salt);  					Rfc2898DeriveBytes keyGenerator = new Rfc2898DeriveBytes(this.password' salt);    					using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())  					{  						aes.Key = keyGenerator.GetBytes(aes.KeySize / 8);  						aes.IV = keyGenerator.GetBytes(aes.BlockSize / 8);    						using (FileStream fs = new FileStream(fileName' FileMode.Create' FileAccess.Write))  						using (CryptoStream cs = new CryptoStream(fs' aes.CreateEncryptor()' CryptoStreamMode.Write))  						using (StreamWriter sw = new StreamWriter(cs' Encoding.UTF8))  						{  							fs.Write(salt' 0' salt.Length);    							XmlWriter writer = XmlWriter.Create(sw' xws);  							xdoc.Save(writer);  							writer.Close();  						}  					}  				}  				else  				{  					XmlWriter writer = XmlWriter.Create(fileName' xws);  					xdoc.Save(writer);  					writer.Close();  				}  			}
Magic Number,Unclassified.Util,FileSettingsStore,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\FileSettingsStore.cs,Save,The following statement contains a magic number: lock (syncLock)  			{  				savePending = false;  				if (isDisposed) return;  				if (readOnly) throw new InvalidOperationException("This SettingsStore instance is created in read-only mode.");    				List<string> listKeys = new List<string>(store.Keys);  				listKeys.Sort();    				XmlDocument xdoc = new XmlDocument();  				XmlNode root = xdoc.CreateElement("settings");  				xdoc.AppendChild(root);  				foreach (string key in listKeys)  				{  					XmlNode xn;  					XmlAttribute xa;    					xn = xdoc.CreateElement("entry");  					xa = xdoc.CreateAttribute("key");  					xa.Value = key;  					xn.Attributes.Append(xa);    					if (store[key] is string)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "string";  						xn.Attributes.Append(xa);  						xn.InnerText = GetString(key);  					}  					else if (store[key] is string[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "string[]";  						xn.Attributes.Append(xa);  						string[] sa = (string[])store[key];  						foreach (string s in sa)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = s;  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is int)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "int";  						xn.Attributes.Append(xa);  						xn.InnerText = GetInt(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is int[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "int[]";  						xn.Attributes.Append(xa);  						int[] ia = (int[])store[key];  						foreach (int i in ia)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = i.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is long)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "long";  						xn.Attributes.Append(xa);  						xn.InnerText = GetLong(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is long[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "long[]";  						xn.Attributes.Append(xa);  						long[] la = (long[])store[key];  						foreach (long l in la)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = l.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is double)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "double";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDouble(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is double[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "double[]";  						xn.Attributes.Append(xa);  						double[] da = (double[])store[key];  						foreach (double d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is decimal)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "decimal";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDecimal(key).ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is decimal[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "decimal[]";  						xn.Attributes.Append(xa);  						decimal[] da = (decimal[])store[key];  						foreach (decimal d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is bool)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "bool";  						xn.Attributes.Append(xa);  						xn.InnerText = GetBool(key) ? "true" : "false";  					}  					else if (store[key] is bool[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "bool[]";  						xn.Attributes.Append(xa);  						bool[] ba = (bool[])store[key];  						foreach (bool b in ba)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = b ? "true" : "false";  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is DateTime)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "DateTime";  						xn.Attributes.Append(xa);  						xn.InnerText = GetDateTime(key).ToString("o"' CultureInfo.InvariantCulture);  					}  					else if (store[key] is DateTime[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "DateTime[]";  						xn.Attributes.Append(xa);  						DateTime[] da = (DateTime[])store[key];  						foreach (DateTime d in da)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = d.ToString("o");  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is TimeSpan)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "TimeSpan";  						xn.Attributes.Append(xa);  						xn.InnerText = GetTimeSpan(key).Ticks.ToString(CultureInfo.InvariantCulture);  					}  					else if (store[key] is TimeSpan[])  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "TimeSpan[]";  						xn.Attributes.Append(xa);  						TimeSpan[] ta = (TimeSpan[])store[key];  						foreach (TimeSpan t in ta)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							itemNode.InnerText = t.Ticks.ToString(CultureInfo.InvariantCulture);  							xn.AppendChild(itemNode);  						}  					}  					else if (store[key] is NameValueCollection)  					{  						xa = xdoc.CreateAttribute("type");  						xa.Value = "map";  						xn.Attributes.Append(xa);  						NameValueCollection collection = (NameValueCollection)store[key];  						for (int i = 0; i < collection.Count; i++)  						{  							XmlNode itemNode = xdoc.CreateElement("item");  							xa = xdoc.CreateAttribute("name");  							xa.Value = collection.GetKey(i);  							itemNode.Attributes.Append(xa);  							itemNode.InnerText = collection[i];  							xn.AppendChild(itemNode);  						}  					}  					else  					{  						// Internal error' cannot save this store entry  						continue;  					}    					root.AppendChild(xn);  				}    #if WITH_FIELDLOG  				FL.Trace("FileSettingsStore.Save"' "fileName = " + fileName);  #endif  				if (!Directory.Exists(Path.GetDirectoryName(fileName)))  				{  #if WITH_FIELDLOG  					FL.Trace("FileSettingsStore.Save: Creating directory");  #endif  					Directory.CreateDirectory(Path.GetDirectoryName(fileName));  				}    				// Create a backup of the existing file. This backup will be permanently kept and  				// can be restored when a load error occurs.  				string backupFileName = fileName + ".bak";  				if (File.Exists(fileName))  				{  					File.Copy(fileName' backupFileName' true);  				}    				XmlWriterSettings xws = new XmlWriterSettings();  				xws.Encoding = Encoding.UTF8;  				xws.Indent = true;  				xws.IndentChars = "\t";  				xws.OmitXmlDeclaration = false;    				if (!string.IsNullOrEmpty(this.password))  				{  					byte[] salt = new byte[8];  					new RNGCryptoServiceProvider().GetBytes(salt);  					Rfc2898DeriveBytes keyGenerator = new Rfc2898DeriveBytes(this.password' salt);    					using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())  					{  						aes.Key = keyGenerator.GetBytes(aes.KeySize / 8);  						aes.IV = keyGenerator.GetBytes(aes.BlockSize / 8);    						using (FileStream fs = new FileStream(fileName' FileMode.Create' FileAccess.Write))  						using (CryptoStream cs = new CryptoStream(fs' aes.CreateEncryptor()' CryptoStreamMode.Write))  						using (StreamWriter sw = new StreamWriter(cs' Encoding.UTF8))  						{  							fs.Write(salt' 0' salt.Length);    							XmlWriter writer = XmlWriter.Create(sw' xws);  							xdoc.Save(writer);  							writer.Close();  						}  					}  				}  				else  				{  					XmlWriter writer = XmlWriter.Create(fileName' xws);  					xdoc.Save(writer);  					writer.Close();  				}  			}
Magic Number,Unclassified.Util,ListExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\ListExtensions.cs,InsertSorted,The following statement contains a magic number: int index = (lower + upper) / 2;
Magic Number,Unclassified.Util,ListExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\ListExtensions.cs,InsertSorted,The following statement contains a magic number: while (lower <= upper)  			{  				// As long as lower <= upper' index is valid and can be used for comparison  				int cmp = comparison(list[index]' newItem);    				if (cmp == 0)  				{  					// Direct hit' insert after this existing (undefined behaviour for multiple equal items...)  					break;  				}  				else if (cmp < 0)  				{  					// Item at index is less than item to insert' move on to right side  					lower = index + 1;  					index = (lower + upper) / 2;  				}  				else  				{  					// Item at index is greater than item to insert' move on to left side  					upper = index - 1;  					index = (lower + upper) / 2;  				}  			}
Magic Number,Unclassified.Util,ListExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\ListExtensions.cs,InsertSorted,The following statement contains a magic number: while (lower <= upper)  			{  				// As long as lower <= upper' index is valid and can be used for comparison  				int cmp = comparison(list[index]' newItem);    				if (cmp == 0)  				{  					// Direct hit' insert after this existing (undefined behaviour for multiple equal items...)  					break;  				}  				else if (cmp < 0)  				{  					// Item at index is less than item to insert' move on to right side  					lower = index + 1;  					index = (lower + upper) / 2;  				}  				else  				{  					// Item at index is greater than item to insert' move on to left side  					upper = index - 1;  					index = (lower + upper) / 2;  				}  			}
Magic Number,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateType,The following statement contains a magic number: if (className.StartsWith("I") && className.Length >= 2 && char.IsUpper(className[1]))  				className = className.Substring(1);
Magic Number,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateOnPropertyChanged,The following statement contains a magic number: ilGen.Emit(OpCodes.Ldc_I4_S' 46);
Magic Number,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateStoreGetter,The following statement contains a magic number: if (attrs.Length == 1)  			{  				DefaultValueAttribute defAttr = (DefaultValueAttribute)attrs[0];  				if (propertyInfo.PropertyType.IsArray)  				{  					throw new NotSupportedException(  						"An array-type property cannot have a default value: " +  						propertyInfo.DeclaringType.Name + "." + propertyInfo.Name);  				}  				if (propType == typeof(bool))  				{  					if ((bool)defAttr.Value)  						ilGen.Emit(OpCodes.Ldc_I4_1);  					else  						ilGen.Emit(OpCodes.Ldc_I4_0);  				}  				else if (propType == typeof(int))  				{  					ilGen.Emit(OpCodes.Ldc_I4' Convert.ToInt32(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(long))  				{  					ilGen.Emit(OpCodes.Ldc_I8' Convert.ToInt64(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(double))  				{  					ilGen.Emit(OpCodes.Ldc_R8' Convert.ToDouble(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(decimal))  				{  					decimal d = Convert.ToDecimal(defAttr.Value' CultureInfo.InvariantCulture);  					// Source: https://msdn.microsoft.com/en-us/library/bb1c1a6x.aspx  					var bits = decimal.GetBits(d);  					bool sign = (bits[3] & 0x80000000) != 0;  					byte scale = (byte) ((bits[3] >> 16) & 0x7f);  					ilGen.Emit(OpCodes.Ldc_I4' bits[0]);  					ilGen.Emit(OpCodes.Ldc_I4' bits[1]);  					ilGen.Emit(OpCodes.Ldc_I4' bits[2]);  					ilGen.Emit(sign ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);  					ilGen.Emit(OpCodes.Ldc_I4' (int) scale);  					var ctor = typeof(decimal).GetConstructor(new[] { typeof(int)' typeof(int)' typeof(int)' typeof(bool)' typeof(byte) });  					ilGen.Emit(OpCodes.Newobj' ctor);  				}  				else if (propType == typeof(string))  				{  					ilGen.Emit(OpCodes.Ldstr' Convert.ToString(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else  				{  					throw new NotSupportedException(  						"The property type does not support default values: " +  						propertyInfo.DeclaringType.Name + "." + propertyInfo.Name);  				}  				ilGen.GenerateCallVirt(storeGetMethodWithDefault);  			}  			else  			{  				ilGen.GenerateCallVirt(storeGetMethod);  			}
Magic Number,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateStoreGetter,The following statement contains a magic number: if (attrs.Length == 1)  			{  				DefaultValueAttribute defAttr = (DefaultValueAttribute)attrs[0];  				if (propertyInfo.PropertyType.IsArray)  				{  					throw new NotSupportedException(  						"An array-type property cannot have a default value: " +  						propertyInfo.DeclaringType.Name + "." + propertyInfo.Name);  				}  				if (propType == typeof(bool))  				{  					if ((bool)defAttr.Value)  						ilGen.Emit(OpCodes.Ldc_I4_1);  					else  						ilGen.Emit(OpCodes.Ldc_I4_0);  				}  				else if (propType == typeof(int))  				{  					ilGen.Emit(OpCodes.Ldc_I4' Convert.ToInt32(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(long))  				{  					ilGen.Emit(OpCodes.Ldc_I8' Convert.ToInt64(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(double))  				{  					ilGen.Emit(OpCodes.Ldc_R8' Convert.ToDouble(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(decimal))  				{  					decimal d = Convert.ToDecimal(defAttr.Value' CultureInfo.InvariantCulture);  					// Source: https://msdn.microsoft.com/en-us/library/bb1c1a6x.aspx  					var bits = decimal.GetBits(d);  					bool sign = (bits[3] & 0x80000000) != 0;  					byte scale = (byte) ((bits[3] >> 16) & 0x7f);  					ilGen.Emit(OpCodes.Ldc_I4' bits[0]);  					ilGen.Emit(OpCodes.Ldc_I4' bits[1]);  					ilGen.Emit(OpCodes.Ldc_I4' bits[2]);  					ilGen.Emit(sign ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);  					ilGen.Emit(OpCodes.Ldc_I4' (int) scale);  					var ctor = typeof(decimal).GetConstructor(new[] { typeof(int)' typeof(int)' typeof(int)' typeof(bool)' typeof(byte) });  					ilGen.Emit(OpCodes.Newobj' ctor);  				}  				else if (propType == typeof(string))  				{  					ilGen.Emit(OpCodes.Ldstr' Convert.ToString(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else  				{  					throw new NotSupportedException(  						"The property type does not support default values: " +  						propertyInfo.DeclaringType.Name + "." + propertyInfo.Name);  				}  				ilGen.GenerateCallVirt(storeGetMethodWithDefault);  			}  			else  			{  				ilGen.GenerateCallVirt(storeGetMethod);  			}
Magic Number,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateStoreGetter,The following statement contains a magic number: if (attrs.Length == 1)  			{  				DefaultValueAttribute defAttr = (DefaultValueAttribute)attrs[0];  				if (propertyInfo.PropertyType.IsArray)  				{  					throw new NotSupportedException(  						"An array-type property cannot have a default value: " +  						propertyInfo.DeclaringType.Name + "." + propertyInfo.Name);  				}  				if (propType == typeof(bool))  				{  					if ((bool)defAttr.Value)  						ilGen.Emit(OpCodes.Ldc_I4_1);  					else  						ilGen.Emit(OpCodes.Ldc_I4_0);  				}  				else if (propType == typeof(int))  				{  					ilGen.Emit(OpCodes.Ldc_I4' Convert.ToInt32(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(long))  				{  					ilGen.Emit(OpCodes.Ldc_I8' Convert.ToInt64(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(double))  				{  					ilGen.Emit(OpCodes.Ldc_R8' Convert.ToDouble(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(decimal))  				{  					decimal d = Convert.ToDecimal(defAttr.Value' CultureInfo.InvariantCulture);  					// Source: https://msdn.microsoft.com/en-us/library/bb1c1a6x.aspx  					var bits = decimal.GetBits(d);  					bool sign = (bits[3] & 0x80000000) != 0;  					byte scale = (byte) ((bits[3] >> 16) & 0x7f);  					ilGen.Emit(OpCodes.Ldc_I4' bits[0]);  					ilGen.Emit(OpCodes.Ldc_I4' bits[1]);  					ilGen.Emit(OpCodes.Ldc_I4' bits[2]);  					ilGen.Emit(sign ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);  					ilGen.Emit(OpCodes.Ldc_I4' (int) scale);  					var ctor = typeof(decimal).GetConstructor(new[] { typeof(int)' typeof(int)' typeof(int)' typeof(bool)' typeof(byte) });  					ilGen.Emit(OpCodes.Newobj' ctor);  				}  				else if (propType == typeof(string))  				{  					ilGen.Emit(OpCodes.Ldstr' Convert.ToString(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else  				{  					throw new NotSupportedException(  						"The property type does not support default values: " +  						propertyInfo.DeclaringType.Name + "." + propertyInfo.Name);  				}  				ilGen.GenerateCallVirt(storeGetMethodWithDefault);  			}  			else  			{  				ilGen.GenerateCallVirt(storeGetMethod);  			}
Magic Number,Unclassified.Util,SettingsAdapterFactory,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsAdapterFactory.cs,CreateStoreGetter,The following statement contains a magic number: if (attrs.Length == 1)  			{  				DefaultValueAttribute defAttr = (DefaultValueAttribute)attrs[0];  				if (propertyInfo.PropertyType.IsArray)  				{  					throw new NotSupportedException(  						"An array-type property cannot have a default value: " +  						propertyInfo.DeclaringType.Name + "." + propertyInfo.Name);  				}  				if (propType == typeof(bool))  				{  					if ((bool)defAttr.Value)  						ilGen.Emit(OpCodes.Ldc_I4_1);  					else  						ilGen.Emit(OpCodes.Ldc_I4_0);  				}  				else if (propType == typeof(int))  				{  					ilGen.Emit(OpCodes.Ldc_I4' Convert.ToInt32(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(long))  				{  					ilGen.Emit(OpCodes.Ldc_I8' Convert.ToInt64(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(double))  				{  					ilGen.Emit(OpCodes.Ldc_R8' Convert.ToDouble(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else if (propType == typeof(decimal))  				{  					decimal d = Convert.ToDecimal(defAttr.Value' CultureInfo.InvariantCulture);  					// Source: https://msdn.microsoft.com/en-us/library/bb1c1a6x.aspx  					var bits = decimal.GetBits(d);  					bool sign = (bits[3] & 0x80000000) != 0;  					byte scale = (byte) ((bits[3] >> 16) & 0x7f);  					ilGen.Emit(OpCodes.Ldc_I4' bits[0]);  					ilGen.Emit(OpCodes.Ldc_I4' bits[1]);  					ilGen.Emit(OpCodes.Ldc_I4' bits[2]);  					ilGen.Emit(sign ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);  					ilGen.Emit(OpCodes.Ldc_I4' (int) scale);  					var ctor = typeof(decimal).GetConstructor(new[] { typeof(int)' typeof(int)' typeof(int)' typeof(bool)' typeof(byte) });  					ilGen.Emit(OpCodes.Newobj' ctor);  				}  				else if (propType == typeof(string))  				{  					ilGen.Emit(OpCodes.Ldstr' Convert.ToString(defAttr.Value' CultureInfo.InvariantCulture));  				}  				else  				{  					throw new NotSupportedException(  						"The property type does not support default values: " +  						propertyInfo.DeclaringType.Name + "." + propertyInfo.Name);  				}  				ilGen.GenerateCallVirt(storeGetMethodWithDefault);  			}  			else  			{  				ilGen.GenerateCallVirt(storeGetMethod);  			}
Magic Number,Unclassified.Util,SettingsHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsHelper.cs,ColorToString,The following statement contains a magic number: return "#" + (color.A != 255 ? color.A.ToString("x2") : "") +  				color.R.ToString("x2") +  				color.G.ToString("x2") +  				color.B.ToString("x2");
Magic Number,Unclassified.Util,SettingsHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsHelper.cs,StringToColor,The following statement contains a magic number: if (str.Length != 6 && str.Length != 8)  				throw new FormatException("Invalid 6- or 8-digit hexadecimal color value.");
Magic Number,Unclassified.Util,SettingsHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsHelper.cs,StringToColor,The following statement contains a magic number: if (str.Length != 6 && str.Length != 8)  				throw new FormatException("Invalid 6- or 8-digit hexadecimal color value.");
Magic Number,Unclassified.Util,SettingsHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsHelper.cs,StringToColor,The following statement contains a magic number: if (str.Length == 6)  				value |= 0xff000000;
Magic Number,Unclassified.Util,SettingsHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsHelper.cs,StringToColor,The following statement contains a magic number: return Color.FromArgb(  				(byte)((value >> 24) & 0xff)'  				(byte)((value >> 16) & 0xff)'  				(byte)((value >> 8) & 0xff)'  				(byte)(value & 0xff));
Magic Number,Unclassified.Util,SettingsHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsHelper.cs,StringToColor,The following statement contains a magic number: return Color.FromArgb(  				(byte)((value >> 24) & 0xff)'  				(byte)((value >> 16) & 0xff)'  				(byte)((value >> 8) & 0xff)'  				(byte)(value & 0xff));
Magic Number,Unclassified.Util,SettingsHelper,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\SettingsHelper.cs,StringToColor,The following statement contains a magic number: return Color.FromArgb(  				(byte)((value >> 24) & 0xff)'  				(byte)((value >> 16) & 0xff)'  				(byte)((value >> 8) & 0xff)'  				(byte)(value & 0xff));
Magic Number,Unclassified.Util,StringExtensions,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\StringExtensions.cs,ToFileName,The following statement contains a magic number: int maxLength = 100;
Magic Number,Unclassified.Util,UnicodeInfo,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\UnicodeInfo.cs,UnicodeInfo,The following statement contains a magic number: using (var ds = new DeflateStream(stream' CompressionMode.Decompress))  			using (var sr = new StreamReader(ds))  			{  				while (!sr.EndOfStream)  				{  					string line = sr.ReadLine();  					if (line.Length > 4 && line[4] == '\t')  					{  						// Character definition  						string[] parts = line.Split('\t');  						int codePoint = int.Parse(parts[0]' System.Globalization.NumberStyles.HexNumber);  						int catIndex = int.Parse(parts[2]);  						characters[codePoint] = new UnicodeCharacter() { CodePoint = codePoint' Name = parts[1]' Category = categoryNames[catIndex] };  					}  					else  					{  						// Category name  						categoryNames.Add(line);  					}  				}  			}
Magic Number,Unclassified.Util,UnicodeInfo,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\UnicodeInfo.cs,UnicodeInfo,The following statement contains a magic number: using (var ds = new DeflateStream(stream' CompressionMode.Decompress))  			using (var sr = new StreamReader(ds))  			{  				while (!sr.EndOfStream)  				{  					string line = sr.ReadLine();  					if (line.Length > 4 && line[4] == '\t')  					{  						// Character definition  						string[] parts = line.Split('\t');  						int codePoint = int.Parse(parts[0]' System.Globalization.NumberStyles.HexNumber);  						int catIndex = int.Parse(parts[2]);  						characters[codePoint] = new UnicodeCharacter() { CodePoint = codePoint' Name = parts[1]' Category = categoryNames[catIndex] };  					}  					else  					{  						// Category name  						categoryNames.Add(line);  					}  				}  			}
Magic Number,Unclassified.Util,UnicodeInfo,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\UnicodeInfo.cs,UnicodeInfo,The following statement contains a magic number: using (var ds = new DeflateStream(stream' CompressionMode.Decompress))  			using (var sr = new StreamReader(ds))  			{  				while (!sr.EndOfStream)  				{  					string line = sr.ReadLine();  					if (line.Length > 4 && line[4] == '\t')  					{  						// Character definition  						string[] parts = line.Split('\t');  						int codePoint = int.Parse(parts[0]' System.Globalization.NumberStyles.HexNumber);  						int catIndex = int.Parse(parts[2]);  						characters[codePoint] = new UnicodeCharacter() { CodePoint = codePoint' Name = parts[1]' Category = categoryNames[catIndex] };  					}  					else  					{  						// Category name  						categoryNames.Add(line);  					}  				}  			}
Magic Number,Unclassified.Util,WinApi,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\Util\WinApi_Input.cs,GET_APPCOMMAND_LPARAM,The following statement contains a magic number: return ((short)(((lParam >> 16) & 0xFFFF) & ~FAPPCOMMAND_MASK));
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CultureTextViewModel,The following statement contains a magic number: BackgroundBrush = cultureName == TextKeyVM.MainWindowVM.PrimaryCulture ?  				new SolidColorBrush(Color.FromArgb(20' 0' 192' 0)) :  				new SolidColorBrush(Color.FromArgb(20' 0' 192' 0));
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CultureTextViewModel,The following statement contains a magic number: BackgroundBrush = cultureName == TextKeyVM.MainWindowVM.PrimaryCulture ?  				new SolidColorBrush(Color.FromArgb(20' 0' 192' 0)) :  				new SolidColorBrush(Color.FromArgb(20' 0' 192' 0));
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CultureTextViewModel,The following statement contains a magic number: BackgroundBrush = cultureName == TextKeyVM.MainWindowVM.PrimaryCulture ?  				new SolidColorBrush(Color.FromArgb(20' 0' 192' 0)) :  				new SolidColorBrush(Color.FromArgb(20' 0' 192' 0));
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CultureTextViewModel,The following statement contains a magic number: BackgroundBrush = cultureName == TextKeyVM.MainWindowVM.PrimaryCulture ?  				new SolidColorBrush(Color.FromArgb(20' 0' 192' 0)) :  				new SolidColorBrush(Color.FromArgb(20' 0' 192' 0));
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The following statement contains a magic number: if (CultureName.Length >= 2 && otherName.Length >= 2)  			{  				// Prefer primary culture (with or without region; if set)  				if (!string.IsNullOrEmpty(TextKeyVM.MainWindowVM.PrimaryCulture))  				{  					// tP:  thisPrimary  					// oP:  otherPrimary  					// oPR: otherPrimaryRelated  					//  					//             !tPR         tPR  					//             !tP    tP    !tP   tP  					//           --------------------------  					// !oPR  !oP | cont.  xxx | -1    -1  |  					//       oP  |  xxx   xxx | xxx   xxx |  					//           --------------------------  					// oPR   !oP |   1    xxx | cont. -1  |  					//       oP  |   1    xxx |  1    xxx |  					//           --------------------------    					bool thisPrimary = string.Compare(CultureName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool thisPrimaryRelated = CultureName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));  					bool otherPrimary = string.Compare(otherName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool otherPrimaryRelated = otherName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));    					if (thisPrimary || thisPrimaryRelated && !otherPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (2)");  						return -1;  					}  					if (otherPrimary || otherPrimaryRelated && !thisPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (2)");  						return 1;  					}  				}    				if (string.Compare(CultureName.Substring(0' 2)' otherName.Substring(0' 2)' StringComparison.InvariantCultureIgnoreCase) == 0)  				{  					// Same language' prefer shorter names (without region)  					if (CultureName.Length != otherName.Length)  					{  						int i = CultureName.Length - otherName.Length;  						//if (i < 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (3)");  						//else if (i > 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (3)");  						//else  						//    System.Diagnostics.Debug.WriteLine(CultureName + " = " + otherName + " (3)");  						return i;  						// If this.length < other.length' then the result is negative and this comes before other  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The following statement contains a magic number: if (CultureName.Length >= 2 && otherName.Length >= 2)  			{  				// Prefer primary culture (with or without region; if set)  				if (!string.IsNullOrEmpty(TextKeyVM.MainWindowVM.PrimaryCulture))  				{  					// tP:  thisPrimary  					// oP:  otherPrimary  					// oPR: otherPrimaryRelated  					//  					//             !tPR         tPR  					//             !tP    tP    !tP   tP  					//           --------------------------  					// !oPR  !oP | cont.  xxx | -1    -1  |  					//       oP  |  xxx   xxx | xxx   xxx |  					//           --------------------------  					// oPR   !oP |   1    xxx | cont. -1  |  					//       oP  |   1    xxx |  1    xxx |  					//           --------------------------    					bool thisPrimary = string.Compare(CultureName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool thisPrimaryRelated = CultureName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));  					bool otherPrimary = string.Compare(otherName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool otherPrimaryRelated = otherName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));    					if (thisPrimary || thisPrimaryRelated && !otherPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (2)");  						return -1;  					}  					if (otherPrimary || otherPrimaryRelated && !thisPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (2)");  						return 1;  					}  				}    				if (string.Compare(CultureName.Substring(0' 2)' otherName.Substring(0' 2)' StringComparison.InvariantCultureIgnoreCase) == 0)  				{  					// Same language' prefer shorter names (without region)  					if (CultureName.Length != otherName.Length)  					{  						int i = CultureName.Length - otherName.Length;  						//if (i < 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (3)");  						//else if (i > 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (3)");  						//else  						//    System.Diagnostics.Debug.WriteLine(CultureName + " = " + otherName + " (3)");  						return i;  						// If this.length < other.length' then the result is negative and this comes before other  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The following statement contains a magic number: if (CultureName.Length >= 2 && otherName.Length >= 2)  			{  				// Prefer primary culture (with or without region; if set)  				if (!string.IsNullOrEmpty(TextKeyVM.MainWindowVM.PrimaryCulture))  				{  					// tP:  thisPrimary  					// oP:  otherPrimary  					// oPR: otherPrimaryRelated  					//  					//             !tPR         tPR  					//             !tP    tP    !tP   tP  					//           --------------------------  					// !oPR  !oP | cont.  xxx | -1    -1  |  					//       oP  |  xxx   xxx | xxx   xxx |  					//           --------------------------  					// oPR   !oP |   1    xxx | cont. -1  |  					//       oP  |   1    xxx |  1    xxx |  					//           --------------------------    					bool thisPrimary = string.Compare(CultureName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool thisPrimaryRelated = CultureName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));  					bool otherPrimary = string.Compare(otherName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool otherPrimaryRelated = otherName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));    					if (thisPrimary || thisPrimaryRelated && !otherPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (2)");  						return -1;  					}  					if (otherPrimary || otherPrimaryRelated && !thisPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (2)");  						return 1;  					}  				}    				if (string.Compare(CultureName.Substring(0' 2)' otherName.Substring(0' 2)' StringComparison.InvariantCultureIgnoreCase) == 0)  				{  					// Same language' prefer shorter names (without region)  					if (CultureName.Length != otherName.Length)  					{  						int i = CultureName.Length - otherName.Length;  						//if (i < 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (3)");  						//else if (i > 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (3)");  						//else  						//    System.Diagnostics.Debug.WriteLine(CultureName + " = " + otherName + " (3)");  						return i;  						// If this.length < other.length' then the result is negative and this comes before other  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The following statement contains a magic number: if (CultureName.Length >= 2 && otherName.Length >= 2)  			{  				// Prefer primary culture (with or without region; if set)  				if (!string.IsNullOrEmpty(TextKeyVM.MainWindowVM.PrimaryCulture))  				{  					// tP:  thisPrimary  					// oP:  otherPrimary  					// oPR: otherPrimaryRelated  					//  					//             !tPR         tPR  					//             !tP    tP    !tP   tP  					//           --------------------------  					// !oPR  !oP | cont.  xxx | -1    -1  |  					//       oP  |  xxx   xxx | xxx   xxx |  					//           --------------------------  					// oPR   !oP |   1    xxx | cont. -1  |  					//       oP  |   1    xxx |  1    xxx |  					//           --------------------------    					bool thisPrimary = string.Compare(CultureName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool thisPrimaryRelated = CultureName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));  					bool otherPrimary = string.Compare(otherName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool otherPrimaryRelated = otherName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));    					if (thisPrimary || thisPrimaryRelated && !otherPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (2)");  						return -1;  					}  					if (otherPrimary || otherPrimaryRelated && !thisPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (2)");  						return 1;  					}  				}    				if (string.Compare(CultureName.Substring(0' 2)' otherName.Substring(0' 2)' StringComparison.InvariantCultureIgnoreCase) == 0)  				{  					// Same language' prefer shorter names (without region)  					if (CultureName.Length != otherName.Length)  					{  						int i = CultureName.Length - otherName.Length;  						//if (i < 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (3)");  						//else if (i > 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (3)");  						//else  						//    System.Diagnostics.Debug.WriteLine(CultureName + " = " + otherName + " (3)");  						return i;  						// If this.length < other.length' then the result is negative and this comes before other  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The following statement contains a magic number: if (CultureName.Length >= 2 && otherName.Length >= 2)  			{  				// Prefer primary culture (with or without region; if set)  				if (!string.IsNullOrEmpty(TextKeyVM.MainWindowVM.PrimaryCulture))  				{  					// tP:  thisPrimary  					// oP:  otherPrimary  					// oPR: otherPrimaryRelated  					//  					//             !tPR         tPR  					//             !tP    tP    !tP   tP  					//           --------------------------  					// !oPR  !oP | cont.  xxx | -1    -1  |  					//       oP  |  xxx   xxx | xxx   xxx |  					//           --------------------------  					// oPR   !oP |   1    xxx | cont. -1  |  					//       oP  |   1    xxx |  1    xxx |  					//           --------------------------    					bool thisPrimary = string.Compare(CultureName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool thisPrimaryRelated = CultureName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));  					bool otherPrimary = string.Compare(otherName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool otherPrimaryRelated = otherName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));    					if (thisPrimary || thisPrimaryRelated && !otherPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (2)");  						return -1;  					}  					if (otherPrimary || otherPrimaryRelated && !thisPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (2)");  						return 1;  					}  				}    				if (string.Compare(CultureName.Substring(0' 2)' otherName.Substring(0' 2)' StringComparison.InvariantCultureIgnoreCase) == 0)  				{  					// Same language' prefer shorter names (without region)  					if (CultureName.Length != otherName.Length)  					{  						int i = CultureName.Length - otherName.Length;  						//if (i < 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (3)");  						//else if (i > 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (3)");  						//else  						//    System.Diagnostics.Debug.WriteLine(CultureName + " = " + otherName + " (3)");  						return i;  						// If this.length < other.length' then the result is negative and this comes before other  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,CultureTextViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\CultureTextViewModel.cs,CompareTo,The following statement contains a magic number: if (CultureName.Length >= 2 && otherName.Length >= 2)  			{  				// Prefer primary culture (with or without region; if set)  				if (!string.IsNullOrEmpty(TextKeyVM.MainWindowVM.PrimaryCulture))  				{  					// tP:  thisPrimary  					// oP:  otherPrimary  					// oPR: otherPrimaryRelated  					//  					//             !tPR         tPR  					//             !tP    tP    !tP   tP  					//           --------------------------  					// !oPR  !oP | cont.  xxx | -1    -1  |  					//       oP  |  xxx   xxx | xxx   xxx |  					//           --------------------------  					// oPR   !oP |   1    xxx | cont. -1  |  					//       oP  |   1    xxx |  1    xxx |  					//           --------------------------    					bool thisPrimary = string.Compare(CultureName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool thisPrimaryRelated = CultureName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));  					bool otherPrimary = string.Compare(otherName' TextKeyVM.MainWindowVM.PrimaryCulture' StringComparison.InvariantCultureIgnoreCase) == 0;  					bool otherPrimaryRelated = otherName.StartsWith(TextKeyVM.MainWindowVM.PrimaryCulture.Substring(0' 2));    					if (thisPrimary || thisPrimaryRelated && !otherPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (2)");  						return -1;  					}  					if (otherPrimary || otherPrimaryRelated && !thisPrimaryRelated)  					{  						//System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (2)");  						return 1;  					}  				}    				if (string.Compare(CultureName.Substring(0' 2)' otherName.Substring(0' 2)' StringComparison.InvariantCultureIgnoreCase) == 0)  				{  					// Same language' prefer shorter names (without region)  					if (CultureName.Length != otherName.Length)  					{  						int i = CultureName.Length - otherName.Length;  						//if (i < 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " < " + otherName + " (3)");  						//else if (i > 0)  						//    System.Diagnostics.Debug.WriteLine(CultureName + " > " + otherName + " (3)");  						//else  						//    System.Diagnostics.Debug.WriteLine(CultureName + " = " + otherName + " (3)");  						return i;  						// If this.length < other.length' then the result is negative and this comes before other  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,MainViewModel,The following statement contains a magic number: searchDc = DelayedCall.Create(UpdateSearch' 250);
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,Save,The following statement contains a magic number: if (loadedFilePath == null || loadedFilePrefix == null)  			{  				// Ask for new file name and version  				SaveFileDialog dlg = new SaveFileDialog();  				dlg.AddExtension = true;  				dlg.CheckPathExists = true;  				dlg.DefaultExt = ".txd";  				dlg.Filter = Tx.T("file filter.tx dictionary files") + " (*.txd)|*.txd|" +  					Tx.T("file filter.xml files") + " (*.xml)|*.xml|" +  					Tx.T("file filter.all files") + " (*.*)|*.*";  				dlg.OverwritePrompt = true;  				dlg.Title = Tx.T("msg.save.title");  				if (dlg.ShowDialog(MainWindow.Instance) == true)  				{  					newFilePath = Path.GetDirectoryName(dlg.FileName);  					newFilePrefix = Path.GetFileNameWithoutExtension(dlg.FileName);  					fileVersion = 2;  					if (Path.GetExtension(dlg.FileName) == ".xml")  						fileVersion = 1;  				}  				else  				{  					return false;  				}  			}  			else if (fileVersion == 1)  			{  				// Saving existing format 1 file.  				// Ask to upgrade to version 2 format.    				if (App.Settings.File.AskSaveUpgrade)  				{  					var result = TaskDialog.Show(  						owner: MainWindow.Instance'  						allowDialogCancellation: true'  						title: "TxEditor"'  						mainInstruction: Tx.T("msg.save.upgrade to format 2")'  						customButtons: new string[] { Tx.T("task dialog.button.upgrade")' Tx.T("task dialog.button.save in original format") }'  						verificationText: Tx.T("msg.save.upgrade to format 2.dont ask again"));    					if (result.CustomButtonResult == null)  					{  						return false;  					}  					if (result.CustomButtonResult == 0)  					{  						fileVersion = 2;  					}  					if (result.VerificationChecked == true)  					{  						// Remember to not ask again  						App.Settings.File.AskSaveUpgrade = false;  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,Save,The following statement contains a magic number: if (loadedFilePath == null || loadedFilePrefix == null)  			{  				// Ask for new file name and version  				SaveFileDialog dlg = new SaveFileDialog();  				dlg.AddExtension = true;  				dlg.CheckPathExists = true;  				dlg.DefaultExt = ".txd";  				dlg.Filter = Tx.T("file filter.tx dictionary files") + " (*.txd)|*.txd|" +  					Tx.T("file filter.xml files") + " (*.xml)|*.xml|" +  					Tx.T("file filter.all files") + " (*.*)|*.*";  				dlg.OverwritePrompt = true;  				dlg.Title = Tx.T("msg.save.title");  				if (dlg.ShowDialog(MainWindow.Instance) == true)  				{  					newFilePath = Path.GetDirectoryName(dlg.FileName);  					newFilePrefix = Path.GetFileNameWithoutExtension(dlg.FileName);  					fileVersion = 2;  					if (Path.GetExtension(dlg.FileName) == ".xml")  						fileVersion = 1;  				}  				else  				{  					return false;  				}  			}  			else if (fileVersion == 1)  			{  				// Saving existing format 1 file.  				// Ask to upgrade to version 2 format.    				if (App.Settings.File.AskSaveUpgrade)  				{  					var result = TaskDialog.Show(  						owner: MainWindow.Instance'  						allowDialogCancellation: true'  						title: "TxEditor"'  						mainInstruction: Tx.T("msg.save.upgrade to format 2")'  						customButtons: new string[] { Tx.T("task dialog.button.upgrade")' Tx.T("task dialog.button.save in original format") }'  						verificationText: Tx.T("msg.save.upgrade to format 2.dont ask again"));    					if (result.CustomButtonResult == null)  					{  						return false;  					}  					if (result.CustomButtonResult == 0)  					{  						fileVersion = 2;  					}  					if (result.VerificationChecked == true)  					{  						// Remember to not ask again  						App.Settings.File.AskSaveUpgrade = false;  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The following statement contains a magic number: if (App.Settings.Wizard.HotkeyInVisualStudioOnly)  			{  				StringBuilder sb = new StringBuilder(1000);  				WinApi.GetWindowText(fgWin' sb' 1000);  				if (!sb.ToString().EndsWith(" - Microsoft Visual Studio")) return;    				// Find active document file name  				try  				{  					var focusedElement = System.Windows.Automation.AutomationElement.FocusedElement;  					if (focusedElement != null)  					{  						var treeWalker = System.Windows.Automation.TreeWalker.ControlViewWalker;  						var parent = treeWalker.GetParent(focusedElement);  						while (parent != null &&  							(parent.Current.ControlType != System.Windows.Automation.ControlType.Pane ||  							parent.Current.ClassName != "ViewPresenter" ||  							string.IsNullOrEmpty(parent.Current.Name)))  						{  							parent = treeWalker.GetParent(parent);  						}  						if (parent != null)  						{  							string fileName = parent.Current.Name.TrimEnd('*');  							fileExtension = Path.GetExtension(fileName).ToLowerInvariant();  						}  					}  				}  				catch (Exception ex)  				{  					FL.Warning(ex' "Getting UI Automation info");  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The following statement contains a magic number: if (App.Settings.Wizard.HotkeyInVisualStudioOnly)  			{  				StringBuilder sb = new StringBuilder(1000);  				WinApi.GetWindowText(fgWin' sb' 1000);  				if (!sb.ToString().EndsWith(" - Microsoft Visual Studio")) return;    				// Find active document file name  				try  				{  					var focusedElement = System.Windows.Automation.AutomationElement.FocusedElement;  					if (focusedElement != null)  					{  						var treeWalker = System.Windows.Automation.TreeWalker.ControlViewWalker;  						var parent = treeWalker.GetParent(focusedElement);  						while (parent != null &&  							(parent.Current.ControlType != System.Windows.Automation.ControlType.Pane ||  							parent.Current.ClassName != "ViewPresenter" ||  							string.IsNullOrEmpty(parent.Current.Name)))  						{  							parent = treeWalker.GetParent(parent);  						}  						if (parent != null)  						{  							string fileName = parent.Current.Name.TrimEnd('*');  							fileExtension = Path.GetExtension(fileName).ToLowerInvariant();  						}  					}  				}  				catch (Exception ex)  				{  					FL.Warning(ex' "Getting UI Automation info");  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey,The following statement contains a magic number: DelayedCall.Start(() => TextKeyWizardFromHotKey2(fileExtension)' 50);
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The following statement contains a magic number: MainWindow.Instance.Top -= 10000;
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The following statement contains a magic number: DelayedCall.Start(() => MainWindow.Instance.Top += 10000' 100);
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The following statement contains a magic number: DelayedCall.Start(() => MainWindow.Instance.Top += 10000' 100);
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The following statement contains a magic number: if (clipboardBackup != null)  			{  				DelayedCall.Start(TextKeyWizardFromHotKey3' 500);  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXmlFile,The following statement contains a magic number: if (m.Success)  			{  				CultureInfo ci = CultureInfo.GetCultureInfo(m.Groups[2].Value);  				if (importing && !LoadedCultureNames.Contains(ci.Name))  				{  					var result = TaskDialog.Show(  						owner: MainWindow.Instance'  						allowDialogCancellation: true'  						title: "TxEditor"'  						mainInstruction: Tx.T("msg.import file.add new culture"' "culture"' ci.Name)'  						content: Tx.T("msg.import file.add new culture.desc"' "name"' fileName' "culture"' ci.Name)'  						customButtons: new string[] { Tx.T("task dialog.button.add culture")' Tx.T("task dialog.button.skip culture")' Tx.T("task dialog.button.cancel") });    					if (result.CustomButtonResult == 0)  					{  					}  					else if (result.CustomButtonResult == 1)  					{  						return true;  					}  					else  					{  						return false;  					}  				}  				LoadFromXml(ci.Name' xmlDoc.DocumentElement);    				if (!importing)  				{  					// Set the primary culture if a file claims to be it  					XmlAttribute primaryAttr = xmlDoc.DocumentElement.Attributes["primary"];  					if (primaryAttr != null && primaryAttr.Value == "true")  					{  						PrimaryCulture = ci.Name;  						SortCulturesInTextKey(RootTextKey);  					}  					if (fileVersion == 0)  					{  						fileVersion = 1;  						loadedFilePath = Path.GetDirectoryName(fileName);  						loadedFilePrefix = m.Groups[1].Value;  						UpdateTitle();  					}  				}  				return true;  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXmlFile,The following statement contains a magic number: if (fileVersion == 0 && !importing)  			{  				fileVersion = 2;  				loadedFilePath = Path.GetDirectoryName(fileName);  				loadedFilePrefix = Path.GetFileNameWithoutExtension(fileName);  				UpdateTitle();  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXml,The following statement contains a magic number: foreach (XmlNode textNode in xe.SelectNodes("text[@key]"))  			{  				string text = textNode.InnerText;  				string key = textNode.Attributes["key"].Value;    				string errorMessage;  				if (!TextKeyViewModel.ValidateName(key' out errorMessage))  				{  					//Log("Load XML: Invalid key: " + errorMessage + " Ignoring definition.");  					continue;  				}    				int count = -1;  				XmlAttribute countAttr = textNode.Attributes["count"];  				if (countAttr != null)  				{  					if (!int.TryParse(countAttr.Value' out count))  					{  						// Count value unparsable. Skip invalid entries  						//Log("Load XML: Count attribute value of key {0} is not an integer. Ignoring definition."' key);  						continue;  					}  					if (count < 0 || count > ushort.MaxValue)  					{  						// Count value out of range. Skip invalid entries  						//Log("Load XML: Count attribute value of key {0} is out of range. Ignoring definition."' key);  						continue;  					}  				}    				int modulo = 0;  				XmlAttribute moduloAttr = textNode.Attributes["mod"];  				if (moduloAttr != null)  				{  					if (!int.TryParse(moduloAttr.Value' out modulo))  					{  						// Modulo value unparsable. Skip invalid entries  						//Log("Load XML: Modulo attribute of key {0} is not an integer. Ignoring definition."' key);  						continue;  					}  					if (modulo < 2 || modulo > 1000)  					{  						// Modulo value out of range. Skip invalid entries  						//Log("Load XML: Modulo attribute of key {0} is out of range. Ignoring definition."' key);  						continue;  					}  				}    				string comment = null;  				XmlAttribute commentAttr = textNode.Attributes["comment"];  				if (commentAttr != null)  				{  					comment = commentAttr.Value;  					if (string.IsNullOrWhiteSpace(comment))  						comment = null;  				}    				XmlAttribute acceptMissingAttr = textNode.Attributes["acceptmissing"];  				bool acceptMissing = acceptMissingAttr != null && acceptMissingAttr.Value == "true";    				XmlAttribute acceptPlaceholdersAttr = textNode.Attributes["acceptplaceholders"];  				bool acceptPlaceholders = acceptPlaceholdersAttr != null && acceptPlaceholdersAttr.Value == "true";    				XmlAttribute acceptPunctuationAttr = textNode.Attributes["acceptpunctuation"];  				bool acceptPunctuation = acceptPunctuationAttr != null && acceptPunctuationAttr.Value == "true";    				// TODO: Catch exceptions NonNamespaceExistsException and NamespaceExistsException for invalid files  				TextKeyViewModel tk = FindOrCreateTextKey(key);    				if (comment != null)  					tk.Comment = comment;    				// Ensure that all loaded cultures exist in every text key so that they can be entered  				foreach (string cn in LoadedCultureNames)  				{  					EnsureCultureInTextKey(tk' cn);  				}  				tk.UpdateCultureTextSeparators();    				// Find the current culture  				var ct = tk.CultureTextVMs.FirstOrDefault(vm => vm.CultureName == cultureName);  				if (count == -1)  				{  					// Default text' store it directly in the item  					ct.Text = text;  					ct.AcceptMissing = acceptMissing;  					ct.AcceptPlaceholders = acceptPlaceholders;  					ct.AcceptPunctuation = acceptPunctuation;  				}  				else  				{  					// Quantified text' go deeper  					// Update existing entry or create and add a new one  					QuantifiedTextViewModel qt = ct.QuantifiedTextVMs  						.FirstOrDefault(q => q.Count == count && q.Modulo == modulo);    					bool newQt = qt == null;  					if (qt == null)  					{  						qt = new QuantifiedTextViewModel(ct);  						qt.Count = count;  						qt.Modulo = modulo;  					}  					qt.Text = text;  					qt.AcceptMissing = acceptMissing;  					qt.AcceptPlaceholders = acceptPlaceholders;  					qt.AcceptPunctuation = acceptPunctuation;  					if (newQt)  					{  						ct.QuantifiedTextVMs.InsertSorted(qt' (a' b) => QuantifiedTextViewModel.Compare(a' b));  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,LoadFromXml,The following statement contains a magic number: foreach (XmlNode textNode in xe.SelectNodes("text[@key]"))  			{  				string text = textNode.InnerText;  				string key = textNode.Attributes["key"].Value;    				string errorMessage;  				if (!TextKeyViewModel.ValidateName(key' out errorMessage))  				{  					//Log("Load XML: Invalid key: " + errorMessage + " Ignoring definition.");  					continue;  				}    				int count = -1;  				XmlAttribute countAttr = textNode.Attributes["count"];  				if (countAttr != null)  				{  					if (!int.TryParse(countAttr.Value' out count))  					{  						// Count value unparsable. Skip invalid entries  						//Log("Load XML: Count attribute value of key {0} is not an integer. Ignoring definition."' key);  						continue;  					}  					if (count < 0 || count > ushort.MaxValue)  					{  						// Count value out of range. Skip invalid entries  						//Log("Load XML: Count attribute value of key {0} is out of range. Ignoring definition."' key);  						continue;  					}  				}    				int modulo = 0;  				XmlAttribute moduloAttr = textNode.Attributes["mod"];  				if (moduloAttr != null)  				{  					if (!int.TryParse(moduloAttr.Value' out modulo))  					{  						// Modulo value unparsable. Skip invalid entries  						//Log("Load XML: Modulo attribute of key {0} is not an integer. Ignoring definition."' key);  						continue;  					}  					if (modulo < 2 || modulo > 1000)  					{  						// Modulo value out of range. Skip invalid entries  						//Log("Load XML: Modulo attribute of key {0} is out of range. Ignoring definition."' key);  						continue;  					}  				}    				string comment = null;  				XmlAttribute commentAttr = textNode.Attributes["comment"];  				if (commentAttr != null)  				{  					comment = commentAttr.Value;  					if (string.IsNullOrWhiteSpace(comment))  						comment = null;  				}    				XmlAttribute acceptMissingAttr = textNode.Attributes["acceptmissing"];  				bool acceptMissing = acceptMissingAttr != null && acceptMissingAttr.Value == "true";    				XmlAttribute acceptPlaceholdersAttr = textNode.Attributes["acceptplaceholders"];  				bool acceptPlaceholders = acceptPlaceholdersAttr != null && acceptPlaceholdersAttr.Value == "true";    				XmlAttribute acceptPunctuationAttr = textNode.Attributes["acceptpunctuation"];  				bool acceptPunctuation = acceptPunctuationAttr != null && acceptPunctuationAttr.Value == "true";    				// TODO: Catch exceptions NonNamespaceExistsException and NamespaceExistsException for invalid files  				TextKeyViewModel tk = FindOrCreateTextKey(key);    				if (comment != null)  					tk.Comment = comment;    				// Ensure that all loaded cultures exist in every text key so that they can be entered  				foreach (string cn in LoadedCultureNames)  				{  					EnsureCultureInTextKey(tk' cn);  				}  				tk.UpdateCultureTextSeparators();    				// Find the current culture  				var ct = tk.CultureTextVMs.FirstOrDefault(vm => vm.CultureName == cultureName);  				if (count == -1)  				{  					// Default text' store it directly in the item  					ct.Text = text;  					ct.AcceptMissing = acceptMissing;  					ct.AcceptPlaceholders = acceptPlaceholders;  					ct.AcceptPunctuation = acceptPunctuation;  				}  				else  				{  					// Quantified text' go deeper  					// Update existing entry or create and add a new one  					QuantifiedTextViewModel qt = ct.QuantifiedTextVMs  						.FirstOrDefault(q => q.Count == count && q.Modulo == modulo);    					bool newQt = qt == null;  					if (qt == null)  					{  						qt = new QuantifiedTextViewModel(ct);  						qt.Count = count;  						qt.Modulo = modulo;  					}  					qt.Text = text;  					qt.AcceptMissing = acceptMissing;  					qt.AcceptPlaceholders = acceptPlaceholders;  					qt.AcceptPunctuation = acceptPunctuation;  					if (newQt)  					{  						ct.QuantifiedTextVMs.InsertSorted(qt' (a' b) => QuantifiedTextViewModel.Compare(a' b));  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteToXmlFile,The following statement contains a magic number: if (fileVersion == 1 && !exporting)  			{  				// Check all files for read-only attribute  				foreach (var cultureName in LoadedCultureNames.Union(DeletedCultureNames).Distinct())  				{  					string cultureFileName = fileNamePrefix + "." + cultureName + ".xml";  					FileInfo fi = new FileInfo(cultureFileName);  					if (fi.Exists && fi.IsReadOnly)  					{  						App.ErrorMessage(Tx.T("msg.cannot write to read-only file"));  						return false;  					}  				}    				// Delete previous backups and move current files to backup  				foreach (var cultureName in LoadedCultureNames.Union(DeletedCultureNames).Distinct())  				{  					string cultureFileName = fileNamePrefix + "." + cultureName + ".xml";  					if (File.Exists(cultureFileName))  					{  						try  						{  							File.Delete(cultureFileName + ".bak");  						}  						catch (Exception ex)  						{  							App.ErrorMessage(Tx.T("msg.cannot delete backup file"' "name"' cultureFileName + ".bak")' ex' "Saving file' deleting old backups");  							return false;  						}  						try  						{  							File.Move(cultureFileName' cultureFileName + ".bak");  						}  						catch (Exception ex)  						{  							App.ErrorMessage(Tx.T("msg.cannot backup file.v1"' "name"' cultureFileName)' ex' "Saving file' creating backups");  							return false;  						}  					}  				}    				// Write new files' one for each loaded culture  				foreach (var cultureName in LoadedCultureNames)  				{  					XmlDocument xmlDoc = new XmlDocument();  					xmlDoc.AppendChild(xmlDoc.CreateElement("translation"));  					var spaceAttr = xmlDoc.CreateAttribute("xml:space");  					spaceAttr.Value = "preserve";  					xmlDoc.DocumentElement.Attributes.Append(spaceAttr);  					if (cultureName == PrimaryCulture)  					{  						var primaryAttr = xmlDoc.CreateAttribute("primary");  						primaryAttr.Value = "true";  						xmlDoc.DocumentElement.Attributes.Append(primaryAttr);  					}  					if (IsTemplateFile)  					{  						var templateAttr = xmlDoc.CreateAttribute("template");  						templateAttr.Value = "true";  						xmlDoc.DocumentElement.Attributes.Append(templateAttr);  					}  					WriteToXml(cultureName' xmlDoc.DocumentElement' exporting);    					// Write xmlDoc to file  					try  					{  						WriteXmlToFile(xmlDoc' fileNamePrefix + "." + cultureName + ".xml");  					}  					catch (Exception ex)  					{  						App.ErrorMessage(Tx.T("msg.cannot write file.v1"' "name"' fileNamePrefix + "." + cultureName + ".xml")' ex' "Saving file");  						return false;  					}  				}    				// Delete all backup files (could also be an option)  				int deleteErrorCount = 0;  				foreach (var cultureName in LoadedCultureNames.Union(DeletedCultureNames).Distinct())  				{  					string cultureFileName = fileNamePrefix + "." + cultureName + ".xml";  					try  					{  						File.Delete(cultureFileName + ".bak");  					}  					catch  					{  						deleteErrorCount++;  					}  				}  				if (deleteErrorCount > 0)  				{  					App.ErrorMessage(Tx.T("msg.cannot delete new backup file.v1"));  				}  				DeletedCultureNames.Clear();  			}  			else if (fileVersion == 2 || exporting)  			{  				// Check file for read-only attribute  				FileInfo fi = new FileInfo(fileNamePrefix + ".txd");  				if (fi.Exists && fi.IsReadOnly)  				{  					App.ErrorMessage(Tx.T("msg.cannot write to read-only file"));  					return false;  				}    				// Delete previous backup and move current file to backup  				bool haveBackup = false;  				if (File.Exists(fileNamePrefix + ".txd"))  				{  					try  					{  						File.Delete(fileNamePrefix + ".txd.bak");  					}  					catch (Exception ex)  					{  						App.ErrorMessage(Tx.T("msg.cannot delete backup file"' "name"' fileNamePrefix + ".txd.bak")' ex' "Saving file' deleting old backup");  						return false;  					}  					try  					{  						File.Move(fileNamePrefix + ".txd"' fileNamePrefix + ".txd.bak");  						haveBackup = true;  					}  					catch (Exception ex)  					{  						App.ErrorMessage(Tx.T("msg.cannot backup file.v2"' "name"' fileNamePrefix + ".txd")' ex' "Saving file' creating backup");  						return false;  					}  				}    				XmlDocument xmlDoc = new XmlDocument();  				xmlDoc.AppendChild(xmlDoc.CreateComment(" TxTranslation dictionary file. Use TxEditor to edit this file. http://unclassified.software/txtranslation "));  				xmlDoc.AppendChild(xmlDoc.CreateElement("translation"));  				var spaceAttr = xmlDoc.CreateAttribute("xml:space");  				spaceAttr.Value = "preserve";  				xmlDoc.DocumentElement.Attributes.Append(spaceAttr);  				if (IsTemplateFile && !exporting)  				{  					var templateAttr = xmlDoc.CreateAttribute("template");  					templateAttr.Value = "true";  					xmlDoc.DocumentElement.Attributes.Append(templateAttr);  				}    				foreach (var cultureName in LoadedCultureNames.OrderBy(cn => cn))  				{  					var cultureElement = xmlDoc.CreateElement("culture");  					xmlDoc.DocumentElement.AppendChild(cultureElement);  					var nameAttr = xmlDoc.CreateAttribute("name");  					nameAttr.Value = cultureName;  					cultureElement.Attributes.Append(nameAttr);  					if (cultureName == PrimaryCulture)  					{  						var primaryAttr = xmlDoc.CreateAttribute("primary");  						primaryAttr.Value = "true";  						cultureElement.Attributes.Append(primaryAttr);  					}  					WriteToXml(cultureName' cultureElement' exporting);  				}    				// Write xmlDoc to file  				try  				{  					WriteXmlToFile(xmlDoc' fileNamePrefix + ".txd");  				}  				catch (Exception ex)  				{  					// Try to restore the backup file  					if (haveBackup)  					{  						try  						{  							File.Delete(fileNamePrefix + ".txd");  							File.Move(fileNamePrefix + ".txd.bak"' fileNamePrefix + ".txd");    							App.ErrorMessage(Tx.T("msg.cannot write file.v2 restored"' "name"' fileNamePrefix + ".txd")' ex' "Saving file");  						}  						catch (Exception ex2)  						{  							App.ErrorMessage(Tx.T("msg.cannot write file.v2"' "name"' fileNamePrefix + ".txd"' "firstmsg"' ex.Message)' ex2' "Saving file' restoring backup");  						}  					}  					else  					{  						App.ErrorMessage(Tx.T("msg.cannot write file.v2 no backup"' "name"' fileNamePrefix + ".txd")' ex' "Saving file");  					}  					return false;  				}    				// Delete backup file (could also be an option)  				try  				{  					File.Delete(fileNamePrefix + ".txd.bak");  				}  				catch (Exception ex)  				{  					App.ErrorMessage(Tx.T("msg.cannot delete new backup file.v2"' "name"' fileNamePrefix + ".txd.bak")' ex' "Saving file' deleting new backup");  				}  			}  			else  			{  				App.ErrorMessage(Tx.T("msg.cannot save unsupported file version"' "ver"' fileVersion.ToString()));  				return false;  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The following statement contains a magic number: if (textKeyVM.IsFullKey && textKeyVM.TextKey != null &&  				(!exporting || textKeyVM.IsSelectedRecursive()))  			{  				var cultureTextVM = textKeyVM.CultureTextVMs.FirstOrDefault(vm => vm.CultureName == cultureName);  				if (cultureTextVM != null)  				{  					if (!string.IsNullOrEmpty(cultureTextVM.Text) ||  						textKeyVM.IsEmpty() && cultureName == PrimaryCulture && !textKeyVM.TextKey.StartsWith("Tx:") ||   // Save empty text keys in the primary culture at least (not for system keys)  						cultureName == PrimaryCulture && !string.IsNullOrWhiteSpace(textKeyVM.Comment) ||   // Always keep comments in the primary culture  						cultureTextVM.AcceptMissing || cultureTextVM.AcceptPlaceholders || cultureTextVM.AcceptPunctuation)   // Keep accept flags  					{  						var textElement = xe.OwnerDocument.CreateElement("text");  						xe.AppendChild(textElement);  						var keyAttr = xe.OwnerDocument.CreateAttribute("key");  						keyAttr.Value = textKeyVM.TextKey;  						textElement.Attributes.Append(keyAttr);  						if (!string.IsNullOrEmpty(cultureTextVM.Text))  						{  							textElement.InnerText = cultureTextVM.Text;  						}    						if (cultureTextVM.AcceptMissing)  						{  							var acceptMissingAttr = xe.OwnerDocument.CreateAttribute("acceptmissing");  							acceptMissingAttr.Value = "true";  							textElement.Attributes.Append(acceptMissingAttr);  						}  						if (cultureTextVM.AcceptPlaceholders)  						{  							var acceptPlaceholdersAttr = xe.OwnerDocument.CreateAttribute("acceptplaceholders");  							acceptPlaceholdersAttr.Value = "true";  							textElement.Attributes.Append(acceptPlaceholdersAttr);  						}  						if (cultureTextVM.AcceptPunctuation)  						{  							var acceptPunctuationAttr = xe.OwnerDocument.CreateAttribute("acceptpunctuation");  							acceptPunctuationAttr.Value = "true";  							textElement.Attributes.Append(acceptPunctuationAttr);  						}    						// Add the text key comment to the primary culture  						// (If no primary culture is set' the first-displayed is used to save the comments)  						if (!string.IsNullOrWhiteSpace(textKeyVM.Comment))  						{  							if (PrimaryCulture != null && cultureName == PrimaryCulture ||  								PrimaryCulture == null && cultureName == textKeyVM.CultureTextVMs[0].CultureName)  							{  								var commentAttr = xe.OwnerDocument.CreateAttribute("comment");  								commentAttr.Value = textKeyVM.Comment;  								textElement.Attributes.Append(commentAttr);  							}  						}  					}  					foreach (var quantifiedTextVM in cultureTextVM.QuantifiedTextVMs.OrderBy(qt => qt.Count).ThenBy(qt => qt.Modulo))  					{  						var textElement = xe.OwnerDocument.CreateElement("text");  						xe.AppendChild(textElement);    						var keyAttr = xe.OwnerDocument.CreateAttribute("key");  						keyAttr.Value = textKeyVM.TextKey;  						textElement.Attributes.Append(keyAttr);    						if (quantifiedTextVM.Count < 0)  						{  							throw new Exception("Invalid count value " + quantifiedTextVM.Count + " set for text key " +  								textKeyVM.TextKey + "' culture " + cultureName);  						}  						var countAttr = xe.OwnerDocument.CreateAttribute("count");  						countAttr.Value = quantifiedTextVM.Count.ToString();  						textElement.Attributes.Append(countAttr);    						if (quantifiedTextVM.Modulo != 0 &&  							(quantifiedTextVM.Modulo < 2 && quantifiedTextVM.Modulo > 1000))  						{  							throw new Exception("Invalid modulo value " + quantifiedTextVM.Modulo + " set for text key " +  								textKeyVM.TextKey + "' culture " + cultureName + "' count " + quantifiedTextVM.Count);  						}  						if (quantifiedTextVM.Modulo > 1)  						{  							var modAttr = xe.OwnerDocument.CreateAttribute("mod");  							modAttr.Value = quantifiedTextVM.Modulo.ToString();  							textElement.Attributes.Append(modAttr);  						}    						if (quantifiedTextVM.AcceptMissing)  						{  							var acceptMissingAttr = xe.OwnerDocument.CreateAttribute("acceptmissing");  							acceptMissingAttr.Value = "true";  							textElement.Attributes.Append(acceptMissingAttr);  						}  						if (quantifiedTextVM.AcceptPlaceholders)  						{  							var acceptPlaceholdersAttr = xe.OwnerDocument.CreateAttribute("acceptplaceholders");  							acceptPlaceholdersAttr.Value = "true";  							textElement.Attributes.Append(acceptPlaceholdersAttr);  						}  						if (quantifiedTextVM.AcceptPunctuation)  						{  							var acceptPunctuationAttr = xe.OwnerDocument.CreateAttribute("acceptpunctuation");  							acceptPunctuationAttr.Value = "true";  							textElement.Attributes.Append(acceptPunctuationAttr);  						}    						if (!string.IsNullOrEmpty(quantifiedTextVM.Text))  						{  							textElement.InnerText = quantifiedTextVM.Text;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToXml,The following statement contains a magic number: if (textKeyVM.IsFullKey && textKeyVM.TextKey != null &&  				(!exporting || textKeyVM.IsSelectedRecursive()))  			{  				var cultureTextVM = textKeyVM.CultureTextVMs.FirstOrDefault(vm => vm.CultureName == cultureName);  				if (cultureTextVM != null)  				{  					if (!string.IsNullOrEmpty(cultureTextVM.Text) ||  						textKeyVM.IsEmpty() && cultureName == PrimaryCulture && !textKeyVM.TextKey.StartsWith("Tx:") ||   // Save empty text keys in the primary culture at least (not for system keys)  						cultureName == PrimaryCulture && !string.IsNullOrWhiteSpace(textKeyVM.Comment) ||   // Always keep comments in the primary culture  						cultureTextVM.AcceptMissing || cultureTextVM.AcceptPlaceholders || cultureTextVM.AcceptPunctuation)   // Keep accept flags  					{  						var textElement = xe.OwnerDocument.CreateElement("text");  						xe.AppendChild(textElement);  						var keyAttr = xe.OwnerDocument.CreateAttribute("key");  						keyAttr.Value = textKeyVM.TextKey;  						textElement.Attributes.Append(keyAttr);  						if (!string.IsNullOrEmpty(cultureTextVM.Text))  						{  							textElement.InnerText = cultureTextVM.Text;  						}    						if (cultureTextVM.AcceptMissing)  						{  							var acceptMissingAttr = xe.OwnerDocument.CreateAttribute("acceptmissing");  							acceptMissingAttr.Value = "true";  							textElement.Attributes.Append(acceptMissingAttr);  						}  						if (cultureTextVM.AcceptPlaceholders)  						{  							var acceptPlaceholdersAttr = xe.OwnerDocument.CreateAttribute("acceptplaceholders");  							acceptPlaceholdersAttr.Value = "true";  							textElement.Attributes.Append(acceptPlaceholdersAttr);  						}  						if (cultureTextVM.AcceptPunctuation)  						{  							var acceptPunctuationAttr = xe.OwnerDocument.CreateAttribute("acceptpunctuation");  							acceptPunctuationAttr.Value = "true";  							textElement.Attributes.Append(acceptPunctuationAttr);  						}    						// Add the text key comment to the primary culture  						// (If no primary culture is set' the first-displayed is used to save the comments)  						if (!string.IsNullOrWhiteSpace(textKeyVM.Comment))  						{  							if (PrimaryCulture != null && cultureName == PrimaryCulture ||  								PrimaryCulture == null && cultureName == textKeyVM.CultureTextVMs[0].CultureName)  							{  								var commentAttr = xe.OwnerDocument.CreateAttribute("comment");  								commentAttr.Value = textKeyVM.Comment;  								textElement.Attributes.Append(commentAttr);  							}  						}  					}  					foreach (var quantifiedTextVM in cultureTextVM.QuantifiedTextVMs.OrderBy(qt => qt.Count).ThenBy(qt => qt.Modulo))  					{  						var textElement = xe.OwnerDocument.CreateElement("text");  						xe.AppendChild(textElement);    						var keyAttr = xe.OwnerDocument.CreateAttribute("key");  						keyAttr.Value = textKeyVM.TextKey;  						textElement.Attributes.Append(keyAttr);    						if (quantifiedTextVM.Count < 0)  						{  							throw new Exception("Invalid count value " + quantifiedTextVM.Count + " set for text key " +  								textKeyVM.TextKey + "' culture " + cultureName);  						}  						var countAttr = xe.OwnerDocument.CreateAttribute("count");  						countAttr.Value = quantifiedTextVM.Count.ToString();  						textElement.Attributes.Append(countAttr);    						if (quantifiedTextVM.Modulo != 0 &&  							(quantifiedTextVM.Modulo < 2 && quantifiedTextVM.Modulo > 1000))  						{  							throw new Exception("Invalid modulo value " + quantifiedTextVM.Modulo + " set for text key " +  								textKeyVM.TextKey + "' culture " + cultureName + "' count " + quantifiedTextVM.Count);  						}  						if (quantifiedTextVM.Modulo > 1)  						{  							var modAttr = xe.OwnerDocument.CreateAttribute("mod");  							modAttr.Value = quantifiedTextVM.Modulo.ToString();  							textElement.Attributes.Append(modAttr);  						}    						if (quantifiedTextVM.AcceptMissing)  						{  							var acceptMissingAttr = xe.OwnerDocument.CreateAttribute("acceptmissing");  							acceptMissingAttr.Value = "true";  							textElement.Attributes.Append(acceptMissingAttr);  						}  						if (quantifiedTextVM.AcceptPlaceholders)  						{  							var acceptPlaceholdersAttr = xe.OwnerDocument.CreateAttribute("acceptplaceholders");  							acceptPlaceholdersAttr.Value = "true";  							textElement.Attributes.Append(acceptPlaceholdersAttr);  						}  						if (quantifiedTextVM.AcceptPunctuation)  						{  							var acceptPunctuationAttr = xe.OwnerDocument.CreateAttribute("acceptpunctuation");  							acceptPunctuationAttr.Value = "true";  							textElement.Attributes.Append(acceptPunctuationAttr);  						}    						if (!string.IsNullOrEmpty(quantifiedTextVM.Text))  						{  							textElement.InnerText = quantifiedTextVM.Text;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToDictionary,The following statement contains a magic number: if (textKeyVM.IsFullKey && textKeyVM.TextKey != null)  			{  				var cultureTextVM = textKeyVM.CultureTextVMs.FirstOrDefault(vm => vm.CultureName == cultureName);  				if (cultureTextVM != null)  				{  					if (!string.IsNullOrEmpty(cultureTextVM.Text) && textKeyVM.TextKey.StartsWith("Tx:"))  					{  						if (!string.IsNullOrEmpty(cultureTextVM.Text))  						{  							if (!dict.ContainsKey(textKeyVM.TextKey))  							{  								dict[textKeyVM.TextKey] = new Dictionary<int' string>();  							}  							dict[textKeyVM.TextKey][-1] = cultureTextVM.Text;  						}  					}  					foreach (var quantifiedTextVM in cultureTextVM.QuantifiedTextVMs.OrderBy(qt => qt.Count).ThenBy(qt => qt.Modulo))  					{  						if (quantifiedTextVM.Count < 0)  						{  							continue;  						}  						if (quantifiedTextVM.Modulo != 0 &&  							(quantifiedTextVM.Modulo < 2 && quantifiedTextVM.Modulo > 1000))  						{  							continue;  						}  						if (!string.IsNullOrEmpty(quantifiedTextVM.Text))  						{  							int count = quantifiedTextVM.Count;  							if (quantifiedTextVM.Modulo != 0)  							{  								// Encode the modulo value into the quantifier.  								count = (quantifiedTextVM.Modulo << 16) | count;  							}  							if (!dict.ContainsKey(textKeyVM.TextKey))  							{  								dict[textKeyVM.TextKey] = new Dictionary<int' string>();  							}  							dict[textKeyVM.TextKey][count] = quantifiedTextVM.Text;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToDictionary,The following statement contains a magic number: if (textKeyVM.IsFullKey && textKeyVM.TextKey != null)  			{  				var cultureTextVM = textKeyVM.CultureTextVMs.FirstOrDefault(vm => vm.CultureName == cultureName);  				if (cultureTextVM != null)  				{  					if (!string.IsNullOrEmpty(cultureTextVM.Text) && textKeyVM.TextKey.StartsWith("Tx:"))  					{  						if (!string.IsNullOrEmpty(cultureTextVM.Text))  						{  							if (!dict.ContainsKey(textKeyVM.TextKey))  							{  								dict[textKeyVM.TextKey] = new Dictionary<int' string>();  							}  							dict[textKeyVM.TextKey][-1] = cultureTextVM.Text;  						}  					}  					foreach (var quantifiedTextVM in cultureTextVM.QuantifiedTextVMs.OrderBy(qt => qt.Count).ThenBy(qt => qt.Modulo))  					{  						if (quantifiedTextVM.Count < 0)  						{  							continue;  						}  						if (quantifiedTextVM.Modulo != 0 &&  							(quantifiedTextVM.Modulo < 2 && quantifiedTextVM.Modulo > 1000))  						{  							continue;  						}  						if (!string.IsNullOrEmpty(quantifiedTextVM.Text))  						{  							int count = quantifiedTextVM.Count;  							if (quantifiedTextVM.Modulo != 0)  							{  								// Encode the modulo value into the quantifier.  								count = (quantifiedTextVM.Modulo << 16) | count;  							}  							if (!dict.ContainsKey(textKeyVM.TextKey))  							{  								dict[textKeyVM.TextKey] = new Dictionary<int' string>();  							}  							dict[textKeyVM.TextKey][count] = quantifiedTextVM.Text;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,WriteTextKeysToDictionary,The following statement contains a magic number: if (textKeyVM.IsFullKey && textKeyVM.TextKey != null)  			{  				var cultureTextVM = textKeyVM.CultureTextVMs.FirstOrDefault(vm => vm.CultureName == cultureName);  				if (cultureTextVM != null)  				{  					if (!string.IsNullOrEmpty(cultureTextVM.Text) && textKeyVM.TextKey.StartsWith("Tx:"))  					{  						if (!string.IsNullOrEmpty(cultureTextVM.Text))  						{  							if (!dict.ContainsKey(textKeyVM.TextKey))  							{  								dict[textKeyVM.TextKey] = new Dictionary<int' string>();  							}  							dict[textKeyVM.TextKey][-1] = cultureTextVM.Text;  						}  					}  					foreach (var quantifiedTextVM in cultureTextVM.QuantifiedTextVMs.OrderBy(qt => qt.Count).ThenBy(qt => qt.Modulo))  					{  						if (quantifiedTextVM.Count < 0)  						{  							continue;  						}  						if (quantifiedTextVM.Modulo != 0 &&  							(quantifiedTextVM.Modulo < 2 && quantifiedTextVM.Modulo > 1000))  						{  							continue;  						}  						if (!string.IsNullOrEmpty(quantifiedTextVM.Text))  						{  							int count = quantifiedTextVM.Count;  							if (quantifiedTextVM.Modulo != 0)  							{  								// Encode the modulo value into the quantifier.  								count = (quantifiedTextVM.Modulo << 16) | count;  							}  							if (!dict.ContainsKey(textKeyVM.TextKey))  							{  								dict[textKeyVM.TextKey] = new Dictionary<int' string>();  							}  							dict[textKeyVM.TextKey][count] = quantifiedTextVM.Text;  						}  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,ValidateTextKeysDelayed,The following statement contains a magic number: if (validateDc == null)  			{  				validateDc = DelayedCall.Start(ValidateTextKeys' 500);  			}  			else  			{  				validateDc.Reset();  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,InsertSystemKeys,The following statement contains a magic number: if (!string.IsNullOrEmpty(culture))  			{  				Stream templateStream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream("Unclassified.TxEditor.Template.txd");  				if (templateStream == null)  				{  					throw new Exception("The template dictionary is not an embedded resource in this assembly. This is a build error.");  				}  				XmlDocument xmlDoc = new XmlDocument();  				xmlDoc.Load(templateStream);    				var xe = xmlDoc.DocumentElement.SelectSingleNode("culture[@name='" + culture + "']") as XmlElement;  				if (xe != null)  				{  					LoadFromXml(culture' xe);  					FileModified = true;  					StatusText = Tx.T("statusbar.system keys added"' "culture"' culture);    					if (culture.Length == 5)  					{  						App.InformationMessage(Tx.T("msg.insert system keys.base culture"' "name"' culture.Substring(0' 2)));  					}  				}  				else  				{  					App.WarningMessage(Tx.T("msg.insert system keys.not available"' "name"' culture));  				}  			}  			else  			{  				App.WarningMessage(Tx.T("msg.insert system keys.no culture selected"));  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,InsertSystemKeys,The following statement contains a magic number: if (!string.IsNullOrEmpty(culture))  			{  				Stream templateStream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream("Unclassified.TxEditor.Template.txd");  				if (templateStream == null)  				{  					throw new Exception("The template dictionary is not an embedded resource in this assembly. This is a build error.");  				}  				XmlDocument xmlDoc = new XmlDocument();  				xmlDoc.Load(templateStream);    				var xe = xmlDoc.DocumentElement.SelectSingleNode("culture[@name='" + culture + "']") as XmlElement;  				if (xe != null)  				{  					LoadFromXml(culture' xe);  					FileModified = true;  					StatusText = Tx.T("statusbar.system keys added"' "culture"' culture);    					if (culture.Length == 5)  					{  						App.InformationMessage(Tx.T("msg.insert system keys.base culture"' "name"' culture.Substring(0' 2)));  					}  				}  				else  				{  					App.WarningMessage(Tx.T("msg.insert system keys.not available"' "name"' culture));  				}  			}  			else  			{  				App.WarningMessage(Tx.T("msg.insert system keys.no culture selected"));  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,OnInit,The following statement contains a magic number: if (App.SplashScreen != null)  			{  				App.SplashScreen.Close(TimeSpan.FromMilliseconds(300));  				// Work-around for implementation bug in SplashScreen.Close that steals the focus  				MainWindow.Instance.Focus();  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,UpdateSuggestionsLayout,The following statement contains a magic number: if (App.Settings.View.ShowSuggestions)  			{  				if (App.Settings.View.SuggestionsHorizontalLayout)  				{  					SuggestionsSplitterHeight = 0;  					SuggestionsPanelHeight = 0;  					SuggestionsSplitterWidth = 6;  					SuggestionsPanelWidth = App.Settings.View.SuggestionsWidth;  				}  				else  				{  					SuggestionsSplitterHeight = 6;  					SuggestionsPanelHeight = App.Settings.View.SuggestionsHeight;  					SuggestionsSplitterWidth = 0;  					SuggestionsPanelWidth = 0;  				}  			}  			else  			{  				SuggestionsSplitterHeight = 0;  				SuggestionsPanelHeight = 0;  				SuggestionsSplitterWidth = 0;  				SuggestionsPanelWidth = 0;  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,UpdateSuggestionsLayout,The following statement contains a magic number: if (App.Settings.View.ShowSuggestions)  			{  				if (App.Settings.View.SuggestionsHorizontalLayout)  				{  					SuggestionsSplitterHeight = 0;  					SuggestionsPanelHeight = 0;  					SuggestionsSplitterWidth = 6;  					SuggestionsPanelWidth = App.Settings.View.SuggestionsWidth;  				}  				else  				{  					SuggestionsSplitterHeight = 6;  					SuggestionsPanelHeight = App.Settings.View.SuggestionsHeight;  					SuggestionsSplitterWidth = 0;  					SuggestionsPanelWidth = 0;  				}  			}  			else  			{  				SuggestionsSplitterHeight = 0;  				SuggestionsPanelHeight = 0;  				SuggestionsSplitterWidth = 0;  				SuggestionsPanelWidth = 0;  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,UpdateSuggestions,The following statement contains a magic number: foreach (var kvp in TextKeys)  			{  				if (kvp.Value.TextKey == tk.TextKey) continue;   // Skip currently selected item  				if (kvp.Value.TextKey.StartsWith("Tx:")) continue;   // Skip system keys    				float score = 0;  				bool isExactMatch = false;  				string otherBaseText = kvp.Value.CultureTextVMs[0].Text;  				string otherTranslatedText = kvp.Value.CultureTextVMs.First(ct => ct.CultureName == LastSelectedCulture).Text;    				if (string.IsNullOrEmpty(otherBaseText)) continue;  				if (string.IsNullOrEmpty(otherTranslatedText)) continue;    				if (otherBaseText == origRefText)  				{  					// Both keys' primary translation matches exactly  					isExactMatch = true;  				}    				// Remove all placeholders and key references  				string otherText = Regex.Replace(otherBaseText' @"(?<!\{)\{[^{]*?\}"' "");    				// Extract all words  				List<string> otherWords = new List<string>();  				m = Regex.Match(otherText' @"(\w{2'})");  				while (m.Success)  				{  					if (!commonWords.Contains(m.Groups[1].Value.ToLowerInvariant()))   // Skip common words  						otherWords.Add(m.Groups[1].Value);  					m = m.NextMatch();  				}    				// Increase score by 1 for each case-insensitively matching word  				foreach (string word in refWords)  				{  					if (otherWords.Any(w => string.Equals(w' word' StringComparison.InvariantCultureIgnoreCase)))  						score += 1;  				}  				// Increase score by 2 for each case-sensitively matching word  				foreach (string word in refWords)  				{  					if (otherWords.Any(w => string.Equals(w' word' StringComparison.InvariantCulture)))  						score += 2;  				}    				// Divide by the square root of the number of relevant words. (Using the square  				// root to reduce the effect for very long texts.)  				if (otherWords.Count > 0)  				{  					score /= (float)Math.Sqrt(otherWords.Count);  				}  				else  				{  					// There are no significant words in the other text  					score = 0;  				}    				if (isExactMatch)  				{  					score = 100000;  				}    				// Accept every text key with a threshold score  				if (score >= 0.5f)  				{  					otherKeys.Add(kvp.Value' score);  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,UpdateSuggestions,The following statement contains a magic number: foreach (var kvp in TextKeys)  			{  				if (kvp.Value.TextKey == tk.TextKey) continue;   // Skip currently selected item  				if (kvp.Value.TextKey.StartsWith("Tx:")) continue;   // Skip system keys    				float score = 0;  				bool isExactMatch = false;  				string otherBaseText = kvp.Value.CultureTextVMs[0].Text;  				string otherTranslatedText = kvp.Value.CultureTextVMs.First(ct => ct.CultureName == LastSelectedCulture).Text;    				if (string.IsNullOrEmpty(otherBaseText)) continue;  				if (string.IsNullOrEmpty(otherTranslatedText)) continue;    				if (otherBaseText == origRefText)  				{  					// Both keys' primary translation matches exactly  					isExactMatch = true;  				}    				// Remove all placeholders and key references  				string otherText = Regex.Replace(otherBaseText' @"(?<!\{)\{[^{]*?\}"' "");    				// Extract all words  				List<string> otherWords = new List<string>();  				m = Regex.Match(otherText' @"(\w{2'})");  				while (m.Success)  				{  					if (!commonWords.Contains(m.Groups[1].Value.ToLowerInvariant()))   // Skip common words  						otherWords.Add(m.Groups[1].Value);  					m = m.NextMatch();  				}    				// Increase score by 1 for each case-insensitively matching word  				foreach (string word in refWords)  				{  					if (otherWords.Any(w => string.Equals(w' word' StringComparison.InvariantCultureIgnoreCase)))  						score += 1;  				}  				// Increase score by 2 for each case-sensitively matching word  				foreach (string word in refWords)  				{  					if (otherWords.Any(w => string.Equals(w' word' StringComparison.InvariantCulture)))  						score += 2;  				}    				// Divide by the square root of the number of relevant words. (Using the square  				// root to reduce the effect for very long texts.)  				if (otherWords.Count > 0)  				{  					score /= (float)Math.Sqrt(otherWords.Count);  				}  				else  				{  					// There are no significant words in the other text  					score = 0;  				}    				if (isExactMatch)  				{  					score = 100000;  				}    				// Accept every text key with a threshold score  				if (score >= 0.5f)  				{  					otherKeys.Add(kvp.Value' score);  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,UpdateSuggestions,The following statement contains a magic number: foreach (var kvp in otherKeys.OrderByDescending(kvp => kvp.Value))  			{  				try  				{  					SuggestionViewModel suggestion = new SuggestionViewModel(this);  					suggestion.TextKey = kvp.Key.TextKey;  					suggestion.BaseText = kvp.Key.CultureTextVMs[0].Text;  					if (LastSelectedCulture != PrimaryCulture)  						suggestion.TranslatedText = kvp.Key.CultureTextVMs.First(ct => ct.CultureName == LastSelectedCulture).Text;  					suggestion.IsExactMatch = kvp.Value >= 100000;  					suggestion.ScoreNum = kvp.Value;  					if (suggestion.IsExactMatch)  						suggestion.Score = Tx.T("suggestions.exact match");  					else  						suggestion.Score = kvp.Value.ToString("0.00");  					suggestions.Add(suggestion);  				}  				catch  				{  					// Something's missing (probably a LINQ-related exception)' ignore that item  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Validate,The following statement contains a magic number: if (CultureTextVMs.Any(ct =>  				ct.QuantifiedTextVMs.Any(qt =>  					qt.Modulo != 0 && (qt.Modulo < 2 || qt.Modulo > 1000))))  			{  				HasOwnProblem = true;  				HasProblem = true;  				AddRemarks(Tx.T("validation.content.invalid modulo"));  			}
Magic Number,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Validate,The following statement contains a magic number: if (CultureTextVMs.Any(ct =>  				ct.QuantifiedTextVMs.Any(qt =>  					qt.Modulo != 0 && (qt.Modulo < 2 || qt.Modulo > 1000))))  			{  				HasOwnProblem = true;  				HasProblem = true;  				AddRemarks(Tx.T("validation.content.invalid modulo"));  			}
Magic Number,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Validate,The following statement contains a magic number: if (CultureTextVMs.Any(ct =>  				ct.QuantifiedTextVMs  					.GroupBy(qt => qt.Count << 16 | qt.Modulo)  					.Any(grp => grp.Count() > 1)))  			{  				HasOwnProblem = true;  				HasProblem = true;  				AddRemarks(Tx.T("validation.content.duplicate count modulo"));  			}
Magic Number,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Validate,The following statement contains a magic number: foreach (var ctVM in CultureTextVMs)  			{  				if (ctVM.CultureName.Length == 2)  				{  					// Check that every non-region culture has a text set  					if (String.IsNullOrEmpty(ctVM.Text))  					{  						ctVM.IsMissing = true;  						if (ctVM.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						ctVM.IsMissing = false;  					}  				}  				else if (ctVM.CultureName.Length == 5)  				{  					// Check that every region-culture with no text has a non-region culture with a  					// text set (as fallback)  					if (String.IsNullOrEmpty(ctVM.Text) &&  						!CultureTextVMs.Any(vm2 => vm2.CultureName == ctVM.CultureName.Substring(0' 2)))  					{  						ctVM.IsMissing = true;  						if (ctVM.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						ctVM.IsMissing = false;  					}  				}    				// Also check quantified texts for missing texts  				foreach (var qt in ctVM.QuantifiedTextVMs)  				{  					if (String.IsNullOrEmpty(qt.Text))  					{  						qt.IsMissing = true;  						if (qt.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						qt.IsMissing = false;  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Validate,The following statement contains a magic number: foreach (var ctVM in CultureTextVMs)  			{  				if (ctVM.CultureName.Length == 2)  				{  					// Check that every non-region culture has a text set  					if (String.IsNullOrEmpty(ctVM.Text))  					{  						ctVM.IsMissing = true;  						if (ctVM.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						ctVM.IsMissing = false;  					}  				}  				else if (ctVM.CultureName.Length == 5)  				{  					// Check that every region-culture with no text has a non-region culture with a  					// text set (as fallback)  					if (String.IsNullOrEmpty(ctVM.Text) &&  						!CultureTextVMs.Any(vm2 => vm2.CultureName == ctVM.CultureName.Substring(0' 2)))  					{  						ctVM.IsMissing = true;  						if (ctVM.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						ctVM.IsMissing = false;  					}  				}    				// Also check quantified texts for missing texts  				foreach (var qt in ctVM.QuantifiedTextVMs)  				{  					if (String.IsNullOrEmpty(qt.Text))  					{  						qt.IsMissing = true;  						if (qt.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						qt.IsMissing = false;  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,Validate,The following statement contains a magic number: foreach (var ctVM in CultureTextVMs)  			{  				if (ctVM.CultureName.Length == 2)  				{  					// Check that every non-region culture has a text set  					if (String.IsNullOrEmpty(ctVM.Text))  					{  						ctVM.IsMissing = true;  						if (ctVM.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						ctVM.IsMissing = false;  					}  				}  				else if (ctVM.CultureName.Length == 5)  				{  					// Check that every region-culture with no text has a non-region culture with a  					// text set (as fallback)  					if (String.IsNullOrEmpty(ctVM.Text) &&  						!CultureTextVMs.Any(vm2 => vm2.CultureName == ctVM.CultureName.Substring(0' 2)))  					{  						ctVM.IsMissing = true;  						if (ctVM.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						ctVM.IsMissing = false;  					}  				}    				// Also check quantified texts for missing texts  				foreach (var qt in ctVM.QuantifiedTextVMs)  				{  					if (String.IsNullOrEmpty(qt.Text))  					{  						qt.IsMissing = true;  						if (qt.AcceptMissing)  						{  							IsAccepted = true;  						}  						else  						{  							HasOwnProblem = true;  							HasProblem = true;  							AddRemarks(Tx.T("validation.content.missing translation"));  						}  					}  					else  					{  						qt.IsMissing = false;  					}  				}  			}
Magic Number,Unclassified.TxEditor.ViewModels,TextKeyViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\TextKeyViewModel.cs,UpdateCultureTextSeparators,The following statement contains a magic number: for (int i = CultureTextVMs.Count - 1; i >= 0; i--)  			{  				string lang = CultureTextVMs[i].CultureName.Substring(0' 2);  				CultureTextVMs[i].LastOfLanguage = lang != prevLang;  				prevLang = lang;  			}
Magic Number,Unclassified.TxEditor.Views,AboutWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\AboutWindow.xaml.cs,ShowDialog,The following statement contains a magic number: if (Owner != null)  			{  				root = Owner.Content as UIElement;    				blur = new BlurEffect();  				blur.Radius = 0;  				root.Effect = blur;    				root.AnimateEase(UIElement.OpacityProperty' 1' 0.6' TimeSpan.FromSeconds(1));  				blur.AnimateEase(BlurEffect.RadiusProperty' 1' 4' TimeSpan.FromSeconds(0.5));  				// NOTE: Blur radius is internally converted to integer which is bad for slow animations.  				// See https://social.msdn.microsoft.com/Forums/vstudio/en-US/ced0cc07-44fd-43e7-8829-e329be038d82  			}
Magic Number,Unclassified.TxEditor.Views,AboutWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\AboutWindow.xaml.cs,ShowDialog,The following statement contains a magic number: if (Owner != null)  			{  				root = Owner.Content as UIElement;    				blur = new BlurEffect();  				blur.Radius = 0;  				root.Effect = blur;    				root.AnimateEase(UIElement.OpacityProperty' 1' 0.6' TimeSpan.FromSeconds(1));  				blur.AnimateEase(BlurEffect.RadiusProperty' 1' 4' TimeSpan.FromSeconds(0.5));  				// NOTE: Blur radius is internally converted to integer which is bad for slow animations.  				// See https://social.msdn.microsoft.com/Forums/vstudio/en-US/ced0cc07-44fd-43e7-8829-e329be038d82  			}
Magic Number,Unclassified.TxEditor.Views,AboutWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\AboutWindow.xaml.cs,ShowDialog,The following statement contains a magic number: if (Owner != null)  			{  				root = Owner.Content as UIElement;    				blur = new BlurEffect();  				blur.Radius = 0;  				root.Effect = blur;    				root.AnimateEase(UIElement.OpacityProperty' 1' 0.6' TimeSpan.FromSeconds(1));  				blur.AnimateEase(BlurEffect.RadiusProperty' 1' 4' TimeSpan.FromSeconds(0.5));  				// NOTE: Blur radius is internally converted to integer which is bad for slow animations.  				// See https://social.msdn.microsoft.com/Forums/vstudio/en-US/ced0cc07-44fd-43e7-8829-e329be038d82  			}
Magic Number,Unclassified.TxEditor.Views,AboutWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\AboutWindow.xaml.cs,ShowDialog,The following statement contains a magic number: if (root != null && blur != null)  			{  				root.AnimateEase(UIElement.OpacityProperty' 0.6' 1' TimeSpan.FromSeconds(0.2));  				blur.AnimateEase(BlurEffect.RadiusProperty' 4' 0' TimeSpan.FromSeconds(0.2));    				DelayedCall.Start(() => { root.Effect = null; }' 250);  			}
Magic Number,Unclassified.TxEditor.Views,AboutWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\AboutWindow.xaml.cs,ShowDialog,The following statement contains a magic number: if (root != null && blur != null)  			{  				root.AnimateEase(UIElement.OpacityProperty' 0.6' 1' TimeSpan.FromSeconds(0.2));  				blur.AnimateEase(BlurEffect.RadiusProperty' 4' 0' TimeSpan.FromSeconds(0.2));    				DelayedCall.Start(() => { root.Effect = null; }' 250);  			}
Magic Number,Unclassified.TxEditor.Views,AboutWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\AboutWindow.xaml.cs,ShowDialog,The following statement contains a magic number: if (root != null && blur != null)  			{  				root.AnimateEase(UIElement.OpacityProperty' 0.6' 1' TimeSpan.FromSeconds(0.2));  				blur.AnimateEase(BlurEffect.RadiusProperty' 4' 0' TimeSpan.FromSeconds(0.2));    				DelayedCall.Start(() => { root.Effect = null; }' 250);  			}
Magic Number,Unclassified.TxEditor.Views,AboutWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\AboutWindow.xaml.cs,ShowDialog,The following statement contains a magic number: if (root != null && blur != null)  			{  				root.AnimateEase(UIElement.OpacityProperty' 0.6' 1' TimeSpan.FromSeconds(0.2));  				blur.AnimateEase(BlurEffect.RadiusProperty' 4' 0' TimeSpan.FromSeconds(0.2));    				DelayedCall.Start(() => { root.Effect = null; }' 250);  			}
Magic Number,Unclassified.TxEditor.Views,AboutWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\AboutWindow.xaml.cs,ShowDialog,The following statement contains a magic number: if (root != null && blur != null)  			{  				root.AnimateEase(UIElement.OpacityProperty' 0.6' 1' TimeSpan.FromSeconds(0.2));  				blur.AnimateEase(BlurEffect.RadiusProperty' 4' 0' TimeSpan.FromSeconds(0.2));    				DelayedCall.Start(() => { root.Effect = null; }' 250);  			}
Magic Number,Unclassified.TxEditor.Views,DetailsMessage,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\DetailsMessage.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.ArrowLeftIcon = ((System.Windows.Shapes.Path)(target));              return;              case 2:              this.ArrowUpIcon = ((System.Windows.Shapes.Path)(target));              return;              }
Magic Number,Unclassified.TxEditor.Views,DateTimeWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\DateTimeWindow.xaml.cs,DateTimeWindow,The following statement contains a magic number: timerDc = DelayedCall.Create(UpdateView' 1000);
Magic Number,Unclassified.TxEditor.Views,TextKeyWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWindow.xaml.cs,Window_Loaded,The following statement contains a magic number: if (!RenameSelectMode)  			{  				Match m = Regex.Match(TextKey' @"^((?:.*?:)?(?:[^.]*\.)*)([^.]*[:.])$");  				if (m.Success)  				{  					TextKeyText.SelectionStart = m.Groups[1].Length;  					TextKeyText.SelectionLength = m.Groups[2].Length;  				}  			}  			else  			{  				Match m = Regex.Match(TextKey' @"^((?:.*?:)?(?:[^.]*\.)*)([^.]*)$");  				if (m.Success)  				{  					TextKeyText.SelectionStart = m.Groups[1].Length;  					TextKeyText.SelectionLength = m.Groups[2].Length;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWindow.xaml.cs,Window_Loaded,The following statement contains a magic number: if (!RenameSelectMode)  			{  				Match m = Regex.Match(TextKey' @"^((?:.*?:)?(?:[^.]*\.)*)([^.]*[:.])$");  				if (m.Success)  				{  					TextKeyText.SelectionStart = m.Groups[1].Length;  					TextKeyText.SelectionLength = m.Groups[2].Length;  				}  			}  			else  			{  				Match m = Regex.Match(TextKey' @"^((?:.*?:)?(?:[^.]*\.)*)([^.]*)$");  				if (m.Success)  				{  					TextKeyText.SelectionStart = m.Groups[1].Length;  					TextKeyText.SelectionLength = m.Groups[2].Length;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Window_Loaded,The following statement contains a magic number: if (App.Settings != null &&  				App.Settings.Wizard.RememberLocation &&  				App.Settings.Wizard.WindowLeft != int.MinValue &&  				App.Settings.Wizard.WindowTop != int.MinValue)  			{  				Left = App.Settings.Wizard.WindowLeft;  				Top = App.Settings.Wizard.WindowTop;  			}  			else  			{  				Left = SystemParameters.WorkArea.Right - 40 - ActualWidth;  				Top = SystemParameters.WorkArea.Bottom - 40 - ActualHeight;  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Window_Loaded,The following statement contains a magic number: if (App.Settings != null &&  				App.Settings.Wizard.RememberLocation &&  				App.Settings.Wizard.WindowLeft != int.MinValue &&  				App.Settings.Wizard.WindowTop != int.MinValue)  			{  				Left = App.Settings.Wizard.WindowLeft;  				Top = App.Settings.Wizard.WindowTop;  			}  			else  			{  				Left = SystemParameters.WorkArea.Right - 40 - ActualWidth;  				Top = SystemParameters.WorkArea.Bottom - 40 - ActualHeight;  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Window_SizeChanged,The following statement contains a magic number: if (App.Settings == null || !App.Settings.Wizard.RememberLocation)  			{  				Left = SystemParameters.WorkArea.Right - 40 - ActualWidth;  				Top = SystemParameters.WorkArea.Bottom - 40 - ActualHeight;  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Window_SizeChanged,The following statement contains a magic number: if (App.Settings == null || !App.Settings.Wizard.RememberLocation)  			{  				Left = SystemParameters.WorkArea.Right - 40 - ActualWidth;  				Top = SystemParameters.WorkArea.Bottom - 40 - ActualHeight;  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,OKButton_Click,The following statement contains a magic number: if (SourceCSharpButton.IsChecked == true && AddColonCheckbox.IsChecked == true)  			{  				var match = Regex.Match(parsedText' @"^(.+?)\s*:(\s*)$");  				if (match.Success)  				{  					translationString = match.Groups[1].Value;  					colonSuffix = match.Groups[2].Value;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ReadClipboard,The following statement contains a magic number: int retryCount = 20;
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ReadClipboard,The following statement contains a magic number: while (true)  			{  				try  				{  					str = Clipboard.GetText();  					break;  				}  				catch (COMException ex)  				{  					retryCount--;  					if (retryCount > 0)  					{  						System.Threading.Thread.Sleep(50);  						continue;  					}  					else  					{  						App.ErrorMessage(Tx.T("window.wizard.error reading clipboard")' ex' "Reading from clipboard");  						return null;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ReadClipboard,The following statement contains a magic number: if (retryCount < 20)  			{  				App.WarningMessage("Tried reading the clipboard " + (20 - retryCount) + " times!");  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ReadClipboard,The following statement contains a magic number: if (retryCount < 20)  			{  				App.WarningMessage("Tried reading the clipboard " + (20 - retryCount) + " times!");  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (initialClipboardText != null)  			{  				if (setTextKey && SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked == true)  				{  					// Initial CSHTML type detection (only on first call):  					// In a .cshtml file there can be C# code as well as Razor code. C# code must be  					// inserted in existing code blocks. It is processed like in a regular .cs file.  					// When selecting plain HTML content' a new Razor code section must be inserted  					// where the text was. This is prefixed with "@" and does not handle  					// placeholders because there are no variables in plain content. (Existing @  					// code blocks within the copied text are not supported because Razor parsing is  					// too complex.)  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						// This looks like an existing C# code string' don't handle it as HTML content  						SourceHtmlButton.IsChecked = false;  					}  				}    				if (SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked != true)  				{  					isPartialString = true;  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						isPartialString = false;  					}    					StringBuilder textContent = new StringBuilder();  					StringBuilder placeholderContent = new StringBuilder();  					Stack<LangState> stateStack = new Stack<LangState>();  					if (isPartialString)  					{  						// Assume a simple string  						stateStack.Push(LangState.String);  					}    					for (int pos = 0; pos < initialClipboardText.Length; pos++)  					{  						char ch = initialClipboardText[pos];  						char nextChar = pos + 1 < initialClipboardText.Length ? initialClipboardText[pos + 1] : '\0';  						var allStates = stateStack.ToArray();   // Stack top = Array beginning  						var state = allStates.Length >= 1 ? allStates[0] : LangState.None;  						var prevState = allStates.Length >= 2 ? allStates[1] : LangState.None;    						if (ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start verbatim string literal  							stateStack.Push(LangState.VerbatimString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start interpolated string literal  							stateStack.Push(LangState.InterpolString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start simple string literal  							stateStack.Push(LangState.String);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '\\' &&  							(state == LangState.InterpolString || state == LangState.String))  						{  							// String escape sequence' evaluate further characters  							if (stateStack.Count == 1)  							{  								switch (nextChar)  								{  									case '\'':  									case '"':  									case '\\':  										textContent.Append(nextChar);  										break;  									case '0': textContent.Append('\0'); break;  									case 'a': textContent.Append('\a'); break;  									case 'b': textContent.Append('\b'); break;  									case 'f': textContent.Append('\f'); break;  									case 'n': textContent.Append('\n'); break;  									case 'r': textContent.Append('\r'); break;  									case 't': textContent.Append('\t'); break;  									case 'U':  										long value = long.Parse(initialClipboardText.Substring(pos + 2' 8)' System.Globalization.NumberStyles.HexNumber);  										//textContent.Append();   // TODO: What does that value mean?  										pos += 8;  										break;  									case 'u':  										int codepoint = int.Parse(initialClipboardText.Substring(pos + 2' 4)' System.Globalization.NumberStyles.HexNumber);  										textContent.Append((char)codepoint);  										pos += 4;  										break;  									case 'v': textContent.Append('\v'); break;  									case 'x':  										// TODO: variable length hex value!  										break;  									default:  										// Ignore invalid escape sequences altogether  										break;  								}  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters (or more)  							pos++;  						}  						else if (ch == '"' && nextChar == '"' &&  							state == LangState.VerbatimString)  						{  							// Verbatim string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' && nextChar == '{' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '}' && nextChar == '}' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' &&  							state == LangState.InterpolString)  						{  							// Start interpolated string code  							stateStack.Push(LangState.None);  							if (stateStack.Count > 2)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '}' &&  							state == LangState.None &&  							prevState == LangState.InterpolString)  						{  							// End interpolated string code  							stateStack.Pop();  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// End string literal  							stateStack.Pop();  							if (stateStack.Count > 0)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// String content (only on first level)  							textContent.Append(ch);  						}    						else if (ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start char literal  							stateStack.Push(LangState.Char);  							placeholderContent.Append(ch);  						}  						else if (ch == '\\' &&  							state == LangState.Char)  						{  							// Char escape sequence' skip next character  							// (Don't parse char literals' they're always in placeholders. If it's  							// a longer escape sequence like '\u0000' we just take the first two  							// characters now and happily append more characters. We don't care  							// about invalid char literals like 'abc' and just pass them through.)  							placeholderContent.Append(ch).Append(nextChar);  							// Handled 2 characters  							pos++;  						}  						else if (ch == '\'' &&  							state == LangState.Char)  						{  							// End char literal  							placeholderContent.Append(ch);  							stateStack.Pop();  						}    						else if (ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open parenthesis  							stateStack.Push(LangState.Parenthesis);  							placeholderContent.Append(ch);  						}  						else if (ch == ')' &&  							state == LangState.Parenthesis)  						{  							// Close parenthesis  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open bracket  							stateStack.Push(LangState.Bracket);  							placeholderContent.Append(ch);  						}  						else if (ch == ']' &&  							state == LangState.Bracket)  						{  							// Close bracket  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open brace  							stateStack.Push(LangState.Brace);  							placeholderContent.Append(ch);  						}  						else if (ch == '}' &&  							state == LangState.Brace)  						{  							// Close brace  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else  						{  							// Other code  							placeholderContent.Append(ch);  						}  					}  					if (placeholderContent.Length > 0)  					{  						// Add last placeholder  						AddParsedPlaceholder(textContent' placeholderContent);  					}  					parsedText = textContent.ToString();  				}  				if (SourceXamlButton.IsChecked == true)  				{  					parsedText = initialClipboardText;  					// TODO: Any further processing required?  				}  				if (SourceAspxButton.IsChecked == true || SourceHtmlButton.IsChecked == true)  				{  					// Decode HTML entities  					parsedText = System.Net.WebUtility.HtmlDecode(initialClipboardText);  				}    				if (SourceCSharpButton.IsChecked == true)  				{  					// Detect trailing colon to offer the option to cut off and generate it  					var match = Regex.Match(parsedText' @"^(.+)\s?:(\s*)$");  					if (match.Success)  					{  						AddColonCheckbox.IsChecked = true;  						AddColonCheckbox.Visibility = Visibility.Visible;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (initialClipboardText != null)  			{  				if (setTextKey && SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked == true)  				{  					// Initial CSHTML type detection (only on first call):  					// In a .cshtml file there can be C# code as well as Razor code. C# code must be  					// inserted in existing code blocks. It is processed like in a regular .cs file.  					// When selecting plain HTML content' a new Razor code section must be inserted  					// where the text was. This is prefixed with "@" and does not handle  					// placeholders because there are no variables in plain content. (Existing @  					// code blocks within the copied text are not supported because Razor parsing is  					// too complex.)  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						// This looks like an existing C# code string' don't handle it as HTML content  						SourceHtmlButton.IsChecked = false;  					}  				}    				if (SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked != true)  				{  					isPartialString = true;  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						isPartialString = false;  					}    					StringBuilder textContent = new StringBuilder();  					StringBuilder placeholderContent = new StringBuilder();  					Stack<LangState> stateStack = new Stack<LangState>();  					if (isPartialString)  					{  						// Assume a simple string  						stateStack.Push(LangState.String);  					}    					for (int pos = 0; pos < initialClipboardText.Length; pos++)  					{  						char ch = initialClipboardText[pos];  						char nextChar = pos + 1 < initialClipboardText.Length ? initialClipboardText[pos + 1] : '\0';  						var allStates = stateStack.ToArray();   // Stack top = Array beginning  						var state = allStates.Length >= 1 ? allStates[0] : LangState.None;  						var prevState = allStates.Length >= 2 ? allStates[1] : LangState.None;    						if (ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start verbatim string literal  							stateStack.Push(LangState.VerbatimString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start interpolated string literal  							stateStack.Push(LangState.InterpolString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start simple string literal  							stateStack.Push(LangState.String);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '\\' &&  							(state == LangState.InterpolString || state == LangState.String))  						{  							// String escape sequence' evaluate further characters  							if (stateStack.Count == 1)  							{  								switch (nextChar)  								{  									case '\'':  									case '"':  									case '\\':  										textContent.Append(nextChar);  										break;  									case '0': textContent.Append('\0'); break;  									case 'a': textContent.Append('\a'); break;  									case 'b': textContent.Append('\b'); break;  									case 'f': textContent.Append('\f'); break;  									case 'n': textContent.Append('\n'); break;  									case 'r': textContent.Append('\r'); break;  									case 't': textContent.Append('\t'); break;  									case 'U':  										long value = long.Parse(initialClipboardText.Substring(pos + 2' 8)' System.Globalization.NumberStyles.HexNumber);  										//textContent.Append();   // TODO: What does that value mean?  										pos += 8;  										break;  									case 'u':  										int codepoint = int.Parse(initialClipboardText.Substring(pos + 2' 4)' System.Globalization.NumberStyles.HexNumber);  										textContent.Append((char)codepoint);  										pos += 4;  										break;  									case 'v': textContent.Append('\v'); break;  									case 'x':  										// TODO: variable length hex value!  										break;  									default:  										// Ignore invalid escape sequences altogether  										break;  								}  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters (or more)  							pos++;  						}  						else if (ch == '"' && nextChar == '"' &&  							state == LangState.VerbatimString)  						{  							// Verbatim string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' && nextChar == '{' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '}' && nextChar == '}' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' &&  							state == LangState.InterpolString)  						{  							// Start interpolated string code  							stateStack.Push(LangState.None);  							if (stateStack.Count > 2)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '}' &&  							state == LangState.None &&  							prevState == LangState.InterpolString)  						{  							// End interpolated string code  							stateStack.Pop();  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// End string literal  							stateStack.Pop();  							if (stateStack.Count > 0)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// String content (only on first level)  							textContent.Append(ch);  						}    						else if (ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start char literal  							stateStack.Push(LangState.Char);  							placeholderContent.Append(ch);  						}  						else if (ch == '\\' &&  							state == LangState.Char)  						{  							// Char escape sequence' skip next character  							// (Don't parse char literals' they're always in placeholders. If it's  							// a longer escape sequence like '\u0000' we just take the first two  							// characters now and happily append more characters. We don't care  							// about invalid char literals like 'abc' and just pass them through.)  							placeholderContent.Append(ch).Append(nextChar);  							// Handled 2 characters  							pos++;  						}  						else if (ch == '\'' &&  							state == LangState.Char)  						{  							// End char literal  							placeholderContent.Append(ch);  							stateStack.Pop();  						}    						else if (ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open parenthesis  							stateStack.Push(LangState.Parenthesis);  							placeholderContent.Append(ch);  						}  						else if (ch == ')' &&  							state == LangState.Parenthesis)  						{  							// Close parenthesis  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open bracket  							stateStack.Push(LangState.Bracket);  							placeholderContent.Append(ch);  						}  						else if (ch == ']' &&  							state == LangState.Bracket)  						{  							// Close bracket  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open brace  							stateStack.Push(LangState.Brace);  							placeholderContent.Append(ch);  						}  						else if (ch == '}' &&  							state == LangState.Brace)  						{  							// Close brace  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else  						{  							// Other code  							placeholderContent.Append(ch);  						}  					}  					if (placeholderContent.Length > 0)  					{  						// Add last placeholder  						AddParsedPlaceholder(textContent' placeholderContent);  					}  					parsedText = textContent.ToString();  				}  				if (SourceXamlButton.IsChecked == true)  				{  					parsedText = initialClipboardText;  					// TODO: Any further processing required?  				}  				if (SourceAspxButton.IsChecked == true || SourceHtmlButton.IsChecked == true)  				{  					// Decode HTML entities  					parsedText = System.Net.WebUtility.HtmlDecode(initialClipboardText);  				}    				if (SourceCSharpButton.IsChecked == true)  				{  					// Detect trailing colon to offer the option to cut off and generate it  					var match = Regex.Match(parsedText' @"^(.+)\s?:(\s*)$");  					if (match.Success)  					{  						AddColonCheckbox.IsChecked = true;  						AddColonCheckbox.Visibility = Visibility.Visible;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (initialClipboardText != null)  			{  				if (setTextKey && SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked == true)  				{  					// Initial CSHTML type detection (only on first call):  					// In a .cshtml file there can be C# code as well as Razor code. C# code must be  					// inserted in existing code blocks. It is processed like in a regular .cs file.  					// When selecting plain HTML content' a new Razor code section must be inserted  					// where the text was. This is prefixed with "@" and does not handle  					// placeholders because there are no variables in plain content. (Existing @  					// code blocks within the copied text are not supported because Razor parsing is  					// too complex.)  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						// This looks like an existing C# code string' don't handle it as HTML content  						SourceHtmlButton.IsChecked = false;  					}  				}    				if (SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked != true)  				{  					isPartialString = true;  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						isPartialString = false;  					}    					StringBuilder textContent = new StringBuilder();  					StringBuilder placeholderContent = new StringBuilder();  					Stack<LangState> stateStack = new Stack<LangState>();  					if (isPartialString)  					{  						// Assume a simple string  						stateStack.Push(LangState.String);  					}    					for (int pos = 0; pos < initialClipboardText.Length; pos++)  					{  						char ch = initialClipboardText[pos];  						char nextChar = pos + 1 < initialClipboardText.Length ? initialClipboardText[pos + 1] : '\0';  						var allStates = stateStack.ToArray();   // Stack top = Array beginning  						var state = allStates.Length >= 1 ? allStates[0] : LangState.None;  						var prevState = allStates.Length >= 2 ? allStates[1] : LangState.None;    						if (ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start verbatim string literal  							stateStack.Push(LangState.VerbatimString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start interpolated string literal  							stateStack.Push(LangState.InterpolString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start simple string literal  							stateStack.Push(LangState.String);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '\\' &&  							(state == LangState.InterpolString || state == LangState.String))  						{  							// String escape sequence' evaluate further characters  							if (stateStack.Count == 1)  							{  								switch (nextChar)  								{  									case '\'':  									case '"':  									case '\\':  										textContent.Append(nextChar);  										break;  									case '0': textContent.Append('\0'); break;  									case 'a': textContent.Append('\a'); break;  									case 'b': textContent.Append('\b'); break;  									case 'f': textContent.Append('\f'); break;  									case 'n': textContent.Append('\n'); break;  									case 'r': textContent.Append('\r'); break;  									case 't': textContent.Append('\t'); break;  									case 'U':  										long value = long.Parse(initialClipboardText.Substring(pos + 2' 8)' System.Globalization.NumberStyles.HexNumber);  										//textContent.Append();   // TODO: What does that value mean?  										pos += 8;  										break;  									case 'u':  										int codepoint = int.Parse(initialClipboardText.Substring(pos + 2' 4)' System.Globalization.NumberStyles.HexNumber);  										textContent.Append((char)codepoint);  										pos += 4;  										break;  									case 'v': textContent.Append('\v'); break;  									case 'x':  										// TODO: variable length hex value!  										break;  									default:  										// Ignore invalid escape sequences altogether  										break;  								}  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters (or more)  							pos++;  						}  						else if (ch == '"' && nextChar == '"' &&  							state == LangState.VerbatimString)  						{  							// Verbatim string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' && nextChar == '{' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '}' && nextChar == '}' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' &&  							state == LangState.InterpolString)  						{  							// Start interpolated string code  							stateStack.Push(LangState.None);  							if (stateStack.Count > 2)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '}' &&  							state == LangState.None &&  							prevState == LangState.InterpolString)  						{  							// End interpolated string code  							stateStack.Pop();  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// End string literal  							stateStack.Pop();  							if (stateStack.Count > 0)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// String content (only on first level)  							textContent.Append(ch);  						}    						else if (ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start char literal  							stateStack.Push(LangState.Char);  							placeholderContent.Append(ch);  						}  						else if (ch == '\\' &&  							state == LangState.Char)  						{  							// Char escape sequence' skip next character  							// (Don't parse char literals' they're always in placeholders. If it's  							// a longer escape sequence like '\u0000' we just take the first two  							// characters now and happily append more characters. We don't care  							// about invalid char literals like 'abc' and just pass them through.)  							placeholderContent.Append(ch).Append(nextChar);  							// Handled 2 characters  							pos++;  						}  						else if (ch == '\'' &&  							state == LangState.Char)  						{  							// End char literal  							placeholderContent.Append(ch);  							stateStack.Pop();  						}    						else if (ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open parenthesis  							stateStack.Push(LangState.Parenthesis);  							placeholderContent.Append(ch);  						}  						else if (ch == ')' &&  							state == LangState.Parenthesis)  						{  							// Close parenthesis  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open bracket  							stateStack.Push(LangState.Bracket);  							placeholderContent.Append(ch);  						}  						else if (ch == ']' &&  							state == LangState.Bracket)  						{  							// Close bracket  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open brace  							stateStack.Push(LangState.Brace);  							placeholderContent.Append(ch);  						}  						else if (ch == '}' &&  							state == LangState.Brace)  						{  							// Close brace  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else  						{  							// Other code  							placeholderContent.Append(ch);  						}  					}  					if (placeholderContent.Length > 0)  					{  						// Add last placeholder  						AddParsedPlaceholder(textContent' placeholderContent);  					}  					parsedText = textContent.ToString();  				}  				if (SourceXamlButton.IsChecked == true)  				{  					parsedText = initialClipboardText;  					// TODO: Any further processing required?  				}  				if (SourceAspxButton.IsChecked == true || SourceHtmlButton.IsChecked == true)  				{  					// Decode HTML entities  					parsedText = System.Net.WebUtility.HtmlDecode(initialClipboardText);  				}    				if (SourceCSharpButton.IsChecked == true)  				{  					// Detect trailing colon to offer the option to cut off and generate it  					var match = Regex.Match(parsedText' @"^(.+)\s?:(\s*)$");  					if (match.Success)  					{  						AddColonCheckbox.IsChecked = true;  						AddColonCheckbox.Visibility = Visibility.Visible;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (initialClipboardText != null)  			{  				if (setTextKey && SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked == true)  				{  					// Initial CSHTML type detection (only on first call):  					// In a .cshtml file there can be C# code as well as Razor code. C# code must be  					// inserted in existing code blocks. It is processed like in a regular .cs file.  					// When selecting plain HTML content' a new Razor code section must be inserted  					// where the text was. This is prefixed with "@" and does not handle  					// placeholders because there are no variables in plain content. (Existing @  					// code blocks within the copied text are not supported because Razor parsing is  					// too complex.)  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						// This looks like an existing C# code string' don't handle it as HTML content  						SourceHtmlButton.IsChecked = false;  					}  				}    				if (SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked != true)  				{  					isPartialString = true;  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						isPartialString = false;  					}    					StringBuilder textContent = new StringBuilder();  					StringBuilder placeholderContent = new StringBuilder();  					Stack<LangState> stateStack = new Stack<LangState>();  					if (isPartialString)  					{  						// Assume a simple string  						stateStack.Push(LangState.String);  					}    					for (int pos = 0; pos < initialClipboardText.Length; pos++)  					{  						char ch = initialClipboardText[pos];  						char nextChar = pos + 1 < initialClipboardText.Length ? initialClipboardText[pos + 1] : '\0';  						var allStates = stateStack.ToArray();   // Stack top = Array beginning  						var state = allStates.Length >= 1 ? allStates[0] : LangState.None;  						var prevState = allStates.Length >= 2 ? allStates[1] : LangState.None;    						if (ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start verbatim string literal  							stateStack.Push(LangState.VerbatimString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start interpolated string literal  							stateStack.Push(LangState.InterpolString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start simple string literal  							stateStack.Push(LangState.String);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '\\' &&  							(state == LangState.InterpolString || state == LangState.String))  						{  							// String escape sequence' evaluate further characters  							if (stateStack.Count == 1)  							{  								switch (nextChar)  								{  									case '\'':  									case '"':  									case '\\':  										textContent.Append(nextChar);  										break;  									case '0': textContent.Append('\0'); break;  									case 'a': textContent.Append('\a'); break;  									case 'b': textContent.Append('\b'); break;  									case 'f': textContent.Append('\f'); break;  									case 'n': textContent.Append('\n'); break;  									case 'r': textContent.Append('\r'); break;  									case 't': textContent.Append('\t'); break;  									case 'U':  										long value = long.Parse(initialClipboardText.Substring(pos + 2' 8)' System.Globalization.NumberStyles.HexNumber);  										//textContent.Append();   // TODO: What does that value mean?  										pos += 8;  										break;  									case 'u':  										int codepoint = int.Parse(initialClipboardText.Substring(pos + 2' 4)' System.Globalization.NumberStyles.HexNumber);  										textContent.Append((char)codepoint);  										pos += 4;  										break;  									case 'v': textContent.Append('\v'); break;  									case 'x':  										// TODO: variable length hex value!  										break;  									default:  										// Ignore invalid escape sequences altogether  										break;  								}  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters (or more)  							pos++;  						}  						else if (ch == '"' && nextChar == '"' &&  							state == LangState.VerbatimString)  						{  							// Verbatim string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' && nextChar == '{' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '}' && nextChar == '}' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' &&  							state == LangState.InterpolString)  						{  							// Start interpolated string code  							stateStack.Push(LangState.None);  							if (stateStack.Count > 2)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '}' &&  							state == LangState.None &&  							prevState == LangState.InterpolString)  						{  							// End interpolated string code  							stateStack.Pop();  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// End string literal  							stateStack.Pop();  							if (stateStack.Count > 0)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// String content (only on first level)  							textContent.Append(ch);  						}    						else if (ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start char literal  							stateStack.Push(LangState.Char);  							placeholderContent.Append(ch);  						}  						else if (ch == '\\' &&  							state == LangState.Char)  						{  							// Char escape sequence' skip next character  							// (Don't parse char literals' they're always in placeholders. If it's  							// a longer escape sequence like '\u0000' we just take the first two  							// characters now and happily append more characters. We don't care  							// about invalid char literals like 'abc' and just pass them through.)  							placeholderContent.Append(ch).Append(nextChar);  							// Handled 2 characters  							pos++;  						}  						else if (ch == '\'' &&  							state == LangState.Char)  						{  							// End char literal  							placeholderContent.Append(ch);  							stateStack.Pop();  						}    						else if (ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open parenthesis  							stateStack.Push(LangState.Parenthesis);  							placeholderContent.Append(ch);  						}  						else if (ch == ')' &&  							state == LangState.Parenthesis)  						{  							// Close parenthesis  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open bracket  							stateStack.Push(LangState.Bracket);  							placeholderContent.Append(ch);  						}  						else if (ch == ']' &&  							state == LangState.Bracket)  						{  							// Close bracket  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open brace  							stateStack.Push(LangState.Brace);  							placeholderContent.Append(ch);  						}  						else if (ch == '}' &&  							state == LangState.Brace)  						{  							// Close brace  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else  						{  							// Other code  							placeholderContent.Append(ch);  						}  					}  					if (placeholderContent.Length > 0)  					{  						// Add last placeholder  						AddParsedPlaceholder(textContent' placeholderContent);  					}  					parsedText = textContent.ToString();  				}  				if (SourceXamlButton.IsChecked == true)  				{  					parsedText = initialClipboardText;  					// TODO: Any further processing required?  				}  				if (SourceAspxButton.IsChecked == true || SourceHtmlButton.IsChecked == true)  				{  					// Decode HTML entities  					parsedText = System.Net.WebUtility.HtmlDecode(initialClipboardText);  				}    				if (SourceCSharpButton.IsChecked == true)  				{  					// Detect trailing colon to offer the option to cut off and generate it  					var match = Regex.Match(parsedText' @"^(.+)\s?:(\s*)$");  					if (match.Success)  					{  						AddColonCheckbox.IsChecked = true;  						AddColonCheckbox.Visibility = Visibility.Visible;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (initialClipboardText != null)  			{  				if (setTextKey && SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked == true)  				{  					// Initial CSHTML type detection (only on first call):  					// In a .cshtml file there can be C# code as well as Razor code. C# code must be  					// inserted in existing code blocks. It is processed like in a regular .cs file.  					// When selecting plain HTML content' a new Razor code section must be inserted  					// where the text was. This is prefixed with "@" and does not handle  					// placeholders because there are no variables in plain content. (Existing @  					// code blocks within the copied text are not supported because Razor parsing is  					// too complex.)  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						// This looks like an existing C# code string' don't handle it as HTML content  						SourceHtmlButton.IsChecked = false;  					}  				}    				if (SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked != true)  				{  					isPartialString = true;  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						isPartialString = false;  					}    					StringBuilder textContent = new StringBuilder();  					StringBuilder placeholderContent = new StringBuilder();  					Stack<LangState> stateStack = new Stack<LangState>();  					if (isPartialString)  					{  						// Assume a simple string  						stateStack.Push(LangState.String);  					}    					for (int pos = 0; pos < initialClipboardText.Length; pos++)  					{  						char ch = initialClipboardText[pos];  						char nextChar = pos + 1 < initialClipboardText.Length ? initialClipboardText[pos + 1] : '\0';  						var allStates = stateStack.ToArray();   // Stack top = Array beginning  						var state = allStates.Length >= 1 ? allStates[0] : LangState.None;  						var prevState = allStates.Length >= 2 ? allStates[1] : LangState.None;    						if (ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start verbatim string literal  							stateStack.Push(LangState.VerbatimString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start interpolated string literal  							stateStack.Push(LangState.InterpolString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start simple string literal  							stateStack.Push(LangState.String);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '\\' &&  							(state == LangState.InterpolString || state == LangState.String))  						{  							// String escape sequence' evaluate further characters  							if (stateStack.Count == 1)  							{  								switch (nextChar)  								{  									case '\'':  									case '"':  									case '\\':  										textContent.Append(nextChar);  										break;  									case '0': textContent.Append('\0'); break;  									case 'a': textContent.Append('\a'); break;  									case 'b': textContent.Append('\b'); break;  									case 'f': textContent.Append('\f'); break;  									case 'n': textContent.Append('\n'); break;  									case 'r': textContent.Append('\r'); break;  									case 't': textContent.Append('\t'); break;  									case 'U':  										long value = long.Parse(initialClipboardText.Substring(pos + 2' 8)' System.Globalization.NumberStyles.HexNumber);  										//textContent.Append();   // TODO: What does that value mean?  										pos += 8;  										break;  									case 'u':  										int codepoint = int.Parse(initialClipboardText.Substring(pos + 2' 4)' System.Globalization.NumberStyles.HexNumber);  										textContent.Append((char)codepoint);  										pos += 4;  										break;  									case 'v': textContent.Append('\v'); break;  									case 'x':  										// TODO: variable length hex value!  										break;  									default:  										// Ignore invalid escape sequences altogether  										break;  								}  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters (or more)  							pos++;  						}  						else if (ch == '"' && nextChar == '"' &&  							state == LangState.VerbatimString)  						{  							// Verbatim string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' && nextChar == '{' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '}' && nextChar == '}' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' &&  							state == LangState.InterpolString)  						{  							// Start interpolated string code  							stateStack.Push(LangState.None);  							if (stateStack.Count > 2)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '}' &&  							state == LangState.None &&  							prevState == LangState.InterpolString)  						{  							// End interpolated string code  							stateStack.Pop();  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// End string literal  							stateStack.Pop();  							if (stateStack.Count > 0)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// String content (only on first level)  							textContent.Append(ch);  						}    						else if (ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start char literal  							stateStack.Push(LangState.Char);  							placeholderContent.Append(ch);  						}  						else if (ch == '\\' &&  							state == LangState.Char)  						{  							// Char escape sequence' skip next character  							// (Don't parse char literals' they're always in placeholders. If it's  							// a longer escape sequence like '\u0000' we just take the first two  							// characters now and happily append more characters. We don't care  							// about invalid char literals like 'abc' and just pass them through.)  							placeholderContent.Append(ch).Append(nextChar);  							// Handled 2 characters  							pos++;  						}  						else if (ch == '\'' &&  							state == LangState.Char)  						{  							// End char literal  							placeholderContent.Append(ch);  							stateStack.Pop();  						}    						else if (ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open parenthesis  							stateStack.Push(LangState.Parenthesis);  							placeholderContent.Append(ch);  						}  						else if (ch == ')' &&  							state == LangState.Parenthesis)  						{  							// Close parenthesis  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open bracket  							stateStack.Push(LangState.Bracket);  							placeholderContent.Append(ch);  						}  						else if (ch == ']' &&  							state == LangState.Bracket)  						{  							// Close bracket  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open brace  							stateStack.Push(LangState.Brace);  							placeholderContent.Append(ch);  						}  						else if (ch == '}' &&  							state == LangState.Brace)  						{  							// Close brace  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else  						{  							// Other code  							placeholderContent.Append(ch);  						}  					}  					if (placeholderContent.Length > 0)  					{  						// Add last placeholder  						AddParsedPlaceholder(textContent' placeholderContent);  					}  					parsedText = textContent.ToString();  				}  				if (SourceXamlButton.IsChecked == true)  				{  					parsedText = initialClipboardText;  					// TODO: Any further processing required?  				}  				if (SourceAspxButton.IsChecked == true || SourceHtmlButton.IsChecked == true)  				{  					// Decode HTML entities  					parsedText = System.Net.WebUtility.HtmlDecode(initialClipboardText);  				}    				if (SourceCSharpButton.IsChecked == true)  				{  					// Detect trailing colon to offer the option to cut off and generate it  					var match = Regex.Match(parsedText' @"^(.+)\s?:(\s*)$");  					if (match.Success)  					{  						AddColonCheckbox.IsChecked = true;  						AddColonCheckbox.Visibility = Visibility.Visible;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (initialClipboardText != null)  			{  				if (setTextKey && SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked == true)  				{  					// Initial CSHTML type detection (only on first call):  					// In a .cshtml file there can be C# code as well as Razor code. C# code must be  					// inserted in existing code blocks. It is processed like in a regular .cs file.  					// When selecting plain HTML content' a new Razor code section must be inserted  					// where the text was. This is prefixed with "@" and does not handle  					// placeholders because there are no variables in plain content. (Existing @  					// code blocks within the copied text are not supported because Razor parsing is  					// too complex.)  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						// This looks like an existing C# code string' don't handle it as HTML content  						SourceHtmlButton.IsChecked = false;  					}  				}    				if (SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked != true)  				{  					isPartialString = true;  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						isPartialString = false;  					}    					StringBuilder textContent = new StringBuilder();  					StringBuilder placeholderContent = new StringBuilder();  					Stack<LangState> stateStack = new Stack<LangState>();  					if (isPartialString)  					{  						// Assume a simple string  						stateStack.Push(LangState.String);  					}    					for (int pos = 0; pos < initialClipboardText.Length; pos++)  					{  						char ch = initialClipboardText[pos];  						char nextChar = pos + 1 < initialClipboardText.Length ? initialClipboardText[pos + 1] : '\0';  						var allStates = stateStack.ToArray();   // Stack top = Array beginning  						var state = allStates.Length >= 1 ? allStates[0] : LangState.None;  						var prevState = allStates.Length >= 2 ? allStates[1] : LangState.None;    						if (ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start verbatim string literal  							stateStack.Push(LangState.VerbatimString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start interpolated string literal  							stateStack.Push(LangState.InterpolString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start simple string literal  							stateStack.Push(LangState.String);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '\\' &&  							(state == LangState.InterpolString || state == LangState.String))  						{  							// String escape sequence' evaluate further characters  							if (stateStack.Count == 1)  							{  								switch (nextChar)  								{  									case '\'':  									case '"':  									case '\\':  										textContent.Append(nextChar);  										break;  									case '0': textContent.Append('\0'); break;  									case 'a': textContent.Append('\a'); break;  									case 'b': textContent.Append('\b'); break;  									case 'f': textContent.Append('\f'); break;  									case 'n': textContent.Append('\n'); break;  									case 'r': textContent.Append('\r'); break;  									case 't': textContent.Append('\t'); break;  									case 'U':  										long value = long.Parse(initialClipboardText.Substring(pos + 2' 8)' System.Globalization.NumberStyles.HexNumber);  										//textContent.Append();   // TODO: What does that value mean?  										pos += 8;  										break;  									case 'u':  										int codepoint = int.Parse(initialClipboardText.Substring(pos + 2' 4)' System.Globalization.NumberStyles.HexNumber);  										textContent.Append((char)codepoint);  										pos += 4;  										break;  									case 'v': textContent.Append('\v'); break;  									case 'x':  										// TODO: variable length hex value!  										break;  									default:  										// Ignore invalid escape sequences altogether  										break;  								}  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters (or more)  							pos++;  						}  						else if (ch == '"' && nextChar == '"' &&  							state == LangState.VerbatimString)  						{  							// Verbatim string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' && nextChar == '{' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '}' && nextChar == '}' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' &&  							state == LangState.InterpolString)  						{  							// Start interpolated string code  							stateStack.Push(LangState.None);  							if (stateStack.Count > 2)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '}' &&  							state == LangState.None &&  							prevState == LangState.InterpolString)  						{  							// End interpolated string code  							stateStack.Pop();  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// End string literal  							stateStack.Pop();  							if (stateStack.Count > 0)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// String content (only on first level)  							textContent.Append(ch);  						}    						else if (ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start char literal  							stateStack.Push(LangState.Char);  							placeholderContent.Append(ch);  						}  						else if (ch == '\\' &&  							state == LangState.Char)  						{  							// Char escape sequence' skip next character  							// (Don't parse char literals' they're always in placeholders. If it's  							// a longer escape sequence like '\u0000' we just take the first two  							// characters now and happily append more characters. We don't care  							// about invalid char literals like 'abc' and just pass them through.)  							placeholderContent.Append(ch).Append(nextChar);  							// Handled 2 characters  							pos++;  						}  						else if (ch == '\'' &&  							state == LangState.Char)  						{  							// End char literal  							placeholderContent.Append(ch);  							stateStack.Pop();  						}    						else if (ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open parenthesis  							stateStack.Push(LangState.Parenthesis);  							placeholderContent.Append(ch);  						}  						else if (ch == ')' &&  							state == LangState.Parenthesis)  						{  							// Close parenthesis  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open bracket  							stateStack.Push(LangState.Bracket);  							placeholderContent.Append(ch);  						}  						else if (ch == ']' &&  							state == LangState.Bracket)  						{  							// Close bracket  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open brace  							stateStack.Push(LangState.Brace);  							placeholderContent.Append(ch);  						}  						else if (ch == '}' &&  							state == LangState.Brace)  						{  							// Close brace  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else  						{  							// Other code  							placeholderContent.Append(ch);  						}  					}  					if (placeholderContent.Length > 0)  					{  						// Add last placeholder  						AddParsedPlaceholder(textContent' placeholderContent);  					}  					parsedText = textContent.ToString();  				}  				if (SourceXamlButton.IsChecked == true)  				{  					parsedText = initialClipboardText;  					// TODO: Any further processing required?  				}  				if (SourceAspxButton.IsChecked == true || SourceHtmlButton.IsChecked == true)  				{  					// Decode HTML entities  					parsedText = System.Net.WebUtility.HtmlDecode(initialClipboardText);  				}    				if (SourceCSharpButton.IsChecked == true)  				{  					// Detect trailing colon to offer the option to cut off and generate it  					var match = Regex.Match(parsedText' @"^(.+)\s?:(\s*)$");  					if (match.Success)  					{  						AddColonCheckbox.IsChecked = true;  						AddColonCheckbox.Visibility = Visibility.Visible;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (initialClipboardText != null)  			{  				if (setTextKey && SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked == true)  				{  					// Initial CSHTML type detection (only on first call):  					// In a .cshtml file there can be C# code as well as Razor code. C# code must be  					// inserted in existing code blocks. It is processed like in a regular .cs file.  					// When selecting plain HTML content' a new Razor code section must be inserted  					// where the text was. This is prefixed with "@" and does not handle  					// placeholders because there are no variables in plain content. (Existing @  					// code blocks within the copied text are not supported because Razor parsing is  					// too complex.)  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						// This looks like an existing C# code string' don't handle it as HTML content  						SourceHtmlButton.IsChecked = false;  					}  				}    				if (SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked != true)  				{  					isPartialString = true;  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						isPartialString = false;  					}    					StringBuilder textContent = new StringBuilder();  					StringBuilder placeholderContent = new StringBuilder();  					Stack<LangState> stateStack = new Stack<LangState>();  					if (isPartialString)  					{  						// Assume a simple string  						stateStack.Push(LangState.String);  					}    					for (int pos = 0; pos < initialClipboardText.Length; pos++)  					{  						char ch = initialClipboardText[pos];  						char nextChar = pos + 1 < initialClipboardText.Length ? initialClipboardText[pos + 1] : '\0';  						var allStates = stateStack.ToArray();   // Stack top = Array beginning  						var state = allStates.Length >= 1 ? allStates[0] : LangState.None;  						var prevState = allStates.Length >= 2 ? allStates[1] : LangState.None;    						if (ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start verbatim string literal  							stateStack.Push(LangState.VerbatimString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start interpolated string literal  							stateStack.Push(LangState.InterpolString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start simple string literal  							stateStack.Push(LangState.String);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '\\' &&  							(state == LangState.InterpolString || state == LangState.String))  						{  							// String escape sequence' evaluate further characters  							if (stateStack.Count == 1)  							{  								switch (nextChar)  								{  									case '\'':  									case '"':  									case '\\':  										textContent.Append(nextChar);  										break;  									case '0': textContent.Append('\0'); break;  									case 'a': textContent.Append('\a'); break;  									case 'b': textContent.Append('\b'); break;  									case 'f': textContent.Append('\f'); break;  									case 'n': textContent.Append('\n'); break;  									case 'r': textContent.Append('\r'); break;  									case 't': textContent.Append('\t'); break;  									case 'U':  										long value = long.Parse(initialClipboardText.Substring(pos + 2' 8)' System.Globalization.NumberStyles.HexNumber);  										//textContent.Append();   // TODO: What does that value mean?  										pos += 8;  										break;  									case 'u':  										int codepoint = int.Parse(initialClipboardText.Substring(pos + 2' 4)' System.Globalization.NumberStyles.HexNumber);  										textContent.Append((char)codepoint);  										pos += 4;  										break;  									case 'v': textContent.Append('\v'); break;  									case 'x':  										// TODO: variable length hex value!  										break;  									default:  										// Ignore invalid escape sequences altogether  										break;  								}  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters (or more)  							pos++;  						}  						else if (ch == '"' && nextChar == '"' &&  							state == LangState.VerbatimString)  						{  							// Verbatim string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' && nextChar == '{' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '}' && nextChar == '}' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' &&  							state == LangState.InterpolString)  						{  							// Start interpolated string code  							stateStack.Push(LangState.None);  							if (stateStack.Count > 2)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '}' &&  							state == LangState.None &&  							prevState == LangState.InterpolString)  						{  							// End interpolated string code  							stateStack.Pop();  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// End string literal  							stateStack.Pop();  							if (stateStack.Count > 0)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// String content (only on first level)  							textContent.Append(ch);  						}    						else if (ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start char literal  							stateStack.Push(LangState.Char);  							placeholderContent.Append(ch);  						}  						else if (ch == '\\' &&  							state == LangState.Char)  						{  							// Char escape sequence' skip next character  							// (Don't parse char literals' they're always in placeholders. If it's  							// a longer escape sequence like '\u0000' we just take the first two  							// characters now and happily append more characters. We don't care  							// about invalid char literals like 'abc' and just pass them through.)  							placeholderContent.Append(ch).Append(nextChar);  							// Handled 2 characters  							pos++;  						}  						else if (ch == '\'' &&  							state == LangState.Char)  						{  							// End char literal  							placeholderContent.Append(ch);  							stateStack.Pop();  						}    						else if (ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open parenthesis  							stateStack.Push(LangState.Parenthesis);  							placeholderContent.Append(ch);  						}  						else if (ch == ')' &&  							state == LangState.Parenthesis)  						{  							// Close parenthesis  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open bracket  							stateStack.Push(LangState.Bracket);  							placeholderContent.Append(ch);  						}  						else if (ch == ']' &&  							state == LangState.Bracket)  						{  							// Close bracket  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open brace  							stateStack.Push(LangState.Brace);  							placeholderContent.Append(ch);  						}  						else if (ch == '}' &&  							state == LangState.Brace)  						{  							// Close brace  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else  						{  							// Other code  							placeholderContent.Append(ch);  						}  					}  					if (placeholderContent.Length > 0)  					{  						// Add last placeholder  						AddParsedPlaceholder(textContent' placeholderContent);  					}  					parsedText = textContent.ToString();  				}  				if (SourceXamlButton.IsChecked == true)  				{  					parsedText = initialClipboardText;  					// TODO: Any further processing required?  				}  				if (SourceAspxButton.IsChecked == true || SourceHtmlButton.IsChecked == true)  				{  					// Decode HTML entities  					parsedText = System.Net.WebUtility.HtmlDecode(initialClipboardText);  				}    				if (SourceCSharpButton.IsChecked == true)  				{  					// Detect trailing colon to offer the option to cut off and generate it  					var match = Regex.Match(parsedText' @"^(.+)\s?:(\s*)$");  					if (match.Success)  					{  						AddColonCheckbox.IsChecked = true;  						AddColonCheckbox.Visibility = Visibility.Visible;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (initialClipboardText != null)  			{  				if (setTextKey && SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked == true)  				{  					// Initial CSHTML type detection (only on first call):  					// In a .cshtml file there can be C# code as well as Razor code. C# code must be  					// inserted in existing code blocks. It is processed like in a regular .cs file.  					// When selecting plain HTML content' a new Razor code section must be inserted  					// where the text was. This is prefixed with "@" and does not handle  					// placeholders because there are no variables in plain content. (Existing @  					// code blocks within the copied text are not supported because Razor parsing is  					// too complex.)  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						// This looks like an existing C# code string' don't handle it as HTML content  						SourceHtmlButton.IsChecked = false;  					}  				}    				if (SourceCSharpButton.IsChecked == true && SourceHtmlButton.IsChecked != true)  				{  					isPartialString = true;  					if ((initialClipboardText.StartsWith("\"") || initialClipboardText.StartsWith("@\"") || initialClipboardText.StartsWith("$\"")) &&  						initialClipboardText.EndsWith("\""))  					{  						isPartialString = false;  					}    					StringBuilder textContent = new StringBuilder();  					StringBuilder placeholderContent = new StringBuilder();  					Stack<LangState> stateStack = new Stack<LangState>();  					if (isPartialString)  					{  						// Assume a simple string  						stateStack.Push(LangState.String);  					}    					for (int pos = 0; pos < initialClipboardText.Length; pos++)  					{  						char ch = initialClipboardText[pos];  						char nextChar = pos + 1 < initialClipboardText.Length ? initialClipboardText[pos + 1] : '\0';  						var allStates = stateStack.ToArray();   // Stack top = Array beginning  						var state = allStates.Length >= 1 ? allStates[0] : LangState.None;  						var prevState = allStates.Length >= 2 ? allStates[1] : LangState.None;    						if (ch == '@' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start verbatim string literal  							stateStack.Push(LangState.VerbatimString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '$' && nextChar == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start interpolated string literal  							stateStack.Push(LangState.InterpolString);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters  							pos++;  						}  						else if (ch == '"' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start simple string literal  							stateStack.Push(LangState.String);  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '\\' &&  							(state == LangState.InterpolString || state == LangState.String))  						{  							// String escape sequence' evaluate further characters  							if (stateStack.Count == 1)  							{  								switch (nextChar)  								{  									case '\'':  									case '"':  									case '\\':  										textContent.Append(nextChar);  										break;  									case '0': textContent.Append('\0'); break;  									case 'a': textContent.Append('\a'); break;  									case 'b': textContent.Append('\b'); break;  									case 'f': textContent.Append('\f'); break;  									case 'n': textContent.Append('\n'); break;  									case 'r': textContent.Append('\r'); break;  									case 't': textContent.Append('\t'); break;  									case 'U':  										long value = long.Parse(initialClipboardText.Substring(pos + 2' 8)' System.Globalization.NumberStyles.HexNumber);  										//textContent.Append();   // TODO: What does that value mean?  										pos += 8;  										break;  									case 'u':  										int codepoint = int.Parse(initialClipboardText.Substring(pos + 2' 4)' System.Globalization.NumberStyles.HexNumber);  										textContent.Append((char)codepoint);  										pos += 4;  										break;  									case 'v': textContent.Append('\v'); break;  									case 'x':  										// TODO: variable length hex value!  										break;  									default:  										// Ignore invalid escape sequences altogether  										break;  								}  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							// Handled 2 characters (or more)  							pos++;  						}  						else if (ch == '"' && nextChar == '"' &&  							state == LangState.VerbatimString)  						{  							// Verbatim string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' && nextChar == '{' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '}' && nextChar == '}' &&  							state == LangState.InterpolString)  						{  							// Interpolated string escape sequence' skip next character  							if (stateStack.Count == 1)  							{  								textContent.Append(nextChar);  							}  							else  							{  								placeholderContent.Append(ch).Append(nextChar);  							}  							pos++;  						}  						else if (ch == '{' &&  							state == LangState.InterpolString)  						{  							// Start interpolated string code  							stateStack.Push(LangState.None);  							if (stateStack.Count > 2)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '}' &&  							state == LangState.None &&  							prevState == LangState.InterpolString)  						{  							// End interpolated string code  							stateStack.Pop();  							if (stateStack.Count == 1)  							{  								AddParsedPlaceholder(textContent' placeholderContent);  							}  							else  							{  								placeholderContent.Append(ch);  							}  						}  						else if (ch == '"' &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// End string literal  							stateStack.Pop();  							if (stateStack.Count > 0)  							{  								placeholderContent.Append(ch);  							}  						}  						else if (stateStack.Count == 1 &&  							(state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// String content (only on first level)  							textContent.Append(ch);  						}    						else if (ch == '\'' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Start char literal  							stateStack.Push(LangState.Char);  							placeholderContent.Append(ch);  						}  						else if (ch == '\\' &&  							state == LangState.Char)  						{  							// Char escape sequence' skip next character  							// (Don't parse char literals' they're always in placeholders. If it's  							// a longer escape sequence like '\u0000' we just take the first two  							// characters now and happily append more characters. We don't care  							// about invalid char literals like 'abc' and just pass them through.)  							placeholderContent.Append(ch).Append(nextChar);  							// Handled 2 characters  							pos++;  						}  						else if (ch == '\'' &&  							state == LangState.Char)  						{  							// End char literal  							placeholderContent.Append(ch);  							stateStack.Pop();  						}    						else if (ch == '(' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open parenthesis  							stateStack.Push(LangState.Parenthesis);  							placeholderContent.Append(ch);  						}  						else if (ch == ')' &&  							state == LangState.Parenthesis)  						{  							// Close parenthesis  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '[' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open bracket  							stateStack.Push(LangState.Bracket);  							placeholderContent.Append(ch);  						}  						else if (ch == ']' &&  							state == LangState.Bracket)  						{  							// Close bracket  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else if (ch == '{' &&  							!(state == LangState.Char || state == LangState.InterpolString || state == LangState.String || state == LangState.VerbatimString))  						{  							// Open brace  							stateStack.Push(LangState.Brace);  							placeholderContent.Append(ch);  						}  						else if (ch == '}' &&  							state == LangState.Brace)  						{  							// Close brace  							stateStack.Pop();  							placeholderContent.Append(ch);  						}  						else  						{  							// Other code  							placeholderContent.Append(ch);  						}  					}  					if (placeholderContent.Length > 0)  					{  						// Add last placeholder  						AddParsedPlaceholder(textContent' placeholderContent);  					}  					parsedText = textContent.ToString();  				}  				if (SourceXamlButton.IsChecked == true)  				{  					parsedText = initialClipboardText;  					// TODO: Any further processing required?  				}  				if (SourceAspxButton.IsChecked == true || SourceHtmlButton.IsChecked == true)  				{  					// Decode HTML entities  					parsedText = System.Net.WebUtility.HtmlDecode(initialClipboardText);  				}    				if (SourceCSharpButton.IsChecked == true)  				{  					// Detect trailing colon to offer the option to cut off and generate it  					var match = Regex.Match(parsedText' @"^(.+)\s?:(\s*)$");  					if (match.Success)  					{  						AddColonCheckbox.IsChecked = true;  						AddColonCheckbox.Visibility = Visibility.Visible;  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (placeholders.Count > 0)  			{  				ParametersLabel.Visibility = Visibility.Visible;  				ParametersGrid.Visibility = Visibility.Visible;  				int row = 0;  				foreach (var pd in placeholders)  				{  					var localPd = pd;    					ParametersGrid.RowDefinitions.Add(new RowDefinition());    					TextBox nameText = new TextBox();  					nameText.Text = pd.Name;  					nameText.SelectAll();  					nameText.Margin = new Thickness(0' row > 0 ? 4 : 0' 0' 0);  					nameText.LostFocus += (s' e2) => { UpdatePlaceholderName(localPd' nameText.Text); };  					ParametersGrid.Children.Add(nameText);  					Grid.SetRow(nameText' row);  					Grid.SetColumn(nameText' 0);    					TextBox codeText = new TextBox();  					codeText.Text = pd.Code;  					codeText.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					codeText.TextChanged += (s' e2) => { localPd.Code = codeText.Text; };  					ParametersGrid.Children.Add(codeText);  					Grid.SetRow(codeText' row);  					Grid.SetColumn(codeText' 1);    					CheckBox quotedCheck = new CheckBox();  					quotedCheck.Content = "Q";  					quotedCheck.IsChecked = pd.IsQuoted;  					quotedCheck.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					quotedCheck.VerticalAlignment = VerticalAlignment.Center;  					quotedCheck.Checked += (s' e2) => { localPd.IsQuoted = true; };  					quotedCheck.Unchecked += (s' e2) => { localPd.IsQuoted = false; };  					ParametersGrid.Children.Add(quotedCheck);  					Grid.SetRow(quotedCheck' row);  					Grid.SetColumn(quotedCheck' 2);    					row++;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (placeholders.Count > 0)  			{  				ParametersLabel.Visibility = Visibility.Visible;  				ParametersGrid.Visibility = Visibility.Visible;  				int row = 0;  				foreach (var pd in placeholders)  				{  					var localPd = pd;    					ParametersGrid.RowDefinitions.Add(new RowDefinition());    					TextBox nameText = new TextBox();  					nameText.Text = pd.Name;  					nameText.SelectAll();  					nameText.Margin = new Thickness(0' row > 0 ? 4 : 0' 0' 0);  					nameText.LostFocus += (s' e2) => { UpdatePlaceholderName(localPd' nameText.Text); };  					ParametersGrid.Children.Add(nameText);  					Grid.SetRow(nameText' row);  					Grid.SetColumn(nameText' 0);    					TextBox codeText = new TextBox();  					codeText.Text = pd.Code;  					codeText.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					codeText.TextChanged += (s' e2) => { localPd.Code = codeText.Text; };  					ParametersGrid.Children.Add(codeText);  					Grid.SetRow(codeText' row);  					Grid.SetColumn(codeText' 1);    					CheckBox quotedCheck = new CheckBox();  					quotedCheck.Content = "Q";  					quotedCheck.IsChecked = pd.IsQuoted;  					quotedCheck.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					quotedCheck.VerticalAlignment = VerticalAlignment.Center;  					quotedCheck.Checked += (s' e2) => { localPd.IsQuoted = true; };  					quotedCheck.Unchecked += (s' e2) => { localPd.IsQuoted = false; };  					ParametersGrid.Children.Add(quotedCheck);  					Grid.SetRow(quotedCheck' row);  					Grid.SetColumn(quotedCheck' 2);    					row++;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (placeholders.Count > 0)  			{  				ParametersLabel.Visibility = Visibility.Visible;  				ParametersGrid.Visibility = Visibility.Visible;  				int row = 0;  				foreach (var pd in placeholders)  				{  					var localPd = pd;    					ParametersGrid.RowDefinitions.Add(new RowDefinition());    					TextBox nameText = new TextBox();  					nameText.Text = pd.Name;  					nameText.SelectAll();  					nameText.Margin = new Thickness(0' row > 0 ? 4 : 0' 0' 0);  					nameText.LostFocus += (s' e2) => { UpdatePlaceholderName(localPd' nameText.Text); };  					ParametersGrid.Children.Add(nameText);  					Grid.SetRow(nameText' row);  					Grid.SetColumn(nameText' 0);    					TextBox codeText = new TextBox();  					codeText.Text = pd.Code;  					codeText.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					codeText.TextChanged += (s' e2) => { localPd.Code = codeText.Text; };  					ParametersGrid.Children.Add(codeText);  					Grid.SetRow(codeText' row);  					Grid.SetColumn(codeText' 1);    					CheckBox quotedCheck = new CheckBox();  					quotedCheck.Content = "Q";  					quotedCheck.IsChecked = pd.IsQuoted;  					quotedCheck.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					quotedCheck.VerticalAlignment = VerticalAlignment.Center;  					quotedCheck.Checked += (s' e2) => { localPd.IsQuoted = true; };  					quotedCheck.Unchecked += (s' e2) => { localPd.IsQuoted = false; };  					ParametersGrid.Children.Add(quotedCheck);  					Grid.SetRow(quotedCheck' row);  					Grid.SetColumn(quotedCheck' 2);    					row++;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (placeholders.Count > 0)  			{  				ParametersLabel.Visibility = Visibility.Visible;  				ParametersGrid.Visibility = Visibility.Visible;  				int row = 0;  				foreach (var pd in placeholders)  				{  					var localPd = pd;    					ParametersGrid.RowDefinitions.Add(new RowDefinition());    					TextBox nameText = new TextBox();  					nameText.Text = pd.Name;  					nameText.SelectAll();  					nameText.Margin = new Thickness(0' row > 0 ? 4 : 0' 0' 0);  					nameText.LostFocus += (s' e2) => { UpdatePlaceholderName(localPd' nameText.Text); };  					ParametersGrid.Children.Add(nameText);  					Grid.SetRow(nameText' row);  					Grid.SetColumn(nameText' 0);    					TextBox codeText = new TextBox();  					codeText.Text = pd.Code;  					codeText.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					codeText.TextChanged += (s' e2) => { localPd.Code = codeText.Text; };  					ParametersGrid.Children.Add(codeText);  					Grid.SetRow(codeText' row);  					Grid.SetColumn(codeText' 1);    					CheckBox quotedCheck = new CheckBox();  					quotedCheck.Content = "Q";  					quotedCheck.IsChecked = pd.IsQuoted;  					quotedCheck.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					quotedCheck.VerticalAlignment = VerticalAlignment.Center;  					quotedCheck.Checked += (s' e2) => { localPd.IsQuoted = true; };  					quotedCheck.Unchecked += (s' e2) => { localPd.IsQuoted = false; };  					ParametersGrid.Children.Add(quotedCheck);  					Grid.SetRow(quotedCheck' row);  					Grid.SetColumn(quotedCheck' 2);    					row++;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (placeholders.Count > 0)  			{  				ParametersLabel.Visibility = Visibility.Visible;  				ParametersGrid.Visibility = Visibility.Visible;  				int row = 0;  				foreach (var pd in placeholders)  				{  					var localPd = pd;    					ParametersGrid.RowDefinitions.Add(new RowDefinition());    					TextBox nameText = new TextBox();  					nameText.Text = pd.Name;  					nameText.SelectAll();  					nameText.Margin = new Thickness(0' row > 0 ? 4 : 0' 0' 0);  					nameText.LostFocus += (s' e2) => { UpdatePlaceholderName(localPd' nameText.Text); };  					ParametersGrid.Children.Add(nameText);  					Grid.SetRow(nameText' row);  					Grid.SetColumn(nameText' 0);    					TextBox codeText = new TextBox();  					codeText.Text = pd.Code;  					codeText.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					codeText.TextChanged += (s' e2) => { localPd.Code = codeText.Text; };  					ParametersGrid.Children.Add(codeText);  					Grid.SetRow(codeText' row);  					Grid.SetColumn(codeText' 1);    					CheckBox quotedCheck = new CheckBox();  					quotedCheck.Content = "Q";  					quotedCheck.IsChecked = pd.IsQuoted;  					quotedCheck.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					quotedCheck.VerticalAlignment = VerticalAlignment.Center;  					quotedCheck.Checked += (s' e2) => { localPd.IsQuoted = true; };  					quotedCheck.Unchecked += (s' e2) => { localPd.IsQuoted = false; };  					ParametersGrid.Children.Add(quotedCheck);  					Grid.SetRow(quotedCheck' row);  					Grid.SetColumn(quotedCheck' 2);    					row++;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,Reset,The following statement contains a magic number: if (placeholders.Count > 0)  			{  				ParametersLabel.Visibility = Visibility.Visible;  				ParametersGrid.Visibility = Visibility.Visible;  				int row = 0;  				foreach (var pd in placeholders)  				{  					var localPd = pd;    					ParametersGrid.RowDefinitions.Add(new RowDefinition());    					TextBox nameText = new TextBox();  					nameText.Text = pd.Name;  					nameText.SelectAll();  					nameText.Margin = new Thickness(0' row > 0 ? 4 : 0' 0' 0);  					nameText.LostFocus += (s' e2) => { UpdatePlaceholderName(localPd' nameText.Text); };  					ParametersGrid.Children.Add(nameText);  					Grid.SetRow(nameText' row);  					Grid.SetColumn(nameText' 0);    					TextBox codeText = new TextBox();  					codeText.Text = pd.Code;  					codeText.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					codeText.TextChanged += (s' e2) => { localPd.Code = codeText.Text; };  					ParametersGrid.Children.Add(codeText);  					Grid.SetRow(codeText' row);  					Grid.SetColumn(codeText' 1);    					CheckBox quotedCheck = new CheckBox();  					quotedCheck.Content = "Q";  					quotedCheck.IsChecked = pd.IsQuoted;  					quotedCheck.Margin = new Thickness(4' row > 0 ? 4 : 0' 0' 0);  					quotedCheck.VerticalAlignment = VerticalAlignment.Center;  					quotedCheck.Checked += (s' e2) => { localPd.IsQuoted = true; };  					quotedCheck.Unchecked += (s' e2) => { localPd.IsQuoted = false; };  					ParametersGrid.Children.Add(quotedCheck);  					Grid.SetRow(quotedCheck' row);  					Grid.SetColumn(quotedCheck' 2);    					row++;  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ScanAllTexts,The following statement contains a magic number: int maxDistance = (int)Math.Round((float)TranslationText.Text.Length / 2' MidpointRounding.AwayFromZero);
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ScanAllTexts,The following statement contains a magic number: if (tk.IsFullKey && tk.CultureTextVMs[0].Text == TranslationText.Text)  			{  				suggestions.Add(new SuggestionViewModel(null) { TextKey = tk.TextKey' BaseText = tk.CultureTextVMs[0].Text' ScoreNum = 1000' IsExactMatch = true });  			}  			else if (tk.IsFullKey && !String.IsNullOrEmpty(tk.CultureTextVMs[0].Text))  			{  				// TODO: Maybe we should split both strings in words and compare them separately' only accepting if at least one word has a small distance  				int distance = ComputeEditDistance(TranslationText.Text' tk.CultureTextVMs[0].Text);  				if (distance <= maxDistance)  				{  					float score;  					if (distance == 0)  					{  						score = 1000;  					}  					else  					{  						score = 100f / distance;  					}  					suggestions.Add(new SuggestionViewModel(null) { TextKey = tk.TextKey' BaseText = tk.CultureTextVMs[0].Text' ScoreNum = score });  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ScanAllTexts,The following statement contains a magic number: if (tk.IsFullKey && tk.CultureTextVMs[0].Text == TranslationText.Text)  			{  				suggestions.Add(new SuggestionViewModel(null) { TextKey = tk.TextKey' BaseText = tk.CultureTextVMs[0].Text' ScoreNum = 1000' IsExactMatch = true });  			}  			else if (tk.IsFullKey && !String.IsNullOrEmpty(tk.CultureTextVMs[0].Text))  			{  				// TODO: Maybe we should split both strings in words and compare them separately' only accepting if at least one word has a small distance  				int distance = ComputeEditDistance(TranslationText.Text' tk.CultureTextVMs[0].Text);  				if (distance <= maxDistance)  				{  					float score;  					if (distance == 0)  					{  						score = 1000;  					}  					else  					{  						score = 100f / distance;  					}  					suggestions.Add(new SuggestionViewModel(null) { TextKey = tk.TextKey' BaseText = tk.CultureTextVMs[0].Text' ScoreNum = score });  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,AutoSelectKeyText,The following statement contains a magic number: if (m.Success)  			{  				TextKeyText.SelectionStart = m.Groups[1].Length;  				TextKeyText.SelectionLength = m.Groups[2].Length;  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ComputeEditDistance,The following statement contains a magic number: for (int i = 1; i <= len_orig; i++)  			{  				for (int j = 1; j <= len_diff; j++)  				{  					char c1 = modified[j - 1];  					char c2 = original[i - 1];  					float cost;  					if (c1 == c2)  					{  						cost = 0;  					}  					else if (Char.ToLowerInvariant(c1) == Char.ToLowerInvariant(c2))  					{  						// Case-only differences have a smaller distance  						cost = 0.5f;  					}  					else if (Char.IsLetter(c1) != Char.IsLetter(c2))  					{  						// Letter/non-letter differences have a greater distance  						cost = 3;  					}  					else  					{  						cost = 1;  					}  					var vals = new float[]  					{  						matrix[i - 1' j] + 1'  						matrix[i' j - 1] + 1'  						matrix[i - 1' j - 1] + cost  					};  					matrix[i' j] = vals.Min();  					// The Damerau (adjacent transposition) extension:  					if (i > 1 && j > 1 && original[i - 1] == modified[j - 2] && original[i - 2] == modified[j - 1])  					{  						matrix[i' j] = Math.Min(matrix[i' j]' matrix[i - 2' j - 2] + cost);  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ComputeEditDistance,The following statement contains a magic number: for (int i = 1; i <= len_orig; i++)  			{  				for (int j = 1; j <= len_diff; j++)  				{  					char c1 = modified[j - 1];  					char c2 = original[i - 1];  					float cost;  					if (c1 == c2)  					{  						cost = 0;  					}  					else if (Char.ToLowerInvariant(c1) == Char.ToLowerInvariant(c2))  					{  						// Case-only differences have a smaller distance  						cost = 0.5f;  					}  					else if (Char.IsLetter(c1) != Char.IsLetter(c2))  					{  						// Letter/non-letter differences have a greater distance  						cost = 3;  					}  					else  					{  						cost = 1;  					}  					var vals = new float[]  					{  						matrix[i - 1' j] + 1'  						matrix[i' j - 1] + 1'  						matrix[i - 1' j - 1] + cost  					};  					matrix[i' j] = vals.Min();  					// The Damerau (adjacent transposition) extension:  					if (i > 1 && j > 1 && original[i - 1] == modified[j - 2] && original[i - 2] == modified[j - 1])  					{  						matrix[i' j] = Math.Min(matrix[i' j]' matrix[i - 2' j - 2] + cost);  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ComputeEditDistance,The following statement contains a magic number: for (int i = 1; i <= len_orig; i++)  			{  				for (int j = 1; j <= len_diff; j++)  				{  					char c1 = modified[j - 1];  					char c2 = original[i - 1];  					float cost;  					if (c1 == c2)  					{  						cost = 0;  					}  					else if (Char.ToLowerInvariant(c1) == Char.ToLowerInvariant(c2))  					{  						// Case-only differences have a smaller distance  						cost = 0.5f;  					}  					else if (Char.IsLetter(c1) != Char.IsLetter(c2))  					{  						// Letter/non-letter differences have a greater distance  						cost = 3;  					}  					else  					{  						cost = 1;  					}  					var vals = new float[]  					{  						matrix[i - 1' j] + 1'  						matrix[i' j - 1] + 1'  						matrix[i - 1' j - 1] + cost  					};  					matrix[i' j] = vals.Min();  					// The Damerau (adjacent transposition) extension:  					if (i > 1 && j > 1 && original[i - 1] == modified[j - 2] && original[i - 2] == modified[j - 1])  					{  						matrix[i' j] = Math.Min(matrix[i' j]' matrix[i - 2' j - 2] + cost);  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ComputeEditDistance,The following statement contains a magic number: for (int i = 1; i <= len_orig; i++)  			{  				for (int j = 1; j <= len_diff; j++)  				{  					char c1 = modified[j - 1];  					char c2 = original[i - 1];  					float cost;  					if (c1 == c2)  					{  						cost = 0;  					}  					else if (Char.ToLowerInvariant(c1) == Char.ToLowerInvariant(c2))  					{  						// Case-only differences have a smaller distance  						cost = 0.5f;  					}  					else if (Char.IsLetter(c1) != Char.IsLetter(c2))  					{  						// Letter/non-letter differences have a greater distance  						cost = 3;  					}  					else  					{  						cost = 1;  					}  					var vals = new float[]  					{  						matrix[i - 1' j] + 1'  						matrix[i' j - 1] + 1'  						matrix[i - 1' j - 1] + cost  					};  					matrix[i' j] = vals.Min();  					// The Damerau (adjacent transposition) extension:  					if (i > 1 && j > 1 && original[i - 1] == modified[j - 2] && original[i - 2] == modified[j - 1])  					{  						matrix[i' j] = Math.Min(matrix[i' j]' matrix[i - 2' j - 2] + cost);  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,TextKeyWizardWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\TextKeyWizardWindow.xaml.cs,ComputeEditDistance,The following statement contains a magic number: for (int i = 1; i <= len_orig; i++)  			{  				for (int j = 1; j <= len_diff; j++)  				{  					char c1 = modified[j - 1];  					char c2 = original[i - 1];  					float cost;  					if (c1 == c2)  					{  						cost = 0;  					}  					else if (Char.ToLowerInvariant(c1) == Char.ToLowerInvariant(c2))  					{  						// Case-only differences have a smaller distance  						cost = 0.5f;  					}  					else if (Char.IsLetter(c1) != Char.IsLetter(c2))  					{  						// Letter/non-letter differences have a greater distance  						cost = 3;  					}  					else  					{  						cost = 1;  					}  					var vals = new float[]  					{  						matrix[i - 1' j] + 1'  						matrix[i' j - 1] + 1'  						matrix[i - 1' j - 1] + cost  					};  					matrix[i' j] = vals.Min();  					// The Damerau (adjacent transposition) extension:  					if (i > 1 && j > 1 && original[i - 1] == modified[j - 2] && original[i - 2] == modified[j - 1])  					{  						matrix[i' j] = Math.Min(matrix[i' j]' matrix[i - 2' j - 2] + cost);  					}  				}  			}
Magic Number,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,MainWindow,The following statement contains a magic number: Width = 950;
Magic Number,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,MainWindow,The following statement contains a magic number: Height = 600;
Magic Number,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,AutoCollapseItems,The following statement contains a magic number: if (ToolGrid.ActualWidth < 10) return;
Magic Number,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,AutoCollapseItems,The following statement contains a magic number: int extentWidth = 6;
Magic Number,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,CharMapButton_ToolTipOpening,The following statement contains a magic number: if (obj != null)  			{  				ToolTipService.SetPlacement(obj' System.Windows.Controls.Primitives.PlacementMode.Relative);  				ToolTipService.SetVerticalOffset(obj' obj.ActualHeight + 6);  			}
Magic Number,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,AnimateStatusText,The following statement contains a magic number: int durationMs = 300;
Magic Number,Unclassified.TxEditor.Views,MainWindow,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\MainWindow.xaml.cs,AnimateStatusText,The following statement contains a magic number: double offset = Math.Max(15' StatusText.ActualHeight);
Missing Default,Unclassified.TxEditor.Controls,AcceptProblemButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\AcceptProblemButton.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this._this = ((Unclassified.TxEditor.Controls.AcceptProblemButton)(target));              return;              }
Missing Default,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,UpdateDecorations,The following switch statement is missing a default case: switch (textBox1.Text[pos])  						{  							case '\t':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "→";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case ' ':  							case '\u2002':   // en space  							case '\u2003':   // em space  							case '\u2004':   // 3 per em space  							case '\u2005':   // 4 per em space  							case '\u2006':   // 6 per em space  							case '\u2008':   // punctuation space  							case '\u2009':   // thin space  							case '\u200a':   // hair space  							case '\u200b':   // zero-width space  							case '\u205f':   // medium mathematical space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "·";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\xa0':     // no-break space  							case '\u2007':   // figure space (non-breaking)  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "°";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\u202f':   // narrow no-break space  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								if (!double.IsNaN(width))  								{  									tb.Margin = new Thickness(startRect.Left - 10' startRect.Top' 0' 0);  									tb.Width = width + 20;  									tb.TextAlignment = TextAlignment.Center;  								}  								else  								{  									tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								}  								tb.Text = "'";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  							case '\n':  								tb = new TextBlock();  								tb.HorizontalAlignment = HorizontalAlignment.Left;  								tb.VerticalAlignment = VerticalAlignment.Top;  								tb.Margin = new Thickness(startRect.Left' startRect.Top' 0' 0);  								tb.Text = "↲";   // "¶";  								tb.Foreground = Brushes.DarkGray;  								grid1.Children.Insert(0' tb);  								decos.Add(tb);  								break;  						}
Missing Default,Unclassified.TxEditor.Controls,DecoratedTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Controls\DecoratedTextBox.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.root = ((Unclassified.TxEditor.Controls.DecoratedTextBox)(target));              return;              case 2:              this.grid1 = ((System.Windows.Controls.Grid)(target));              return;              case 3:              this.textBox1 = ((System.Windows.Controls.TextBox)(target));                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.textBox1_TextChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.SelectionChanged += new System.Windows.RoutedEventHandler(this.textBox1_SelectionChanged);                            #line default              #line hidden                            #line 34 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.textBox1_KeyDown);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.GotFocus += new System.Windows.RoutedEventHandler(this.textBox1_GotFocus);                            #line default              #line hidden                            #line 35 "..\..\..\..\Controls\DecoratedTextBox.xaml"              this.textBox1.LostFocus += new System.Windows.RoutedEventHandler(this.textBox1_LostFocus);                            #line default              #line hidden              return;              case 4:              this.TextBoxExtraBorderCompensation = ((System.Windows.Controls.Border)(target));              return;              case 5:              this.TextBoxBorderEquivalent = ((System.Windows.Controls.Border)(target));              return;              case 6:              this.placeholder = ((System.Windows.Controls.TextBlock)(target));              return;              }
Missing Default,Unclassified.UI,IconButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconButton.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this._this = ((Unclassified.UI.IconButton)(target));              return;              }
Missing Default,Unclassified.UI,IconToggleButton,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\IconToggleButton.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this._this = ((Unclassified.UI.IconToggleButton)(target));              return;              }
Missing Default,Unclassified.UI,ProgressSpinner,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\ProgressSpinner.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.MainGrid = ((System.Windows.Controls.Grid)(target));              return;              case 2:              this.MainGridRotateTransform = ((System.Windows.Media.RotateTransform)(target));              return;              }
Missing Default,Unclassified.UI,DateTimeTextBox,C:\repos\dg9ngf_TxTranslation\TxEditor\Unclassified\UI\DateTimeTextBox.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.YearText = ((System.Windows.Controls.TextBox)(target));                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 17 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 18 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 19 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.YearText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 2:              this.MonthText = ((System.Windows.Controls.TextBox)(target));                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 24 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 25 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 26 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MonthText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 3:              this.DayText = ((System.Windows.Controls.TextBox)(target));                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 31 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 32 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 33 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.DayText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 4:              this.HourText = ((System.Windows.Controls.TextBox)(target));                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 38 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 39 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 40 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.HourText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 5:              this.MinuteText = ((System.Windows.Controls.TextBox)(target));                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 45 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 46 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 47 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.MinuteText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 6:              this.SecondText = ((System.Windows.Controls.TextBox)(target));                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.GotFocus += new System.Windows.RoutedEventHandler(this.Text_GotFocus);                            #line default              #line hidden                            #line 52 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.LostFocus += new System.Windows.RoutedEventHandler(this.Text_LostFocus);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewKeyDown += new System.Windows.Input.KeyEventHandler(this.Text_PreviewKeyDown);                            #line default              #line hidden                            #line 53 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.PreviewTextInput += new System.Windows.Input.TextCompositionEventHandler(this.Text_PreviewTextInput);                            #line default              #line hidden                            #line 54 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              this.SecondText.AddHandler(System.Windows.DataObject.PastingEvent' new System.Windows.DataObjectPastingEventHandler(this.Text_Pasting));                            #line default              #line hidden              return;              case 7:                            #line 80 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.UpButton_Click);                            #line default              #line hidden              return;              case 8:                            #line 86 "..\..\..\..\..\Unclassified\UI\DateTimeTextBox.xaml"              ((System.Windows.Controls.Primitives.RepeatButton)(target)).Click += new System.Windows.RoutedEventHandler(this.DownButton_Click);                            #line default              #line hidden              return;              }
Missing Default,Unclassified.TxEditor.ViewModels,MainViewModel,C:\repos\dg9ngf_TxTranslation\TxEditor\ViewModels\MainViewModel.cs,TextKeyWizardFromHotKey2,The following switch statement is missing a default case: switch (fileExtension)  			{  				case ".aspx":  					win.SourceAspxButton.IsChecked = true;  					break;  				case ".cs":  					win.SourceCSharpButton.IsChecked = true;  					break;  				case ".cshtml":  					win.SourceCSharpButton.IsChecked = true;  					win.SourceHtmlButton.IsChecked = true;  					break;  				case ".xaml":  					win.SourceXamlButton.IsChecked = true;  					break;  			}
Missing Default,Unclassified.TxEditor.Views,DetailsMessage,C:\repos\dg9ngf_TxTranslation\TxEditor\Views\DetailsMessage.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.ArrowLeftIcon = ((System.Windows.Shapes.Path)(target));              return;              case 2:              this.ArrowUpIcon = ((System.Windows.Shapes.Path)(target));              return;              }
