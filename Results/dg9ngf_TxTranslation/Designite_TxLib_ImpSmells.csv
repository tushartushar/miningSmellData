Implementation smell,Namespace,Class,File,Method,Description
Long Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Time,The method has 173 lines of code.
Long Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The method has 155 lines of code.
Complex Method,Unclassified.TxLib,DateTimeInterval,C:\repos\dg9ngf_TxTranslation\TxLib\DateTimeInterval.cs,DateTimeInterval,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.TxLib,DateTimeInterval,C:\repos\dg9ngf_TxTranslation\TxLib\DateTimeInterval.cs,UpdateCountValues,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ReplaceSystemTexts,Cyclomatic complexity of the method is 9
Complex Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,Cyclomatic complexity of the method is 12
Complex Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Time,Cyclomatic complexity of the method is 18
Complex Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,Cyclomatic complexity of the method is 19
Complex Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,Cyclomatic complexity of the method is 16
Complex Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,Cyclomatic complexity of the method is 8
Complex Method,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCultureText,Cyclomatic complexity of the method is 12
Long Parameter List,Unclassified.TxLib,DateTimeInterval,C:\repos\dg9ngf_TxTranslation\TxLib\DateTimeInterval.cs,DateTimeInterval,The method has 7 parameters. Parameters: start' years' months' days' hours' minutes' seconds
Long Parameter List,Unclassified.TxLib,DateTimeInterval,C:\repos\dg9ngf_TxTranslation\TxLib\DateTimeInterval.cs,DateTimeInterval,The method has 8 parameters. Parameters: start' years' months' days' hours' minutes' seconds' milliseconds
Long Parameter List,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,AddText,The method has 5 parameters. Parameters: culture' key' count' modulo' text
Long Parameter List,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The method has 5 parameters. Parameters: text' key' count' data' usedPlaceholderNames
Long Identifier,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,,The length of the parameter LogFileEnvironmentVariableName is 30.
Long Identifier,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,,The length of the parameter LogUnusedEnvironmentVariableName is 32.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,reloadTimer_Callback,The length of the statement  "				System.Diagnostics.Trace.WriteLine("Unhandled " + ex.GetType().Name + " while reloading the dictionary files: " + ex.Message); " is 126.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Number,The length of the statement  "			string decSep = GetText(SystemKeys.NumberDecimalSeparator' false' CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator); " is 130.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Ordinal,The length of the statement  "				text = ResolveData(GetText(SystemKeys.NumberOrdinalFeminin' number' false' false)' SystemKeys.NumberOrdinalFeminin' number' (Dictionary<string' string>)null); " is 158.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Ordinal,The length of the statement  "				text = ResolveData(GetText(SystemKeys.NumberOrdinal' number' false' true)' SystemKeys.NumberOrdinal' number' (Dictionary<string' string>)null); " is 143.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Percent,The length of the statement  "			string decSep = GetText(SystemKeys.NumberDecimalSeparator' false' CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator); " is 130.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Time,The length of the statement  "				string dowAndDate = ResolveData(GetText(SystemKeys.DateDowWithDate' false' "{dow}' {date}")' SystemKeys.DateDowWithDate' -1' data); " is 131.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The length of the statement  "			long newEnd = (long)Math.Round((double)(end.Ticks - start.Ticks) / System.TimeSpan.TicksPerSecond) * System.TimeSpan.TicksPerSecond; " is 132.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The length of the statement  "			if ((interval.Years != 0 || interval.Months != 0 || interval.Days != 0 || interval.Hours != 0 || interval.Minutes != 0) && interval.Seconds <= 3) " is 145.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The length of the statement  "			if ((interval.Years != 0 || interval.Months != 0 || interval.Days != 0 || interval.Hours != 0) && interval.Minutes <= 3) " is 120.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The length of the statement  "				levels.Add(ResolveData(GetText(keys[4]' interval.Minutes)' keys[4]' interval.Minutes' (Dictionary<string' string>)null)); " is 121.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The length of the statement  "				levels.Add(ResolveData(GetText(keys[5]' interval.Seconds)' keys[5]' interval.Seconds' (Dictionary<string' string>)null)); " is 121.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The length of the statement  "											LogStack("Resolve data: Subcount placeholder name \"{0}\" resolves to value \"{1}\" which is not an integer. Ignoring count."' countName' countValue); " is 150.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCultureText,The length of the statement  "							LogStack("Get text: Text key \"{0}\" with quantifier in culture {1} was requested without a count value."' key' culture); " is 121.
Long Statement,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,LogStack,The length of the statement  "						stackTrace = Regex.Replace(stackTrace' @"\r?\n[^\r\n]+System\.RuntimeTypeHandle\.CreateInstance\(.*?$"' ""' RegexOptions.Singleline); " is 133.
Complex Conditional,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,NumberUnit,The conditional expression  "unit[0] == '°' || unit[0] == '′' || unit[0] == '″' || unit[0] == '"'"  is complex.
Complex Conditional,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The conditional expression  "(interval.Years != 0 || interval.Months != 0 || interval.Days != 0 || interval.Hours != 0 || interval.Minutes != 0) && interval.Seconds <= 3"  is complex.
Complex Conditional,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The conditional expression  "(interval.Years != 0 || interval.Months != 0 || interval.Days != 0 || interval.Hours != 0) && interval.Minutes <= 3"  is complex.
Complex Conditional,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The conditional expression  "(interval.Years != 0 || interval.Months != 0 || interval.Days != 0) && interval.Hours <= 1"  is complex.
Complex Conditional,Unclassified.TxLib,NConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The conditional expression  "values[1] is byte || values[1] is sbyte ||  					values[1] is ushort || values[1] is short ||  					values[1] is uint || values[1] is int ||  					values[1] is long"  is complex.
Empty Catch Block,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,CurrentDomain_ProcessExit,The method has an empty catch block.
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,LoadFromXmlFile,The following statement contains a magic number: using (new WriteLock(rwlock))  			{  				if (UseFileSystemWatcher)  				{  					// Monitor this file to automatically reload it when it is changed  					if (!fileWatchers.ContainsKey(fileName))  					{  						FileSystemWatcher fsw = new FileSystemWatcher(Path.GetDirectoryName(fileName)' Path.GetFileName(fileName));  						fsw.InternalBufferSize = 4096;   // Minimum possible value  						fsw.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Security | NotifyFilters.Size | NotifyFilters.FileName;  						fsw.Changed += fsw_Changed;  						fsw.Created += fsw_Changed;  						fsw.Renamed += fsw_Changed;  						fsw.EnableRaisingEvents = true;  						fileWatchers[fileName] = fsw;  					}  				}    				// Remember last write time of the file to be able to compare it later  				fileTimes[fileName] = new FileInfo(fileName).LastWriteTimeUtc;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,LoadFromXml,The following statement contains a magic number: using (new WriteLock(isGlobalDict ? rwlock : null))  			{  				// Get a reference to the specified language dictionary  				Dictionary<string' Dictionary<int' string>> language;  				if (!dict.TryGetValue(culture' out language))  				{  					language = new Dictionary<string' Dictionary<int' string>>();  					dict.Add(culture' language);  				}    				// Read the XML document  				foreach (XmlNode textNode in xe.SelectNodes("text[@key]"))  				{  					string text = textNode.InnerText;  					string key = textNode.Attributes["key"].Value;    					if (key == "")  					{  						Log("Load XML: Key attribute is empty. Ignoring definition.");  						continue;  					}    					int count = -1;  					XmlAttribute countAttr = textNode.Attributes["count"];  					if (countAttr != null)  					{  						if (!int.TryParse(countAttr.Value' out count))  						{  							// Count value unparsable. Skip invalid entries  							Log("Load XML: Count attribute value of key {0} is not an integer. Ignoring definition."' key);  							continue;  						}  						if (count < 0 || count > ushort.MaxValue)  						{  							// Count value out of range. Skip invalid entries  							Log("Load XML: Count attribute value of key {0} is out of range. Ignoring definition."' key);  							continue;  						}  					}    					int modulo = 0;  					XmlAttribute moduloAttr = textNode.Attributes["mod"];  					if (moduloAttr != null)  					{  						if (!int.TryParse(moduloAttr.Value' out modulo))  						{  							// Modulo value unparsable. Skip invalid entries  							Log("Load XML: Modulo attribute of key {0} is not an integer. Ignoring definition."' key);  							continue;  						}  						if (modulo < 2 || modulo > 1000)  						{  							// Modulo value out of range. Skip invalid entries  							Log("Load XML: Modulo attribute of key {0} is out of range. Ignoring definition."' key);  							continue;  						}  					}    					Dictionary<int' string> textItem;  					if (language.TryGetValue(key' out textItem))  					{  						// Key has already been read' add the new text item.  						// Existing text items are overwritten.  						if (count != -1 && modulo != 0)  						{  							// Encode the modulo value into the quantifier.  							count = (modulo << 16) | count;  						}  						textItem[count] = text;  					}  					else  					{  						// New key.  						textItem = new Dictionary<int' string>();  						textItem.Add(count' text);  						language.Add(key' textItem);  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,LoadFromXml,The following statement contains a magic number: using (new WriteLock(isGlobalDict ? rwlock : null))  			{  				// Get a reference to the specified language dictionary  				Dictionary<string' Dictionary<int' string>> language;  				if (!dict.TryGetValue(culture' out language))  				{  					language = new Dictionary<string' Dictionary<int' string>>();  					dict.Add(culture' language);  				}    				// Read the XML document  				foreach (XmlNode textNode in xe.SelectNodes("text[@key]"))  				{  					string text = textNode.InnerText;  					string key = textNode.Attributes["key"].Value;    					if (key == "")  					{  						Log("Load XML: Key attribute is empty. Ignoring definition.");  						continue;  					}    					int count = -1;  					XmlAttribute countAttr = textNode.Attributes["count"];  					if (countAttr != null)  					{  						if (!int.TryParse(countAttr.Value' out count))  						{  							// Count value unparsable. Skip invalid entries  							Log("Load XML: Count attribute value of key {0} is not an integer. Ignoring definition."' key);  							continue;  						}  						if (count < 0 || count > ushort.MaxValue)  						{  							// Count value out of range. Skip invalid entries  							Log("Load XML: Count attribute value of key {0} is out of range. Ignoring definition."' key);  							continue;  						}  					}    					int modulo = 0;  					XmlAttribute moduloAttr = textNode.Attributes["mod"];  					if (moduloAttr != null)  					{  						if (!int.TryParse(moduloAttr.Value' out modulo))  						{  							// Modulo value unparsable. Skip invalid entries  							Log("Load XML: Modulo attribute of key {0} is not an integer. Ignoring definition."' key);  							continue;  						}  						if (modulo < 2 || modulo > 1000)  						{  							// Modulo value out of range. Skip invalid entries  							Log("Load XML: Modulo attribute of key {0} is out of range. Ignoring definition."' key);  							continue;  						}  					}    					Dictionary<int' string> textItem;  					if (language.TryGetValue(key' out textItem))  					{  						// Key has already been read' add the new text item.  						// Existing text items are overwritten.  						if (count != -1 && modulo != 0)  						{  							// Encode the modulo value into the quantifier.  							count = (modulo << 16) | count;  						}  						textItem[count] = text;  					}  					else  					{  						// New key.  						textItem = new Dictionary<int' string>();  						textItem.Add(count' text);  						language.Add(key' textItem);  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,LoadFromXml,The following statement contains a magic number: using (new WriteLock(isGlobalDict ? rwlock : null))  			{  				// Get a reference to the specified language dictionary  				Dictionary<string' Dictionary<int' string>> language;  				if (!dict.TryGetValue(culture' out language))  				{  					language = new Dictionary<string' Dictionary<int' string>>();  					dict.Add(culture' language);  				}    				// Read the XML document  				foreach (XmlNode textNode in xe.SelectNodes("text[@key]"))  				{  					string text = textNode.InnerText;  					string key = textNode.Attributes["key"].Value;    					if (key == "")  					{  						Log("Load XML: Key attribute is empty. Ignoring definition.");  						continue;  					}    					int count = -1;  					XmlAttribute countAttr = textNode.Attributes["count"];  					if (countAttr != null)  					{  						if (!int.TryParse(countAttr.Value' out count))  						{  							// Count value unparsable. Skip invalid entries  							Log("Load XML: Count attribute value of key {0} is not an integer. Ignoring definition."' key);  							continue;  						}  						if (count < 0 || count > ushort.MaxValue)  						{  							// Count value out of range. Skip invalid entries  							Log("Load XML: Count attribute value of key {0} is out of range. Ignoring definition."' key);  							continue;  						}  					}    					int modulo = 0;  					XmlAttribute moduloAttr = textNode.Attributes["mod"];  					if (moduloAttr != null)  					{  						if (!int.TryParse(moduloAttr.Value' out modulo))  						{  							// Modulo value unparsable. Skip invalid entries  							Log("Load XML: Modulo attribute of key {0} is not an integer. Ignoring definition."' key);  							continue;  						}  						if (modulo < 2 || modulo > 1000)  						{  							// Modulo value out of range. Skip invalid entries  							Log("Load XML: Modulo attribute of key {0} is out of range. Ignoring definition."' key);  							continue;  						}  					}    					Dictionary<int' string> textItem;  					if (language.TryGetValue(key' out textItem))  					{  						// Key has already been read' add the new text item.  						// Existing text items are overwritten.  						if (count != -1 && modulo != 0)  						{  							// Encode the modulo value into the quantifier.  							count = (modulo << 16) | count;  						}  						textItem[count] = text;  					}  					else  					{  						// New key.  						textItem = new Dictionary<int' string>();  						textItem.Add(count' text);  						language.Add(key' textItem);  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,AddText,The following statement contains a magic number: if (modulo != 0 && (modulo < 2 || modulo > 1000))  			{  				throw new ArgumentOutOfRangeException("modulo"' "The modulo value must be in the range of 2 to 1000.");  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,AddText,The following statement contains a magic number: if (modulo != 0 && (modulo < 2 || modulo > 1000))  			{  				throw new ArgumentOutOfRangeException("modulo"' "The modulo value must be in the range of 2 to 1000.");  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,AddText,The following statement contains a magic number: using (new WriteLock(rwlock))  			{  				// Get a reference to the specified language dictionary  				Dictionary<string' Dictionary<int' string>> language;  				if (!languages.TryGetValue(culture' out language))  				{  					language = new Dictionary<string' Dictionary<int' string>>();  					languages.Add(culture' language);  				}    				Dictionary<int' string> textItem;  				if (language.TryGetValue(key' out textItem))  				{  					// Key is already defined' add the new text item.  					// Existing text items are overwritten.  					if (count != -1 && modulo != 0)  					{  						// Encode the modulo value into the quantifier.  						count = (modulo << 16) | count;  					}  					textItem[count] = text;  				}  				else  				{  					// New key.  					textItem = new Dictionary<int' string>();  					textItem.Add(count' text);  					language.Add(key' textItem);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,SetCulture,The following statement contains a magic number: if (ci.Name != CultureInfo.CurrentCulture.Name)  			{  				if (Environment.Version.Major < 4)  				{  					// Before .NET 4.0 the CurrentCulture could only be assigned a non-neutral  					// culture. Find the default culture in this case and use it instead.  					ci = new CultureInfo(ci.LCID | 0x0400);  				}  				Thread.CurrentThread.CurrentCulture = ci;  				RaiseDictionaryChanged();  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCultureName,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				foreach (string culture in GetCulturesToTry(3))  				{  					if (languages.ContainsKey(culture)) return culture;  				}  				// The dictionary is empty  				return null;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCulturesToTry,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				if ((stages & 1) != 0)  				{  					// First try with the current culture' if set.  					string cc = CultureInfo.CurrentCulture.Name;  					yield return cc;    					// If the culture name has a region set' try without it.  					if (cc.Length == 5)  					{  						yield return cc.Substring(0' 2);  					}  				}  				if ((stages & 2) != 0)  				{  					// Try other cultures' according to the preference set from the HTTP request header (cf. GetCultureName method)  					if (httpPreferredCultures != null)  					{  						for (int i = 0; i < httpPreferredCultures.Length; i++)  						{  							string cc2 = httpPreferredCultures[i];  							yield return cc2;    							// If the culture name has a region set AND the culture without a region is  							// not contained in the list of preferred cultures AND no other culture  							// with this language part is yet to come in the list of preferred  							// cultures' THEN try without the region now.  							if (cc2.Length == 5 &&  								Array.IndexOf(httpPreferredCultures' cc2.Substring(0' 2)) == -1)  							{  								bool found = false;  								for (int j = i + 1; j < httpPreferredCultures.Length; j++)  								{  									if (httpPreferredCultures[j].Substring(0' 2) == cc2.Substring(0' 2))  									{  										found = true;  										break;  									}  								}  								if (!found)  								{  									yield return cc2.Substring(0' 2);  								}  							}  						}  					}    					// Then try with the primary culture' if set.  					if (PrimaryCulture != null)  					{  						yield return PrimaryCulture;    						// If the culture name has a region set' try without it.  						if (PrimaryCulture.Length == 5)  						{  							yield return PrimaryCulture.Substring(0' 2);  						}  					}    					// Finally try every available language  					foreach (string cc2 in languages.Keys)  					{  						yield return cc2;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,SetWebCulture,The following statement contains a magic number: if (httpPreferredCultures.Length > 0)  			{  				// Set the current thread's culture to the most preferred one that is supported  				foreach (string culture in httpPreferredCultures)  				{  					if (languages.ContainsKey(culture) ||  						culture.Length == 5 && languages.ContainsKey(culture.Substring(0' 2)))  					{  						SetCulture(culture);  						return;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,SetWebCulture,The following statement contains a magic number: if (httpPreferredCultures.Length > 0)  			{  				// Set the current thread's culture to the most preferred one that is supported  				foreach (string culture in httpPreferredCultures)  				{  					if (languages.ContainsKey(culture) ||  						culture.Length == 5 && languages.ContainsKey(culture.Substring(0' 2)))  					{  						SetCulture(culture);  						return;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Number,The following statement contains a magic number: string numStr = Number(number' 29);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024)   // < 0.9 KiB -> "0 B"  				return NumberUnit(Number(bytes' 0)' byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024)   // < 0.9 KiB -> "0 B"  				return NumberUnit(Number(bytes' 0)' byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50 * 1024)   // < 50 KiB -> "0.0 KiB"  				return NumberUnit(Number((decimal)bytes / 1024' 1)' "Ki" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50 * 1024)   // < 50 KiB -> "0.0 KiB"  				return NumberUnit(Number((decimal)bytes / 1024' 1)' "Ki" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50 * 1024)   // < 50 KiB -> "0.0 KiB"  				return NumberUnit(Number((decimal)bytes / 1024' 1)' "Ki" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024)   // < 0.9 MiB -> "0 KiB"  				return NumberUnit(Number((decimal)bytes / 1024' 0)' "Ki" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024)   // < 0.9 MiB -> "0 KiB"  				return NumberUnit(Number((decimal)bytes / 1024' 0)' "Ki" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024)   // < 0.9 MiB -> "0 KiB"  				return NumberUnit(Number((decimal)bytes / 1024' 0)' "Ki" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024)   // < 0.9 MiB -> "0 KiB"  				return NumberUnit(Number((decimal)bytes / 1024' 0)' "Ki" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50 * 1024 * 1024)   // < 50 MiB -> "0.0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 1)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50 * 1024 * 1024)   // < 50 MiB -> "0.0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 1)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50 * 1024 * 1024)   // < 50 MiB -> "0.0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 1)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50 * 1024 * 1024)   // < 50 MiB -> "0.0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 1)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50 * 1024 * 1024)   // < 50 MiB -> "0.0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 1)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024)   // < 0.9 GiB -> "0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 0)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024)   // < 0.9 GiB -> "0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 0)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024)   // < 0.9 GiB -> "0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 0)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024)   // < 0.9 GiB -> "0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 0)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024)   // < 0.9 GiB -> "0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 0)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024)   // < 0.9 GiB -> "0 MiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024' 0)' "Mi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024)   // < 50 GiB -> "0.0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 1)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024)   // < 50 GiB -> "0.0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 1)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024)   // < 50 GiB -> "0.0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 1)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024)   // < 50 GiB -> "0.0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 1)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024)   // < 50 GiB -> "0.0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 1)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024)   // < 50 GiB -> "0.0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 1)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024)   // < 0.9 TiB -> "0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 0)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024)   // < 0.9 TiB -> "0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 0)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024)   // < 0.9 TiB -> "0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 0)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024)   // < 0.9 TiB -> "0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 0)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024)   // < 0.9 TiB -> "0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 0)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024)   // < 0.9 TiB -> "0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 0)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024)   // < 0.9 TiB -> "0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 0)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024)   // < 0.9 TiB -> "0 GiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024' 0)' "Gi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024)   // < 50 TiB -> "0.0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 1)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024)   // < 50 TiB -> "0.0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 1)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024)   // < 50 TiB -> "0.0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 1)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024)   // < 50 TiB -> "0.0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 1)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024)   // < 50 TiB -> "0.0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 1)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024)   // < 50 TiB -> "0.0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 1)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024)   // < 50 TiB -> "0.0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 1)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024)   // < 50 TiB -> "0.0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 1)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 PiB -> "0 TiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024' 0)' "Ti" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 50L * 1024 * 1024 * 1024 * 1024 * 1024)   // < 50 PiB -> "0.0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: if (absBytes < 0.9 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024)   // < 0.9 EiB -> "0 PiB"  				return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024' 0)' "Pi" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Ei" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Ei" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Ei" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Ei" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Ei" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,DataSize,The following statement contains a magic number: return NumberUnit(Number((decimal)bytes / 1024 / 1024 / 1024 / 1024 / 1024 / 1024' 1)' "Ei" + byteUnit);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Percent,The following statement contains a magic number: string numStr = Number(value' 29);
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Time,The following statement contains a magic number: switch (details & TxTime.AnyDate)  			{  				case TxTime.Year:  					dateFormat = GetText(SystemKeys.DateYear' false' "yyyy");  					break;  				case TxTime.YearMonth:  					dateFormat = GetText(SystemKeys.DateYearMonth' false' "yyyy-MM");  					break;  				case TxTime.YearMonthTab:  					dateFormat = GetText(SystemKeys.DateYearMonthTab' false' "yyyy-MM");  					break;  				case TxTime.YearMonthAbbr:  					dateFormat = GetText(SystemKeys.DateYearMonthAbbr' false' "MMM yyyy");  					break;  				case TxTime.YearMonthLong:  					dateFormat = GetText(SystemKeys.DateYearMonthLong' false' "Y");  					break;  				case TxTime.YearMonthDay:  					dateFormat = GetText(SystemKeys.DateYearMonthDay' false' "d");  					break;  				case TxTime.YearMonthDayTab:  					dateFormat = GetText(SystemKeys.DateYearMonthDayTab' false' "d");  					break;  				case TxTime.YearMonthDayAbbr:  					dateFormat = GetText(SystemKeys.DateYearMonthDayAbbr' false' "d MMM yyyy");  					break;  				case TxTime.YearMonthDayLong:  					dateFormat = GetText(SystemKeys.DateYearMonthDayLong' false' "d MMMM yyyy");  					break;  				case TxTime.Month:  					dateFormat = GetText(SystemKeys.DateMonth' false' "%M");  					break;  				case TxTime.MonthTab:  					dateFormat = GetText(SystemKeys.DateMonthTab' false' "MM");  					break;  				case TxTime.MonthAbbr:  					dateFormat = GetText(SystemKeys.DateMonthAbbr' false' "MMM");  					break;  				case TxTime.MonthLong:  					dateFormat = GetText(SystemKeys.DateMonthLong' false' "MMMM");  					break;  				case TxTime.MonthDay:  					dateFormat = GetText(SystemKeys.DateMonthDay' false' "MM-dd");  					break;  				case TxTime.MonthDayTab:  					dateFormat = GetText(SystemKeys.DateMonthDayTab' false' "MM-dd");  					break;  				case TxTime.MonthDayAbbr:  					dateFormat = GetText(SystemKeys.DateMonthDayAbbr' false' "d MMM");  					break;  				case TxTime.MonthDayLong:  					dateFormat = GetText(SystemKeys.DateMonthDayLong' false' "M");  					break;  				case TxTime.Day:  					dateFormat = GetText(SystemKeys.DateDay' false' "%d");  					break;  				case TxTime.DayTab:  					dateFormat = GetText(SystemKeys.DateDayTab' false' "dd");  					break;  				case TxTime.YearQuarter:  					if (returnFormat) return "?";   // This cannot be expressed as a date format  					data = new Dictionary<string' string>();  					data["year"] = time.Year.ToString();  					data["quarter"] = ((time.Month - 1) / 3 + 1).ToString();  					sb.Append(ResolveData(GetText(SystemKeys.DateYearQuarter' false' "Q{quarter}'/'{year}")' ""' -1' data));  					break;  				case TxTime.Quarter:  					if (returnFormat) return "?";   // This cannot be expressed as a date format  					data = new Dictionary<string' string>();  					data["quarter"] = ((time.Month - 1) / 3 + 1).ToString();  					sb.Append(ResolveData(GetText(SystemKeys.DateQuarter' false' "Q{quarter}")' ""' -1' data));  					break;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Time,The following statement contains a magic number: switch (details & TxTime.AnyDate)  			{  				case TxTime.Year:  					dateFormat = GetText(SystemKeys.DateYear' false' "yyyy");  					break;  				case TxTime.YearMonth:  					dateFormat = GetText(SystemKeys.DateYearMonth' false' "yyyy-MM");  					break;  				case TxTime.YearMonthTab:  					dateFormat = GetText(SystemKeys.DateYearMonthTab' false' "yyyy-MM");  					break;  				case TxTime.YearMonthAbbr:  					dateFormat = GetText(SystemKeys.DateYearMonthAbbr' false' "MMM yyyy");  					break;  				case TxTime.YearMonthLong:  					dateFormat = GetText(SystemKeys.DateYearMonthLong' false' "Y");  					break;  				case TxTime.YearMonthDay:  					dateFormat = GetText(SystemKeys.DateYearMonthDay' false' "d");  					break;  				case TxTime.YearMonthDayTab:  					dateFormat = GetText(SystemKeys.DateYearMonthDayTab' false' "d");  					break;  				case TxTime.YearMonthDayAbbr:  					dateFormat = GetText(SystemKeys.DateYearMonthDayAbbr' false' "d MMM yyyy");  					break;  				case TxTime.YearMonthDayLong:  					dateFormat = GetText(SystemKeys.DateYearMonthDayLong' false' "d MMMM yyyy");  					break;  				case TxTime.Month:  					dateFormat = GetText(SystemKeys.DateMonth' false' "%M");  					break;  				case TxTime.MonthTab:  					dateFormat = GetText(SystemKeys.DateMonthTab' false' "MM");  					break;  				case TxTime.MonthAbbr:  					dateFormat = GetText(SystemKeys.DateMonthAbbr' false' "MMM");  					break;  				case TxTime.MonthLong:  					dateFormat = GetText(SystemKeys.DateMonthLong' false' "MMMM");  					break;  				case TxTime.MonthDay:  					dateFormat = GetText(SystemKeys.DateMonthDay' false' "MM-dd");  					break;  				case TxTime.MonthDayTab:  					dateFormat = GetText(SystemKeys.DateMonthDayTab' false' "MM-dd");  					break;  				case TxTime.MonthDayAbbr:  					dateFormat = GetText(SystemKeys.DateMonthDayAbbr' false' "d MMM");  					break;  				case TxTime.MonthDayLong:  					dateFormat = GetText(SystemKeys.DateMonthDayLong' false' "M");  					break;  				case TxTime.Day:  					dateFormat = GetText(SystemKeys.DateDay' false' "%d");  					break;  				case TxTime.DayTab:  					dateFormat = GetText(SystemKeys.DateDayTab' false' "dd");  					break;  				case TxTime.YearQuarter:  					if (returnFormat) return "?";   // This cannot be expressed as a date format  					data = new Dictionary<string' string>();  					data["year"] = time.Year.ToString();  					data["quarter"] = ((time.Month - 1) / 3 + 1).ToString();  					sb.Append(ResolveData(GetText(SystemKeys.DateYearQuarter' false' "Q{quarter}'/'{year}")' ""' -1' data));  					break;  				case TxTime.Quarter:  					if (returnFormat) return "?";   // This cannot be expressed as a date format  					data = new Dictionary<string' string>();  					data["quarter"] = ((time.Month - 1) / 3 + 1).ToString();  					sb.Append(ResolveData(GetText(SystemKeys.DateQuarter' false' "Q{quarter}")' ""' -1' data));  					break;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Time,The following statement contains a magic number: if (returnFormat && sb.Length > 2)  				return sb.ToString().Replace("%"' "");
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,RelativeTime,The following statement contains a magic number: if (Math.Abs(interval.TimeSpan.TotalSeconds) <= 3)  			{  				return GetText(SystemKeys.TimeNow' -1) ?? NotFound(SystemKeys.TimeNow);  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,RelativeTime,The following statement contains a magic number: string[] keys = new string[6];
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,RelativeTime,The following statement contains a magic number: keys[2] = !interval.Negative ? SystemKeys.TimeRelativeDays : SystemKeys.TimeRelativeNegDays;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,RelativeTime,The following statement contains a magic number: keys[3] = !interval.Negative ? SystemKeys.TimeRelativeHours : SystemKeys.TimeRelativeNegHours;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,RelativeTime,The following statement contains a magic number: keys[4] = !interval.Negative ? SystemKeys.TimeRelativeMinutes : SystemKeys.TimeRelativeNegMinutes;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,RelativeTime,The following statement contains a magic number: keys[5] = !interval.Negative ? SystemKeys.TimeRelativeSeconds : SystemKeys.TimeRelativeNegSeconds;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpan,The following statement contains a magic number: string[] keys = new string[6];
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpan,The following statement contains a magic number: keys[2] = !interval.Negative ? SystemKeys.TimeSpanRelativeDays : SystemKeys.TimeSpanRelativeNegDays;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpan,The following statement contains a magic number: keys[3] = !interval.Negative ? SystemKeys.TimeSpanRelativeHours : SystemKeys.TimeSpanRelativeNegHours;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpan,The following statement contains a magic number: keys[4] = !interval.Negative ? SystemKeys.TimeSpanRelativeMinutes : SystemKeys.TimeSpanRelativeNegMinutes;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpan,The following statement contains a magic number: keys[5] = !interval.Negative ? SystemKeys.TimeSpanRelativeSeconds : SystemKeys.TimeSpanRelativeNegSeconds;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpanRaw,The following statement contains a magic number: string[] keys = new string[6];
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpanRaw,The following statement contains a magic number: keys[2] = !interval.Negative ? SystemKeys.TimeSpanDays : SystemKeys.TimeSpanNegDays;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpanRaw,The following statement contains a magic number: keys[3] = !interval.Negative ? SystemKeys.TimeSpanHours : SystemKeys.TimeSpanNegHours;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpanRaw,The following statement contains a magic number: keys[4] = !interval.Negative ? SystemKeys.TimeSpanMinutes : SystemKeys.TimeSpanNegMinutes;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,TimeSpanRaw,The following statement contains a magic number: keys[5] = !interval.Negative ? SystemKeys.TimeSpanSeconds : SystemKeys.TimeSpanNegSeconds;
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if ((interval.Years != 0 || interval.Months != 0 || interval.Days != 0 || interval.Hours != 0 || interval.Minutes != 0) && interval.Seconds <= 3)  			{  				interval.Seconds = 0;  			}  			else if (interval.Seconds >= 57)  			{  				interval.Minutes++;  				interval.Seconds = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if ((interval.Years != 0 || interval.Months != 0 || interval.Days != 0 || interval.Hours != 0 || interval.Minutes != 0) && interval.Seconds <= 3)  			{  				interval.Seconds = 0;  			}  			else if (interval.Seconds >= 57)  			{  				interval.Minutes++;  				interval.Seconds = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if ((interval.Years != 0 || interval.Months != 0 || interval.Days != 0 || interval.Hours != 0) && interval.Minutes <= 3)  			{  				interval.Minutes = 0;  			}  			else if (interval.Minutes >= 57)  			{  				interval.Hours++;  				interval.Minutes = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if ((interval.Years != 0 || interval.Months != 0 || interval.Days != 0 || interval.Hours != 0) && interval.Minutes <= 3)  			{  				interval.Minutes = 0;  			}  			else if (interval.Minutes >= 57)  			{  				interval.Hours++;  				interval.Minutes = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if ((interval.Years != 0 || interval.Months != 0 || interval.Days != 0) && interval.Hours <= 1)  			{  				interval.Hours = 0;  			}  			else if (interval.Hours >= 23)  			{  				interval.Days++;  				interval.Hours = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if ((interval.Years != 0 || interval.Months != 0) && interval.Days <= 2)  			{  				interval.Days = 0;  			}  			else if (interval.Days >= 28)  			{  				interval.Months++;  				interval.Days = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if ((interval.Years != 0 || interval.Months != 0) && interval.Days <= 2)  			{  				interval.Days = 0;  			}  			else if (interval.Days >= 28)  			{  				interval.Months++;  				interval.Days = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Years >= 5)  			{  				if (interval.Months >= 7)  					interval.Years++;  				interval.Months = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Years >= 5)  			{  				if (interval.Months >= 7)  					interval.Years++;  				interval.Months = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Months >= 5)  			{  				if (interval.Days >= 16)  					interval.Months++;  				interval.Days = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Months >= 5)  			{  				if (interval.Days >= 16)  					interval.Months++;  				interval.Days = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Days >= 5)  			{  				if (interval.Hours >= 12)  					interval.Days++;  				interval.Hours = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Days >= 5)  			{  				if (interval.Hours >= 12)  					interval.Days++;  				interval.Hours = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Hours >= 5)  			{  				if (interval.Minutes >= 30)  					interval.Hours++;  				interval.Minutes = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Hours >= 5)  			{  				if (interval.Minutes >= 30)  					interval.Hours++;  				interval.Minutes = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Minutes >= 5)  			{  				if (interval.Seconds >= 30)  					interval.Minutes++;  				interval.Seconds = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetRoundedInterval,The following statement contains a magic number: if (interval.Minutes >= 5)  			{  				if (interval.Seconds >= 30)  					interval.Minutes++;  				interval.Seconds = 0;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (levelCount == 1)  			{  				string suffix = singleSpecial ? ".single" : "";  				if (interval.Years > 0)  				{  					string text = GetText(keys[0] + suffix' interval.Years);  					if (text != null)  						return ResolveData(text' keys[0] + suffix' interval.Years' (Dictionary<string' string>)null);  				}  				else if (interval.Months > 0)  				{  					string text = GetText(keys[1] + suffix' interval.Months);  					if (text != null)  						return ResolveData(text' keys[1] + suffix' interval.Months' (Dictionary<string' string>)null);  				}  				else if (interval.Days > 0)  				{  					string text = GetText(keys[2] + suffix' interval.Days);  					if (text != null)  						return ResolveData(text' keys[2] + suffix' interval.Days' (Dictionary<string' string>)null);  				}  				else if (interval.Hours > 0)  				{  					string text = GetText(keys[3] + suffix' interval.Hours);  					if (text != null)  						return ResolveData(text' keys[3] + suffix' interval.Hours' (Dictionary<string' string>)null);  				}  				else if (interval.Minutes > 0)  				{  					string text = GetText(keys[4] + suffix' interval.Minutes);  					if (text != null)  						return ResolveData(text' keys[4] + suffix' interval.Minutes' (Dictionary<string' string>)null);  				}  				else if (interval.Seconds > 0)  				{  					string text = GetText(keys[5] + suffix' interval.Seconds);  					if (text != null)  						return ResolveData(text' keys[5] + suffix' interval.Seconds' (Dictionary<string' string>)null);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (levelCount == 1)  			{  				string suffix = singleSpecial ? ".single" : "";  				if (interval.Years > 0)  				{  					string text = GetText(keys[0] + suffix' interval.Years);  					if (text != null)  						return ResolveData(text' keys[0] + suffix' interval.Years' (Dictionary<string' string>)null);  				}  				else if (interval.Months > 0)  				{  					string text = GetText(keys[1] + suffix' interval.Months);  					if (text != null)  						return ResolveData(text' keys[1] + suffix' interval.Months' (Dictionary<string' string>)null);  				}  				else if (interval.Days > 0)  				{  					string text = GetText(keys[2] + suffix' interval.Days);  					if (text != null)  						return ResolveData(text' keys[2] + suffix' interval.Days' (Dictionary<string' string>)null);  				}  				else if (interval.Hours > 0)  				{  					string text = GetText(keys[3] + suffix' interval.Hours);  					if (text != null)  						return ResolveData(text' keys[3] + suffix' interval.Hours' (Dictionary<string' string>)null);  				}  				else if (interval.Minutes > 0)  				{  					string text = GetText(keys[4] + suffix' interval.Minutes);  					if (text != null)  						return ResolveData(text' keys[4] + suffix' interval.Minutes' (Dictionary<string' string>)null);  				}  				else if (interval.Seconds > 0)  				{  					string text = GetText(keys[5] + suffix' interval.Seconds);  					if (text != null)  						return ResolveData(text' keys[5] + suffix' interval.Seconds' (Dictionary<string' string>)null);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (levelCount == 1)  			{  				string suffix = singleSpecial ? ".single" : "";  				if (interval.Years > 0)  				{  					string text = GetText(keys[0] + suffix' interval.Years);  					if (text != null)  						return ResolveData(text' keys[0] + suffix' interval.Years' (Dictionary<string' string>)null);  				}  				else if (interval.Months > 0)  				{  					string text = GetText(keys[1] + suffix' interval.Months);  					if (text != null)  						return ResolveData(text' keys[1] + suffix' interval.Months' (Dictionary<string' string>)null);  				}  				else if (interval.Days > 0)  				{  					string text = GetText(keys[2] + suffix' interval.Days);  					if (text != null)  						return ResolveData(text' keys[2] + suffix' interval.Days' (Dictionary<string' string>)null);  				}  				else if (interval.Hours > 0)  				{  					string text = GetText(keys[3] + suffix' interval.Hours);  					if (text != null)  						return ResolveData(text' keys[3] + suffix' interval.Hours' (Dictionary<string' string>)null);  				}  				else if (interval.Minutes > 0)  				{  					string text = GetText(keys[4] + suffix' interval.Minutes);  					if (text != null)  						return ResolveData(text' keys[4] + suffix' interval.Minutes' (Dictionary<string' string>)null);  				}  				else if (interval.Seconds > 0)  				{  					string text = GetText(keys[5] + suffix' interval.Seconds);  					if (text != null)  						return ResolveData(text' keys[5] + suffix' interval.Seconds' (Dictionary<string' string>)null);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (levelCount == 1)  			{  				string suffix = singleSpecial ? ".single" : "";  				if (interval.Years > 0)  				{  					string text = GetText(keys[0] + suffix' interval.Years);  					if (text != null)  						return ResolveData(text' keys[0] + suffix' interval.Years' (Dictionary<string' string>)null);  				}  				else if (interval.Months > 0)  				{  					string text = GetText(keys[1] + suffix' interval.Months);  					if (text != null)  						return ResolveData(text' keys[1] + suffix' interval.Months' (Dictionary<string' string>)null);  				}  				else if (interval.Days > 0)  				{  					string text = GetText(keys[2] + suffix' interval.Days);  					if (text != null)  						return ResolveData(text' keys[2] + suffix' interval.Days' (Dictionary<string' string>)null);  				}  				else if (interval.Hours > 0)  				{  					string text = GetText(keys[3] + suffix' interval.Hours);  					if (text != null)  						return ResolveData(text' keys[3] + suffix' interval.Hours' (Dictionary<string' string>)null);  				}  				else if (interval.Minutes > 0)  				{  					string text = GetText(keys[4] + suffix' interval.Minutes);  					if (text != null)  						return ResolveData(text' keys[4] + suffix' interval.Minutes' (Dictionary<string' string>)null);  				}  				else if (interval.Seconds > 0)  				{  					string text = GetText(keys[5] + suffix' interval.Seconds);  					if (text != null)  						return ResolveData(text' keys[5] + suffix' interval.Seconds' (Dictionary<string' string>)null);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (levelCount == 1)  			{  				string suffix = singleSpecial ? ".single" : "";  				if (interval.Years > 0)  				{  					string text = GetText(keys[0] + suffix' interval.Years);  					if (text != null)  						return ResolveData(text' keys[0] + suffix' interval.Years' (Dictionary<string' string>)null);  				}  				else if (interval.Months > 0)  				{  					string text = GetText(keys[1] + suffix' interval.Months);  					if (text != null)  						return ResolveData(text' keys[1] + suffix' interval.Months' (Dictionary<string' string>)null);  				}  				else if (interval.Days > 0)  				{  					string text = GetText(keys[2] + suffix' interval.Days);  					if (text != null)  						return ResolveData(text' keys[2] + suffix' interval.Days' (Dictionary<string' string>)null);  				}  				else if (interval.Hours > 0)  				{  					string text = GetText(keys[3] + suffix' interval.Hours);  					if (text != null)  						return ResolveData(text' keys[3] + suffix' interval.Hours' (Dictionary<string' string>)null);  				}  				else if (interval.Minutes > 0)  				{  					string text = GetText(keys[4] + suffix' interval.Minutes);  					if (text != null)  						return ResolveData(text' keys[4] + suffix' interval.Minutes' (Dictionary<string' string>)null);  				}  				else if (interval.Seconds > 0)  				{  					string text = GetText(keys[5] + suffix' interval.Seconds);  					if (text != null)  						return ResolveData(text' keys[5] + suffix' interval.Seconds' (Dictionary<string' string>)null);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (levelCount == 1)  			{  				string suffix = singleSpecial ? ".single" : "";  				if (interval.Years > 0)  				{  					string text = GetText(keys[0] + suffix' interval.Years);  					if (text != null)  						return ResolveData(text' keys[0] + suffix' interval.Years' (Dictionary<string' string>)null);  				}  				else if (interval.Months > 0)  				{  					string text = GetText(keys[1] + suffix' interval.Months);  					if (text != null)  						return ResolveData(text' keys[1] + suffix' interval.Months' (Dictionary<string' string>)null);  				}  				else if (interval.Days > 0)  				{  					string text = GetText(keys[2] + suffix' interval.Days);  					if (text != null)  						return ResolveData(text' keys[2] + suffix' interval.Days' (Dictionary<string' string>)null);  				}  				else if (interval.Hours > 0)  				{  					string text = GetText(keys[3] + suffix' interval.Hours);  					if (text != null)  						return ResolveData(text' keys[3] + suffix' interval.Hours' (Dictionary<string' string>)null);  				}  				else if (interval.Minutes > 0)  				{  					string text = GetText(keys[4] + suffix' interval.Minutes);  					if (text != null)  						return ResolveData(text' keys[4] + suffix' interval.Minutes' (Dictionary<string' string>)null);  				}  				else if (interval.Seconds > 0)  				{  					string text = GetText(keys[5] + suffix' interval.Seconds);  					if (text != null)  						return ResolveData(text' keys[5] + suffix' interval.Seconds' (Dictionary<string' string>)null);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (levelCount == 1)  			{  				string suffix = singleSpecial ? ".single" : "";  				if (interval.Years > 0)  				{  					string text = GetText(keys[0] + suffix' interval.Years);  					if (text != null)  						return ResolveData(text' keys[0] + suffix' interval.Years' (Dictionary<string' string>)null);  				}  				else if (interval.Months > 0)  				{  					string text = GetText(keys[1] + suffix' interval.Months);  					if (text != null)  						return ResolveData(text' keys[1] + suffix' interval.Months' (Dictionary<string' string>)null);  				}  				else if (interval.Days > 0)  				{  					string text = GetText(keys[2] + suffix' interval.Days);  					if (text != null)  						return ResolveData(text' keys[2] + suffix' interval.Days' (Dictionary<string' string>)null);  				}  				else if (interval.Hours > 0)  				{  					string text = GetText(keys[3] + suffix' interval.Hours);  					if (text != null)  						return ResolveData(text' keys[3] + suffix' interval.Hours' (Dictionary<string' string>)null);  				}  				else if (interval.Minutes > 0)  				{  					string text = GetText(keys[4] + suffix' interval.Minutes);  					if (text != null)  						return ResolveData(text' keys[4] + suffix' interval.Minutes' (Dictionary<string' string>)null);  				}  				else if (interval.Seconds > 0)  				{  					string text = GetText(keys[5] + suffix' interval.Seconds);  					if (text != null)  						return ResolveData(text' keys[5] + suffix' interval.Seconds' (Dictionary<string' string>)null);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (levelCount == 1)  			{  				string suffix = singleSpecial ? ".single" : "";  				if (interval.Years > 0)  				{  					string text = GetText(keys[0] + suffix' interval.Years);  					if (text != null)  						return ResolveData(text' keys[0] + suffix' interval.Years' (Dictionary<string' string>)null);  				}  				else if (interval.Months > 0)  				{  					string text = GetText(keys[1] + suffix' interval.Months);  					if (text != null)  						return ResolveData(text' keys[1] + suffix' interval.Months' (Dictionary<string' string>)null);  				}  				else if (interval.Days > 0)  				{  					string text = GetText(keys[2] + suffix' interval.Days);  					if (text != null)  						return ResolveData(text' keys[2] + suffix' interval.Days' (Dictionary<string' string>)null);  				}  				else if (interval.Hours > 0)  				{  					string text = GetText(keys[3] + suffix' interval.Hours);  					if (text != null)  						return ResolveData(text' keys[3] + suffix' interval.Hours' (Dictionary<string' string>)null);  				}  				else if (interval.Minutes > 0)  				{  					string text = GetText(keys[4] + suffix' interval.Minutes);  					if (text != null)  						return ResolveData(text' keys[4] + suffix' interval.Minutes' (Dictionary<string' string>)null);  				}  				else if (interval.Seconds > 0)  				{  					string text = GetText(keys[5] + suffix' interval.Seconds);  					if (text != null)  						return ResolveData(text' keys[5] + suffix' interval.Seconds' (Dictionary<string' string>)null);  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Years > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[0]' interval.Years)' keys[0]' interval.Years' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Months > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[1]' interval.Months)' keys[1]' interval.Months' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Days > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[2]' interval.Days)' keys[2]' interval.Days' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Days > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[2]' interval.Days)' keys[2]' interval.Days' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Days > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[2]' interval.Days)' keys[2]' interval.Days' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Hours > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[3]' interval.Hours)' keys[3]' interval.Hours' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Hours > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[3]' interval.Hours)' keys[3]' interval.Hours' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Hours > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[3]' interval.Hours)' keys[3]' interval.Hours' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Minutes > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[4]' interval.Minutes)' keys[4]' interval.Minutes' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Minutes > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[4]' interval.Minutes)' keys[4]' interval.Minutes' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Minutes > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[4]' interval.Minutes)' keys[4]' interval.Minutes' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Seconds > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[5]' interval.Seconds)' keys[5]' interval.Seconds' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Seconds > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[5]' interval.Seconds)' keys[5]' interval.Seconds' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,FormatTimeInterval,The following statement contains a magic number: if (interval.Seconds > 0 && levels.Count < 2)  				levels.Add(ResolveData(GetText(keys[5]' interval.Seconds)' keys[5]' interval.Seconds' (Dictionary<string' string>)null));
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The following statement contains a magic number: if ((data.Length % 2) != 0)  			{  				LogStack("Resolve data: Uneven length of data arguments array. The last single item is ignored.");  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The following statement contains a magic number: if (data != null)  			{  				dataDict = new Dictionary<string' string>();  				int i = 0;  				while (i + 1 < data.Length)  				{  					string name = data[i];  					string value = data[i + 1];  					if (dataDict.ContainsKey(name))  					{  						LogStack("Resolve data: Duplicate placeholder name {0}."' name);  					}  					dataDict[name] = value;  					i += 2;  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				while (true)  				{  					// Skip if escape sequence  					if (text.Length > openBracePos + 1 && text[openBracePos + 1] == '{')  					{  						openBracePos++;  						result.Append('{');  					}  					else  					{  						int closeBracePos = text.IndexOf('}'' openBracePos + 1);  						if (closeBracePos == -1)  						{  							// No matching brace found' leave the rest as-is  							result.Append(text.Substring(openBracePos));  							break;  						}  						int braceLength = closeBracePos - openBracePos - 1;  						if (braceLength == 0)  						{  							// Empty braces' leave as-is  							result.Append("{}");  						}  						else if (braceLength == 1 && text[openBracePos + 1] == '#')  						{  							// Found a {#} placeholder' insert the count value  							if (count == -1)  							{  								LogStack("Resolve data: No count value or -1 specified for {{#}} placeholder in key \"{0}\"."' key);  							}  							result.Append(count.ToString());  						}  						else if (braceLength > 1 && text[openBracePos + 1] == '=')  						{  							// Found another text key inclusion {=...}' resolve that value  							string subkey;  							int subcount = -1;  							// Check for a count part  							int countPos = text.IndexOf('#'' openBracePos + 2' braceLength - 1);  							if (countPos == -1)  							{  								// No count value found' interpret everything as text key  								subkey = text.Substring(openBracePos + 2' braceLength - 1);  							}  							else  							{  								// Count value {=...#...} found  								subkey = text.Substring(openBracePos + 2' countPos - (openBracePos + 2));  								string countName = text.Substring(countPos + 1' closeBracePos - (countPos + 1));  								if (countName != "")  								{  									if (usedPlaceholderNames != null)  										usedPlaceholderNames.Add(countName);  									string countValue;  									if (data != null && data.TryGetValue(countName' out countValue))  									{  										if (!int.TryParse(countValue' NumberStyles.Integer' CultureInfo.InvariantCulture' out subcount))  										{  											// Reset value  											subcount = -1;  											LogStack("Resolve data: Subcount placeholder name \"{0}\" resolves to value \"{1}\" which is not an integer. Ignoring count."' countName' countValue);  										}  									}  									else  									{  										LogStack("Resolve data: Subcount placeholder name \"{0}\" is unset. Ignoring count."' countName);  									}  								}  								else  								{  									// Pass through the current count value  									subcount = count;  								}  							}  							// Resolve the subtext  							// (It doesn't matter which key is passed here as second argument  							// because it's not used in that call level anyway.)  							string subtext = ResolveData(GetText(subkey' subcount)' key' subcount' data' usedPlaceholderNames);  							if (subtext != null)  							{  								result.Append(subtext);  							}  							else  							{  								LogStack("Resolve data: Subkey text \"{0}\" is unset."' subkey);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						else  						{  							// Anything else is a placeholder name' insert its value  							string varName = text.Substring(openBracePos + 1' braceLength);  							if (usedPlaceholderNames != null)  								usedPlaceholderNames.Add(varName);  							string varValue;  							if (data != null && data.TryGetValue(varName' out varValue))  							{  								result.Append(varValue);  							}  							else  							{  								LogStack("Resolve data: Placeholder name \"{0}\" is unset."' varName);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						openBracePos = closeBracePos;  					}  					int nextBracePos = text.IndexOf('{'' openBracePos + 1);  					if (nextBracePos == -1)  					{  						// Nothing more found' append the remaining text  						result.Append(text.Substring(openBracePos + 1));  						break;  					}  					else if (nextBracePos > openBracePos + 1)  					{  						// Copy text between this and the next brace  						result.Append(text.Substring(openBracePos + 1' nextBracePos - (openBracePos + 1)));  					}  					openBracePos = nextBracePos;  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				while (true)  				{  					// Skip if escape sequence  					if (text.Length > openBracePos + 1 && text[openBracePos + 1] == '{')  					{  						openBracePos++;  						result.Append('{');  					}  					else  					{  						int closeBracePos = text.IndexOf('}'' openBracePos + 1);  						if (closeBracePos == -1)  						{  							// No matching brace found' leave the rest as-is  							result.Append(text.Substring(openBracePos));  							break;  						}  						int braceLength = closeBracePos - openBracePos - 1;  						if (braceLength == 0)  						{  							// Empty braces' leave as-is  							result.Append("{}");  						}  						else if (braceLength == 1 && text[openBracePos + 1] == '#')  						{  							// Found a {#} placeholder' insert the count value  							if (count == -1)  							{  								LogStack("Resolve data: No count value or -1 specified for {{#}} placeholder in key \"{0}\"."' key);  							}  							result.Append(count.ToString());  						}  						else if (braceLength > 1 && text[openBracePos + 1] == '=')  						{  							// Found another text key inclusion {=...}' resolve that value  							string subkey;  							int subcount = -1;  							// Check for a count part  							int countPos = text.IndexOf('#'' openBracePos + 2' braceLength - 1);  							if (countPos == -1)  							{  								// No count value found' interpret everything as text key  								subkey = text.Substring(openBracePos + 2' braceLength - 1);  							}  							else  							{  								// Count value {=...#...} found  								subkey = text.Substring(openBracePos + 2' countPos - (openBracePos + 2));  								string countName = text.Substring(countPos + 1' closeBracePos - (countPos + 1));  								if (countName != "")  								{  									if (usedPlaceholderNames != null)  										usedPlaceholderNames.Add(countName);  									string countValue;  									if (data != null && data.TryGetValue(countName' out countValue))  									{  										if (!int.TryParse(countValue' NumberStyles.Integer' CultureInfo.InvariantCulture' out subcount))  										{  											// Reset value  											subcount = -1;  											LogStack("Resolve data: Subcount placeholder name \"{0}\" resolves to value \"{1}\" which is not an integer. Ignoring count."' countName' countValue);  										}  									}  									else  									{  										LogStack("Resolve data: Subcount placeholder name \"{0}\" is unset. Ignoring count."' countName);  									}  								}  								else  								{  									// Pass through the current count value  									subcount = count;  								}  							}  							// Resolve the subtext  							// (It doesn't matter which key is passed here as second argument  							// because it's not used in that call level anyway.)  							string subtext = ResolveData(GetText(subkey' subcount)' key' subcount' data' usedPlaceholderNames);  							if (subtext != null)  							{  								result.Append(subtext);  							}  							else  							{  								LogStack("Resolve data: Subkey text \"{0}\" is unset."' subkey);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						else  						{  							// Anything else is a placeholder name' insert its value  							string varName = text.Substring(openBracePos + 1' braceLength);  							if (usedPlaceholderNames != null)  								usedPlaceholderNames.Add(varName);  							string varValue;  							if (data != null && data.TryGetValue(varName' out varValue))  							{  								result.Append(varValue);  							}  							else  							{  								LogStack("Resolve data: Placeholder name \"{0}\" is unset."' varName);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						openBracePos = closeBracePos;  					}  					int nextBracePos = text.IndexOf('{'' openBracePos + 1);  					if (nextBracePos == -1)  					{  						// Nothing more found' append the remaining text  						result.Append(text.Substring(openBracePos + 1));  						break;  					}  					else if (nextBracePos > openBracePos + 1)  					{  						// Copy text between this and the next brace  						result.Append(text.Substring(openBracePos + 1' nextBracePos - (openBracePos + 1)));  					}  					openBracePos = nextBracePos;  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				while (true)  				{  					// Skip if escape sequence  					if (text.Length > openBracePos + 1 && text[openBracePos + 1] == '{')  					{  						openBracePos++;  						result.Append('{');  					}  					else  					{  						int closeBracePos = text.IndexOf('}'' openBracePos + 1);  						if (closeBracePos == -1)  						{  							// No matching brace found' leave the rest as-is  							result.Append(text.Substring(openBracePos));  							break;  						}  						int braceLength = closeBracePos - openBracePos - 1;  						if (braceLength == 0)  						{  							// Empty braces' leave as-is  							result.Append("{}");  						}  						else if (braceLength == 1 && text[openBracePos + 1] == '#')  						{  							// Found a {#} placeholder' insert the count value  							if (count == -1)  							{  								LogStack("Resolve data: No count value or -1 specified for {{#}} placeholder in key \"{0}\"."' key);  							}  							result.Append(count.ToString());  						}  						else if (braceLength > 1 && text[openBracePos + 1] == '=')  						{  							// Found another text key inclusion {=...}' resolve that value  							string subkey;  							int subcount = -1;  							// Check for a count part  							int countPos = text.IndexOf('#'' openBracePos + 2' braceLength - 1);  							if (countPos == -1)  							{  								// No count value found' interpret everything as text key  								subkey = text.Substring(openBracePos + 2' braceLength - 1);  							}  							else  							{  								// Count value {=...#...} found  								subkey = text.Substring(openBracePos + 2' countPos - (openBracePos + 2));  								string countName = text.Substring(countPos + 1' closeBracePos - (countPos + 1));  								if (countName != "")  								{  									if (usedPlaceholderNames != null)  										usedPlaceholderNames.Add(countName);  									string countValue;  									if (data != null && data.TryGetValue(countName' out countValue))  									{  										if (!int.TryParse(countValue' NumberStyles.Integer' CultureInfo.InvariantCulture' out subcount))  										{  											// Reset value  											subcount = -1;  											LogStack("Resolve data: Subcount placeholder name \"{0}\" resolves to value \"{1}\" which is not an integer. Ignoring count."' countName' countValue);  										}  									}  									else  									{  										LogStack("Resolve data: Subcount placeholder name \"{0}\" is unset. Ignoring count."' countName);  									}  								}  								else  								{  									// Pass through the current count value  									subcount = count;  								}  							}  							// Resolve the subtext  							// (It doesn't matter which key is passed here as second argument  							// because it's not used in that call level anyway.)  							string subtext = ResolveData(GetText(subkey' subcount)' key' subcount' data' usedPlaceholderNames);  							if (subtext != null)  							{  								result.Append(subtext);  							}  							else  							{  								LogStack("Resolve data: Subkey text \"{0}\" is unset."' subkey);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						else  						{  							// Anything else is a placeholder name' insert its value  							string varName = text.Substring(openBracePos + 1' braceLength);  							if (usedPlaceholderNames != null)  								usedPlaceholderNames.Add(varName);  							string varValue;  							if (data != null && data.TryGetValue(varName' out varValue))  							{  								result.Append(varValue);  							}  							else  							{  								LogStack("Resolve data: Placeholder name \"{0}\" is unset."' varName);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						openBracePos = closeBracePos;  					}  					int nextBracePos = text.IndexOf('{'' openBracePos + 1);  					if (nextBracePos == -1)  					{  						// Nothing more found' append the remaining text  						result.Append(text.Substring(openBracePos + 1));  						break;  					}  					else if (nextBracePos > openBracePos + 1)  					{  						// Copy text between this and the next brace  						result.Append(text.Substring(openBracePos + 1' nextBracePos - (openBracePos + 1)));  					}  					openBracePos = nextBracePos;  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				while (true)  				{  					// Skip if escape sequence  					if (text.Length > openBracePos + 1 && text[openBracePos + 1] == '{')  					{  						openBracePos++;  						result.Append('{');  					}  					else  					{  						int closeBracePos = text.IndexOf('}'' openBracePos + 1);  						if (closeBracePos == -1)  						{  							// No matching brace found' leave the rest as-is  							result.Append(text.Substring(openBracePos));  							break;  						}  						int braceLength = closeBracePos - openBracePos - 1;  						if (braceLength == 0)  						{  							// Empty braces' leave as-is  							result.Append("{}");  						}  						else if (braceLength == 1 && text[openBracePos + 1] == '#')  						{  							// Found a {#} placeholder' insert the count value  							if (count == -1)  							{  								LogStack("Resolve data: No count value or -1 specified for {{#}} placeholder in key \"{0}\"."' key);  							}  							result.Append(count.ToString());  						}  						else if (braceLength > 1 && text[openBracePos + 1] == '=')  						{  							// Found another text key inclusion {=...}' resolve that value  							string subkey;  							int subcount = -1;  							// Check for a count part  							int countPos = text.IndexOf('#'' openBracePos + 2' braceLength - 1);  							if (countPos == -1)  							{  								// No count value found' interpret everything as text key  								subkey = text.Substring(openBracePos + 2' braceLength - 1);  							}  							else  							{  								// Count value {=...#...} found  								subkey = text.Substring(openBracePos + 2' countPos - (openBracePos + 2));  								string countName = text.Substring(countPos + 1' closeBracePos - (countPos + 1));  								if (countName != "")  								{  									if (usedPlaceholderNames != null)  										usedPlaceholderNames.Add(countName);  									string countValue;  									if (data != null && data.TryGetValue(countName' out countValue))  									{  										if (!int.TryParse(countValue' NumberStyles.Integer' CultureInfo.InvariantCulture' out subcount))  										{  											// Reset value  											subcount = -1;  											LogStack("Resolve data: Subcount placeholder name \"{0}\" resolves to value \"{1}\" which is not an integer. Ignoring count."' countName' countValue);  										}  									}  									else  									{  										LogStack("Resolve data: Subcount placeholder name \"{0}\" is unset. Ignoring count."' countName);  									}  								}  								else  								{  									// Pass through the current count value  									subcount = count;  								}  							}  							// Resolve the subtext  							// (It doesn't matter which key is passed here as second argument  							// because it's not used in that call level anyway.)  							string subtext = ResolveData(GetText(subkey' subcount)' key' subcount' data' usedPlaceholderNames);  							if (subtext != null)  							{  								result.Append(subtext);  							}  							else  							{  								LogStack("Resolve data: Subkey text \"{0}\" is unset."' subkey);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						else  						{  							// Anything else is a placeholder name' insert its value  							string varName = text.Substring(openBracePos + 1' braceLength);  							if (usedPlaceholderNames != null)  								usedPlaceholderNames.Add(varName);  							string varValue;  							if (data != null && data.TryGetValue(varName' out varValue))  							{  								result.Append(varValue);  							}  							else  							{  								LogStack("Resolve data: Placeholder name \"{0}\" is unset."' varName);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						openBracePos = closeBracePos;  					}  					int nextBracePos = text.IndexOf('{'' openBracePos + 1);  					if (nextBracePos == -1)  					{  						// Nothing more found' append the remaining text  						result.Append(text.Substring(openBracePos + 1));  						break;  					}  					else if (nextBracePos > openBracePos + 1)  					{  						// Copy text between this and the next brace  						result.Append(text.Substring(openBracePos + 1' nextBracePos - (openBracePos + 1)));  					}  					openBracePos = nextBracePos;  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				while (true)  				{  					// Skip if escape sequence  					if (text.Length > openBracePos + 1 && text[openBracePos + 1] == '{')  					{  						openBracePos++;  						result.Append('{');  					}  					else  					{  						int closeBracePos = text.IndexOf('}'' openBracePos + 1);  						if (closeBracePos == -1)  						{  							// No matching brace found' leave the rest as-is  							result.Append(text.Substring(openBracePos));  							break;  						}  						int braceLength = closeBracePos - openBracePos - 1;  						if (braceLength == 0)  						{  							// Empty braces' leave as-is  							result.Append("{}");  						}  						else if (braceLength == 1 && text[openBracePos + 1] == '#')  						{  							// Found a {#} placeholder' insert the count value  							if (count == -1)  							{  								LogStack("Resolve data: No count value or -1 specified for {{#}} placeholder in key \"{0}\"."' key);  							}  							result.Append(count.ToString());  						}  						else if (braceLength > 1 && text[openBracePos + 1] == '=')  						{  							// Found another text key inclusion {=...}' resolve that value  							string subkey;  							int subcount = -1;  							// Check for a count part  							int countPos = text.IndexOf('#'' openBracePos + 2' braceLength - 1);  							if (countPos == -1)  							{  								// No count value found' interpret everything as text key  								subkey = text.Substring(openBracePos + 2' braceLength - 1);  							}  							else  							{  								// Count value {=...#...} found  								subkey = text.Substring(openBracePos + 2' countPos - (openBracePos + 2));  								string countName = text.Substring(countPos + 1' closeBracePos - (countPos + 1));  								if (countName != "")  								{  									if (usedPlaceholderNames != null)  										usedPlaceholderNames.Add(countName);  									string countValue;  									if (data != null && data.TryGetValue(countName' out countValue))  									{  										if (!int.TryParse(countValue' NumberStyles.Integer' CultureInfo.InvariantCulture' out subcount))  										{  											// Reset value  											subcount = -1;  											LogStack("Resolve data: Subcount placeholder name \"{0}\" resolves to value \"{1}\" which is not an integer. Ignoring count."' countName' countValue);  										}  									}  									else  									{  										LogStack("Resolve data: Subcount placeholder name \"{0}\" is unset. Ignoring count."' countName);  									}  								}  								else  								{  									// Pass through the current count value  									subcount = count;  								}  							}  							// Resolve the subtext  							// (It doesn't matter which key is passed here as second argument  							// because it's not used in that call level anyway.)  							string subtext = ResolveData(GetText(subkey' subcount)' key' subcount' data' usedPlaceholderNames);  							if (subtext != null)  							{  								result.Append(subtext);  							}  							else  							{  								LogStack("Resolve data: Subkey text \"{0}\" is unset."' subkey);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						else  						{  							// Anything else is a placeholder name' insert its value  							string varName = text.Substring(openBracePos + 1' braceLength);  							if (usedPlaceholderNames != null)  								usedPlaceholderNames.Add(varName);  							string varValue;  							if (data != null && data.TryGetValue(varName' out varValue))  							{  								result.Append(varValue);  							}  							else  							{  								LogStack("Resolve data: Placeholder name \"{0}\" is unset."' varName);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						openBracePos = closeBracePos;  					}  					int nextBracePos = text.IndexOf('{'' openBracePos + 1);  					if (nextBracePos == -1)  					{  						// Nothing more found' append the remaining text  						result.Append(text.Substring(openBracePos + 1));  						break;  					}  					else if (nextBracePos > openBracePos + 1)  					{  						// Copy text between this and the next brace  						result.Append(text.Substring(openBracePos + 1' nextBracePos - (openBracePos + 1)));  					}  					openBracePos = nextBracePos;  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,ResolveData,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				while (true)  				{  					// Skip if escape sequence  					if (text.Length > openBracePos + 1 && text[openBracePos + 1] == '{')  					{  						openBracePos++;  						result.Append('{');  					}  					else  					{  						int closeBracePos = text.IndexOf('}'' openBracePos + 1);  						if (closeBracePos == -1)  						{  							// No matching brace found' leave the rest as-is  							result.Append(text.Substring(openBracePos));  							break;  						}  						int braceLength = closeBracePos - openBracePos - 1;  						if (braceLength == 0)  						{  							// Empty braces' leave as-is  							result.Append("{}");  						}  						else if (braceLength == 1 && text[openBracePos + 1] == '#')  						{  							// Found a {#} placeholder' insert the count value  							if (count == -1)  							{  								LogStack("Resolve data: No count value or -1 specified for {{#}} placeholder in key \"{0}\"."' key);  							}  							result.Append(count.ToString());  						}  						else if (braceLength > 1 && text[openBracePos + 1] == '=')  						{  							// Found another text key inclusion {=...}' resolve that value  							string subkey;  							int subcount = -1;  							// Check for a count part  							int countPos = text.IndexOf('#'' openBracePos + 2' braceLength - 1);  							if (countPos == -1)  							{  								// No count value found' interpret everything as text key  								subkey = text.Substring(openBracePos + 2' braceLength - 1);  							}  							else  							{  								// Count value {=...#...} found  								subkey = text.Substring(openBracePos + 2' countPos - (openBracePos + 2));  								string countName = text.Substring(countPos + 1' closeBracePos - (countPos + 1));  								if (countName != "")  								{  									if (usedPlaceholderNames != null)  										usedPlaceholderNames.Add(countName);  									string countValue;  									if (data != null && data.TryGetValue(countName' out countValue))  									{  										if (!int.TryParse(countValue' NumberStyles.Integer' CultureInfo.InvariantCulture' out subcount))  										{  											// Reset value  											subcount = -1;  											LogStack("Resolve data: Subcount placeholder name \"{0}\" resolves to value \"{1}\" which is not an integer. Ignoring count."' countName' countValue);  										}  									}  									else  									{  										LogStack("Resolve data: Subcount placeholder name \"{0}\" is unset. Ignoring count."' countName);  									}  								}  								else  								{  									// Pass through the current count value  									subcount = count;  								}  							}  							// Resolve the subtext  							// (It doesn't matter which key is passed here as second argument  							// because it's not used in that call level anyway.)  							string subtext = ResolveData(GetText(subkey' subcount)' key' subcount' data' usedPlaceholderNames);  							if (subtext != null)  							{  								result.Append(subtext);  							}  							else  							{  								LogStack("Resolve data: Subkey text \"{0}\" is unset."' subkey);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						else  						{  							// Anything else is a placeholder name' insert its value  							string varName = text.Substring(openBracePos + 1' braceLength);  							if (usedPlaceholderNames != null)  								usedPlaceholderNames.Add(varName);  							string varValue;  							if (data != null && data.TryGetValue(varName' out varValue))  							{  								result.Append(varValue);  							}  							else  							{  								LogStack("Resolve data: Placeholder name \"{0}\" is unset."' varName);  								result.Append(text.Substring(openBracePos' braceLength + 2));  							}  						}  						openBracePos = closeBracePos;  					}  					int nextBracePos = text.IndexOf('{'' openBracePos + 1);  					if (nextBracePos == -1)  					{  						// Nothing more found' append the remaining text  						result.Append(text.Substring(openBracePos + 1));  						break;  					}  					else if (nextBracePos > openBracePos + 1)  					{  						// Copy text between this and the next brace  						result.Append(text.Substring(openBracePos + 1' nextBracePos - (openBracePos + 1)));  					}  					openBracePos = nextBracePos;  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetText,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				string firstCulture = null;  				foreach (string culture in GetCulturesToTry(1))  				{  					string text = GetCultureText(culture' key' count);  					if (text != null)  					{  						if (globalMode == TxMode.UnicodeTest || threadMode == TxMode.UnicodeTest)  						{  							text = GetUnicodeTestString(text);  						}  						return text;  					}  					if (firstCulture == null) firstCulture = culture;  				}  				if (!useFallback)  				{  					if (logMissing)  					{  						Log("Get text: Text key \"{0}\" is unset for culture {1}. Fallback cultures will NOT be used."'  							key'  							firstCulture.Length == 5 ? firstCulture + " and " + firstCulture.Substring(0' 2) : firstCulture);  					}  					return null;  				}    				foreach (string culture in GetCulturesToTry(2))  				{  					string text = GetCultureText(culture' key' count);  					if (text != null)  					{  						if (globalMode == TxMode.UnicodeTest || threadMode == TxMode.UnicodeTest)  						{  							text = GetUnicodeTestString(text);  						}  						return text;  					}  				}  				// Nothing found' return null  				Log("Get text: Text key \"{0}\" is unset for ALL cultures."' key);  				return null;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetText,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				string firstCulture = null;  				foreach (string culture in GetCulturesToTry(1))  				{  					string text = GetCultureText(culture' key' count);  					if (text != null)  					{  						if (globalMode == TxMode.UnicodeTest || threadMode == TxMode.UnicodeTest)  						{  							text = GetUnicodeTestString(text);  						}  						return text;  					}  					if (firstCulture == null) firstCulture = culture;  				}  				if (!useFallback)  				{  					if (logMissing)  					{  						Log("Get text: Text key \"{0}\" is unset for culture {1}. Fallback cultures will NOT be used."'  							key'  							firstCulture.Length == 5 ? firstCulture + " and " + firstCulture.Substring(0' 2) : firstCulture);  					}  					return null;  				}    				foreach (string culture in GetCulturesToTry(2))  				{  					string text = GetCultureText(culture' key' count);  					if (text != null)  					{  						if (globalMode == TxMode.UnicodeTest || threadMode == TxMode.UnicodeTest)  						{  							text = GetUnicodeTestString(text);  						}  						return text;  					}  				}  				// Nothing found' return null  				Log("Get text: Text key \"{0}\" is unset for ALL cultures."' key);  				return null;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetText,The following statement contains a magic number: using (new ReadLock(rwlock))  			{  				string firstCulture = null;  				foreach (string culture in GetCulturesToTry(1))  				{  					string text = GetCultureText(culture' key' count);  					if (text != null)  					{  						if (globalMode == TxMode.UnicodeTest || threadMode == TxMode.UnicodeTest)  						{  							text = GetUnicodeTestString(text);  						}  						return text;  					}  					if (firstCulture == null) firstCulture = culture;  				}  				if (!useFallback)  				{  					if (logMissing)  					{  						Log("Get text: Text key \"{0}\" is unset for culture {1}. Fallback cultures will NOT be used."'  							key'  							firstCulture.Length == 5 ? firstCulture + " and " + firstCulture.Substring(0' 2) : firstCulture);  					}  					return null;  				}    				foreach (string culture in GetCulturesToTry(2))  				{  					string text = GetCultureText(culture' key' count);  					if (text != null)  					{  						if (globalMode == TxMode.UnicodeTest || threadMode == TxMode.UnicodeTest)  						{  							text = GetUnicodeTestString(text);  						}  						return text;  					}  				}  				// Nothing found' return null  				Log("Get text: Text key \"{0}\" is unset for ALL cultures."' key);  				return null;  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCultureText,The following statement contains a magic number: if (languages.TryGetValue(culture' out language))  			{  				// Find the text key within that dictionary  				Dictionary<int' string> textItem;  				if (language.TryGetValue(key' out textItem))  				{  					string text;  					if (count > -1)  					{  						// A count value is specified' search for a matching text value.  						// First try a direct match  						if (textItem.TryGetValue(count' out text))  						{  							return text;  						}  						// Then test all available quantifiers (except -1).  						// First collect all defined quantifiers  						List<int> quantifiers = new List<int>();  						foreach (KeyValuePair<int' string> kvp in textItem)  						{  							if (kvp.Key != -1)  							{  								quantifiers.Add(kvp.Key);  							}  						}  						// Then sort them by value  						quantifiers.Sort();  						// And evaluate them' the greatest value first' then decreasing.  						// (Greatest modulo values are most specific and need to be considered first.  						// Since the modulo value is encoded in the higher bits' this can be compared  						// normally.)  						for (int i = quantifiers.Count - 1; i >= 0; i--)  						{  							int q = quantifiers[i];  							int c = q & 0xFFFF;  							int mod = (q >> 16) & 0xFFFF;  							if (mod >= 2 && c == count % mod)  							{  								return textItem[q];  							}  						}  					}  					else if (usedKeys != null)  					{  						// No count value is specified and unused logging is active.  						// Check whether the text key has quantifiers defined.  						if (textItem.Count > 1 || !textItem.ContainsKey(-1))  						{  							LogStack("Get text: Text key \"{0}\" with quantifier in culture {1} was requested without a count value."' key' culture);  						}  					}  					// Try the generic form if nothing was found by now  					if (textItem.TryGetValue(-1' out text))  					{  						return text;  					}  				}  			}
Magic Number,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,GetCultureText,The following statement contains a magic number: if (languages.TryGetValue(culture' out language))  			{  				// Find the text key within that dictionary  				Dictionary<int' string> textItem;  				if (language.TryGetValue(key' out textItem))  				{  					string text;  					if (count > -1)  					{  						// A count value is specified' search for a matching text value.  						// First try a direct match  						if (textItem.TryGetValue(count' out text))  						{  							return text;  						}  						// Then test all available quantifiers (except -1).  						// First collect all defined quantifiers  						List<int> quantifiers = new List<int>();  						foreach (KeyValuePair<int' string> kvp in textItem)  						{  							if (kvp.Key != -1)  							{  								quantifiers.Add(kvp.Key);  							}  						}  						// Then sort them by value  						quantifiers.Sort();  						// And evaluate them' the greatest value first' then decreasing.  						// (Greatest modulo values are most specific and need to be considered first.  						// Since the modulo value is encoded in the higher bits' this can be compared  						// normally.)  						for (int i = quantifiers.Count - 1; i >= 0; i--)  						{  							int q = quantifiers[i];  							int c = q & 0xFFFF;  							int mod = (q >> 16) & 0xFFFF;  							if (mod >= 2 && c == count % mod)  							{  								return textItem[q];  							}  						}  					}  					else if (usedKeys != null)  					{  						// No count value is specified and unused logging is active.  						// Check whether the text key has quantifiers defined.  						if (textItem.Count > 1 || !textItem.ContainsKey(-1))  						{  							LogStack("Get text: Text key \"{0}\" with quantifier in culture {1} was requested without a count value."' key' culture);  						}  					}  					// Try the generic form if nothing was found by now  					if (textItem.TryGetValue(-1' out text))  					{  						return text;  					}  				}  			}
Magic Number,Unclassified.TxLib,UpgradeableReadLock,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,UpgradeableReadLock,The following statement contains a magic number: if (!wasLocked && !rwlock.TryEnterUpgradeableReadLock((ReadLockTimeout + WriteLockTimeout) / 2))  				{  					throw new InvalidOperationException("The upgradeable reader lock could not be acquired.");  				}
Magic Number,Unclassified.TxLib,TxDictionaryBinding,C:\repos\dg9ngf_TxTranslation\TxLib\TxWinForms.cs,AddTextBindings,The following statement contains a magic number: if (control.Text.Length > 2 && control.Text.StartsWith("[") && control.Text.EndsWith("]"))  			{  				string key = control.Text.Substring(1' control.Text.Length - 2);  				AddBinding(control' "Text"' key);  			}
Magic Number,Unclassified.TxLib,TxDictionaryBinding,C:\repos\dg9ngf_TxTranslation\TxLib\TxWinForms.cs,AddTextBindings,The following statement contains a magic number: if (control.Text.Length > 2 && control.Text.StartsWith("[") && control.Text.EndsWith("]"))  			{  				string key = control.Text.Substring(1' control.Text.Length - 2);  				AddBinding(control' "Text"' key);  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Magic Number,Unclassified.TxLib,TimeConverter,C:\repos\dg9ngf_TxTranslation\TxLib\TxXaml.cs,Convert,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(new DependencyObject()))  			{  				switch (relKind)  				{  					case RelativeTimeKind.None:  						text = Tx.Time(DateTime.Now' details);  						break;  					case RelativeTimeKind.PointInTime:  						text = Tx.RelativeTime(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						text = Tx.TimeSpan(DateTime.Now.AddHours(2).AddMinutes(34));  						break;  					case RelativeTimeKind.TimeSpan:  						text = Tx.TimeSpan(TimeSpan.FromHours(2) + TimeSpan.FromMinutes(34));  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}  			else  			{  				// values[0] is the dictionary Dummy binding' don't use it  				// values[1] is the timer Dummy binding' don't use it    				// Read the time value from binding number three.  				if (values[2] == DependencyProperty.UnsetValue)  				{  					return DependencyProperty.UnsetValue;  				}  				DateTime dt;  				TimeSpan ts;  				switch (relKind)  				{  					case RelativeTimeKind.None:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.Time(dt' details);  						break;  					case RelativeTimeKind.PointInTime:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.RelativeTime(dt);  						break;  					case RelativeTimeKind.CurrentTimeSpan:  						dt = System.Convert.ToDateTime(values[2]);  						text = Tx.TimeSpan(dt);  						break;  					case RelativeTimeKind.TimeSpan:  						if (values[2] is TimeSpan)  						{  							ts = (TimeSpan)values[2];  							text = Tx.TimeSpan(ts);  						}  						else  						{  							text = "";  						}  						break;  					default:  						text = "{Error: Invalid relKind}";   // Should not happen  						break;  				}  			}
Missing Default,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Time,The following switch statement is missing a default case: switch (details & TxTime.AnyDate)  			{  				case TxTime.Year:  					dateFormat = GetText(SystemKeys.DateYear' false' "yyyy");  					break;  				case TxTime.YearMonth:  					dateFormat = GetText(SystemKeys.DateYearMonth' false' "yyyy-MM");  					break;  				case TxTime.YearMonthTab:  					dateFormat = GetText(SystemKeys.DateYearMonthTab' false' "yyyy-MM");  					break;  				case TxTime.YearMonthAbbr:  					dateFormat = GetText(SystemKeys.DateYearMonthAbbr' false' "MMM yyyy");  					break;  				case TxTime.YearMonthLong:  					dateFormat = GetText(SystemKeys.DateYearMonthLong' false' "Y");  					break;  				case TxTime.YearMonthDay:  					dateFormat = GetText(SystemKeys.DateYearMonthDay' false' "d");  					break;  				case TxTime.YearMonthDayTab:  					dateFormat = GetText(SystemKeys.DateYearMonthDayTab' false' "d");  					break;  				case TxTime.YearMonthDayAbbr:  					dateFormat = GetText(SystemKeys.DateYearMonthDayAbbr' false' "d MMM yyyy");  					break;  				case TxTime.YearMonthDayLong:  					dateFormat = GetText(SystemKeys.DateYearMonthDayLong' false' "d MMMM yyyy");  					break;  				case TxTime.Month:  					dateFormat = GetText(SystemKeys.DateMonth' false' "%M");  					break;  				case TxTime.MonthTab:  					dateFormat = GetText(SystemKeys.DateMonthTab' false' "MM");  					break;  				case TxTime.MonthAbbr:  					dateFormat = GetText(SystemKeys.DateMonthAbbr' false' "MMM");  					break;  				case TxTime.MonthLong:  					dateFormat = GetText(SystemKeys.DateMonthLong' false' "MMMM");  					break;  				case TxTime.MonthDay:  					dateFormat = GetText(SystemKeys.DateMonthDay' false' "MM-dd");  					break;  				case TxTime.MonthDayTab:  					dateFormat = GetText(SystemKeys.DateMonthDayTab' false' "MM-dd");  					break;  				case TxTime.MonthDayAbbr:  					dateFormat = GetText(SystemKeys.DateMonthDayAbbr' false' "d MMM");  					break;  				case TxTime.MonthDayLong:  					dateFormat = GetText(SystemKeys.DateMonthDayLong' false' "M");  					break;  				case TxTime.Day:  					dateFormat = GetText(SystemKeys.DateDay' false' "%d");  					break;  				case TxTime.DayTab:  					dateFormat = GetText(SystemKeys.DateDayTab' false' "dd");  					break;  				case TxTime.YearQuarter:  					if (returnFormat) return "?";   // This cannot be expressed as a date format  					data = new Dictionary<string' string>();  					data["year"] = time.Year.ToString();  					data["quarter"] = ((time.Month - 1) / 3 + 1).ToString();  					sb.Append(ResolveData(GetText(SystemKeys.DateYearQuarter' false' "Q{quarter}'/'{year}")' ""' -1' data));  					break;  				case TxTime.Quarter:  					if (returnFormat) return "?";   // This cannot be expressed as a date format  					data = new Dictionary<string' string>();  					data["quarter"] = ((time.Month - 1) / 3 + 1).ToString();  					sb.Append(ResolveData(GetText(SystemKeys.DateQuarter' false' "Q{quarter}")' ""' -1' data));  					break;  			}
Missing Default,Unclassified.TxLib,Tx,C:\repos\dg9ngf_TxTranslation\TxLib\Tx.cs,Time,The following switch statement is missing a default case: switch (details & TxTime.AnyTime)  				{  					case TxTime.HourMinuteSecondMs:  						timeFormat = GetText(SystemKeys.TimeHourMinuteSecondMs' false' "H:mm:ss.fff");  						break;  					case TxTime.HourMinuteSecondMsTab:  						timeFormat = GetText(SystemKeys.TimeHourMinuteSecondMsTab' false' "HH:mm:ss.fff");  						break;  					case TxTime.HourMinuteSecond:  						timeFormat = GetText(SystemKeys.TimeHourMinuteSecond' false' "T");  						break;  					case TxTime.HourMinuteSecondTab:  						timeFormat = GetText(SystemKeys.TimeHourMinuteSecondTab' false' "T");  						break;  					case TxTime.HourMinute:  						timeFormat = GetText(SystemKeys.TimeHourMinute' false' "t");  						break;  					case TxTime.HourMinuteTab:  						timeFormat = GetText(SystemKeys.TimeHourMinuteTab' false' "t");  						break;  					case TxTime.Hour:  						timeFormat = GetText(SystemKeys.TimeHour' false' "%H");  						break;  					case TxTime.HourTab:  						timeFormat = GetText(SystemKeys.TimeHourTab' false' "HH");  						break;  				}
