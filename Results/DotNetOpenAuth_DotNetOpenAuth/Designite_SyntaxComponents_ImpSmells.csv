Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteOperatorSyntax,The method has 110 lines of code.
Long Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WritePropertySyntax,The method has 103 lines of code.
Long Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteOperatorSyntax,The method has 107 lines of code.
Long Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteOperatorSyntax,The method has 118 lines of code.
Long Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteOperatorSyntax,The method has 131 lines of code.
Long Method,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The method has 177 lines of code.
Complex Method,Microsoft.Ddue.Tools,AspNetSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\AspNetSyntax.cs,WriteSyntax,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteGenericTemplates,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteBaseClassAndImplementedInterfaces,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteParameters,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteProcedureModifiers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteBaseClassAndImplementedInterfaces,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteGenericTemplateConstraints,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteDotNetObject,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteGenericTemplateConstraints,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteProcedureModifiers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,CreateCamelCaseName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteClassSyntax,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteNormalMethodSyntax,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 34
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteProcedureModifiers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteGenericTemplates,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteFieldSyntax,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 34
Complex Method,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,LoadConfiguration,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 16
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiIsSerializableTypeExpression is 31.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiImplementedInterfacesExpression is 34.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiVisibilityOfMemberExpression is 31.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiIsSerializedFieldExpression is 30.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiIsAbstractProcedureExpression is 32.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiIsExplicitImplementationExpression is 37.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiImplementedMembersExpression is 31.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter parameterIsParamArrayExpression is 31.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiContainingTypeNameExpression is 31.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiContainingTypeSubgroupExpression is 35.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiContainingAssemblyExpression is 31.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiContainingNamespaceIdExpression is 34.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter apiContainingNamespaceNameExpression is 36.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter specializationArgumentsExpression is 33.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter attributeAssignmentsExpression is 30.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter templateIsConstrainedExpression is 31.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter templateIsReferenceTypeExpression is 33.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter templateIsConstructableExpression is 33.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter templateIsContravariantExpression is 33.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter attachedEventRemoverExpression is 30.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter attachedPropertyGetterExpression is 32.
Long Identifier,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,,The length of the parameter attachedPropertySetterExpression is 32.
Long Identifier,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,,The length of the parameter hasTypeConverterAttributeExpression is 35.
Long Identifier,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,,The length of the parameter hasDefaultConstructorExpression is 31.
Long Identifier,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,,The length of the parameter ancestorContentPropertyIdExpression is 35.
Long Identifier,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,,The length of the parameter noSettablePropertiesExpression is 30.
Long Statement,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteNormalMethodSyntax,The length of the statement  "            bool isVirtual = (bool)reflection.Evaluate(apiIsVirtualExpression) && !(bool)reflection.Evaluate(apiIsAbstractProcedureExpression); " is 131.
Long Statement,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WritePropertySyntax,The length of the statement  "            bool isVirtual = (bool)reflection.Evaluate(apiIsVirtualExpression) && !(bool)reflection.Evaluate(apiIsAbstractProcedureExpression); " is 131.
Long Statement,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteEventSyntax,The length of the statement  "            bool isVirtual = (bool)reflection.Evaluate(apiIsVirtualExpression) && !(bool)reflection.Evaluate(apiIsAbstractProcedureExpression); " is 131.
Long Statement,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,CreateCamelCaseName,The length of the statement  "                return name.Substring(0' conversionLength - 1).ToLower(CultureInfo.InvariantCulture) + name.Substring(conversionLength - 1); " is 124.
Long Statement,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The length of the statement  "						template = reflection.SelectSingleNode( String.Format("containers/container[@type]/templates/template[{0}]"' position) ); " is 121.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,ParseDocuments,The length of the statement  "            //WriteMessage(MessageLevel.Info' String.Format("XamlUsageSyntaxGenerator: Searching for files that match '{0}'."' filterFiles)); " is 129.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,ParseDocument,The length of the statement  "                throw new ConfigurationErrorsException(string.Format("Exception parsing XamlUsageSyntaxGenerator filter file: {0}. Exception message: {1}"' file' e.Message)); " is 158.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WritePropertySyntax,The length of the statement  "            bool returnTypeIsReadonlyStruct = (returnTypeSubgroup == "structure" && notWriteableReturnType && !IsPrimitiveType(returnTypeId)); " is 130.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WritePropertySyntax,The length of the statement  "            else if ((bool)containingType.Evaluate(apiIsAbstractTypeExpression) && (bool)containingType.Evaluate(apiIsSealedTypeExpression)) " is 128.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,IsContentProperty,The length of the statement  "            string propertyId = string.Concat("P:"' namespaceId.Substring(2)' "."' string.Concat(containingTypeName' "."' propertyName)); " is 125.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,IsPrimitiveType,The length of the statement  "            // The primitive types are Boolean' Byte' SByte' Int16' UInt16' Int32' UInt32' Int64' UInt64' IntPtr' Char' Double' and Single. " is 127.
Complex Conditional,Microsoft.Ddue.Tools,AspNetSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\AspNetSyntax.cs,WebControlPrefix,The conditional expression  "(space == "N:System.Web.UI") && ((name == "Page") || (name == "ScriptControl") || (name == "UserControl"))"  is complex.
Complex Conditional,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WritePropertySyntax,The conditional expression  "string.IsNullOrEmpty(getVisibility) || (getVisibility != "assembly" &&                       getVisibility != "private" && getVisibility != "family and assembly")"  is complex.
Complex Conditional,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WritePropertySyntax,The conditional expression  "string.IsNullOrEmpty(setVisibility) || (setVisibility != "assembly" &&                      setVisibility != "private" && setVisibility != "family and assembly")"  is complex.
Magic Number,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteNormalMethodSyntax,The following statement contains a magic number: int iterations = isVirtual ? 2 : 1;
Magic Number,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WritePropertySyntax,The following statement contains a magic number: int iterations = isVirtual ? 2 : 1;
Magic Number,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteEventSyntax,The following statement contains a magic number: int iterations = isVirtual ? 2 : 1;
Magic Number,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteNormalTypeReference,The following statement contains a magic number: string name = api.Substring(2);
Magic Number,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteAttachedPropertySyntax,The following statement contains a magic number: string propertyName = String.Format("{0}.{1}"' typeName' methodName.Substring(3));
Magic Number,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The following statement contains a magic number: int position = Convert.ToInt32( reference.Substring(4) ) + 1;
Magic Number,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The following statement contains a magic number: reference[3]=='`'
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name)                  {                      // unary math operators                      case "UnaryPlus":                          identifier = "+";                          type = -1;                          break;                      case "UnaryNegation":                          identifier = "-";                          type = -1;                          break;                      case "Increment":                          identifier = "++";                          type = +1;                          break;                      case "Decrement":                          identifier = "--";                          type = +1;                          break;                      // unary logical operators                      case "LogicalNot":                          identifier = "Not";                          type = -1;                          break;                      case "True":                          identifier = "IsTrue";                          type = -1;                          break;                      case "False":                          identifier = "IsFalse";                          type = -1;                          break;                      // binary comparison operators                      case "Equality":                          identifier = "=";                          type = 2;                          break;                      case "Inequality":                          identifier = "<>";                          type = 2;                          break;                      case "LessThan":                          identifier = "<";                          type = 2;                          break;                      case "GreaterThan":                          identifier = ">";                          type = 2;                          break;                      case "LessThanOrEqual":                          identifier = "<=";                          type = 2;                          break;                      case "GreaterThanOrEqual":                          identifier = ">=";                          type = 2;                          break;                      // binary math operators                      case "Addition":                          identifier = "+";                          type = 2;                          break;                      case "Subtraction":                          identifier = "-";                          type = 2;                          break;                      case "Multiply":                          identifier = "*";                          type = 2;                          break;                      case "Division":                          identifier = "/";                          type = 2;                          break;                      case "Exponent":                          identifier = "^";                          type = 2;                          break;                      case "Modulus":                          identifier = "Mod";                          type = 2;                          break;                      case "IntegerDivision":                          identifier = @"\";                          type = 2;                          break;                      // binary logical operators                      case "BitwiseAnd":                          identifier = "And";                          type = 2;                          break;                      case "BitwiseOr":                          identifier = "Or";                          type = 2;                          break;                      case "ExclusiveOr":                          identifier = "Xor";                          type = 2;                          break;                      // bit-array operators                      case "OnesComplement":                          identifier = "~";                          type = -1;                          break;                      case "LeftShift":                          identifier = "<<";                          type = 2;                          break;                      case "RightShift":                          identifier = ">>";                          type = 2;                          break;                      // concatenation                      case "Concatenate":                          identifier = "&";                          type = 2;                          break;                      case "Assign":                          identifier = "=";                          type = 2;                          break;                          // didn't recognize an operator                      default:                          identifier = null;                          type = 0;                          break;                  }
Magic Number,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,IsContentProperty,The following statement contains a magic number: string propertyId = string.Concat("P:"' namespaceId.Substring(2)' "."' string.Concat(containingTypeName' "."' propertyName));
Missing Default,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  				case "public":  					writer.WriteKeyword("public");  				break;  				case "family":  					writer.WriteKeyword("protected");  				break;  				case "family or assembly":  					writer.WriteKeyword("protected public");  				break;  				case "family and assembly":  					writer.WriteKeyword("protected private");  				break;  				case "assembly":  					writer.WriteKeyword("internal");  				break;  				case "private":  					writer.WriteKeyword("private");  				break;  			}
Missing Default,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  				case "arrayOf":  					XPathNavigator element = reference.SelectSingleNode(typeExpression);  					int rank = Convert.ToInt32( reference.GetAttribute("rank"'String.Empty) );  					writer.WriteKeyword("array");  					writer.WriteString("<");  					WriteTypeReference(element' writer);  					if (rank > 1) {  						writer.WriteString("'");  						writer.WriteString(rank.ToString());  					}  					writer.WriteString(">");  					if (handle) writer.WriteString("^");  				break;  				case "pointerTo":  					XPathNavigator pointee = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(pointee' writer);  					writer.WriteString("*");  				break;  				case "referenceTo":  					XPathNavigator referee = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(referee' writer);  					writer.WriteString("%");  				break;  				case "type":  					string id = reference.GetAttribute("api"' String.Empty);  					bool isRef = (reference.GetAttribute("ref"' String.Empty) == "true");  					WriteNormalTypeReference(id' writer);  					XPathNodeIterator typeModifiers = reference.Select(typeModifiersExpression);  					while (typeModifiers.MoveNext()) {  						WriteTypeReference(typeModifiers.Current' writer);  					}  					if (handle && isRef) writer.WriteString("^");  					  				break;  				case "template":  					string name = reference.GetAttribute("name"' String.Empty);  					writer.WriteString(name);  					XPathNodeIterator modifiers = reference.Select(typeModifiersExpression);  					while (modifiers.MoveNext()) {  						WriteTypeReference(modifiers.Current' writer);  					}  				break;  				case "specialization":  					writer.WriteString("<");  					XPathNodeIterator arguments = reference.Select(specializationArgumentsExpression);  					while (arguments.MoveNext()) {  						if (arguments.CurrentPosition > 1) writer.WriteString("' ");  						WriteTypeReference(arguments.Current' writer);  					}  					writer.WriteString(">");  				break;  			}
Missing Default,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  				case "nullValue":  					writer.WriteKeyword("nullptr");  				break;  				case "typeValue":  					writer.WriteKeyword("typeof");  					writer.WriteString("(");  					WriteTypeReference(value.SelectSingleNode(typeExpression)' false' writer);  					writer.WriteString(")");  				break;  				case "enumValue":  					XPathNodeIterator fields = value.SelectChildren(XPathNodeType.Element);  					while (fields.MoveNext()) {  						string name = fields.Current.GetAttribute("name"' String.Empty);  						if (fields.CurrentPosition > 1) writer.WriteString("|");  						WriteTypeReference(type' writer);  						writer.WriteString("::");  						writer.WriteString(name);  					}  				break;  				case "value":  					string text = value.Value;  					string typeId = type.GetAttribute("api"' String.Empty);  					switch (typeId) {  						case "T:System.String":  							writer.WriteString("L\"");  							writer.WriteString(text);  							writer.WriteString("\"");  						break;  						case "T:System.Boolean":  							bool bool_value = Convert.ToBoolean(text);  							if (bool_value) {  								writer.WriteKeyword("true");  							} else {  								writer.WriteKeyword("false");  							}  						break;  						case "T:System.Char":  							writer.WriteString(@"L'");  							writer.WriteString(text);  							writer.WriteString(@"'");  						break;  					}  				break;  			}
Missing Default,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  						case "T:System.String":  							writer.WriteString("L\"");  							writer.WriteString(text);  							writer.WriteString("\"");  						break;  						case "T:System.Boolean":  							bool bool_value = Convert.ToBoolean(text);  							if (bool_value) {  								writer.WriteKeyword("true");  							} else {  								writer.WriteKeyword("false");  							}  						break;  						case "T:System.Char":  							writer.WriteString(@"L'");  							writer.WriteString(text);  							writer.WriteString(@"'");  						break;  					}
Missing Default,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  				case "public":  					writer.WriteKeyword("public");  				break;  				case "family":  					writer.WriteKeyword("protected");  				break;  				case "family or assembly":  					writer.WriteKeyword("protected internal");  				break;  				case "assembly":  					writer.WriteKeyword("internal");  				break;  				case "private":  					writer.WriteKeyword("private");  				break;                  case "family and assembly":                      // this isn't handled in C#                  break;  			}
Missing Default,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  				case "nullValue":  					writer.WriteKeyword("null");  				break;  				case "typeValue":  					writer.WriteKeyword("typeof");  					writer.WriteString("(");  					WriteTypeReference(value.SelectSingleNode(typeExpression)' writer);  					writer.WriteString(")");  				break;  				case "enumValue":  					XPathNodeIterator fields = value.SelectChildren(XPathNodeType.Element);  					while (fields.MoveNext()) {  						string name = fields.Current.GetAttribute("name"' String.Empty);  						if (fields.CurrentPosition > 1) writer.WriteString("|");  						WriteTypeReference(type' writer);  						writer.WriteString(".");  						writer.WriteString(name);  					}  				break;  				case "value":  					string text = value.Value;  					string typeId = type.GetAttribute("api"' String.Empty);  					switch (typeId) {  						case "T:System.String":  							writer.WriteString("\"");  							writer.WriteString(text);  							writer.WriteString("\"");  						break;  						case "T:System.Boolean":  							bool bool_value = Convert.ToBoolean(text);  							if (bool_value) {  								writer.WriteKeyword("true");  							} else {  								writer.WriteKeyword("false");  							}  						break;  						case "T:System.Char":  							writer.WriteString("'");  							writer.WriteString(text);  							writer.WriteString("'");  						break;  					}  				break;  			}
Missing Default,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  						case "T:System.String":  							writer.WriteString("\"");  							writer.WriteString(text);  							writer.WriteString("\"");  						break;  						case "T:System.Boolean":  							bool bool_value = Convert.ToBoolean(text);  							if (bool_value) {  								writer.WriteKeyword("true");  							} else {  								writer.WriteKeyword("false");  							}  						break;  						case "T:System.Char":  							writer.WriteString("'");  							writer.WriteString(text);  							writer.WriteString("'");  						break;  					}
Missing Default,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  				case "arrayOf":  					int rank = Convert.ToInt32( reference.GetAttribute("rank"'String.Empty) );  					XPathNavigator element = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(element' writer);  					writer.WriteString("[");  					for (int i=1; i<rank; i++) { writer.WriteString("'"); }  					writer.WriteString("]");  				break;  				case "pointerTo":  					XPathNavigator pointee = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(pointee' writer);  					writer.WriteString("*");  				break;  				case "referenceTo":  					XPathNavigator referee = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(referee' writer);  				break;  				case "type":  					string id = reference.GetAttribute("api"' String.Empty);  					WriteNormalTypeReference(id' writer);  					XPathNodeIterator typeModifiers = reference.Select(typeModifiersExpression);  					while (typeModifiers.MoveNext()) {  						WriteTypeReference(typeModifiers.Current' writer);  					}  				break;  				case "template":  					string name = reference.GetAttribute("name"' String.Empty);  					writer.WriteString(name);  					XPathNodeIterator modifiers = reference.Select(typeModifiersExpression);  					while (modifiers.MoveNext()) {  						WriteTypeReference(modifiers.Current' writer);  					}  				break;  				case "specialization":  					writer.WriteString("<");  					XPathNodeIterator arguments = reference.Select(specializationArgumentsExpression);  					while (arguments.MoveNext()) {  						if (arguments.CurrentPosition > 1) writer.WriteString("' ");  						WriteTypeReference(arguments.Current' writer);  					}  					writer.WriteString(">");  				break;  			}
Missing Default,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName)              {                  case "nullValue":                      writer.WriteKeyword("null");                      break;                  case "typeValue":                      writer.WriteKeyword("typeof");                      writer.WriteString("(");                      WriteTypeReference(value.SelectSingleNode(typeExpression)' writer);                      writer.WriteString(")");                      break;                  case "enumValue":                      XPathNodeIterator fields = value.SelectChildren(XPathNodeType.Element);                      while (fields.MoveNext())                      {                          string name = fields.Current.GetAttribute("name"' String.Empty);                          if (fields.CurrentPosition > 1) writer.WriteString("|");                          WriteTypeReference(type' writer);                          writer.WriteString(".");                          writer.WriteString(name);                      }                      break;                  case "value":                      string text = value.Value;                      string typeId = type.GetAttribute("api"' String.Empty);                      switch (typeId)                      {                          case "T:System.String":                              writer.WriteString("\"");                              writer.WriteString(text);                              writer.WriteString("\"");                              break;                          case "T:System.Boolean":                              bool bool_value = Convert.ToBoolean(text);                              if (bool_value)                              {                                  writer.WriteKeyword("true");                              }                              else                              {                                  writer.WriteKeyword("false");                              }                              break;                          case "T:System.Char":                              writer.WriteString("'");                              writer.WriteString(text);                              writer.WriteString("'");                              break;                      }                      break;              }
Missing Default,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId)                      {                          case "T:System.String":                              writer.WriteString("\"");                              writer.WriteString(text);                              writer.WriteString("\"");                              break;                          case "T:System.Boolean":                              bool bool_value = Convert.ToBoolean(text);                              if (bool_value)                              {                                  writer.WriteKeyword("true");                              }                              else                              {                                  writer.WriteKeyword("false");                              }                              break;                          case "T:System.Char":                              writer.WriteString("'");                              writer.WriteString(text);                              writer.WriteString("'");                              break;                      }
Missing Default,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName)              {                  case "arrayOf":                      int rank = Convert.ToInt32(reference.GetAttribute("rank"' String.Empty));                      XPathNavigator element = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(element' writer);                      writer.WriteString("[");                      for (int i = 1; i < rank; i++) { writer.WriteString("'"); }                      writer.WriteString("]");                      break;                  case "pointerTo":                      XPathNavigator pointee = reference.SelectSingleNode(typeExpression);                      writer.WriteKeyword("nativeptr");                      writer.WriteString("<");                      WriteTypeReference(pointee' writer);                      writer.WriteString(">");                      break;                  case "referenceTo":                      XPathNavigator referee = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(referee' writer);                      break;                  case "type":                      string id = reference.GetAttribute("api"' String.Empty);                      WriteNormalTypeReference(id' writer);                      XPathNodeIterator typeModifiers = reference.Select(typeModifiersExpression);                      while (typeModifiers.MoveNext())                      {                          WriteTypeReference(typeModifiers.Current' writer);                      }                      break;                  case "template":                      string name = reference.GetAttribute("name"' String.Empty);                      writer.WriteString("'");                      writer.WriteString(name);                      XPathNodeIterator modifiers = reference.Select(typeModifiersExpression);                      while (modifiers.MoveNext())                      {                          WriteTypeReference(modifiers.Current' writer);                      }                      break;                  case "specialization":                      writer.WriteString("<");                      XPathNodeIterator arguments = reference.Select(specializationArgumentsExpression);                      while (arguments.MoveNext())                      {                          if (arguments.CurrentPosition > 1) writer.WriteString("' ");                          WriteTypeReference(arguments.Current' writer);                      }                      writer.WriteString(">");                      break;              }
Missing Default,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteAccessModifier,The following switch statement is missing a default case: switch (visibility) {                  case "public":                      writer.WriteKeyword("public");                      break;                  case "family":                      writer.WriteKeyword("protected");                      break;                  case "family or assembly":                      // this isn't handled in JScript                      break;                  case "assembly":                      writer.WriteKeyword("internal");                      break;                  case "private":                      writer.WriteKeyword("private");                      break;                  case "family and assembly":                      // this isn't handled in JScript                      break;              }
Missing Default,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {                  case "arrayOf":                      int rank = Convert.ToInt32(reference.GetAttribute("rank"' String.Empty));                      XPathNavigator element = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(element' writer);                      writer.WriteString("[");                      for (int i = 1; i < rank; i++) { writer.WriteString("'"); }                      writer.WriteString("]");                      break;                  case "pointerTo":                      XPathNavigator pointee = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(pointee' writer);                      writer.WriteString("*");                      break;                  case "referenceTo":                      XPathNavigator referee = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(referee' writer);                      break;                  case "type":                      string id = reference.GetAttribute("api"' String.Empty);                      WriteNormalTypeReference(id' writer);                      XPathNodeIterator typeModifiers = reference.Select(typeModifiersExpression);                      while (typeModifiers.MoveNext()) {                          WriteTypeReference(typeModifiers.Current' writer);                      }                      break;                  case "template":                      string name = reference.GetAttribute("name"' String.Empty);                      writer.WriteString(name);                      XPathNodeIterator modifiers = reference.Select(typeModifiersExpression);                      while (modifiers.MoveNext()) {                          WriteTypeReference(modifiers.Current' writer);                      }                      break;                  case "specialization":                      writer.WriteString("<");                      XPathNodeIterator arguments = reference.Select(specializationArgumentsExpression);                      while (arguments.MoveNext()) {                          if (arguments.CurrentPosition > 1) writer.WriteString("' ");                          WriteTypeReference(arguments.Current' writer);                      }                      writer.WriteString(">");                      break;              }
Missing Default,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {                  case "public":                      writer.WriteKeyword("public");                      break;                  case "family":                      writer.WriteKeyword("protected");                      break;                  case "family or assembly":                      // this isn't handled in JScript                      break;                  case "assembly":                      writer.WriteKeyword("internal");                      break;                  case "private":                      writer.WriteKeyword("private");                      break;                  case "family and assembly":                      // this isn't handled in JScript                      break;              }
Missing Default,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  				case "public":  					writer.WriteKeyword("public");  				break;  				case "family":  					// in Java' protected = family or assembly  					writer.WriteKeyword("protected");  				break;  				case "family or assembly":  					writer.WriteKeyword("protected");  				break;  				case "assembly":  					// no assembly-only access in Java  				break;  				case "private":  					writer.WriteKeyword("private");  				break;  			}
Missing Default,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  				case "nullValue":  					writer.WriteKeyword("null");  				break;  				case "typeValue":  					// this isn't really supported in J#; there is no compile-time way to get a type representation  					// writer.WriteKeyword("typeof");  					// writer.WriteString("(");  					WriteTypeReference(value.SelectSingleNode(typeExpression)' writer);  					// writer.WriteString(")");  				break;  				case "enumValue":  					XPathNodeIterator fields = value.SelectChildren(XPathNodeType.Element);  					while (fields.MoveNext()) {  						string name = fields.Current.GetAttribute("name"' String.Empty);  						if (fields.CurrentPosition > 1) writer.WriteString("|");  						WriteTypeReference(type' writer);  						writer.WriteString(".");  						writer.WriteString(name);  					}  				break;  				case "value":  					string text = value.Value;  					string typeId = type.GetAttribute("api"' String.Empty);  					switch (typeId) {  						case "T:System.String":  							writer.WriteString("\"");  							writer.WriteString(text);  							writer.WriteString("\"");  						break;  						case "T:System.Boolean":  							bool bool_value = Convert.ToBoolean(text);  							if (bool_value) {  								writer.WriteKeyword("true");  							} else {  								writer.WriteKeyword("false");  							}  						break;  						case "T:System.Char":  							writer.WriteString("'");  							writer.WriteString(text);  							writer.WriteString("'");  						break;  					}  				break;  			}
Missing Default,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  						case "T:System.String":  							writer.WriteString("\"");  							writer.WriteString(text);  							writer.WriteString("\"");  						break;  						case "T:System.Boolean":  							bool bool_value = Convert.ToBoolean(text);  							if (bool_value) {  								writer.WriteKeyword("true");  							} else {  								writer.WriteKeyword("false");  							}  						break;  						case "T:System.Char":  							writer.WriteString("'");  							writer.WriteString(text);  							writer.WriteString("'");  						break;  					}
Missing Default,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  				case "arrayOf":  					int rank = Convert.ToInt32( reference.GetAttribute("rank"'String.Empty) );  					XPathNavigator element = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(element' writer);  					writer.WriteString("[");  					for (int i=1; i<rank; i++) { writer.WriteString("'"); }  					writer.WriteString("]");  				break;  				case "pointerTo":  					XPathNavigator pointee = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(pointee' writer);  					writer.WriteString("*");  				break;  				case "referenceTo":  					XPathNavigator referee = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(referee' writer);  				break;  				case "type":  					string id = reference.GetAttribute("api"' String.Empty);  					WriteNormalTypeReference(id' writer);  					XPathNodeIterator typeModifiers = reference.Select(typeModifiersExpression);  					while (typeModifiers.MoveNext()) {  						WriteTypeReference(typeModifiers.Current' writer);  					}  				break;  				case "template":  					string name = reference.GetAttribute("name"' String.Empty);  					writer.WriteString(name);  					XPathNodeIterator modifiers = reference.Select(typeModifiersExpression);  					while (modifiers.MoveNext()) {  						WriteTypeReference(modifiers.Current' writer);  					}  				break;  				case "specialization":  					writer.WriteString("<");  					XPathNodeIterator arguments = reference.Select(specializationArgumentsExpression);  					while (arguments.MoveNext()) {  						if (arguments.CurrentPosition > 1) writer.WriteString("' ");  						WriteTypeReference(arguments.Current' writer);  					}  					writer.WriteString(">");  				break;  			}
Missing Default,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName)              {                  case "arrayOf":                          int rank = Convert.ToInt32(reference.GetAttribute("rank"' string.Empty));                          XPathNavigator navigator = reference.SelectSingleNode(typeExpression);                          WriteTypeReference(navigator' writer);                          writer.WriteString("[");                          for (int i = 1; i < rank; i++) { writer.WriteString("'"); }                          writer.WriteString("]");                          break;                  case "type":                          string id = reference.GetAttribute("api"' string.Empty);                          WriteNormalTypeReference(id' writer);                          break;                  case "pointerTo":                  case "referenceTo":                  case "template":                  case "specialization":                          // Not supported                          break;              }
Missing Default,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteNormalTypeReference,The following switch statement is missing a default case: switch (api) {                  case "T:System.Byte":                      writer.WriteReferenceLink(api' "Byte");                      return;                    case "T:System.SByte":                      writer.WriteReferenceLink(api' "SByte");                      return;                    case "T:System.Char":                      writer.WriteReferenceLink(api' "Char");                      return;                    case "T:System.Int16":                      writer.WriteReferenceLink(api' "Int16");                      return;                    case "T:System.Int32":                      writer.WriteReferenceLink(api' "Int32");                      return;                    case "T:System.Int64":                      writer.WriteReferenceLink(api' "Int64");                      return;                    case "T:System.UInt16":                      writer.WriteReferenceLink(api' "UInt16");                      return;                    case "T:System.UInt32":                      writer.WriteReferenceLink(api' "UInt32");                      return;                    case "T:System.UInt64":                      writer.WriteReferenceLink(api' "UInt64");                      return;                    case "T:System.Single":                      writer.WriteReferenceLink(api' "Single");                      return;                    case "T:System.Double":                      writer.WriteReferenceLink(api' "Double");                      return;                    case "T:System.Decimal":                      writer.WriteReferenceLink(api' "Decimal");                      return;                    case "T:System.Boolean":                      writer.WriteReferenceLink(api' "Boolean");                      return;              }
Missing Default,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteSyntax,The following switch statement is missing a default case: switch (group) {  				case "namespace":  					WriteNamespaceSyntax(reflection' writer);  				break;  				case "type":  					WriteTypeSyntax(reflection' writer);  				break;  				case "member":  					WriteMemberSyntax(reflection' writer);  				break;  			}
Missing Default,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteTypeSyntax,The following switch statement is missing a default case: switch (subgroup) {  				case "class":  					WriteClassSyntax(reflection' writer);  				break;  				case "structure":  					WriteStructureSyntax(reflection' writer);  				break;  				case "interface":  					WriteInterfaceSyntax(reflection' writer);  				break;  				case "delegate":  					WriteDelegateSyntax(reflection' writer);  				break;  				case "enumeration":  					WriteEnumerationSyntax(reflection' writer);  				break;  			}
Missing Default,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteMemberSyntax,The following switch statement is missing a default case: switch (subgroup) {  				case "constructor":  					WriteConstructorSyntax(reflection' writer);  				break;  				case "method":  					WriteMethodSyntax(reflection' writer);  				break;  				case "property":                      if (subsubgroup == "attachedProperty")                          WriteAttachedPropertySyntax(reflection' writer);                      else                          WritePropertySyntax(reflection' writer);                      break;  				case "event":                      if (subsubgroup == "attachedEvent")                          WriteAttachedEventSyntax(reflection' writer);                      else                          WriteEventSyntax(reflection' writer);                      break;  				case "field":  					WriteFieldSyntax(reflection' writer);  				break;  			}
Missing Default,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,SeperateTypes,The following switch statement is missing a default case: switch (typelist[index]) {  					case '{':  						specializationCount++;  					break;  					case '}':  						specializationCount--;  					break;  					case ''':  						if (specializationCount == 0) {  							types.Add( "T:" + typelist.Substring(start' index-start) );  							start = index + 1;  						}  					break;  				}
Missing Default,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  				case "public":  					writer.WriteKeyword("Public");  				break;  				case "family":  					writer.WriteKeyword("Protected");  				break;  				case "family or assembly":  					writer.WriteKeyword("Protected Friend");  				break;  				case "family and assembly":  					writer.WriteKeyword("Friend"); // not right' but same outside assembly  				break;  				case "assembly":  					writer.WriteKeyword("Friend");  				break;  				case "private":  					writer.WriteKeyword("Private");  				break;  			}
Missing Default,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  				case "nullValue":  					writer.WriteKeyword("Nothing");  				break;  				case "typeValue":  					writer.WriteKeyword("GetType");  					writer.WriteString("(");  					WriteTypeReference(value.SelectSingleNode(typeExpression)' writer);  					writer.WriteString(")");  				break;  				case "enumValue":  					XPathNodeIterator fields = value.SelectChildren(XPathNodeType.Element);  					while (fields.MoveNext()) {  						string name = fields.Current.GetAttribute("name"' String.Empty);  						if (fields.CurrentPosition > 1) {  							writer.WriteString(" ");  							writer.WriteKeyword("Or");  							writer.WriteString(" ");  						}  						WriteTypeReference(type' writer);  						writer.WriteString(".");  						writer.WriteString(name);  					}  				break;  				case "value":  					string text = value.Value;  					string typeId = type.GetAttribute("api"' String.Empty);  					switch (typeId) {  						case "T:System.String":  							writer.WriteString("\"");  							writer.WriteString(text);  							writer.WriteString("\"");  						break;  						case "T:System.Boolean":  							bool bool_value = Convert.ToBoolean(text);  							if (bool_value) {  								writer.WriteKeyword("True");  							} else {  								writer.WriteKeyword("False");  							}  						break;  						case "T:System.Char":  							writer.WriteString("\"");  							writer.WriteString(text);  							writer.WriteString("\"C");  						break;  					}  				break;  			}
Missing Default,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  						case "T:System.String":  							writer.WriteString("\"");  							writer.WriteString(text);  							writer.WriteString("\"");  						break;  						case "T:System.Boolean":  							bool bool_value = Convert.ToBoolean(text);  							if (bool_value) {  								writer.WriteKeyword("True");  							} else {  								writer.WriteKeyword("False");  							}  						break;  						case "T:System.Char":  							writer.WriteString("\"");  							writer.WriteString(text);  							writer.WriteString("\"C");  						break;  					}
Missing Default,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  				case "arrayOf":  					int rank = Convert.ToInt32( reference.GetAttribute("rank"'String.Empty) );  					XPathNavigator element = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(element' writer);  					writer.WriteString("(");  					for (int i=1; i<rank; i++) { writer.WriteString("'"); }  					writer.WriteString(")");  				break;  				case "pointerTo":  					XPathNavigator pointee = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(pointee' writer);  					writer.WriteString("*");  				break;  				case "referenceTo":  					XPathNavigator referee = reference.SelectSingleNode(typeExpression);  					WriteTypeReference(referee' writer);  				break;  				case "type":  					string id = reference.GetAttribute("api"' String.Empty);  					WriteNormalTypeReference(id' writer);  					XPathNodeIterator typeModifiers = reference.Select(typeModifiersExpression);  					while (typeModifiers.MoveNext()) {  						WriteTypeReference(typeModifiers.Current' writer);  					}  				break;  				case "template":  					string name = reference.GetAttribute("name"' String.Empty);  					writer.WriteString(name);  					XPathNodeIterator modifiers = reference.Select(typeModifiersExpression);  					while (modifiers.MoveNext()) {  						WriteTypeReference(modifiers.Current' writer);  					}  				break;  				case "specialization":  					writer.WriteString("(");  					writer.WriteKeyword("Of");  					writer.WriteString(" ");  					XPathNodeIterator arguments = reference.Select(specializationArgumentsExpression);  					while (arguments.MoveNext()) {  						if (arguments.CurrentPosition > 1) writer.WriteString("' ");  						WriteTypeReference(arguments.Current' writer);  					}  					writer.WriteString(")");  				break;  			}
Missing Default,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following switch statement is missing a default case: switch (type) {                      case -1:                          writer.WriteIdentifier(identifier);                          parameters.MoveNext();                          writer.WriteParameter((string)parameters.Current.Evaluate(parameterNameExpression));                      break;                      case +1:                          parameters.MoveNext();                          writer.WriteParameter((string)parameters.Current.Evaluate(parameterNameExpression));                          writer.WriteIdentifier(identifier);                      break;                      case 2:                          writer.WriteString("(");                            // parameter 1                          parameters.MoveNext();                          writer.WriteParameter((string)parameters.Current.Evaluate(parameterNameExpression));                            writer.WriteString(" ");                          writer.WriteIdentifier(identifier);                          writer.WriteString(" ");                            // parameter 2                          parameters.MoveNext();                          writer.WriteParameter((string)parameters.Current.Evaluate(parameterNameExpression));                            writer.WriteString(")");                      break;                  }
Missing Default,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {                  case "arrayOf":                      int rank = Convert.ToInt32(reference.GetAttribute("rank"' String.Empty));                      XPathNavigator element = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(element' writer);                      writer.WriteString("(");                      for (int i = 1; i < rank; i++) { writer.WriteString("'"); }                      writer.WriteString(")");                      break;                  case "pointerTo":                      XPathNavigator pointee = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(pointee' writer);                      writer.WriteString("*");                      break;                  case "referenceTo":                      XPathNavigator referee = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(referee' writer);                      break;                  case "type":                      string id = reference.GetAttribute("api"' String.Empty);                      WriteNormalTypeReference(id' writer);                      XPathNodeIterator typeModifiers = reference.Select(typeModifiersExpression);                      while (typeModifiers.MoveNext()) {                          WriteTypeReference(typeModifiers.Current' writer);                      }                      break;                  case "template":                      string name = reference.GetAttribute("name"' String.Empty);                      writer.WriteString(name);                      XPathNodeIterator modifiers = reference.Select(typeModifiersExpression);                      while (modifiers.MoveNext()) {                          WriteTypeReference(modifiers.Current' writer);                      }                      break;                  case "specialization":                      writer.WriteString("(");                      writer.WriteKeyword("Of");                      writer.WriteString(" ");                      XPathNodeIterator arguments = reference.Select(specializationArgumentsExpression);                      while (arguments.MoveNext()) {                          if (arguments.CurrentPosition > 1) writer.WriteString("' ");                          WriteTypeReference(arguments.Current' writer);                      }                      writer.WriteString(")");                      break;              }
Missing Default,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteSyntax,The following switch statement is missing a default case: switch (group)                  {                      case "namespace":                          WriteNamespaceSyntax(reflection' writer);                          break;                      case "type":                          WriteTypeSyntax(reflection' writer);                          break;                      case "member":                          WriteMemberSyntax(reflection' writer);                          break;                  }
Missing Default,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,D:\research\architectureSmells\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName)              {                  case "arrayOf":                      int rank = Convert.ToInt32(reference.GetAttribute("rank"' String.Empty));                      XPathNavigator element = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(element' writer);                      writer.WriteString("[");                      for (int i = 1; i < rank; i++) { writer.WriteString("'"); }                      writer.WriteString("]");                      break;                  case "pointerTo":                      XPathNavigator pointee = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(pointee' writer);                      writer.WriteString("*");                      break;                  case "referenceTo":                      XPathNavigator referee = reference.SelectSingleNode(typeExpression);                      WriteTypeReference(referee' writer);                      break;                  case "type":                      string id = reference.GetAttribute("api"' String.Empty);                        XPathNavigator outerTypeReference = reference.SelectSingleNode(typeOuterTypeExpression);                      if (outerTypeReference != null)                      {                          WriteTypeReference(outerTypeReference' writer);                          writer.WriteString(".");                      }                        WriteNormalTypeReference(id' writer);                      XPathNodeIterator typeModifiers = reference.Select(typeModifiersExpression);                      while (typeModifiers.MoveNext())                      {                          WriteTypeReference(typeModifiers.Current' writer);                      }                      break;                  case "template":                      string name = reference.GetAttribute("name"' String.Empty);                      writer.WriteString(name);                      XPathNodeIterator modifiers = reference.Select(typeModifiersExpression);                      while (modifiers.MoveNext())                      {                          WriteTypeReference(modifiers.Current' writer);                      }                      break;                  case "specialization":                      writer.WriteString("<");                      XPathNodeIterator arguments = reference.Select(specializationArgumentsExpression);                      while (arguments.MoveNext())                      {                          if (arguments.CurrentPosition > 1) writer.WriteString("' ");                          WriteTypeReference(arguments.Current' writer);                      }                      writer.WriteString(">");                      break;              }
