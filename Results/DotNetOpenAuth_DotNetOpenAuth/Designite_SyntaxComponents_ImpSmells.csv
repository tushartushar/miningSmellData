Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteOperatorSyntax,The method has 109 lines of code.
Long Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WritePropertySyntax,The method has 100 lines of code.
Long Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteOperatorSyntax,The method has 105 lines of code.
Long Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteOperatorSyntax,The method has 113 lines of code.
Long Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteOperatorSyntax,The method has 129 lines of code.
Long Method,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The method has 175 lines of code.
Complex Method,Microsoft.Ddue.Tools,AspNetSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\AspNetSyntax.cs,WriteSyntax,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 85
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteVisibility,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteGenericTemplates,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteBaseClassAndImplementedInterfaces,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteParameters,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 43
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 42
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 80
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteVisibility,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteBaseClassAndImplementedInterfaces,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteGenericTemplateConstraints,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 48
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 81
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteDotNetObject,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteGenericTemplateConstraints,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 39
Complex Method,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 48
Complex Method,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteAccessModifier,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 42
Complex Method,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteVisibility,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteVisibility,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 30
Complex Method,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,CreateCamelCaseName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 27
Complex Method,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteSyntax,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteTypeSyntax,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteMemberSyntax,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,SeperateTypes,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 95
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteVisibility,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteAttributes,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteValue,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteGenericTemplates,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 38
Complex Method,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,Cyclomatic complexity of the method is 139
Complex Method,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 38
Complex Method,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteSyntax,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,LoadConfiguration,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WritePropertySyntax,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteTypeReference,Cyclomatic complexity of the method is 39
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteNormalTypeReference,Cyclomatic complexity of the method is 48
Complex Method,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,IsPrimitiveType,Cyclomatic complexity of the method is 15
Long Statement,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteNormalMethodSyntax,The length of the statement  "	bool isVirtual = (bool)reflection.Evaluate (apiIsVirtualExpression) && !(bool)reflection.Evaluate (apiIsAbstractProcedureExpression); " is 133.
Long Statement,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WritePropertySyntax,The length of the statement  "	bool isVirtual = (bool)reflection.Evaluate (apiIsVirtualExpression) && !(bool)reflection.Evaluate (apiIsAbstractProcedureExpression); " is 133.
Long Statement,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteEventSyntax,The length of the statement  "	bool isVirtual = (bool)reflection.Evaluate (apiIsVirtualExpression) && !(bool)reflection.Evaluate (apiIsAbstractProcedureExpression); " is 133.
Long Statement,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,CreateCamelCaseName,The length of the statement  "		return name.Substring (0' conversionLength - 1).ToLower (CultureInfo.InvariantCulture) + name.Substring (conversionLength - 1); " is 127.
Long Statement,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The length of the statement  "				template = reflection.SelectSingleNode (String.Format ("containers/container[@type]/templates/template[{0}]"' position)); " is 121.
Long Statement,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WritePropertySyntax,The length of the statement  "		if (string.IsNullOrEmpty (getVisibility) || (getVisibility != "assembly" && getVisibility != "private" && getVisibility != "family and assembly")) { " is 148.
Long Statement,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WritePropertySyntax,The length of the statement  "		if (string.IsNullOrEmpty (setVisibility) || (setVisibility != "assembly" && setVisibility != "private" && setVisibility != "family and assembly")) { " is 148.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,ParseDocuments,The length of the statement  "	//WriteMessage(MessageLevel.Info' String.Format("XamlUsageSyntaxGenerator: Searching for files that match '{0}'."' filterFiles)); " is 129.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,ParseDocument,The length of the statement  "		throw new ConfigurationErrorsException (string.Format ("Exception parsing XamlUsageSyntaxGenerator filter file: {0}. Exception message: {1}"' file' e.Message)); " is 160.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WritePropertySyntax,The length of the statement  "	bool returnTypeIsReadonlyStruct = (returnTypeSubgroup == "structure" && notWriteableReturnType && !IsPrimitiveType (returnTypeId)); " is 131.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WritePropertySyntax,The length of the statement  "	} else if ((bool)containingType.Evaluate (apiIsAbstractTypeExpression) && (bool)containingType.Evaluate (apiIsSealedTypeExpression)) { " is 134.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,IsContentProperty,The length of the statement  "	string propertyId = string.Concat ("P:"' namespaceId.Substring (2)' "."' string.Concat (containingTypeName' "."' propertyName)); " is 128.
Long Statement,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,IsPrimitiveType,The length of the statement  "	// The primitive types are Boolean' Byte' SByte' Int16' UInt16' Int32' UInt32' Int64' UInt64' IntPtr' Char' Double' and Single. " is 127.
Complex Conditional,Microsoft.Ddue.Tools,AspNetSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\AspNetSyntax.cs,WebControlPrefix,The conditional expression  "(space == "N:System.Web.UI") && ((name == "Page") || (name == "ScriptControl") || (name == "UserControl"))"  is complex.
Complex Conditional,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WritePropertySyntax,The conditional expression  "string.IsNullOrEmpty (getVisibility) || (getVisibility != "assembly" && getVisibility != "private" && getVisibility != "family and assembly")"  is complex.
Complex Conditional,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WritePropertySyntax,The conditional expression  "string.IsNullOrEmpty (setVisibility) || (setVisibility != "assembly" && setVisibility != "private" && setVisibility != "family and assembly")"  is complex.
Magic Number,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The following statement contains a magic number: if (reference.StartsWith ("T:`")) {  	if (reference [3] == '`') {  		// a method template parameter  		int position = Convert.ToInt32 (reference.Substring (4)) + 1;  		if (group == "member") {  			// we are in a method' so presumably it is one of that method's template parameters  			template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  		}  	} else {  		// a type template parameter  		int position = Convert.ToInt32 (reference.Substring (3)) + 1;  		if (group == "type") {  			// we are in a type' so look there for the parameter  			template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  		}  		if (template == null) {  			// either we weren't in a type' or it didn't have the template  			// so now look at the templates of the containing type  			template = reflection.SelectSingleNode (String.Format ("containers/container[@type]/templates/template[{0}]"' position));  		}  	}  }  
Magic Number,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The following statement contains a magic number: if (reference.StartsWith ("T:`")) {  	if (reference [3] == '`') {  		// a method template parameter  		int position = Convert.ToInt32 (reference.Substring (4)) + 1;  		if (group == "member") {  			// we are in a method' so presumably it is one of that method's template parameters  			template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  		}  	} else {  		// a type template parameter  		int position = Convert.ToInt32 (reference.Substring (3)) + 1;  		if (group == "type") {  			// we are in a type' so look there for the parameter  			template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  		}  		if (template == null) {  			// either we weren't in a type' or it didn't have the template  			// so now look at the templates of the containing type  			template = reflection.SelectSingleNode (String.Format ("containers/container[@type]/templates/template[{0}]"' position));  		}  	}  }  
Magic Number,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The following statement contains a magic number: if (reference.StartsWith ("T:`")) {  	if (reference [3] == '`') {  		// a method template parameter  		int position = Convert.ToInt32 (reference.Substring (4)) + 1;  		if (group == "member") {  			// we are in a method' so presumably it is one of that method's template parameters  			template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  		}  	} else {  		// a type template parameter  		int position = Convert.ToInt32 (reference.Substring (3)) + 1;  		if (group == "type") {  			// we are in a type' so look there for the parameter  			template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  		}  		if (template == null) {  			// either we weren't in a type' or it didn't have the template  			// so now look at the templates of the containing type  			template = reflection.SelectSingleNode (String.Format ("containers/container[@type]/templates/template[{0}]"' position));  		}  	}  }  
Magic Number,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The following statement contains a magic number: if (reference [3] == '`') {  	// a method template parameter  	int position = Convert.ToInt32 (reference.Substring (4)) + 1;  	if (group == "member") {  		// we are in a method' so presumably it is one of that method's template parameters  		template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  	}  } else {  	// a type template parameter  	int position = Convert.ToInt32 (reference.Substring (3)) + 1;  	if (group == "type") {  		// we are in a type' so look there for the parameter  		template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  	}  	if (template == null) {  		// either we weren't in a type' or it didn't have the template  		// so now look at the templates of the containing type  		template = reflection.SelectSingleNode (String.Format ("containers/container[@type]/templates/template[{0}]"' position));  	}  }  
Magic Number,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The following statement contains a magic number: if (reference [3] == '`') {  	// a method template parameter  	int position = Convert.ToInt32 (reference.Substring (4)) + 1;  	if (group == "member") {  		// we are in a method' so presumably it is one of that method's template parameters  		template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  	}  } else {  	// a type template parameter  	int position = Convert.ToInt32 (reference.Substring (3)) + 1;  	if (group == "type") {  		// we are in a type' so look there for the parameter  		template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  	}  	if (template == null) {  		// either we weren't in a type' or it didn't have the template  		// so now look at the templates of the containing type  		template = reflection.SelectSingleNode (String.Format ("containers/container[@type]/templates/template[{0}]"' position));  	}  }  
Magic Number,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,GetTemplateParameterName,The following statement contains a magic number: if (reference [3] == '`') {  	// a method template parameter  	int position = Convert.ToInt32 (reference.Substring (4)) + 1;  	if (group == "member") {  		// we are in a method' so presumably it is one of that method's template parameters  		template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  	}  } else {  	// a type template parameter  	int position = Convert.ToInt32 (reference.Substring (3)) + 1;  	if (group == "type") {  		// we are in a type' so look there for the parameter  		template = reflection.SelectSingleNode (String.Format ("templates/template[{0}]"' position));  	}  	if (template == null) {  		// either we weren't in a type' or it didn't have the template  		// so now look at the templates of the containing type  		template = reflection.SelectSingleNode (String.Format ("containers/container[@type]/templates/template[{0}]"' position));  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (!(bool)reflection.Evaluate (apiIsUdtReturnExpression)) {  	switch (name) {  	// unary math operators  	case "UnaryPlus":  		identifier = "+";  		type = -1;  		break;  	case "UnaryNegation":  		identifier = "-";  		type = -1;  		break;  	case "Increment":  		identifier = "++";  		type = +1;  		break;  	case "Decrement":  		identifier = "--";  		type = +1;  		break;  	// unary logical operators  	case "LogicalNot":  		identifier = "Not";  		type = -1;  		break;  	case "True":  		identifier = "IsTrue";  		type = -1;  		break;  	case "False":  		identifier = "IsFalse";  		type = -1;  		break;  	// binary comparison operators  	case "Equality":  		identifier = "=";  		type = 2;  		break;  	case "Inequality":  		identifier = "<>";  		type = 2;  		break;  	case "LessThan":  		identifier = "<";  		type = 2;  		break;  	case "GreaterThan":  		identifier = ">";  		type = 2;  		break;  	case "LessThanOrEqual":  		identifier = "<=";  		type = 2;  		break;  	case "GreaterThanOrEqual":  		identifier = ">=";  		type = 2;  		break;  	// binary math operators  	case "Addition":  		identifier = "+";  		type = 2;  		break;  	case "Subtraction":  		identifier = "-";  		type = 2;  		break;  	case "Multiply":  		identifier = "*";  		type = 2;  		break;  	case "Division":  		identifier = "/";  		type = 2;  		break;  	case "Exponent":  		identifier = "^";  		type = 2;  		break;  	case "Modulus":  		identifier = "Mod";  		type = 2;  		break;  	case "IntegerDivision":  		identifier = @"\";  		type = 2;  		break;  	// binary logical operators  	case "BitwiseAnd":  		identifier = "And";  		type = 2;  		break;  	case "BitwiseOr":  		identifier = "Or";  		type = 2;  		break;  	case "ExclusiveOr":  		identifier = "Xor";  		type = 2;  		break;  	// bit-array operators  	case "OnesComplement":  		identifier = "~";  		type = -1;  		break;  	case "LeftShift":  		identifier = "<<";  		type = 2;  		break;  	case "RightShift":  		identifier = ">>";  		type = 2;  		break;  	// concatenation  	case "Concatenate":  		identifier = "&";  		type = 2;  		break;  	case "Assign":  		identifier = "=";  		type = 2;  		break;  	// didn't recognize an operator  	default:  		identifier = null;  		type = 0;  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (name) {  // unary math operators  case "UnaryPlus":  	identifier = "+";  	type = -1;  	break;  case "UnaryNegation":  	identifier = "-";  	type = -1;  	break;  case "Increment":  	identifier = "++";  	type = +1;  	break;  case "Decrement":  	identifier = "--";  	type = +1;  	break;  // unary logical operators  case "LogicalNot":  	identifier = "Not";  	type = -1;  	break;  case "True":  	identifier = "IsTrue";  	type = -1;  	break;  case "False":  	identifier = "IsFalse";  	type = -1;  	break;  // binary comparison operators  case "Equality":  	identifier = "=";  	type = 2;  	break;  case "Inequality":  	identifier = "<>";  	type = 2;  	break;  case "LessThan":  	identifier = "<";  	type = 2;  	break;  case "GreaterThan":  	identifier = ">";  	type = 2;  	break;  case "LessThanOrEqual":  	identifier = "<=";  	type = 2;  	break;  case "GreaterThanOrEqual":  	identifier = ">=";  	type = 2;  	break;  // binary math operators  case "Addition":  	identifier = "+";  	type = 2;  	break;  case "Subtraction":  	identifier = "-";  	type = 2;  	break;  case "Multiply":  	identifier = "*";  	type = 2;  	break;  case "Division":  	identifier = "/";  	type = 2;  	break;  case "Exponent":  	identifier = "^";  	type = 2;  	break;  case "Modulus":  	identifier = "Mod";  	type = 2;  	break;  case "IntegerDivision":  	identifier = @"\";  	type = 2;  	break;  // binary logical operators  case "BitwiseAnd":  	identifier = "And";  	type = 2;  	break;  case "BitwiseOr":  	identifier = "Or";  	type = 2;  	break;  case "ExclusiveOr":  	identifier = "Xor";  	type = 2;  	break;  // bit-array operators  case "OnesComplement":  	identifier = "~";  	type = -1;  	break;  case "LeftShift":  	identifier = "<<";  	type = 2;  	break;  case "RightShift":  	identifier = ">>";  	type = 2;  	break;  // concatenation  case "Concatenate":  	identifier = "&";  	type = 2;  	break;  case "Assign":  	identifier = "=";  	type = 2;  	break;  // didn't recognize an operator  default:  	identifier = null;  	type = 0;  	break;  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: type = 2;  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: if (identifier == null) {  	writer.WriteMessage ("UnsupportedOperator_" + Language);  } else {  	XPathNodeIterator parameters = reflection.Select (apiParametersExpression);  	if (parameters.Count != Math.Abs (type)) {  		writer.WriteMessage ("UnsupportedOperator_" + Language);  		return;  	}  	//throw new InvalidOperationException("An operator has the wrong number of parameters.");  	WriteParameterDeclarations (reflection' writer);  	ParameterDeclaration ("returnValue"' returnType' writer);  	writer.WriteLine ();  	writer.WriteParameter ("returnValue");  	writer.WriteString (" = ");  	switch (type) {  	case -1:  		writer.WriteIdentifier (identifier);  		parameters.MoveNext ();  		writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  		break;  	case +1:  		parameters.MoveNext ();  		writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  		writer.WriteIdentifier (identifier);  		break;  	case 2:  		writer.WriteString ("(");  		// parameter 1  		parameters.MoveNext ();  		writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  		writer.WriteString (" ");  		writer.WriteIdentifier (identifier);  		writer.WriteString (" ");  		// parameter 2  		parameters.MoveNext ();  		writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  		writer.WriteString (")");  		break;  	}  }  
Magic Number,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following statement contains a magic number: switch (type) {  case -1:  	writer.WriteIdentifier (identifier);  	parameters.MoveNext ();  	writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  	break;  case +1:  	parameters.MoveNext ();  	writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  	writer.WriteIdentifier (identifier);  	break;  case 2:  	writer.WriteString ("(");  	// parameter 1  	parameters.MoveNext ();  	writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  	writer.WriteString (" ");  	writer.WriteIdentifier (identifier);  	writer.WriteString (" ");  	// parameter 2  	parameters.MoveNext ();  	writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  	writer.WriteString (")");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  case "public":  	writer.WriteKeyword ("public");  	break;  case "family":  	writer.WriteKeyword ("protected");  	break;  case "family or assembly":  	writer.WriteKeyword ("protected public");  	break;  case "family and assembly":  	writer.WriteKeyword ("protected private");  	break;  case "assembly":  	writer.WriteKeyword ("internal");  	break;  case "private":  	writer.WriteKeyword ("private");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	XPathNavigator element = reference.SelectSingleNode (typeExpression);  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' String.Empty));  	writer.WriteKeyword ("array");  	writer.WriteString ("<");  	WriteTypeReference (element' writer);  	if (rank > 1) {  		writer.WriteString ("'");  		writer.WriteString (rank.ToString ());  	}  	writer.WriteString (">");  	if (handle)  		writer.WriteString ("^");  	break;  case "pointerTo":  	XPathNavigator pointee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (pointee' writer);  	writer.WriteString ("*");  	break;  case "referenceTo":  	XPathNavigator referee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (referee' writer);  	writer.WriteString ("%");  	break;  case "type":  	string id = reference.GetAttribute ("api"' String.Empty);  	bool isRef = (reference.GetAttribute ("ref"' String.Empty) == "true");  	WriteNormalTypeReference (id' writer);  	XPathNodeIterator typeModifiers = reference.Select (typeModifiersExpression);  	while (typeModifiers.MoveNext ()) {  		WriteTypeReference (typeModifiers.Current' writer);  	}  	if (handle && isRef)  		writer.WriteString ("^");  	break;  case "template":  	string name = reference.GetAttribute ("name"' String.Empty);  	writer.WriteString (name);  	XPathNodeIterator modifiers = reference.Select (typeModifiersExpression);  	while (modifiers.MoveNext ()) {  		WriteTypeReference (modifiers.Current' writer);  	}  	break;  case "specialization":  	writer.WriteString ("<");  	XPathNodeIterator arguments = reference.Select (specializationArgumentsExpression);  	while (arguments.MoveNext ()) {  		if (arguments.CurrentPosition > 1)  			writer.WriteString ("' ");  		WriteTypeReference (arguments.Current' writer);  	}  	writer.WriteString (">");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  case "nullValue":  	writer.WriteKeyword ("nullptr");  	break;  case "typeValue":  	writer.WriteKeyword ("typeof");  	writer.WriteString ("(");  	WriteTypeReference (value.SelectSingleNode (typeExpression)' false' writer);  	writer.WriteString (")");  	break;  case "enumValue":  	XPathNodeIterator fields = value.SelectChildren (XPathNodeType.Element);  	while (fields.MoveNext ()) {  		string name = fields.Current.GetAttribute ("name"' String.Empty);  		if (fields.CurrentPosition > 1)  			writer.WriteString ("|");  		WriteTypeReference (type' writer);  		writer.WriteString ("::");  		writer.WriteString (name);  	}  	break;  case "value":  	string text = value.Value;  	string typeId = type.GetAttribute ("api"' String.Empty);  	switch (typeId) {  	case "T:System.String":  		writer.WriteString ("L\"");  		writer.WriteString (text);  		writer.WriteString ("\"");  		break;  	case "T:System.Boolean":  		bool bool_value = Convert.ToBoolean (text);  		if (bool_value) {  			writer.WriteKeyword ("true");  		} else {  			writer.WriteKeyword ("false");  		}  		break;  	case "T:System.Char":  		writer.WriteString (@"L'");  		writer.WriteString (text);  		writer.WriteString (@"'");  		break;  	}  	break;  }  
Missing Default,Microsoft.Ddue.Tools,CPlusPlusDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CPlusPlusDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  case "T:System.String":  	writer.WriteString ("L\"");  	writer.WriteString (text);  	writer.WriteString ("\"");  	break;  case "T:System.Boolean":  	bool bool_value = Convert.ToBoolean (text);  	if (bool_value) {  		writer.WriteKeyword ("true");  	} else {  		writer.WriteKeyword ("false");  	}  	break;  case "T:System.Char":  	writer.WriteString (@"L'");  	writer.WriteString (text);  	writer.WriteString (@"'");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  case "public":  	writer.WriteKeyword ("public");  	break;  case "family":  	writer.WriteKeyword ("protected");  	break;  case "family or assembly":  	writer.WriteKeyword ("protected internal");  	break;  case "assembly":  	writer.WriteKeyword ("internal");  	break;  case "private":  	writer.WriteKeyword ("private");  	break;  case "family and assembly":  	// this isn't handled in C#  	break;  }  
Missing Default,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  case "nullValue":  	writer.WriteKeyword ("null");  	break;  case "typeValue":  	writer.WriteKeyword ("typeof");  	writer.WriteString ("(");  	WriteTypeReference (value.SelectSingleNode (typeExpression)' writer);  	writer.WriteString (")");  	break;  case "enumValue":  	XPathNodeIterator fields = value.SelectChildren (XPathNodeType.Element);  	while (fields.MoveNext ()) {  		string name = fields.Current.GetAttribute ("name"' String.Empty);  		if (fields.CurrentPosition > 1)  			writer.WriteString ("|");  		WriteTypeReference (type' writer);  		writer.WriteString (".");  		writer.WriteString (name);  	}  	break;  case "value":  	string text = value.Value;  	string typeId = type.GetAttribute ("api"' String.Empty);  	switch (typeId) {  	case "T:System.String":  		writer.WriteString ("\"");  		writer.WriteString (text);  		writer.WriteString ("\"");  		break;  	case "T:System.Boolean":  		bool bool_value = Convert.ToBoolean (text);  		if (bool_value) {  			writer.WriteKeyword ("true");  		} else {  			writer.WriteKeyword ("false");  		}  		break;  	case "T:System.Char":  		writer.WriteString ("'");  		writer.WriteString (text);  		writer.WriteString ("'");  		break;  	}  	break;  }  
Missing Default,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  case "T:System.String":  	writer.WriteString ("\"");  	writer.WriteString (text);  	writer.WriteString ("\"");  	break;  case "T:System.Boolean":  	bool bool_value = Convert.ToBoolean (text);  	if (bool_value) {  		writer.WriteKeyword ("true");  	} else {  		writer.WriteKeyword ("false");  	}  	break;  case "T:System.Char":  	writer.WriteString ("'");  	writer.WriteString (text);  	writer.WriteString ("'");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,CSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\CSharpDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' String.Empty));  	XPathNavigator element = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (element' writer);  	writer.WriteString ("[");  	for (int i = 1; i < rank; i++) {  		writer.WriteString ("'");  	}  	writer.WriteString ("]");  	break;  case "pointerTo":  	XPathNavigator pointee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (pointee' writer);  	writer.WriteString ("*");  	break;  case "referenceTo":  	XPathNavigator referee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (referee' writer);  	break;  case "type":  	string id = reference.GetAttribute ("api"' String.Empty);  	WriteNormalTypeReference (id' writer);  	XPathNodeIterator typeModifiers = reference.Select (typeModifiersExpression);  	while (typeModifiers.MoveNext ()) {  		WriteTypeReference (typeModifiers.Current' writer);  	}  	break;  case "template":  	string name = reference.GetAttribute ("name"' String.Empty);  	writer.WriteString (name);  	XPathNodeIterator modifiers = reference.Select (typeModifiersExpression);  	while (modifiers.MoveNext ()) {  		WriteTypeReference (modifiers.Current' writer);  	}  	break;  case "specialization":  	writer.WriteString ("<");  	XPathNodeIterator arguments = reference.Select (specializationArgumentsExpression);  	while (arguments.MoveNext ()) {  		if (arguments.CurrentPosition > 1)  			writer.WriteString ("' ");  		WriteTypeReference (arguments.Current' writer);  	}  	writer.WriteString (">");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  case "nullValue":  	writer.WriteKeyword ("null");  	break;  case "typeValue":  	writer.WriteKeyword ("typeof");  	writer.WriteString ("(");  	WriteTypeReference (value.SelectSingleNode (typeExpression)' writer);  	writer.WriteString (")");  	break;  case "enumValue":  	XPathNodeIterator fields = value.SelectChildren (XPathNodeType.Element);  	while (fields.MoveNext ()) {  		string name = fields.Current.GetAttribute ("name"' String.Empty);  		if (fields.CurrentPosition > 1)  			writer.WriteString ("|");  		WriteTypeReference (type' writer);  		writer.WriteString (".");  		writer.WriteString (name);  	}  	break;  case "value":  	string text = value.Value;  	string typeId = type.GetAttribute ("api"' String.Empty);  	switch (typeId) {  	case "T:System.String":  		writer.WriteString ("\"");  		writer.WriteString (text);  		writer.WriteString ("\"");  		break;  	case "T:System.Boolean":  		bool bool_value = Convert.ToBoolean (text);  		if (bool_value) {  			writer.WriteKeyword ("true");  		} else {  			writer.WriteKeyword ("false");  		}  		break;  	case "T:System.Char":  		writer.WriteString ("'");  		writer.WriteString (text);  		writer.WriteString ("'");  		break;  	}  	break;  }  
Missing Default,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  case "T:System.String":  	writer.WriteString ("\"");  	writer.WriteString (text);  	writer.WriteString ("\"");  	break;  case "T:System.Boolean":  	bool bool_value = Convert.ToBoolean (text);  	if (bool_value) {  		writer.WriteKeyword ("true");  	} else {  		writer.WriteKeyword ("false");  	}  	break;  case "T:System.Char":  	writer.WriteString ("'");  	writer.WriteString (text);  	writer.WriteString ("'");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,FSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\FSharpDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' String.Empty));  	XPathNavigator element = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (element' writer);  	writer.WriteString ("[");  	for (int i = 1; i < rank; i++) {  		writer.WriteString ("'");  	}  	writer.WriteString ("]");  	break;  case "pointerTo":  	XPathNavigator pointee = reference.SelectSingleNode (typeExpression);  	writer.WriteKeyword ("nativeptr");  	writer.WriteString ("<");  	WriteTypeReference (pointee' writer);  	writer.WriteString (">");  	break;  case "referenceTo":  	XPathNavigator referee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (referee' writer);  	break;  case "type":  	string id = reference.GetAttribute ("api"' String.Empty);  	WriteNormalTypeReference (id' writer);  	XPathNodeIterator typeModifiers = reference.Select (typeModifiersExpression);  	while (typeModifiers.MoveNext ()) {  		WriteTypeReference (typeModifiers.Current' writer);  	}  	break;  case "template":  	string name = reference.GetAttribute ("name"' String.Empty);  	writer.WriteString ("'");  	writer.WriteString (name);  	XPathNodeIterator modifiers = reference.Select (typeModifiersExpression);  	while (modifiers.MoveNext ()) {  		WriteTypeReference (modifiers.Current' writer);  	}  	break;  case "specialization":  	writer.WriteString ("<");  	XPathNodeIterator arguments = reference.Select (specializationArgumentsExpression);  	while (arguments.MoveNext ()) {  		if (arguments.CurrentPosition > 1)  			writer.WriteString ("' ");  		WriteTypeReference (arguments.Current' writer);  	}  	writer.WriteString (">");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteAccessModifier,The following switch statement is missing a default case: switch (visibility) {  case "public":  	writer.WriteKeyword ("public");  	break;  case "family":  	writer.WriteKeyword ("protected");  	break;  case "family or assembly":  	// this isn't handled in JScript  	break;  case "assembly":  	writer.WriteKeyword ("internal");  	break;  case "private":  	writer.WriteKeyword ("private");  	break;  case "family and assembly":  	// this isn't handled in JScript  	break;  }  
Missing Default,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' String.Empty));  	XPathNavigator element = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (element' writer);  	writer.WriteString ("[");  	for (int i = 1; i < rank; i++) {  		writer.WriteString ("'");  	}  	writer.WriteString ("]");  	break;  case "pointerTo":  	XPathNavigator pointee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (pointee' writer);  	writer.WriteString ("*");  	break;  case "referenceTo":  	XPathNavigator referee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (referee' writer);  	break;  case "type":  	string id = reference.GetAttribute ("api"' String.Empty);  	WriteNormalTypeReference (id' writer);  	XPathNodeIterator typeModifiers = reference.Select (typeModifiersExpression);  	while (typeModifiers.MoveNext ()) {  		WriteTypeReference (typeModifiers.Current' writer);  	}  	break;  case "template":  	string name = reference.GetAttribute ("name"' String.Empty);  	writer.WriteString (name);  	XPathNodeIterator modifiers = reference.Select (typeModifiersExpression);  	while (modifiers.MoveNext ()) {  		WriteTypeReference (modifiers.Current' writer);  	}  	break;  case "specialization":  	writer.WriteString ("<");  	XPathNodeIterator arguments = reference.Select (specializationArgumentsExpression);  	while (arguments.MoveNext ()) {  		if (arguments.CurrentPosition > 1)  			writer.WriteString ("' ");  		WriteTypeReference (arguments.Current' writer);  	}  	writer.WriteString (">");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,JScriptDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JScriptDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  case "public":  	writer.WriteKeyword ("public");  	break;  case "family":  	writer.WriteKeyword ("protected");  	break;  case "family or assembly":  	// this isn't handled in JScript  	break;  case "assembly":  	writer.WriteKeyword ("internal");  	break;  case "private":  	writer.WriteKeyword ("private");  	break;  case "family and assembly":  	// this isn't handled in JScript  	break;  }  
Missing Default,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  case "public":  	writer.WriteKeyword ("public");  	break;  case "family":  	// in Java' protected = family or assembly  	writer.WriteKeyword ("protected");  	break;  case "family or assembly":  	writer.WriteKeyword ("protected");  	break;  case "assembly":  	// no assembly-only access in Java  	break;  case "private":  	writer.WriteKeyword ("private");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  case "nullValue":  	writer.WriteKeyword ("null");  	break;  case "typeValue":  	// this isn't really supported in J#; there is no compile-time way to get a type representation  	// writer.WriteKeyword("typeof");  	// writer.WriteString("(");  	WriteTypeReference (value.SelectSingleNode (typeExpression)' writer);  	// writer.WriteString(")");  	break;  case "enumValue":  	XPathNodeIterator fields = value.SelectChildren (XPathNodeType.Element);  	while (fields.MoveNext ()) {  		string name = fields.Current.GetAttribute ("name"' String.Empty);  		if (fields.CurrentPosition > 1)  			writer.WriteString ("|");  		WriteTypeReference (type' writer);  		writer.WriteString (".");  		writer.WriteString (name);  	}  	break;  case "value":  	string text = value.Value;  	string typeId = type.GetAttribute ("api"' String.Empty);  	switch (typeId) {  	case "T:System.String":  		writer.WriteString ("\"");  		writer.WriteString (text);  		writer.WriteString ("\"");  		break;  	case "T:System.Boolean":  		bool bool_value = Convert.ToBoolean (text);  		if (bool_value) {  			writer.WriteKeyword ("true");  		} else {  			writer.WriteKeyword ("false");  		}  		break;  	case "T:System.Char":  		writer.WriteString ("'");  		writer.WriteString (text);  		writer.WriteString ("'");  		break;  	}  	break;  }  
Missing Default,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  case "T:System.String":  	writer.WriteString ("\"");  	writer.WriteString (text);  	writer.WriteString ("\"");  	break;  case "T:System.Boolean":  	bool bool_value = Convert.ToBoolean (text);  	if (bool_value) {  		writer.WriteKeyword ("true");  	} else {  		writer.WriteKeyword ("false");  	}  	break;  case "T:System.Char":  	writer.WriteString ("'");  	writer.WriteString (text);  	writer.WriteString ("'");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,JSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\JSharpDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' String.Empty));  	XPathNavigator element = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (element' writer);  	writer.WriteString ("[");  	for (int i = 1; i < rank; i++) {  		writer.WriteString ("'");  	}  	writer.WriteString ("]");  	break;  case "pointerTo":  	XPathNavigator pointee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (pointee' writer);  	writer.WriteString ("*");  	break;  case "referenceTo":  	XPathNavigator referee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (referee' writer);  	break;  case "type":  	string id = reference.GetAttribute ("api"' String.Empty);  	WriteNormalTypeReference (id' writer);  	XPathNodeIterator typeModifiers = reference.Select (typeModifiersExpression);  	while (typeModifiers.MoveNext ()) {  		WriteTypeReference (typeModifiers.Current' writer);  	}  	break;  case "template":  	string name = reference.GetAttribute ("name"' String.Empty);  	writer.WriteString (name);  	XPathNodeIterator modifiers = reference.Select (typeModifiersExpression);  	while (modifiers.MoveNext ()) {  		WriteTypeReference (modifiers.Current' writer);  	}  	break;  case "specialization":  	writer.WriteString ("<");  	XPathNodeIterator arguments = reference.Select (specializationArgumentsExpression);  	while (arguments.MoveNext ()) {  		if (arguments.CurrentPosition > 1)  			writer.WriteString ("' ");  		WriteTypeReference (arguments.Current' writer);  	}  	writer.WriteString (">");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' string.Empty));  	XPathNavigator navigator = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (navigator' writer);  	writer.WriteString ("[");  	for (int i = 1; i < rank; i++) {  		writer.WriteString ("'");  	}  	writer.WriteString ("]");  	break;  case "type":  	string id = reference.GetAttribute ("api"' string.Empty);  	WriteNormalTypeReference (id' writer);  	break;  case "pointerTo":  case "referenceTo":  case "template":  case "specialization":  	// Not supported  	break;  }  
Missing Default,Microsoft.Ddue.Tools,ScriptSharpDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\ScriptSharpDeclarationSyntax.cs,WriteNormalTypeReference,The following switch statement is missing a default case: switch (api) {  case "T:System.Byte":  	writer.WriteReferenceLink (api' "Byte");  	return;  case "T:System.SByte":  	writer.WriteReferenceLink (api' "SByte");  	return;  case "T:System.Char":  	writer.WriteReferenceLink (api' "Char");  	return;  case "T:System.Int16":  	writer.WriteReferenceLink (api' "Int16");  	return;  case "T:System.Int32":  	writer.WriteReferenceLink (api' "Int32");  	return;  case "T:System.Int64":  	writer.WriteReferenceLink (api' "Int64");  	return;  case "T:System.UInt16":  	writer.WriteReferenceLink (api' "UInt16");  	return;  case "T:System.UInt32":  	writer.WriteReferenceLink (api' "UInt32");  	return;  case "T:System.UInt64":  	writer.WriteReferenceLink (api' "UInt64");  	return;  case "T:System.Single":  	writer.WriteReferenceLink (api' "Single");  	return;  case "T:System.Double":  	writer.WriteReferenceLink (api' "Double");  	return;  case "T:System.Decimal":  	writer.WriteReferenceLink (api' "Decimal");  	return;  case "T:System.Boolean":  	writer.WriteReferenceLink (api' "Boolean");  	return;  }  
Missing Default,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteSyntax,The following switch statement is missing a default case: switch (group) {  case "namespace":  	WriteNamespaceSyntax (reflection' writer);  	break;  case "type":  	WriteTypeSyntax (reflection' writer);  	break;  case "member":  	WriteMemberSyntax (reflection' writer);  	break;  }  
Missing Default,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteTypeSyntax,The following switch statement is missing a default case: switch (subgroup) {  case "class":  	WriteClassSyntax (reflection' writer);  	break;  case "structure":  	WriteStructureSyntax (reflection' writer);  	break;  case "interface":  	WriteInterfaceSyntax (reflection' writer);  	break;  case "delegate":  	WriteDelegateSyntax (reflection' writer);  	break;  case "enumeration":  	WriteEnumerationSyntax (reflection' writer);  	break;  }  
Missing Default,Microsoft.Ddue.Tools,SyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,WriteMemberSyntax,The following switch statement is missing a default case: switch (subgroup) {  case "constructor":  	WriteConstructorSyntax (reflection' writer);  	break;  case "method":  	WriteMethodSyntax (reflection' writer);  	break;  case "property":  	if (subsubgroup == "attachedProperty")  		WriteAttachedPropertySyntax (reflection' writer);  	else  		WritePropertySyntax (reflection' writer);  	break;  case "event":  	if (subsubgroup == "attachedEvent")  		WriteAttachedEventSyntax (reflection' writer);  	else  		WriteEventSyntax (reflection' writer);  	break;  case "field":  	WriteFieldSyntax (reflection' writer);  	break;  }  
Missing Default,Microsoft.Ddue.Tools,DeclarationSyntaxGeneratorTemplate,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\SyntaxGenerators.cs,SeperateTypes,The following switch statement is missing a default case: switch (typelist [index]) {  case '{':  	specializationCount++;  	break;  case '}':  	specializationCount--;  	break;  case ''':  	if (specializationCount == 0) {  		types.Add ("T:" + typelist.Substring (start' index - start));  		start = index + 1;  	}  	break;  }  
Missing Default,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteVisibility,The following switch statement is missing a default case: switch (visibility) {  case "public":  	writer.WriteKeyword ("Public");  	break;  case "family":  	writer.WriteKeyword ("Protected");  	break;  case "family or assembly":  	writer.WriteKeyword ("Protected Friend");  	break;  case "family and assembly":  	writer.WriteKeyword ("Friend");  	// not right' but same outside assembly  	break;  case "assembly":  	writer.WriteKeyword ("Friend");  	break;  case "private":  	writer.WriteKeyword ("Private");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (value.LocalName) {  case "nullValue":  	writer.WriteKeyword ("Nothing");  	break;  case "typeValue":  	writer.WriteKeyword ("GetType");  	writer.WriteString ("(");  	WriteTypeReference (value.SelectSingleNode (typeExpression)' writer);  	writer.WriteString (")");  	break;  case "enumValue":  	XPathNodeIterator fields = value.SelectChildren (XPathNodeType.Element);  	while (fields.MoveNext ()) {  		string name = fields.Current.GetAttribute ("name"' String.Empty);  		if (fields.CurrentPosition > 1) {  			writer.WriteString (" ");  			writer.WriteKeyword ("Or");  			writer.WriteString (" ");  		}  		WriteTypeReference (type' writer);  		writer.WriteString (".");  		writer.WriteString (name);  	}  	break;  case "value":  	string text = value.Value;  	string typeId = type.GetAttribute ("api"' String.Empty);  	switch (typeId) {  	case "T:System.String":  		writer.WriteString ("\"");  		writer.WriteString (text);  		writer.WriteString ("\"");  		break;  	case "T:System.Boolean":  		bool bool_value = Convert.ToBoolean (text);  		if (bool_value) {  			writer.WriteKeyword ("True");  		} else {  			writer.WriteKeyword ("False");  		}  		break;  	case "T:System.Char":  		writer.WriteString ("\"");  		writer.WriteString (text);  		writer.WriteString ("\"C");  		break;  	}  	break;  }  
Missing Default,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteValue,The following switch statement is missing a default case: switch (typeId) {  case "T:System.String":  	writer.WriteString ("\"");  	writer.WriteString (text);  	writer.WriteString ("\"");  	break;  case "T:System.Boolean":  	bool bool_value = Convert.ToBoolean (text);  	if (bool_value) {  		writer.WriteKeyword ("True");  	} else {  		writer.WriteKeyword ("False");  	}  	break;  case "T:System.Char":  	writer.WriteString ("\"");  	writer.WriteString (text);  	writer.WriteString ("\"C");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,VisualBasicDeclarationSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicDeclarationSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' String.Empty));  	XPathNavigator element = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (element' writer);  	writer.WriteString ("(");  	for (int i = 1; i < rank; i++) {  		writer.WriteString ("'");  	}  	writer.WriteString (")");  	break;  case "pointerTo":  	XPathNavigator pointee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (pointee' writer);  	writer.WriteString ("*");  	break;  case "referenceTo":  	XPathNavigator referee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (referee' writer);  	break;  case "type":  	string id = reference.GetAttribute ("api"' String.Empty);  	WriteNormalTypeReference (id' writer);  	XPathNodeIterator typeModifiers = reference.Select (typeModifiersExpression);  	while (typeModifiers.MoveNext ()) {  		WriteTypeReference (typeModifiers.Current' writer);  	}  	break;  case "template":  	string name = reference.GetAttribute ("name"' String.Empty);  	writer.WriteString (name);  	XPathNodeIterator modifiers = reference.Select (typeModifiersExpression);  	while (modifiers.MoveNext ()) {  		WriteTypeReference (modifiers.Current' writer);  	}  	break;  case "specialization":  	writer.WriteString ("(");  	writer.WriteKeyword ("Of");  	writer.WriteString (" ");  	XPathNodeIterator arguments = reference.Select (specializationArgumentsExpression);  	while (arguments.MoveNext ()) {  		if (arguments.CurrentPosition > 1)  			writer.WriteString ("' ");  		WriteTypeReference (arguments.Current' writer);  	}  	writer.WriteString (")");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteOperatorSyntax,The following switch statement is missing a default case: switch (type) {  case -1:  	writer.WriteIdentifier (identifier);  	parameters.MoveNext ();  	writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  	break;  case +1:  	parameters.MoveNext ();  	writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  	writer.WriteIdentifier (identifier);  	break;  case 2:  	writer.WriteString ("(");  	// parameter 1  	parameters.MoveNext ();  	writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  	writer.WriteString (" ");  	writer.WriteIdentifier (identifier);  	writer.WriteString (" ");  	// parameter 2  	parameters.MoveNext ();  	writer.WriteParameter ((string)parameters.Current.Evaluate (parameterNameExpression));  	writer.WriteString (")");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,VisualBasicUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\VisualBasicUsageSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' String.Empty));  	XPathNavigator element = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (element' writer);  	writer.WriteString ("(");  	for (int i = 1; i < rank; i++) {  		writer.WriteString ("'");  	}  	writer.WriteString (")");  	break;  case "pointerTo":  	XPathNavigator pointee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (pointee' writer);  	writer.WriteString ("*");  	break;  case "referenceTo":  	XPathNavigator referee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (referee' writer);  	break;  case "type":  	string id = reference.GetAttribute ("api"' String.Empty);  	WriteNormalTypeReference (id' writer);  	XPathNodeIterator typeModifiers = reference.Select (typeModifiersExpression);  	while (typeModifiers.MoveNext ()) {  		WriteTypeReference (typeModifiers.Current' writer);  	}  	break;  case "template":  	string name = reference.GetAttribute ("name"' String.Empty);  	writer.WriteString (name);  	XPathNodeIterator modifiers = reference.Select (typeModifiersExpression);  	while (modifiers.MoveNext ()) {  		WriteTypeReference (modifiers.Current' writer);  	}  	break;  case "specialization":  	writer.WriteString ("(");  	writer.WriteKeyword ("Of");  	writer.WriteString (" ");  	XPathNodeIterator arguments = reference.Select (specializationArgumentsExpression);  	while (arguments.MoveNext ()) {  		if (arguments.CurrentPosition > 1)  			writer.WriteString ("' ");  		WriteTypeReference (arguments.Current' writer);  	}  	writer.WriteString (")");  	break;  }  
Missing Default,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteSyntax,The following switch statement is missing a default case: switch (group) {  case "namespace":  	WriteNamespaceSyntax (reflection' writer);  	break;  case "type":  	WriteTypeSyntax (reflection' writer);  	break;  case "member":  	WriteMemberSyntax (reflection' writer);  	break;  }  
Missing Default,Microsoft.Ddue.Tools,XamlUsageSyntaxGenerator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\BuildAssembler\SyntaxComponents\XamlUsageSyntax.cs,WriteTypeReference,The following switch statement is missing a default case: switch (reference.LocalName) {  case "arrayOf":  	int rank = Convert.ToInt32 (reference.GetAttribute ("rank"' String.Empty));  	XPathNavigator element = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (element' writer);  	writer.WriteString ("[");  	for (int i = 1; i < rank; i++) {  		writer.WriteString ("'");  	}  	writer.WriteString ("]");  	break;  case "pointerTo":  	XPathNavigator pointee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (pointee' writer);  	writer.WriteString ("*");  	break;  case "referenceTo":  	XPathNavigator referee = reference.SelectSingleNode (typeExpression);  	WriteTypeReference (referee' writer);  	break;  case "type":  	string id = reference.GetAttribute ("api"' String.Empty);  	XPathNavigator outerTypeReference = reference.SelectSingleNode (typeOuterTypeExpression);  	if (outerTypeReference != null) {  		WriteTypeReference (outerTypeReference' writer);  		writer.WriteString (".");  	}  	WriteNormalTypeReference (id' writer);  	XPathNodeIterator typeModifiers = reference.Select (typeModifiersExpression);  	while (typeModifiers.MoveNext ()) {  		WriteTypeReference (typeModifiers.Current' writer);  	}  	break;  case "template":  	string name = reference.GetAttribute ("name"' String.Empty);  	writer.WriteString (name);  	XPathNodeIterator modifiers = reference.Select (typeModifiersExpression);  	while (modifiers.MoveNext ()) {  		WriteTypeReference (modifiers.Current' writer);  	}  	break;  case "specialization":  	writer.WriteString ("<");  	XPathNodeIterator arguments = reference.Select (specializationArgumentsExpression);  	while (arguments.MoveNext ()) {  		if (arguments.CurrentPosition > 1)  			writer.WriteString ("' ");  		WriteTypeReference (arguments.Current' writer);  	}  	writer.WriteString (">");  	break;  }  
