Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,Visit,The method has 458 lines of code.
Long Method,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitTypeNode,The method has 104 lines of code.
Long Method,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitTypeReference,The method has 324 lines of code.
Long Method,System.Compiler,DocumentText,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Equals,The method has 101 lines of code.
Long Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The method has 130 lines of code.
Long Method,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The method has 128 lines of code.
Long Method,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The method has 176 lines of code.
Long Method,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The method has 318 lines of code.
Long Method,System.Compiler,StandardVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\StandardVisitor.cs,Visit,The method has 565 lines of code.
Long Method,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The method has 341 lines of code.
Long Method,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,ClearStatics,The method has 288 lines of code.
Long Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The method has 424 lines of code.
Long Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The method has 131 lines of code.
Long Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,Visit,The method has 254 lines of code.
Long Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The method has 204 lines of code.
Long Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBinaryExpression,The method has 125 lines of code.
Long Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBranch,The method has 158 lines of code.
Long Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The method has 212 lines of code.
Long Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitUnaryExpression,The method has 176 lines of code.
Long Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCustomAttributeLiteral,The method has 142 lines of code.
Long Method,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,FillInVsVersionStructure,The method has 112 lines of code.
Long Method,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The method has 286 lines of code.
Long Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The method has 147 lines of code.
Long Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The method has 292 lines of code.
Long Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The method has 146 lines of code.
Long Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteNTHeader,The method has 112 lines of code.
Long Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The method has 114 lines of code.
Long Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The method has 209 lines of code.
Long Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The method has 181 lines of code.
Long Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The method has 206 lines of code.
Long Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeMembers,The method has 126 lines of code.
Long Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseTypeSignature,The method has 158 lines of code.
Long Method,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The method has 747 lines of code.
Long Method,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ProcessOneILInstruction,The method has 108 lines of code.
Long Method,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The method has 381 lines of code.
Complex Method,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,Visit,Cyclomatic complexity of the method is 229
Complex Method,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitExpression,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitExpression,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitMemberReference,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitMethod,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitTypeNode,Cyclomatic complexity of the method is 13
Complex Method,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitNestedTypes,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitTypeReference,Cyclomatic complexity of the method is 152
Complex Method,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,Cyclomatic complexity of the method is 16
Complex Method,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,DocumentText,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,DocumentText,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Equals,Cyclomatic complexity of the method is 18
Complex Method,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetLineCount,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ComputeLineOffsets,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,CompilerOptions,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,CompilerOptions,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Node,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetVisitorFor,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler,MemberBinding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,MemberBinding,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,AttributeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetUsageInformation,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,AttributeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetRuntimeAttribute,Cyclomatic complexity of the method is 13
Complex Method,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAttributes,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetModuleAttribute,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,Cyclomatic complexity of the method is 14
Complex Method,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,MayAccessInternalTypesOf,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetFriendAssemblies,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,Cyclomatic complexity of the method is 35
Complex Method,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAttribute,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetParameterHelpText,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetHelpText,Cyclomatic complexity of the method is 17
Complex Method,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AppendValue,Cyclomatic complexity of the method is 14
Complex Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetUnmangledNameWithTypeParameters,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetSerializedTypeName,Cyclomatic complexity of the method is 13
Complex Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TryToFindExistingInstance,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTypeNode,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetVisibilityIntersection,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsInheritedFrom,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,DeepStripModifiers,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,DeepStripModifiers,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Class,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAbstractMethods,Cyclomatic complexity of the method is 16
Complex Method,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAliasFor,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetNamespaceFullNameFor,Cyclomatic complexity of the method is 16
Complex Method,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,Cyclomatic complexity of the method is 35
Complex Method,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,Cyclomatic complexity of the method is 49
Complex Method,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetReferencedTypes,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,DelegateNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ProvideMembers,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,FunctionType,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,For,Cyclomatic complexity of the method is 21
Complex Method,System.Compiler,Interface,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAllDefaultMembers,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,ArrayType,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetMembersNamed,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,FunctionPointer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,For,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetDocumentationId,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetUnmangledNameWithoutTypeParameters,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetUnmangledNameWithTypeParameters,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetVisibilityUnion,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetMethodInfo,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler,InstanceInitializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetConstructorInfo,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,StaticInitializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetConstructorInfo,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Property,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetPropertyInfo,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Parameter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAttribute,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,Cyclomatic complexity of the method is 122
Complex Method,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitBinaryExpression,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitExpression,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,StandardVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\StandardVisitor.cs,Visit,Cyclomatic complexity of the method is 237
Complex Method,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV2Beta1,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetDummyTypeNode,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,Unstacker,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Unstacker.cs,VisitMethod,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,Cyclomatic complexity of the method is 224
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAliasDefinitionList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssemblyReferenceList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAttributeList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitBlockList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitCatchList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitCompilationUnitList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitExpressionList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitFaultHandlerList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitFieldList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitNodeList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCustomAttributeSignature,Cyclomatic complexity of the method is 14
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,Cyclomatic complexity of the method is 27
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,Cyclomatic complexity of the method is 63
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,Cyclomatic complexity of the method is 25
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetLocalVarIndex,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMethodIndex,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMethodSpecIndex,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetStaticDataIndex,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeSpecIndex,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetUnspecializedField,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetUnspecializedMethod,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateConstantTable,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,Cyclomatic complexity of the method is 63
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,Cyclomatic complexity of the method is 29
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateFileTable,Cyclomatic complexity of the method is 16
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateGenericParamTable,Cyclomatic complexity of the method is 14
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateGenericParamConstraintTable,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMethodSemanticsTable,Cyclomatic complexity of the method is 14
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeDefTable,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,Visit,Cyclomatic complexity of the method is 185
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAddressDereference,Cyclomatic complexity of the method is 27
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAttributeList,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAddressOf,Cyclomatic complexity of the method is 28
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,Cyclomatic complexity of the method is 58
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBinaryExpression,Cyclomatic complexity of the method is 107
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBlock,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBranch,Cyclomatic complexity of the method is 98
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodCall,Cyclomatic complexity of the method is 20
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitClass,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitEvent,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitExpression,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitIndexer,Cyclomatic complexity of the method is 40
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLocal,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,Cyclomatic complexity of the method is 26
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethod,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,Cyclomatic complexity of the method is 45
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitModule,Cyclomatic complexity of the method is 32
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitParameter,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitReferencedType,Cyclomatic complexity of the method is 29
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitStatement,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitUnaryExpression,Cyclomatic complexity of the method is 140
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCustomAttributeLiteral,Cyclomatic complexity of the method is 52
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteMethodSignature,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSerializedTypeName,Cyclomatic complexity of the method is 13
Complex Method,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteTypeSignature,Cyclomatic complexity of the method is 34
Complex Method,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WritePE,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetPublicKey,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AddWin32Icon,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AddWin32ResourceFileToModule,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,ParseVersion,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadASCII,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetValueFromBlob,Cyclomatic complexity of the method is 14
Complex Method,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,Cyclomatic complexity of the method is 185
Complex Method,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadWin32Resources,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeTables,Cyclomatic complexity of the method is 42
Complex Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeFieldRvaTable,Cyclomatic complexity of the method is 13
Complex Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,Cyclomatic complexity of the method is 249
Complex Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,Cyclomatic complexity of the method is 19
Complex Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,SetupDebugReader,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,Cyclomatic complexity of the method is 23
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMethodsToProperty,Cyclomatic complexity of the method is 20
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMethodsToEvent,Cyclomatic complexity of the method is 25
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributeLiteralValue,Cyclomatic complexity of the method is 21
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ConstructCustomAttributeLiteralArray,Cyclomatic complexity of the method is 21
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,Cyclomatic complexity of the method is 22
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseSimpleTypeName,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSecurityAttributesFor,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeParameterConstraints,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeParametersFor,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetGenericParameter,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetGenericParameterConstraints,Cyclomatic complexity of the method is 14
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetFieldFromDef,Cyclomatic complexity of the method is 13
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,Cyclomatic complexity of the method is 55
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetLiteral,Cyclomatic complexity of the method is 48
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,Cyclomatic complexity of the method is 19
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,Cyclomatic complexity of the method is 43
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromToken,Cyclomatic complexity of the method is 24
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,Cyclomatic complexity of the method is 71
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,RemoveTypeParametersBelongToDeclaringType,Cyclomatic complexity of the method is 8
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeExtensionFromDef,Cyclomatic complexity of the method is 9
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeFromRef,Cyclomatic complexity of the method is 25
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,Cyclomatic complexity of the method is 32
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetNestedTypes,Cyclomatic complexity of the method is 12
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeMembers,Cyclomatic complexity of the method is 26
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeSignatureIsClass,Cyclomatic complexity of the method is 15
Complex Method,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseTypeSignature,Cyclomatic complexity of the method is 95
Complex Method,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,Cyclomatic complexity of the method is 11
Complex Method,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,Cyclomatic complexity of the method is 22
Complex Method,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayElementAssignment,Cyclomatic complexity of the method is 29
Complex Method,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayElementLoad,Cyclomatic complexity of the method is 41
Complex Method,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseCall,Cyclomatic complexity of the method is 10
Complex Method,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,Cyclomatic complexity of the method is 674
Complex Method,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ProcessOneILInstruction,Cyclomatic complexity of the method is 91
Complex Method,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,Cyclomatic complexity of the method is 27
Complex Method,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,Cyclomatic complexity of the method is 364
Long Parameter List,System.Compiler,GlobalAssemblyCache,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,CreateAssemblyEnum,The method has 5 parameters.
Long Parameter List,System.Compiler,IAssemblyName,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,BindToObject,The method has 8 parameters.
Long Parameter List,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitTypeNode,The method has 5 parameters.
Long Parameter List,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Document,The method has 6 parameters.
Long Parameter List,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Document,The method has 6 parameters.
Long Parameter List,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetOffsets,The method has 6 parameters.
Long Parameter List,System.Compiler,DocumentWithPrecomputedLineNumbers,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,DocumentWithPrecomputedLineNumbers,The method has 5 parameters.
Long Parameter List,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetOffsets,The method has 6 parameters.
Long Parameter List,System.Compiler,SourceContext,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,SourceContext,The method has 5 parameters.
Long Parameter List,System.Compiler,AddressDereference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AddressDereference,The method has 5 parameters.
Long Parameter List,System.Compiler,BinaryExpression,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,BinaryExpression,The method has 5 parameters.
Long Parameter List,System.Compiler,TernaryExpression,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TernaryExpression,The method has 5 parameters.
Long Parameter List,System.Compiler,NameBinding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,NameBinding,The method has 5 parameters.
Long Parameter List,System.Compiler,MethodCall,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,MethodCall,The method has 5 parameters.
Long Parameter List,System.Compiler,Block,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Block,The method has 5 parameters.
Long Parameter List,System.Compiler,Branch,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Branch,The method has 5 parameters.
Long Parameter List,System.Compiler,Try,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Try,The method has 5 parameters.
Long Parameter List,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetModule,The method has 5 parameters.
Long Parameter List,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetModule,The method has 6 parameters.
Long Parameter List,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetModule,The method has 5 parameters.
Long Parameter List,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetModule,The method has 6 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyNode,The method has 5 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The method has 5 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The method has 6 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The method has 5 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The method has 6 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The method has 5 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The method has 6 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The method has 5 parameters.
Long Parameter List,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetStrongName,The method has 5 parameters.
Long Parameter List,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TypeNode,The method has 5 parameters.
Long Parameter List,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TypeNode,The method has 9 parameters.
Long Parameter List,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetArrayType,The method has 5 parameters.
Long Parameter List,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TryToFindExistingInstance,The method has 7 parameters.
Long Parameter List,System.Compiler,Class,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Class,The method has 9 parameters.
Long Parameter List,System.Compiler,DelegateNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,DelegateNode,The method has 8 parameters.
Long Parameter List,System.Compiler,EnumNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,EnumNode,The method has 8 parameters.
Long Parameter List,System.Compiler,Interface,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Interface,The method has 5 parameters.
Long Parameter List,System.Compiler,Interface,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Interface,The method has 8 parameters.
Long Parameter List,System.Compiler,Struct,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Struct,The method has 8 parameters.
Long Parameter List,System.Compiler,TypeParameter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TypeParameter,The method has 5 parameters.
Long Parameter List,System.Compiler,MethodTypeParameter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,MethodTypeParameter,The method has 5 parameters.
Long Parameter List,System.Compiler,ArrayTypeExpression,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ArrayTypeExpression,The method has 5 parameters.
Long Parameter List,System.Compiler,Event,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Event,The method has 8 parameters.
Long Parameter List,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Method,The method has 6 parameters.
Long Parameter List,System.Compiler,ProxyMethod,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ProxyMethod,The method has 6 parameters.
Long Parameter List,System.Compiler,InstanceInitializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,InstanceInitializer,The method has 5 parameters.
Long Parameter List,System.Compiler,ParameterField,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ParameterField,The method has 6 parameters.
Long Parameter List,System.Compiler,Field,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Field,The method has 6 parameters.
Long Parameter List,System.Compiler,Property,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Property,The method has 6 parameters.
Long Parameter List,System.Compiler,Parameter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Parameter,The method has 6 parameters.
Long Parameter List,System.Compiler,Namespace,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Namespace,The method has 6 parameters.
Long Parameter List,System.Compiler,PlatformHelpers,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,StringCompareOrdinalIgnoreCase,The method has 5 parameters.
Long Parameter List,System.Compiler,IParserFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\StandardVisitor.cs,CreateParser,The method has 6 parameters.
Long Parameter List,System.Compiler,ISymUnmanagedWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineLocalVariable,The method has 9 parameters.
Long Parameter List,System.Compiler,ISymUnmanagedWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineParameter,The method has 7 parameters.
Long Parameter List,System.Compiler,ISymUnmanagedWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineField,The method has 9 parameters.
Long Parameter List,System.Compiler,ISymUnmanagedWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineGlobalVariable,The method has 8 parameters.
Long Parameter List,System.Compiler,ISymUnmanagedWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetMethodSourceRange,The method has 6 parameters.
Long Parameter List,System.Compiler,ISymUnmanagedWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineSequencePoints,The method has 7 parameters.
Long Parameter List,System.Compiler,ISymUnmanagedWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,Initialize2,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineNestedType,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineMethod,The method has 7 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineImportType,The method has 6 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineImportMember,The method has 7 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineEvent,The method has 8 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetEventProps,The method has 7 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineField,The method has 8 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineProperty,The method has 11 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineParam,The method has 7 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetFieldProps,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetPropertyProps,The method has 8 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetParamProps,The method has 6 parameters.
Long Parameter List,System.Compiler,IMetaDataEmit,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,TranslateSigWithScope,The method has 10 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefProps,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumMembersWithName,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumMethodsWithName,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumFieldsWithName,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumMethodImpls,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumPermissionSets,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMethodProps,The method has 9 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefProps,The method has 6 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetEventProps,The method has 12 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetClassLayout,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetPinvokeMap,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumCustomAttributes,The method has 5 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberProps,The method has 12 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetFieldProps,The method has 10 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetPropertyProps,The method has 15 parameters.
Long Parameter List,System.Compiler,IMetaDataImport,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetParamProps,The method has 9 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineSequencePoints,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineNestedType,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineMethod,The method has 7 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineImportType,The method has 6 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineImportMember,The method has 7 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineEvent,The method has 8 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetEventProps,The method has 7 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineField,The method has 8 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineProperty,The method has 11 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineParam,The method has 7 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetFieldProps,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetPropertyProps,The method has 8 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetParamProps,The method has 6 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,TranslateSigWithScope,The method has 10 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefProps,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumMembersWithName,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumMethodsWithName,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumFieldsWithName,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumMethodImpls,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumPermissionSets,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMethodProps,The method has 9 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefProps,The method has 6 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetEventProps,The method has 12 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetClassLayout,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetPinvokeMap,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,EnumCustomAttributes,The method has 5 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberProps,The method has 12 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetFieldProps,The method has 10 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetPropertyProps,The method has 15 parameters.
Long Parameter List,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetParamProps,The method has 9 parameters.
Long Parameter List,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WritePE,The method has 6 parameters.
Long Parameter List,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,StrongNameSignatureGeneration,The method has 6 parameters.
Long Parameter List,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,MscorsnStrongNameSignatureGeneration,The method has 6 parameters.
Long Parameter List,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,StrongNameGetPublicKey,The method has 5 parameters.
Long Parameter List,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,MscorsnStrongNameGetPublicKeyUsing,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,MemoryMappedFile,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,CreateFileMapping,The method has 6 parameters.
Long Parameter List,System.Compiler.Metadata,MemoryMappedFile,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,MapViewOfFile,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadWin32ResourceDataEntry,The method has 7 parameters.
Long Parameter List,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The method has 7 parameters.
Long Parameter List,System.Compiler.Metadata,IMetaDataDispenser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,OpenScopeOnMemory,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,ISymUnmanagedBinder2,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetReaderForFile2,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,ISymUnmanagedReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSymAttribute,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,ISymUnmanagedReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodsFromDocumentPosition,The method has 6 parameters.
Long Parameter List,System.Compiler.Metadata,ISymUnmanagedMethod,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetRanges,The method has 6 parameters.
Long Parameter List,System.Compiler.Metadata,ISymUnmanagedMethod,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSequencePoints,The method has 8 parameters.
Long Parameter List,System.Compiler.Metadata,ISymUnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSourceRange,The method has 7 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,Reader,The method has 6 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,Reader,The method has 6 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,Reader,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ReadFile,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddFieldsToType,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetUnderlyingTypeOfEnumNode,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddPropertiesToType,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddEventsToType,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,The method has 8 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DummyTypeExtensionProvider,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeExtensionFromDef,The method has 6 parameters.
Long Parameter List,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetDummyTypeNode,The method has 5 parameters.
Long Parameter List,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseBranch,The method has 5 parameters.
Long Identifier,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ImplementsExplicitly,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The length of the parameter returnNullIfHiddenByNestedNamespace is 35.
Long Identifier,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineLocalVariables,The length of the parameter posOfFirstInstructionOfNextBlock is 32.
Long Identifier,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,ForceTemplateTypeMethodBodiesToGetSpecialized,The length of the parameter savedNewTemplateInstanceIsRecursive is 35.
Long Identifier,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the parameter customAttributeConstructorRefSize is 33.
Long Identifier,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the parameter customAttributeConstructorRefSize is 33.
Long Identifier,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodBody,The length of the parameter savedCurrentMethodTypeParameters is 32.
Long Identifier,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodInstructions,The length of the parameter savedCurrentMethodTypeParameters is 32.
Long Identifier,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The length of the parameter savedCurrentMethodTypeParameters is 32.
Long Identifier,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodAttributes,The length of the parameter savedCurrentMethodTypeParameters is 32.
Long Statement,System.Compiler,AssemblyName,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,GetLocation,The length of the statement  "	assemblyCache.QueryAssemblyInfo (ASSEMBLYINFO_FLAG.VALIDATE | ASSEMBLYINFO_FLAG.GETSIZE' this.StrongName' ref assemblyInfo); " is 124.
Long Statement,System.Compiler,AssemblyName,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,GetLocation,The length of the statement  "	assemblyCache.QueryAssemblyInfo (ASSEMBLYINFO_FLAG.VALIDATE | ASSEMBLYINFO_FLAG.GETSIZE' this.StrongName' ref assemblyInfo); " is 124.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitAssembly,The length of the statement  "		assembly1.SecurityAttributes = this.VisitSecurityAttributeList (assembly1.SecurityAttributes' assembly2.SecurityAttributes); " is 124.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitAssignmentExpression,The length of the statement  "		assignment1.AssignmentStatement = (Statement)this.Visit (assignment1.AssignmentStatement' assignment2.AssignmentStatement); " is 123.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitCompilation,The length of the statement  "	compilation1.CompilationUnits = this.VisitCompilationUnitList (compilation1.CompilationUnits' compilation2 == null ? null : compilation2.CompilationUnits); " is 155.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitField,The length of the statement  "		field1.ImplementedInterfaces = this.VisitInterfaceReferenceList (field1.ImplementedInterfaces' field2.ImplementedInterfaces); " is 125.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitFunctionDeclaration,The length of the statement  "		functionDeclaration1.Parameters = this.VisitParameterList (functionDeclaration1.Parameters' functionDeclaration2.Parameters); " is 125.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitFunctionDeclaration,The length of the statement  "		functionDeclaration1.ReturnType = this.VisitTypeReference (functionDeclaration1.ReturnType' functionDeclaration2.ReturnType); " is 125.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitTemplateInstance,The length of the statement  "		genericInstance1.TypeArguments = this.VisitTypeReferenceList (genericInstance1.TypeArguments' genericInstance2.TypeArguments); " is 126.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitInterfaceReferenceList,The length of the statement  "	for (int i = 0' n = interfaceReferences1.Count' m = interfaceReferences2 == null ? 0 : interfaceReferences2.Count; i < n; i++) { " is 128.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitLocalDeclarationList,The length of the statement  "	for (int i = 0' n = localDeclarations1.Count' m = localDeclarations2 == null ? 0 : localDeclarations2.Count; i < n; i++) { " is 122.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitLocalDeclarationsStatement,The length of the statement  "		localDeclarations1.Declarations = this.VisitLocalDeclarationList (localDeclarations1.Declarations' localDeclarations2.Declarations); " is 132.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitQuantifier,The length of the statement  "		quantifier1.Comprehension = (Comprehension)this.VisitComprehension (quantifier1.Comprehension' quantifier2.Comprehension); " is 122.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitComprehension,The length of the statement  "		comprehension1.BindingsAndFilters = this.VisitExpressionList (comprehension1.BindingsAndFilters' comprehension2.BindingsAndFilters); " is 132.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitComprehensionBinding,The length of the statement  "		comprehensionBinding1.TargetVariableType = this.VisitTypeReference (comprehensionBinding1.TargetVariableType' comprehensionBinding2.TargetVariableType); " is 152.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitComprehensionBinding,The length of the statement  "		comprehensionBinding1.TargetVariable = this.VisitTargetExpression (comprehensionBinding1.TargetVariable' comprehensionBinding2.TargetVariable); " is 143.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitComprehensionBinding,The length of the statement  "		comprehensionBinding1.SourceEnumerable = this.VisitExpression (comprehensionBinding1.SourceEnumerable' comprehensionBinding2.SourceEnumerable); " is 143.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitResourceUse,The length of the statement  "		resourceUse1.ResourceAcquisition = (Statement)this.Visit (resourceUse1.ResourceAcquisition' resourceUse2.ResourceAcquisition); " is 126.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitTypeswitchCase,The length of the statement  "		typeswitchCase1.LabelVariable = this.VisitTargetExpression (typeswitchCase1.LabelVariable' typeswitchCase2.LabelVariable); " is 122.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitTypeNode,The length of the statement  "		typeNode1.SecurityAttributes = this.VisitSecurityAttributeList (typeNode1.SecurityAttributes' typeNode2.SecurityAttributes); " is 124.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitTypeNode,The length of the statement  "		typeNode1.TemplateParameters = this.VisitTypeParameterList (typeNode1.TemplateParameters' typeNode2.TemplateParameters); " is 120.
Long Statement,System.Compiler,StandardDoubleVisitor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\DoubleVisitor.cs,VisitVariableDeclaration,The length of the statement  "		variableDeclaration1.Initializer = this.VisitExpression (variableDeclaration1.Initializer' variableDeclaration2.Initializer); " is 125.
Long Statement,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitMemberReference,The length of the statement  "	if (method != null && method.Template != null && method.TemplateArguments != null && method.TemplateArguments.Count > 0) { " is 122.
Long Statement,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitModuleReference,The length of the statement  "	for (int i = 0' n = this.TargetModule.ModuleReferences == null ? 0 : this.TargetModule.ModuleReferences.Count; i < n; i++) { " is 124.
Long Statement,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitTypeReference,The length of the statement  "		dup = FunctionType.For (this.VisitTypeReference (ftype.ReturnType)' this.VisitParameterList (ftype.Parameters)' this.TargetType); " is 129.
Long Statement,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitTypeReference,The length of the statement  "		if (type.Template != null && type.Template != type && (type.TemplateArguments != null || (!this.RecordOriginalAsTemplate && type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))) { " is 219.
Long Statement,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,ChangeExtension,The length of the statement  "		if (((ch1 == BetterPath.DirectorySeparatorChar) || (ch1 == BetterPath.AltDirectorySeparatorChar)) || (ch1 == BetterPath.VolumeSeparatorChar)) " is 141.
Long Statement,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Combine,The length of the statement  "	if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || (path2.Length >= 2 && path2 [1] == BetterPath.VolumeSeparatorChar)) " is 160.
Long Statement,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Combine,The length of the statement  "	if (ch != BetterPath.DirectorySeparatorChar && ch != BetterPath.AltDirectorySeparatorChar && ch != BetterPath.VolumeSeparatorChar) " is 130.
Long Statement,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetExtension,The length of the statement  "		if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || ch == BetterPath.VolumeSeparatorChar) " is 130.
Long Statement,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetFileName,The length of the statement  "		if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || ch == BetterPath.VolumeSeparatorChar) " is 130.
Long Statement,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetDirectoryName,The length of the statement  "		if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || ch == BetterPath.VolumeSeparatorChar) " is 130.
Long Statement,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,HasExtension,The length of the statement  "			if (((ch1 == BetterPath.DirectorySeparatorChar) || (ch1 == BetterPath.AltDirectorySeparatorChar)) || (ch1 == BetterPath.VolumeSeparatorChar)) { " is 143.
Long Statement,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,DeleteLines,The length of the statement  "	Debug.Assert (offset >= 0 && this.Text != null && offset < this.Text.Length && lineCount > 0 && this.lineOffsets != null); " is 122.
Long Statement,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,InsertLines,The length of the statement  "	Debug.Assert (offset >= 0 && this.Text != null && offset < this.Text.Length && lineCount > 0 && this.lineOffsets != null); " is 122.
Long Statement,System.Compiler,SourceContext,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Encloses,The length of the statement  "	return this.StartPos <= sourceContext.StartPos && this.EndPos >= sourceContext.EndPos && this.EndPos > sourceContext.StartPos; " is 126.
Long Statement,System.Compiler,AttributeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,SetAttributeProperty,The length of the statement  "	//Because we invoke the setter through reflection' a stack walk is performed. The following two commented-out statements " is 120.
Long Statement,System.Compiler,AttributeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,SetAttributeProperty,The length of the statement  "	//System.Security.PermissionSet perm = new System.Security.PermissionSet(System.Security.Permissions.PermissionState.None); " is 123.
Long Statement,System.Compiler,AttributeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ConstructAttribute,The length of the statement  "	//Because we invoke the constructor through reflection' a stack walk is performed. The following two commented-out statements " is 125.
Long Statement,System.Compiler,AttributeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ConstructAttribute,The length of the statement  "	//System.Security.PermissionSet perm = new System.Security.PermissionSet(System.Security.Permissions.PermissionState.None); " is 123.
Long Statement,System.Compiler,SecurityAttribute,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetSecurityElement,The length of the statement  "	System.Reflection.MethodInfo getTopElement = parserType.GetMethod ("GetTopElement"' BindingFlags.NonPublic | BindingFlags.Instance' null' new Type[] { " is 150.
Long Statement,System.Compiler,SecurityAttribute,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetSecurityElement,The length of the statement  "	object parser = Activator.CreateInstance (parserType' BindingFlags.Instance | BindingFlags.NonPublic' null' new Object[] { " is 122.
Long Statement,System.Compiler,SecurityAttribute,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,InstantiatePermissionAttributes,The length of the statement  "	System.Security.PermissionSet permissions = new System.Security.PermissionSet (System.Security.Permissions.PermissionState.None); " is 129.
Long Statement,System.Compiler,SecurityAttribute,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetPermissionOrSetOfPermissionsFromAttribute,The length of the statement  "	System.Security.Permissions.SecurityAttribute secAttr = attr.GetRuntimeAttribute () as System.Security.Permissions.SecurityAttribute; " is 133.
Long Statement,System.Compiler,SecurityAttribute,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetPermissionOrSetOfPermissionsFromAttribute,The length of the statement  "	System.Security.Permissions.PermissionSetAttribute pSetAttr = secAttr as System.Security.Permissions.PermissionSetAttribute; " is 124.
Long Statement,System.Compiler,SecurityAttribute,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,CreatePermission,The length of the statement  "	System.Security.PermissionSet perm = new System.Security.PermissionSet (System.Security.Permissions.PermissionState.None); " is 122.
Long Statement,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The length of the statement  "	return this.GetType (@namespace' name' lookInReferencedAssemblies' lookInReferencedAssemblies ? new TrivialHashtable () : null); " is 128.
Long Statement,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetModule,The length of the statement  "	return (new Reader (location' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches)).ReadModule (); " is 120.
Long Statement,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Dispose,The length of the statement  "		AssemblyReference aRef = (AssemblyReference)TargetPlatform.AssemblyReferenceFor [Identifier.For (this.Name).UniqueIdKey]; " is 121.
Long Statement,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The length of the statement  "	return (new Reader (buffer' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches)).ReadModule () as AssemblyNode; " is 134.
Long Statement,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The length of the statement  "	return (new Reader (location' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches)).ReadModule () as AssemblyNode; " is 136.
Long Statement,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssembly,The length of the statement  "		return AssemblyNode.GetAssembly (runtimeAssembly.Location' cache' false' getDebugInfo' useGlobalCache' preserveShortBranches); " is 126.
Long Statement,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ParseAssignment,The length of the statement  "	throw new ArgumentException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.InvalidAssemblyStrongName' assemblyStrongName)' "assemblyStrongName"); " is 159.
Long Statement,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Matches,The length of the statement  "	if (PlatformHelpers.StringCompareOrdinalIgnoreCase (this.Name' name) != 0 || PlatformHelpers.StringCompareOrdinalIgnoreCase (this.Culture' culture) != 0) " is 153.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetFullUnmangledNameWithoutTypeParameters,The length of the statement  "		return this.DeclaringType.GetFullUnmangledNameWithoutTypeParameters () + "+" + this.GetUnmangledNameWithoutTypeParameters (); " is 125.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetFullUnmangledNameWithTypeParameters,The length of the statement  "		return this.DeclaringType.GetFullUnmangledNameWithTypeParameters () + "+" + this.GetUnmangledNameWithTypeParameters (true); " is 123.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetArrayType,The length of the statement  "	return this.GetArrayType (rank' sizes == null ? 0 : sizes.Length' loBounds == null ? 0 : loBounds.Length' sizes == null ? new int[0] : sizes' loBounds == null ? new int[0] : loBounds); " is 184.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetConstructors,The length of the statement  "		return this.constructors = TypeNode.WeedOutNonSpecialMethods (this.GetMembersNamed (StandardIds.Ctor)' MethodFlags.RTSpecialName); " is 130.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetModified,The length of the statement  "	result = optionalModifier ? (TypeNode)new OptionalModifier (modifierType' this) : (TypeNode)new RequiredModifier (modifierType' this); " is 134.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TryToFindExistingInstance,The length of the statement  "	result = module.GetStructurallyEquivalentType (this.Namespace == null ? Identifier.Empty : this.Namespace' mangledName' uniqueMangledName' lookInReferencedAssemblies); " is 167.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TryToFindExistingInstance,The length of the statement  "		//Mangled name is the same. But mangling is not unique (types are not qualified with assemblies)' so check for equality. " is 120.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TryToFindExistingInstance,The length of the statement  "		result = module.GetStructurallyEquivalentType (this.Namespace == null ? Identifier.Empty : this.Namespace' mangledName' null' lookInReferencedAssemblies); " is 154.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "	if (module == null || templateArguments == null || (declaringType == null && (templateParameters == null || templateParameters.Count == 0))) " is 140.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "	Identifier mangledName = this.GetMangledTemplateInstanceName (templateArguments' out uniqueMangledName' out notFullySpecialized); " is 129.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "	this.TryToFindExistingInstance (module' declaringType' templateArguments' mangledName' uniqueMangledName' out result' out dummyId); " is 131.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "		this.TryToFindExistingInstance (module' declaringType' templateArguments' mangledName' uniqueMangledName' out result' out unusedMangledName); " is 141.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "		TypeNodeList consolidatedTemplateArguments = declaringType == null ? templateArguments : declaringType.GetConsolidatedTemplateArguments (templateArguments); " is 156.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "		result = duplicator.VisitTypeNode (this' unusedMangledName' consolidatedTemplateArguments' this.Template == null ? this : this.Template' true); " is 143.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "		        //Arrange for template instance to be emitted to module and to be recognized as a template instance when imported from module." is 126.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "        attr.Target = AttributeTargets.Delegate|AttributeTargets.Class|AttributeTargets.Enum|AttributeTargets.Interface|AttributeTargets.Struct;" is 136.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetOpFalse,The length of the statement  "					if (!opFalse.IsSpecialName || !opFalse.IsStatic || !opFalse.IsPublic || opFalse.ReturnType != CoreSystemTypes.Boolean || opFalse.Parameters == null || opFalse.Parameters.Count != 1) " is 181.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetOpTrue,The length of the statement  "					if (!opTrue.IsSpecialName || !opTrue.IsStatic || !opTrue.IsPublic || opTrue.ReturnType != CoreSystemTypes.Boolean || opTrue.Parameters == null || opTrue.Parameters.Count != 1) " is 175.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetRuntimeType,The length of the statement  "			} else if (this.DeclaringModule != null && this.DeclaringModule.IsNormalized && this.DeclaringModule.ContainingAssembly != null) { " is 130.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetImplementingMethod,The length of the statement  "		if ((locM.ReturnType != meth.ReturnType && !(locM.ReturnType != null && locM.ReturnType.IsStructurallyEquivalentTo (meth.ReturnType))) || !locM.ParametersMatchStructurally (meth.Parameters)) " is 190.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "	if (targetType == CoreSystemTypes.Object || this.IsStructurallyEquivalentTo (targetType) || this.BaseType != null && (this.BaseType.IsAssignableTo (targetType))) " is 161.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "	if (this.BaseType != null && this.ConsolidatedTemplateParameters != null && this.BaseType.Template != null && this.BaseType.Template.IsAssignableTo (targetType)) " is 161.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "	//When seeing if one template is assignable to another' be sure to strip off template instances along the inheritance chain " is 123.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "		if (iface.Template != null && this.ConsolidatedTemplateParameters != null && iface.Template.IsAssignableTo (targetType)) " is 120.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "		//When seeing if one template is assignable to another' be sure to strip off template instances along the inheritance chain " is 123.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableToInstanceOf,The length of the statement  "	if (targetTemplate.IsStructurallyEquivalentTo (this.Template == null ? this : this.Template) || this.BaseType != null && (this.BaseType.IsAssignableToInstanceOf (targetTemplate) || this.BaseType.Template != null && this.BaseType.Template.IsAssignableToInstanceOf (targetTemplate))) " is 281.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableToInstanceOf,The length of the statement  "	if (this != CoreSystemTypes.Object && this.BaseType != null && this.BaseType.IsAssignableToInstanceOf (targetTemplate' out templateArguments)) " is 142.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsStructurallyEquivalentTo,The length of the statement  "		if (this.DeclaringType != null && (this.TemplateArguments == null || this.TemplateArguments.Count == 0) && (type.TemplateArguments == null || type.TemplateArguments.Count == 0)) " is 177.
Long Statement,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,DeepStripModifiers,The length of the statement  "			TypeNodeList templateTypeArgs = templateType.TemplateArguments != null ? templateType.TemplateArguments : templateType.TemplateParameters; " is 138.
Long Statement,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetNamespaceFullNameFor,The length of the statement  "	if (name == null || this.AssociatedNamespace == null || this.AssociatedModule == null || this.nestedNamespaceFullName == null) { " is 128.
Long Statement,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The length of the statement  "			if (nsScope.AssociatedNamespace.FullNameId != null && nsScope.AssociatedNamespace.FullNameId.UniqueIdKey != Identifier.Empty.UniqueIdKey) " is 137.
Long Statement,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The length of the statement  "				if (nsScope.AssociatedNamespace.FullNameId != null && nsScope.AssociatedNamespace.FullNameId.UniqueIdKey != Identifier.Empty.UniqueIdKey) " is 137.
Long Statement,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The length of the statement  "		if (this.AssociatedNamespace.FullName != null && this.AssociatedNamespace.Name.UniqueIdKey != Identifier.Empty.UniqueIdKey) " is 123.
Long Statement,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The length of the statement  "		//If the namespace (or an outer namespace) has an alias definition with this name it wins. (Expected to be mutually exclusive with above.)         " is 138.
Long Statement,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The length of the statement  "			if (result == null && returnNullIfHiddenByNestedNamespace && nsScope != null && nsScope.AliasedNamespace != null && nsScope.AliasedNamespace [name.UniqueIdKey] != null) " is 168.
Long Statement,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The length of the statement  "	if (duplicates != null && duplicates.Count > 1 && this.AssociatedNamespace != null && this.AssociatedNamespace.Name != null && this.AssociatedNamespace.Name.Name != null) { " is 172.
Long Statement,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsNotAccessible,The length of the statement  "	return !dup.IsPublic && (associatedAssembly == null || !associatedAssembly.MayAccessInternalTypesOf (dup.DeclaringModule as AssemblyNode)) && !this.AssociatedModule.ContainsModule (dup.DeclaringModule); " is 202.
Long Statement,System.Compiler,DelegateNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ProvideMembers,The length of the statement  "	parameters.Add (new Parameter (null' ParameterFlags.None' StandardIds.callback' SystemTypes.AsyncCallback' null' null)); " is 120.
Long Statement,System.Compiler,FunctionType,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,For,The length of the statement  "		//Mangled name is the same. But mangling is not unique (types are not qualified with assemblies)' so check for equality. " is 120.
Long Statement,System.Compiler,ArrayType,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "	if (targetType == this || targetType == CoreSystemTypes.Object || targetType == CoreSystemTypes.Array || targetType == SystemTypes.ICloneable) " is 142.
Long Statement,System.Compiler,ArrayType,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "	if (targetType.Template != null && SystemTypes.GenericIEnumerable != null && SystemTypes.GenericIEnumerable.DeclaringModule == CoreSystemTypes.SystemAssembly) { " is 160.
Long Statement,System.Compiler,ArrayType,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "		if (targetType.Template == SystemTypes.GenericIEnumerable || targetType.Template == SystemTypes.GenericICollection || targetType.Template == SystemTypes.GenericIList) { " is 168.
Long Statement,System.Compiler,Reference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "	return targetType == this || (targetType is Pointer && (((Pointer)targetType).ElementType == this.ElementType || ((Pointer)targetType).ElementType == CoreSystemTypes.Void)); " is 173.
Long Statement,System.Compiler,TypeModifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsStructurallyEquivalentTo,The length of the statement  "	if (this.ModifiedType != t.ModifiedType && (this.ModifiedType == null || !this.ModifiedType.IsStructurallyEquivalentTo (t.ModifiedType))) " is 137.
Long Statement,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetDocumentationId,The length of the statement  "		if (TargetPlatform.GenericTypeNamesMangleChar != 0 && this.TemplateParameters != null && this.TemplateParameters.Count > 0) { " is 125.
Long Statement,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetDocumentationId,The length of the statement  "	if (this.IsSpecialName && this.ReturnType != null && this.Name != null && (this.Name.UniqueIdKey == StandardIds.opExplicit.UniqueIdKey || this.Name.UniqueIdKey == StandardIds.opImplicit.UniqueIdKey)) { " is 201.
Long Statement,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetMethodInfo,The length of the statement  "			//Have to cheat here since the type might involve a type parameter of the method and getting the runtime type for that is a problem " is 131.
Long Statement,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetMethodInfo,The length of the statement  "		System.Reflection.MemberInfo[] members = t.GetMember (this.Name.ToString ()' System.Reflection.MemberTypes.Method' BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); " is 235.
Long Statement,System.Compiler,InstanceInitializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetConstructorInfo,The length of the statement  "		System.Reflection.MemberInfo[] members = t.GetMember (this.Name.ToString ()' System.Reflection.MemberTypes.Constructor' BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 218.
Long Statement,System.Compiler,StaticInitializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetConstructorInfo,The length of the statement  "		System.Reflection.MemberInfo[] members = t.GetMember (this.Name.ToString ()' System.Reflection.MemberTypes.Constructor' BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); " is 216.
Long Statement,System.Compiler,Property,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetPropertyInfo,The length of the statement  "		System.Reflection.MemberInfo[] members = t.GetMember (this.Name.ToString ()' System.Reflection.MemberTypes.Property' BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); " is 237.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,GetCorrespondingMember,The length of the statement  "		if (unspecializedMember != null && specializedMember == null && unspecializedOffset == i && !(unspecializedMember is TypeParameter || unspecializedMember is ClassParameter)) { " is 175.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,GetCorrespondingMember,The length of the statement  "		if (unspecializedMember == null && specializedMember != null && specializedOffset == i && !(specializedMember is TypeParameter || specializedMember is ClassParameter)) { " is 169.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeNode,The length of the statement  "	if (savedCurrentType != null && savedCurrentType.TemplateArguments != null && savedCurrentType.TemplateArguments.Count > 0 && typeNode.Template != null && (typeNode.Template.TemplateParameters == null || typeNode.Template.TemplateParameters.Count == 0)) { " is 255.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeNode,The length of the statement  "		typeNode.ProviderHandle = new SpecializerHandle (typeNode.ProvideNestedTypes' typeNode.ProvideTypeMembers' typeNode.ProviderHandle); " is 132.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "		TypeNode referringType = ftype.DeclaringType == null ? this.CurrentType : this.VisitTypeReference (ftype.DeclaringType); " is 120.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "		return FunctionType.For (this.VisitTypeReference (ftype.ReturnType)' this.VisitParameterList (ftype.Parameters)' referringType); " is 128.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          TypeNode referringType = tIntersect.DeclaringType == null ? this.CurrentType : this.VisitTypeReference(tIntersect.DeclaringType);" is 129.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          TypeNode referringType = tUnion.DeclaringType == null ? this.CurrentType : this.VisitTypeReference(tUnion.DeclaringType);" is 121.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          TypeNode referringType = conType.DeclaringType == null ? this.CurrentType : this.VisitTypeReference(conType.DeclaringType);" is 123.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "					if (arguments != null && arguments.Count > 0 && nt.ConsolidatedTemplateParameters != null && nt.ConsolidatedTemplateParameters.Count > 0) " is 137.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "		if (type.Template != null && (type.ConsolidatedTemplateParameters == null || type.ConsolidatedTemplateParameters.Count == 0)) { " is 127.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "			if (!type.IsNotFullySpecialized && (!type.IsNormalized || (this.CurrentType != null && type.DeclaringModule == this.CurrentType.DeclaringModule))) " is 146.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "								if (tparg == par || (tparg.ParameterListIndex == par.ParameterListIndex && tparg.DeclaringMember == par.DeclaringMember)) { " is 123.
Long Statement,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "		return type.GetTemplateInstance (this.TargetModule' this.CurrentType' this.VisitTypeReference (type.DeclaringType)' tArgs); " is 123.
Long Statement,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitAssignmentStatement,The length of the statement  "			else if (!sType.IsValueType && !(sType == CoreSystemTypes.Object && source is Literal && target.NodeType == NodeType.AddressDereference)) " is 137.
Long Statement,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitAssignmentStatement,The length of the statement  "				assignment.Source = new AddressDereference (new BinaryExpression (source' new MemberBinding (null' sType)' NodeType.Unbox)' sType); " is 131.
Long Statement,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitMemberBinding,The length of the statement  "		//Need to take the address of the target object (this parameter)' or need to box it' if this target object type is value type " is 125.
Long Statement,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitMemberBinding,The length of the statement  "					memberBinding.TargetObject = new UnaryExpression (memberBinding.TargetObject' NodeType.AddressOf' memberBinding.TargetObject.Type.GetReferenceType ()); " is 151.
Long Statement,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitMemberBinding,The length of the statement  "					memberBinding.TargetObject = new BinaryExpression (memberBinding.TargetObject' obType' NodeType.Box' method.DeclaringType); " is 123.
Long Statement,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitReturn,The length of the statement  "		Return.Expression = new BinaryExpression (rval' new MemberBinding (null' rval.Type)' NodeType.Box' this.CurrentMethod.ReturnType); " is 130.
Long Statement,System.Compiler,SnippetParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\StandardVisitor.cs,VisitCompilationUnitSnippet,The length of the statement  "		p = this.DefaultParserFactory.CreateParser (fileName' lineNumber' sourceText' this.SymbolTable' this.ErrorNodes' this.Options); " is 127.
Long Statement,System.Compiler,SnippetParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\StandardVisitor.cs,VisitExpressionSnippet,The length of the statement  "		p = this.DefaultParserFactory.CreateParser (fileName' lineNumber' sourceText' this.SymbolTable' this.ErrorNodes' this.Options); " is 127.
Long Statement,System.Compiler,SnippetParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\StandardVisitor.cs,VisitStatementSnippet,The length of the statement  "		p = this.DefaultParserFactory.CreateParser (fileName' lineNumber' sourceText' this.SymbolTable' this.ErrorNodes' this.Options); " is 127.
Long Statement,System.Compiler,SnippetParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\StandardVisitor.cs,VisitTypeMemberSnippet,The length of the statement  "		p = this.DefaultParserFactory.CreateParser (fileName' lineNumber' sourceText' this.SymbolTable' this.ErrorNodes' this.Options); " is 127.
Long Statement,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV1,The length of the statement  "		platformAssembliesLocation = TargetPlatform.PlatformAssembliesLocation = Path.Combine (Path.GetDirectoryName (typeof(object).Module.Assembly.Location)' "..\\v1.0.3705"); " is 169.
Long Statement,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV1,The length of the statement  "		AssemblyReference aref = new AssemblyReference (name + "' Version=" + version + "' Culture=neutral' PublicKeyToken=" + token); " is 126.
Long Statement,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV1_1,The length of the statement  "		platformAssembliesLocation = TargetPlatform.PlatformAssembliesLocation = Path.Combine (Path.GetDirectoryName (typeof(object).Module.Assembly.Location)' "..\\v1.1.4322"); " is 169.
Long Statement,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV1_1,The length of the statement  "		AssemblyReference aref = new AssemblyReference (name + "' Version=" + version + "' Culture=neutral' PublicKeyToken=" + token); " is 126.
Long Statement,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV2,The length of the statement  "		platformAssembliesLocation = TargetPlatform.PlatformAssembliesLocation = Path.Combine (Path.GetDirectoryName (typeof(object).Module.Assembly.Location)' "..\\v2.0.50727"); " is 170.
Long Statement,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV2,The length of the statement  "		AssemblyReference aref = new AssemblyReference (name + "' Version=" + version + "' Culture=neutral' PublicKeyToken=" + token); " is 126.
Long Statement,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV2Beta1,The length of the statement  "		AssemblyReference aref = new AssemblyReference (name + "' Version=" + version + "' Culture=neutral' PublicKeyToken=" + token); " is 126.
Long Statement,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Clear,The length of the statement  "		//Dispose the system assemblies in case they were not in the static cache. It is safe to dispose an assembly more than once. " is 124.
Long Statement,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "		if (TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 || (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999)) { " is 178.
Long Statement,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,InstantiateGenericInterfaces,The length of the statement  "	if (TargetPlatform.TargetVersion != null && (TargetPlatform.TargetVersion.Major < 2 && TargetPlatform.TargetVersion.Minor < 2)) " is 127.
Long Statement,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,InstantiateGenericInterfaces,The length of the statement  "		interfaces [i] = (Interface)ifaceExpr.Template.GetGenericTemplateInstance (type.DeclaringModule' ifaceExpr.ConsolidatedTemplateArguments); " is 138.
Long Statement,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetSystemAssembly,The length of the statement  "	result = (AssemblyNode)(new Reader (SystemAssemblyLocation.Location' null' doNotLockFile' getDebugInfo' true' false)).ReadModule (); " is 132.
Long Statement,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetSystemAssembly,The length of the statement  "	if (result == null && TargetPlatform.TargetVersion != null && TargetPlatform.TargetVersion == typeof(object).Module.Assembly.GetName ().Version) { " is 146.
Long Statement,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetSystemAssembly,The length of the statement  "		result = (AssemblyNode)(new Reader (SystemAssemblyLocation.Location' null' doNotLockFile' getDebugInfo' true' false)).ReadModule (); " is 132.
Long Statement,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetDummyTypeNode,The length of the statement  "		else if (name.EndsWith ("Callback") || name.EndsWith ("Delegate") || name == "ThreadStart" || name == "FrameGuardGetter" || name == "GuardThreadStart") " is 151.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Clear,The length of the statement  "        if (SystemTypes.SystemCompilerRuntimeAssembly != null && SystemTypes.SystemCompilerRuntimeAssembly != AssemblyNode.Dummy) {" is 123.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	InternalsVisibleToAttribute = (Class)GetTypeNodeFor ("System.Runtime.CompilerServices"' "InternalsVisibleToAttribute"' ElementType.Class); " is 138.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericICollection = (Interface)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "ICollection"' 1' ElementType.Class); " is 129.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericIEnumerable = (Interface)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "IEnumerable"' 1' ElementType.Class); " is 129.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	AllowPartiallyTrustedCallersAttribute = (Class)GetTypeNodeFor ("System.Security"' "AllowPartiallyTrustedCallersAttribute"' ElementType.Class); " is 142.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	AssemblyConfigurationAttribute = (Class)GetTypeNodeFor ("System.Reflection"' "AssemblyConfigurationAttribute"' ElementType.Class); " is 130.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	AssemblyCopyrightAttribute = (Class)GetTypeNodeFor ("System.Reflection"' "AssemblyCopyrightAttribute"' ElementType.Class); " is 122.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	AssemblyDelaySignAttribute = (Class)GetTypeNodeFor ("System.Reflection"' "AssemblyDelaySignAttribute"' ElementType.Class); " is 122.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	AssemblyDescriptionAttribute = (Class)GetTypeNodeFor ("System.Reflection"' "AssemblyDescriptionAttribute"' ElementType.Class); " is 126.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	AssemblyFileVersionAttribute = (Class)GetTypeNodeFor ("System.Reflection"' "AssemblyFileVersionAttribute"' ElementType.Class); " is 126.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	AssemblyInformationalVersionAttribute = (Class)GetTypeNodeFor ("System.Reflection"' "AssemblyInformationalVersionAttribute"' ElementType.Class); " is 144.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	AssemblyTrademarkAttribute = (Class)GetTypeNodeFor ("System.Reflection"' "AssemblyTrademarkAttribute"' ElementType.Class); " is 122.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	ClassInterfaceAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "ClassInterfaceAttribute"' ElementType.Class); " is 129.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	ComRegisterFunctionAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "ComRegisterFunctionAttribute"' ElementType.Class); " is 139.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	ComSourceInterfacesAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "ComSourceInterfacesAttribute"' ElementType.Class); " is 139.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	ComUnregisterFunctionAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "ComUnregisterFunctionAttribute"' ElementType.Class); " is 143.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	ComVisibleAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "ComVisibleAttribute"' ElementType.Class); " is 121.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	DebuggerStepThroughAttribute = (Class)GetTypeNodeFor ("System.Diagnostics"' "DebuggerStepThroughAttribute"' ElementType.Class); " is 127.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	DebuggingModes = DebuggableAttribute == null ? null : DebuggableAttribute.GetNestedType (Identifier.For ("DebuggingModes")) as EnumNode; " is 136.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	FieldOffsetAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "FieldOffsetAttribute"' ElementType.Class); " is 123.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	ImportedFromTypeLibAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "ImportedFromTypeLibAttribute"' ElementType.Class); " is 139.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	IndexerNameAttribute = (Class)GetTypeNodeFor ("System.Runtime.CompilerServices"' "IndexerNameAttribute"' ElementType.Class); " is 124.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	InterfaceTypeAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "InterfaceTypeAttribute"' ElementType.Class); " is 127.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	MethodImplAttribute = (Class)GetTypeNodeFor ("System.Runtime.CompilerServices"' "MethodImplAttribute"' ElementType.Class); " is 122.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	RuntimeCompatibilityAttribute = (Class)GetTypeNodeFor ("System.Runtime.CompilerServices"' "RuntimeCompatibilityAttribute"' ElementType.Class); " is 142.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	SatelliteContractVersionAttribute = (Class)GetTypeNodeFor ("System.Resources"' "SatelliteContractVersionAttribute"' ElementType.Class); " is 135.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	SecurityTransparentAttribute = (Class)GetTypeNodeFor ("System.Security"' "SecurityTransparentAttribute"' ElementType.Class); " is 124.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	SecurityTreatAsSafeAttribute = (Class)GetTypeNodeFor ("System.Security"' "SecurityTreatAsSafeAttribute"' ElementType.Class); " is 124.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	StructLayoutAttribute = (Class)GetTypeNodeFor ("System.Runtime.InteropServices"' "StructLayoutAttribute"' ElementType.Class); " is 125.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	SuppressMessageAttribute = (Class)GetTypeNodeFor ("System.Diagnostics.CodeAnalysis"' "SuppressMessageAttribute"' ElementType.Class); " is 132.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	SuppressUnmanagedCodeSecurityAttribute = (Class)GetTypeNodeFor ("System.Security"' "SuppressUnmanagedCodeSecurityAttribute"' ElementType.Class); " is 144.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericDictionary = (Class)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "Dictionary"' 2' ElementType.Class); " is 123.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericIComparable = (Interface)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "IComparable"' 1' ElementType.Class); " is 129.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericIComparer = (Interface)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "IComparer"' 1' ElementType.Class); " is 125.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericIDictionary = (Interface)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "IDictionary"' 2' ElementType.Class); " is 129.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericIEnumerator = (Interface)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "IEnumerator"' 1' ElementType.Class); " is 129.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericKeyValuePair = (Struct)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "KeyValuePair"' 2' ElementType.ValueType); " is 132.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	GenericSortedDictionary = (Class)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "SortedDictionary"' 2' ElementType.Class); " is 135.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	WindowsImpersonationContext = (Class)GetTypeNodeFor ("System.Security.Principal"' "WindowsImpersonationContext"' ElementType.Class); " is 132.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	#      XmlAttributeAttributeClass = (Class)GetXmlTypeNodeFor("System.Xml.Serialization"' "XmlAttributeAttribute"' ElementType.Class);" is 133.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      XmlChoiceIdentifierAttributeClass = (Class)GetXmlTypeNodeFor("System.Xml.Serialization"' "XmlChoiceIdentifierAttribute"' ElementType.Class);" is 140.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      XmlElementAttributeClass = (Class)GetXmlTypeNodeFor("System.Xml.Serialization"' "XmlElementAttribute"' ElementType.Class);" is 122.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      XmlIgnoreAttributeClass = (Class)GetXmlTypeNodeFor("System.Xml.Serialization"' "XmlIgnoreAttribute"' ElementType.Class);" is 120.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      TemplateInstanceAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CciNs' "TemplateInstanceAttribute"' ElementType.Class);" is 120.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      UnmanagedStructTemplateParameterAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CciNs' "UnmanagedStructTemplateParameterAttribute"' ElementType.Class);" is 152.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      TemplateParameterFlagsAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CciNs' "TemplateParameterFlagsAttribute"' ElementType.Class);" is 132.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	#      GenericArrayToIEnumerableAdapter = (Class)GetCompilerRuntimeTypeNodeFor("StructuralTypes"' "ArrayToIEnumerableAdapter"' 1' ElementType.Class);" is 149.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      GenericIEnumerableToGenericIListAdapter = (Class)GetCompilerRuntimeTypeNodeFor("StructuralTypes"' "GenericIEnumerableToGenericIListAdapter"' 1' ElementType.Class);" is 163.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      GenericNonEmptyIEnumerable = (Struct)GetCompilerRuntimeTypeNodeFor("StructuralTypes"' "NonEmptyIEnumerable"' 1' ElementType.ValueType);" is 135.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      StreamNotSingletonException = (Class)GetCompilerRuntimeTypeNodeFor("System.Query"' "StreamNotSingletonException"' ElementType.Class);" is 133.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      IllegalUpcastException = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "IllegalUpcastException"' ElementType.Class);" is 120.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      InitGuardSetsDelegate = (DelegateNode) GetCompilerRuntimeTypeNodeFor(GuardsNs' "InitGuardSetsDelegate"' ElementType.Class);" is 123.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      CheckInvariantDelegate = (DelegateNode) GetCompilerRuntimeTypeNodeFor(GuardsNs' "CheckInvariantDelegate"' ElementType.Class);" is 125.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      ObjectInvariantException = (Class)GetCompilerRuntimeTypeNodeFor("Microsoft.Contracts"' "ObjectInvariantException"' ElementType.Class);" is 134.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      ThreadConditionDelegate = (DelegateNode) GetCompilerRuntimeTypeNodeFor(GuardsNs' "ThreadConditionDelegate"' ElementType.Class);" is 127.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	#      UnreachableException = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "UnreachableException"' ElementType.Class);" is 123.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      InvalidContractException = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "InvalidContractException"' ElementType.Class);" is 124.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      ContractMarkerException = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ContractMarkerException"' ElementType.Class);" is 122.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "	#      ModelfieldContractAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ModelfieldContractAttribute"' ElementType.Class);" is 137.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      ModelfieldException = (Class)GetCompilerRuntimeTypeNodeFor("Microsoft.Contracts"' "ModelfieldException"' ElementType.Class);" is 124.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "        WriteConfinedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "WriteConfinedAttribute"' ElementType.Class);" is 125.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "        GlobalWriteAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "GlobalWriteAttribute"' ElementType.Class);" is 121.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "        GlobalAccessAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "GlobalAccessAttribute"' ElementType.Class);" is 123.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      StateIndependentAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "StateIndependentAttribute"' ElementType.Class);" is 126.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      SpecProtectedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "SpecProtectedAttribute"' ElementType.Class);" is 120.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      LockProtectedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "LockProtectedAttribute"' ElementType.Class);" is 125.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      RequiresLockProtectedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "RequiresLockProtectedAttribute"' ElementType.Class);" is 141.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      RequiresImmutableAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "RequiresImmutableAttribute"' ElementType.Class);" is 133.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      RequiresCanWriteAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "RequiresCanWriteAttribute"' ElementType.Class);" is 131.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      InferredReturnValueAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "InferredReturnValueAttribute"' ElementType.Class);" is 132.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      NoDefaultActivityAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "NoDefaultActivityAttribute"' ElementType.Class);" is 133.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      NoDefaultContractAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "NoDefaultContractAttribute"' ElementType.Class);" is 133.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      ShadowsAssemblyAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ShadowsAssemblyAttribute"' ElementType.Class);" is 124.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      ElementCollectionAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ElementCollectionAttribute"' ElementType.Class);" is 128.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      RecursionTerminationAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "RecursionTerminationAttribute"' ElementType.Class);" is 134.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      NoReferenceComparisonAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "NoReferenceComparisonAttribute"' ElementType.Class);" is 136.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The length of the statement  "      ResultNotNewlyAllocatedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ResultNotNewlyAllocatedAttribute"' ElementType.Class);" is 140.
Long Statement,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetGenericRuntimeTypeNodeFor,The length of the statement  "	      if (TargetPlatform.TargetVersion != null && TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor < 2)" is 126.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitAddressDereference ((AddressDereference)node' changes as AddressDereference' deletions as AddressDereference' insertions as AddressDereference); " is 161.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitAliasDefinition ((AliasDefinition)node' changes as AliasDefinition' deletions as AliasDefinition' insertions as AliasDefinition); " is 146.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitAnonymousNestedFunction ((AnonymousNestedFunction)node' changes as AnonymousNestedFunction' deletions as AnonymousNestedFunction' insertions as AnonymousNestedFunction); " is 186.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitApplyToAll ((ApplyToAll)node' changes as ApplyToAll' deletions as ApplyToAll' insertions as ApplyToAll); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitExpression ((Expression)node' changes as Expression' deletions as Expression' insertions as Expression); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitAssembly ((AssemblyNode)node' changes as AssemblyNode' deletions as AssemblyNode' insertions as AssemblyNode); " is 127.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitAssemblyReference ((AssemblyReference)node' changes as AssemblyReference' deletions as AssemblyReference' insertions as AssemblyReference); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitAssignmentExpression ((AssignmentExpression)node' changes as AssignmentExpression' deletions as AssignmentExpression' insertions as AssignmentExpression); " is 171.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitAssignmentStatement ((AssignmentStatement)node' changes as AssignmentStatement' deletions as AssignmentStatement' insertions as AssignmentStatement); " is 166.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitAttributeNode ((AttributeNode)node' changes as AttributeNode' deletions as AttributeNode' insertions as AttributeNode); " is 136.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitBlockExpression ((BlockExpression)node' changes as BlockExpression' deletions as BlockExpression' insertions as BlockExpression); " is 146.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitCompilation ((Compilation)node' changes as Compilation' deletions as Compilation' insertions as Compilation); " is 126.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitCompilationUnit ((CompilationUnit)node' changes as CompilationUnit' deletions as CompilationUnit' insertions as CompilationUnit); " is 146.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitCompilationUnitSnippet ((CompilationUnitSnippet)node' changes as CompilationUnitSnippet' deletions as CompilationUnitSnippet' insertions as CompilationUnitSnippet); " is 181.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitConstrainedType((ConstrainedType)node' changes as ConstrainedType' deletions as ConstrainedType' insertions as ConstrainedType);" is 145.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitCurrentClosure ((CurrentClosure)node' changes as CurrentClosure' deletions as CurrentClosure' insertions as CurrentClosure); " is 141.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitMethodCall ((MethodCall)node' changes as MethodCall' deletions as MethodCall' insertions as MethodCall); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitCoerceTuple ((CoerceTuple)node' changes as CoerceTuple' deletions as CoerceTuple' insertions as CoerceTuple); " is 126.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitCollectionEnumerator ((CollectionEnumerator)node' changes as CollectionEnumerator' deletions as CollectionEnumerator' insertions as CollectionEnumerator); " is 171.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitComposition ((Composition)node' changes as Composition' deletions as Composition' insertions as Composition); " is 126.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitConstructArray ((ConstructArray)node' changes as ConstructArray' deletions as ConstructArray' insertions as ConstructArray); " is 141.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitConstructDelegate ((ConstructDelegate)node' changes as ConstructDelegate' deletions as ConstructDelegate' insertions as ConstructDelegate); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitConstructFlexArray ((ConstructFlexArray)node' changes as ConstructFlexArray' deletions as ConstructFlexArray' insertions as ConstructFlexArray); " is 161.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitConstructIterator ((ConstructIterator)node' changes as ConstructIterator' deletions as ConstructIterator' insertions as ConstructIterator); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitConstructTuple ((ConstructTuple)node' changes as ConstructTuple' deletions as ConstructTuple' insertions as ConstructTuple); " is 141.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitDelegateNode ((DelegateNode)node' changes as DelegateNode' deletions as DelegateNode' insertions as DelegateNode); " is 131.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitExpression ((Expression)node' changes as Expression' deletions as Expression' insertions as Expression); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitEndFinally ((EndFinally)node' changes as EndFinally' deletions as EndFinally' insertions as EndFinally); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitExpressionSnippet ((ExpressionSnippet)node' changes as ExpressionSnippet' deletions as ExpressionSnippet' insertions as ExpressionSnippet); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitExpressionStatement ((ExpressionStatement)node' changes as ExpressionStatement' deletions as ExpressionStatement' insertions as ExpressionStatement); " is 166.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitFaultHandler ((FaultHandler)node' changes as FaultHandler' deletions as FaultHandler' insertions as FaultHandler); " is 131.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitFieldInitializerBlock ((FieldInitializerBlock)node' changes as FieldInitializerBlock' deletions as FieldInitializerBlock' insertions as FieldInitializerBlock); " is 176.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitFunctionDeclaration ((FunctionDeclaration)node' changes as FunctionDeclaration' deletions as FunctionDeclaration' insertions as FunctionDeclaration); " is 166.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitIdentifier ((Identifier)node' changes as Identifier' deletions as Identifier' insertions as Identifier); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitImplicitThis ((ImplicitThis)node' changes as ImplicitThis' deletions as ImplicitThis' insertions as ImplicitThis); " is 131.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitInstanceInitializer ((InstanceInitializer)node' changes as InstanceInitializer' deletions as InstanceInitializer' insertions as InstanceInitializer); " is 166.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitStaticInitializer ((StaticInitializer)node' changes as StaticInitializer' deletions as StaticInitializer' insertions as StaticInitializer); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitLabeledStatement ((LabeledStatement)node' changes as LabeledStatement' deletions as LabeledStatement' insertions as LabeledStatement); " is 151.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitLocalDeclaration ((LocalDeclaration)node' changes as LocalDeclaration' deletions as LocalDeclaration' insertions as LocalDeclaration); " is 151.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitLocalDeclarationsStatement ((LocalDeclarationsStatement)node' changes as LocalDeclarationsStatement' deletions as LocalDeclarationsStatement' insertions as LocalDeclarationsStatement); " is 201.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitLRExpression ((LRExpression)node' changes as LRExpression' deletions as LRExpression' insertions as LRExpression); " is 131.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitMemberBinding ((MemberBinding)node' changes as MemberBinding' deletions as MemberBinding' insertions as MemberBinding); " is 136.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitTemplateInstance ((TemplateInstance)node' changes as TemplateInstance' deletions as TemplateInstance' insertions as TemplateInstance); " is 151.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitStackAlloc ((StackAlloc)node' changes as StackAlloc' deletions as StackAlloc' insertions as StackAlloc); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitModuleReference ((ModuleReference)node' changes as ModuleReference' deletions as ModuleReference' insertions as ModuleReference); " is 146.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitNameBinding ((NameBinding)node' changes as NameBinding' deletions as NameBinding' insertions as NameBinding); " is 126.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitNamedArgument ((NamedArgument)node' changes as NamedArgument' deletions as NamedArgument' insertions as NamedArgument); " is 136.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitTypeModifier ((TypeModifier)node' changes as TypeModifier' deletions as TypeModifier' insertions as TypeModifier); " is 131.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitExpression ((Expression)node' changes as Expression' deletions as Expression' insertions as Expression); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitPrefixExpression ((PrefixExpression)node' changes as PrefixExpression' deletions as PrefixExpression' insertions as PrefixExpression); " is 151.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitPostfixExpression ((PostfixExpression)node' changes as PostfixExpression' deletions as PostfixExpression' insertions as PostfixExpression); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitQualifiedIdentifier ((QualifiedIdentifier)node' changes as QualifiedIdentifier' deletions as QualifiedIdentifier' insertions as QualifiedIdentifier); " is 166.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitResourceUse ((ResourceUse)node' changes as ResourceUse' deletions as ResourceUse' insertions as ResourceUse); " is 126.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitSecurityAttribute ((SecurityAttribute)node' changes as SecurityAttribute' deletions as SecurityAttribute' insertions as SecurityAttribute); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitSetterValue ((SetterValue)node' changes as SetterValue' deletions as SetterValue' insertions as SetterValue); " is 126.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitStatementSnippet ((StatementSnippet)node' changes as StatementSnippet' deletions as StatementSnippet' insertions as StatementSnippet); " is 151.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitSwitchCase ((SwitchCase)node' changes as SwitchCase' deletions as SwitchCase' insertions as SwitchCase); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitSwitchInstruction ((SwitchInstruction)node' changes as SwitchInstruction' deletions as SwitchInstruction' insertions as SwitchInstruction); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitTypeswitch ((Typeswitch)node' changes as Typeswitch' deletions as Typeswitch' insertions as Typeswitch); " is 121.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitTypeswitchCase ((TypeswitchCase)node' changes as TypeswitchCase' deletions as TypeswitchCase' insertions as TypeswitchCase); " is 141.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTypeIntersection((TypeIntersection)node' changes as TypeIntersection' deletions as TypeIntersection' insertions as TypeIntersection);" is 150.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitTypeMemberSnippet ((TypeMemberSnippet)node' changes as TypeMemberSnippet' deletions as TypeMemberSnippet' insertions as TypeMemberSnippet); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitTypeReference ((TypeReference)node' changes as TypeReference' deletions as TypeReference' insertions as TypeReference); " is 136.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitUsedNamespace ((UsedNamespace)node' changes as UsedNamespace' deletions as UsedNamespace' insertions as UsedNamespace); " is 136.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitVariableDeclaration ((VariableDeclaration)node' changes as VariableDeclaration' deletions as VariableDeclaration' insertions as VariableDeclaration); " is 166.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitTernaryExpression ((TernaryExpression)node' changes as TernaryExpression' deletions as TernaryExpression' insertions as TernaryExpression); " is 156.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitBinaryExpression ((BinaryExpression)node' changes as BinaryExpression' deletions as BinaryExpression' insertions as BinaryExpression); " is 151.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "		return this.VisitUnaryExpression ((UnaryExpression)node' changes as UnaryExpression' deletions as UnaryExpression' insertions as UnaryExpression); " is 146.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryAggregate((QueryAggregate)node' changes as QueryAggregate' deletions as QueryAggregate' insertions as QueryAggregate);" is 140.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryAlias((QueryAlias)node' changes as QueryAlias' deletions as QueryAlias' insertions as QueryAlias);" is 120.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryQuantifier((QueryQuantifier)node' changes as QueryQuantifier' deletions as QueryQuantifier' insertions as QueryQuantifier);" is 145.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryCommit((QueryCommit)node' changes as QueryCommit' deletions as QueryCommit' insertions as QueryCommit);" is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryContext((QueryContext)node' changes as QueryContext' deletions as QueryContext' insertions as QueryContext);" is 130.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryDelete((QueryDelete)node' changes as QueryDelete' deletions as QueryDelete' insertions as QueryDelete);" is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryDifference((QueryDifference)node' changes as QueryDifference' deletions as QueryDifference' insertions as QueryDifference);" is 145.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryDistinct((QueryDistinct)node' changes as QueryDistinct' deletions as QueryDistinct' insertions as QueryDistinct);" is 135.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryExists((QueryExists)node' changes as QueryExists' deletions as QueryExists' insertions as QueryExists);" is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryFilter((QueryFilter)node' changes as QueryFilter' deletions as QueryFilter' insertions as QueryFilter);" is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryGeneratedType((QueryGeneratedType)node' changes as QueryGeneratedType' deletions as QueryGeneratedType' insertions as QueryGeneratedType);" is 160.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryGroupBy((QueryGroupBy)node' changes as QueryGroupBy' deletions as QueryGroupBy' insertions as QueryGroupBy);" is 130.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryInsert((QueryInsert)node' changes as QueryInsert' deletions as QueryInsert' insertions as QueryInsert);" is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryIntersection((QueryIntersection)node' changes as QueryIntersection' deletions as QueryIntersection' insertions as QueryIntersection);" is 155.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryIterator((QueryIterator)node' changes as QueryIterator' deletions as QueryIterator' insertions as QueryIterator);" is 135.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryLimit((QueryLimit)node' changes as QueryLimit' deletions as QueryLimit' insertions as QueryLimit);" is 120.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryOrderBy((QueryOrderBy)node' changes as QueryOrderBy' deletions as QueryOrderBy' insertions as QueryOrderBy);" is 130.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryOrderItem((QueryOrderItem)node' changes as QueryOrderItem' deletions as QueryOrderItem' insertions as QueryOrderItem);" is 140.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryPosition((QueryPosition)node' changes as QueryPosition' deletions as QueryPosition' insertions as QueryPosition);" is 135.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryProject((QueryProject)node' changes as QueryProject' deletions as QueryProject' insertions as QueryProject);          " is 130.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryQuantifiedExpression((QueryQuantifiedExpression)node' changes as QueryQuantifiedExpression' deletions as QueryQuantifiedExpression' insertions as QueryQuantifiedExpression);" is 195.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryRollback((QueryRollback)node' changes as QueryRollback' deletions as QueryRollback' insertions as QueryRollback);" is 135.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQuerySelect((QuerySelect)node' changes as QuerySelect' deletions as QuerySelect' insertions as QuerySelect);" is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQuerySingleton((QuerySingleton)node' changes as QuerySingleton' deletions as QuerySingleton' insertions as QuerySingleton);" is 140.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryTransact((QueryTransact)node' changes as QueryTransact' deletions as QueryTransact' insertions as QueryTransact);" is 135.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryTypeFilter((QueryTypeFilter)node' changes as QueryTypeFilter' deletions as QueryTypeFilter' insertions as QueryTypeFilter);" is 145.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryUnion((QueryUnion)node' changes as QueryUnion' deletions as QueryUnion' insertions as QueryUnion);" is 120.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryUpdate((QueryUpdate)node' changes as QueryUpdate' deletions as QueryUpdate' insertions as QueryUpdate);" is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryYielder((QueryYielder)node' changes as QueryYielder' deletions as QueryYielder' insertions as QueryYielder);" is 130.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAliasDefinition,The length of the statement  "			aliasDefinition.AliasedType = this.VisitTypeReference (aliasDefinition.AliasedType' changes.AliasedType' deletions.AliasedType' insertions.AliasedType); " is 152.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAnonymousNestedFunction,The length of the statement  "			func.Parameters = this.VisitParameterList (func.Parameters' changes.Parameters' deletions.Parameters' insertions.Parameters); " is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitApplyToAll,The length of the statement  "			applyToAll.Operand1 = this.VisitExpression (applyToAll.Operand1' changes.Operand1' deletions.Operand1' insertions.Operand1); " is 124.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitApplyToAll,The length of the statement  "			applyToAll.Operand2 = this.VisitExpression (applyToAll.Operand2' changes.Operand2' deletions.Operand2' insertions.Operand2); " is 124.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssembly,The length of the statement  "			assembly.AssemblyReferences = this.VisitAssemblyReferenceList (assembly.AssemblyReferences' changes.AssemblyReferences' deletions.AssemblyReferences' insertions.AssemblyReferences); " is 181.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssembly,The length of the statement  "			assembly.Attributes = this.VisitAttributeList (assembly.Attributes' changes.Attributes' deletions.Attributes' insertions.Attributes); " is 133.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssembly,The length of the statement  "			assembly.ExportedTypes = this.VisitTypeReferenceList (assembly.ExportedTypes' changes.ExportedTypes' deletions.ExportedTypes' insertions.ExportedTypes); " is 152.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssembly,The length of the statement  "			assembly.ModuleAttributes = this.VisitAttributeList (assembly.ModuleAttributes' changes.ModuleAttributes' deletions.ModuleAttributes' insertions.ModuleAttributes); " is 163.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssembly,The length of the statement  "			assembly.ModuleReferences = this.VisitModuleReferenceList (assembly.ModuleReferences' changes.ModuleReferences' deletions.ModuleReferences' insertions.ModuleReferences); " is 169.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssembly,The length of the statement  "			assembly.SecurityAttributes = this.VisitSecurityAttributeList (assembly.SecurityAttributes' changes.SecurityAttributes' deletions.SecurityAttributes' insertions.SecurityAttributes); " is 181.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssemblyReferenceList,The length of the statement  "			assemblyReferences [i] = this.VisitAssemblyReference (assemblyReferences [i]' changes [i]' deletions [i]' insertions [i]); " is 122.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssertion,The length of the statement  "			assertion.Condition = this.VisitExpression (assertion.Condition' changes.Condition' deletions.Condition' insertions.Condition); " is 127.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAssignmentExpression,The length of the statement  "			assignment.AssignmentStatement = this.VisitAssignmentStatement (assignment.AssignmentStatement as AssignmentStatement' changes.AssignmentStatement as AssignmentStatement' deletions.AssignmentStatement as AssignmentStatement' insertions.AssignmentStatement as AssignmentStatement); " is 280.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAttributeNode,The length of the statement  "			attribute.Constructor = this.VisitExpression (attribute.Constructor' changes.Constructor' deletions.Constructor' insertions.Constructor); " is 137.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitAttributeNode,The length of the statement  "			attribute.Expressions = this.VisitExpressionList (attribute.Expressions' changes.Expressions' deletions.Expressions' insertions.Expressions); " is 141.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitBinaryExpression,The length of the statement  "			binaryExpression.Operand1 = this.VisitExpression (binaryExpression.Operand1' changes.Operand1' deletions.Operand1' insertions.Operand1); " is 136.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitBinaryExpression,The length of the statement  "			binaryExpression.Operand2 = this.VisitExpression (binaryExpression.Operand2' changes.Operand2' deletions.Operand2' insertions.Operand2); " is 136.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitBlock,The length of the statement  "			block.Statements = this.VisitStatementList (block.Statements' changes.Statements' deletions.Statements' insertions.Statements); " is 127.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitCoerceTuple,The length of the statement  "			coerceTuple.OriginalTuple = this.VisitExpression (coerceTuple.OriginalTuple' changes.OriginalTuple' deletions.OriginalTuple' insertions.OriginalTuple); " is 151.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitCompilation,The length of the statement  "			compilation.CompilationUnits = this.VisitCompilationUnitList (compilation.CompilationUnits' changes.CompilationUnits' deletions.CompilationUnits' insertions.CompilationUnits); " is 175.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitComposition,The length of the statement  "			comp.Expression = this.VisitExpression (comp.Expression' changes.Expression' deletions.Expression' insertions.Expression); " is 122.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitConstruct,The length of the statement  "			cons.Constructor = this.VisitExpression (cons.Constructor' changes.Constructor' deletions.Constructor' insertions.Constructor); " is 127.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitConstructArray,The length of the statement  "			consArr.Initializers = this.VisitExpressionList (consArr.Initializers' changes.Initializers' deletions.Initializers' insertions.Initializers); " is 142.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitConstructArray,The length of the statement  "			consArr.Operands = this.VisitExpressionList (consArr.Operands' changes.Operands' deletions.Operands' insertions.Operands); " is 122.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitConstructDelegate,The length of the statement  "			consDelegate.TargetObject = this.VisitExpression (consDelegate.TargetObject' changes.TargetObject' deletions.TargetObject' insertions.TargetObject); " is 148.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitConstructFlexArray,The length of the statement  "			consArr.Initializers = this.VisitExpressionList (consArr.Initializers' changes.Initializers' deletions.Initializers' insertions.Initializers); " is 142.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitConstructFlexArray,The length of the statement  "			consArr.Operands = this.VisitExpressionList (consArr.Operands' changes.Operands' deletions.Operands' insertions.Operands); " is 122.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitDelegateNode,The length of the statement  "			delegateNode.Attributes = this.VisitAttributeList (delegateNode.Attributes' changes.Attributes' deletions.Attributes' insertions.Attributes); " is 141.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitDelegateNode,The length of the statement  "			delegateNode.Parameters = this.VisitParameterList (delegateNode.Parameters' changes.Parameters' deletions.Parameters' insertions.Parameters); " is 141.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitDelegateNode,The length of the statement  "			delegateNode.SecurityAttributes = this.VisitSecurityAttributeList (delegateNode.SecurityAttributes' changes.SecurityAttributes' deletions.SecurityAttributes' insertions.SecurityAttributes); " is 189.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitDelegateNode,The length of the statement  "			delegateNode.TemplateParameters = this.VisitTypeReferenceList (delegateNode.TemplateParameters' changes.TemplateParameters' deletions.TemplateParameters' insertions.TemplateParameters); " is 185.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitDoWhile,The length of the statement  "			doWhile.Condition = this.VisitExpression (doWhile.Condition' changes.Condition' deletions.Condition' insertions.Condition); " is 123.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitEvent,The length of the statement  "			evnt.Attributes = this.VisitAttributeList (evnt.Attributes' changes.Attributes' deletions.Attributes' insertions.Attributes); " is 125.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitEvent,The length of the statement  "			evnt.InitialHandler = this.VisitExpression (evnt.InitialHandler' changes.InitialHandler' deletions.InitialHandler' insertions.InitialHandler); " is 142.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitExpressionStatement,The length of the statement  "			statement.Expression = this.VisitExpression (statement.Expression' changes.Expression' deletions.Expression' insertions.Expression); " is 132.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitField,The length of the statement  "			field.Attributes = this.VisitAttributeList (field.Attributes' changes.Attributes' deletions.Attributes' insertions.Attributes); " is 127.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitField,The length of the statement  "			field.DefaultValue = this.VisitLiteral (field.DefaultValue' changes.DefaultValue' deletions.DefaultValue' insertions.DefaultValue); " is 131.
Long Statement,System.Compiler,Updater,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Updater.cs,VisitField,The length of the statement  "			field.ImplementedInterfaces = this.VisitInterfaceReferenceList (field.ImplementedInterfaces' changes.ImplementedInterfaces' deletions.ImplementedInterfaces' insertions.ImplementedInterfaces); " is 191.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The length of the statement  "						string server = Path.Combine (Path.GetDirectoryName (typeof(object).Assembly.Location)' "..\\v1.1.4322\\diasymreader.dll"); " is 123.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetAssemblyRefIndex,The length of the statement  "		throw new InvalidOperationException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnresolvedAssemblyReferenceNotAllowed' assembly.Name)); " is 152.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The length of the statement  "	if (field != null && field.DeclaringType != null && field.DeclaringType.Template != null && field.DeclaringType.Template.IsGeneric) " is 131.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The length of the statement  "		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0))) " is 156.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetFieldToken,The length of the statement  "	if (f.DeclaringType == null || (f.DeclaringType.DeclaringModule == this.module && !this.IsStructural (f.DeclaringType))) " is 120.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeToken,The length of the statement  "	if (this.IsStructural (type) && (!type.IsGeneric || (type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))) " is 146.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefToken,The length of the statement  "	if (this.IsStructural (type) && (!type.IsGeneric || (type.Template != null && type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))) " is 171.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetUnspecializedMethod,The length of the statement  "		for (int j = 0' m = unspecializedMethod.TemplateParameters == null ? 0 : unspecializedMethod.TemplateParameters.Count; j < m; j++) { " is 132.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The length of the statement  "			if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0))) " is 156.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The length of the statement  "			if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1) " is 132.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodCall,The length of the statement  "	if ((method.CallingConvention & (CallingConventionFlags)7) == CallingConventionFlags.VarArg || (method.CallingConvention & (CallingConventionFlags)7) == CallingConventionFlags.C) { " is 180.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitClass,The length of the statement  "	if ((Class.Flags & (TypeFlags.ExplicitLayout | TypeFlags.SequentialLayout)) != 0 && (Class.PackingSize != 0 || Class.ClassSize != 0)) " is 133.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The length of the statement  "			} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) { " is 176.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethod,The length of the statement  "	if ((method.Flags & MethodFlags.PInvokeImpl) != 0 && method.PInvokeImportName != null && method.PInvokeModule != null) { " is 120.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The length of the statement  "			if (eh == null || eh.HandlerStartBlock == null || (eh.HandlerType != NodeType.Catch && eh.HandlerType != NodeType.Filter)) " is 122.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The length of the statement  "			int handlerLength = handlerLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset; " is 127.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineSequencePoint,The length of the statement  "	if (this.symWriter != null && node != null && node.SourceContext.Document != null && !node.SourceContext.Document.Hidden) { " is 123.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitStruct,The length of the statement  "	if ((Struct.Flags & (TypeFlags.ExplicitLayout | TypeFlags.SequentialLayout)) != 0 && (Struct.PackingSize != 0 || Struct.ClassSize != 0)) " is 136.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteMethodSignature,The length of the statement  "        returnType = TypeNode.DeepStripModifiers(returnType' (method.Template != null) ? method.Template.ReturnType : null' SystemTypes.NonNullType' SystemTypes.NullableType);" is 167.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteMethodSignature,The length of the statement  "    //    returnType = TypeNode.DeepStripModifier(returnType' SystemTypes.NullableType' (method.Template != null) ? returnType.GetTemplateInstance(returnType' returnType.TemplateArguments) : null);" is 193.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteMethodSignature,The length of the statement  "          parameterType = TypeNode.DeepStripModifiers(parameterType' (method.Template != null) ? method.Template.Parameters[i].Type : null' SystemTypes.NonNullType' SystemTypes.NullableType);" is 181.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteMethodSignature,The length of the statement  "          //parameterType = TypeNode.DeepStripModifier(parameterType' SystemTypes.NullableType' (method.Template != null) ? parameterType.GetTemplateInstance(parameterType' parameterType.TemplateArguments) : null);" is 204.
Long Statement,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AppendAssemblyQualifierIfNecessary,The length of the statement  "	if (referencedAssembly != null && referencedAssembly != this.module/*&& referencedAssembly != CoreSystemTypes.SystemAssembly*/) { " is 129.
Long Statement,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WritePE,The length of the statement  "		Writer.WritePE (module.Location' options.IncludeDebugInformation' module' options.DelaySign' options.AssemblyKeyFile' options.AssemblyKeyName); " is 143.
Long Statement,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WritePE,The length of the statement  "			if (!Writer.StrongNameSignatureGeneration (location' keyName' assem.KeyBlob' assem.KeyBlob == null ? 0 : assem.KeyBlob.Length' IntPtr.Zero' IntPtr.Zero)) " is 153.
Long Statement,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WritePE,The length of the statement  "			if (!Writer.MscorsnStrongNameSignatureGeneration (location' keyName' assem.KeyBlob' assem.KeyBlob == null ? 0 : assem.KeyBlob.Length' IntPtr.Zero' IntPtr.Zero)) " is 160.
Long Statement,System.Compiler.Metadata,MemoryMappedFile,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,OpenMap,The length of the statement  "		                hmap = CreateFileMapping(stream.SafeFileHandle.DangerousGetHandle()' IntPtr.Zero' PageAccess.PAGE_READONLY' 0' length' null);" is 125.
Long Statement,System.Compiler.Metadata,MemoryMappedFile,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,OpenMap,The length of the statement  "			throw new FileLoadException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CreateFileMappingReturnedErrorCode' rc.ToString ())' filename); " is 152.
Long Statement,System.Compiler.Metadata,MemoryMappedFile,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,OpenMap,The length of the statement  "		throw new FileLoadException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.MapViewOfFileReturnedErrorCode' rc.ToString ())' filename); " is 148.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int constantParentRefSize = this.constantParentRefSize = tableSize [(int)TableIndices.Param] < 0x4000 && tableSize [(int)TableIndices.Field] < 0x4000 && tableSize [(int)TableIndices.Property] < 0x4000 ? 2 : 4; " is 209.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "		customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 && tableSize [(int)TableIndices.GenericParam] < 0x0800 && tableSize [(int)TableIndices.MethodSpec] < 0x0800 && tableSize [(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4; " is 1172.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "		customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4; " is 999.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int customAttributeConstructorRefSize = this.customAttributeConstructorRefSize = tableSize [(int)TableIndices.Method] < 0x2000 && tableSize [(int)TableIndices.MemberRef] < 0x2000 ? 2 : 4; " is 187.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int declSecurityParentRefSize = this.declSecurityParentRefSize = tableSize [(int)TableIndices.TypeDef] < 0x4000 && tableSize [(int)TableIndices.Method] < 0x4000 && tableSize [(int)TableIndices.Assembly] < 0x4000 ? 2 : 4; " is 220.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int fieldMarshalParentRefSize = this.fieldMarshalParentRefSize = tableSize [(int)TableIndices.Field] < 0x8000 && tableSize [(int)TableIndices.Param] < 0x8000 ? 2 : 4; " is 166.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int hasSemanticRefSize = this.hasSemanticRefSize = tableSize [(int)TableIndices.Event] < 0x8000 && tableSize [(int)TableIndices.Property] < 0x8000 ? 2 : 4; " is 155.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int implementationRefSize = this.implementationRefSize = tableSize [(int)TableIndices.File] < 0x4000 && tableSize [(int)TableIndices.AssemblyRef] < 0x4000 && tableSize [(int)TableIndices.ExportedType] < 0x4000 ? 2 : 4; " is 218.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int methodDefOrRefSize = this.methodDefOrRefSize = tableSize [(int)TableIndices.Method] < 0x8000 && tableSize [(int)TableIndices.MemberRef] < 0x8000 ? 2 : 4; " is 157.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int memberRefParentSize = this.memberRefParentSize = tableSize [(int)TableIndices.TypeDef] < 0x2000 && tableSize [(int)TableIndices.TypeRef] < 0x2000 && tableSize [(int)TableIndices.ModuleRef] < 0x2000 && tableSize [(int)TableIndices.Method] < 0x2000 && tableSize [(int)TableIndices.TypeSpec] < 0x2000 ? 2 : 4; " is 310.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int memberForwardedRefSize = this.memberForwardedRefSize = tableSize [(int)TableIndices.Field] < 0x8000 && tableSize [(int)TableIndices.Method] < 0x8000 ? 2 : 4; " is 161.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int typeDefOrMethodDefSize = this.typeDefOrMethodDefSize = tableSize [(int)TableIndices.TypeDef] < 0x8000 && tableSize [(int)TableIndices.Method] < 0x8000 ? 2 : 4; " is 163.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int typeDefOrRefOrSpecSize = this.typeDefOrRefOrSpecSize = tableSize [(int)TableIndices.TypeDef] < 0x4000 && tableSize [(int)TableIndices.TypeRef] < 0x4000 && tableSize [(int)TableIndices.TypeSpec] < 0x4000 ? 2 : 4; " is 215.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "	int resolutionScopeRefSize = this.resolutionScopeRefSize = tableSize [(int)TableIndices.Module] < 0x4000 && tableSize [(int)TableIndices.ModuleRef] < 0x4000 && tableSize [(int)TableIndices.AssemblyRef] < 0x4000 && tableSize [(int)TableIndices.TypeRef] < 0x4000 ? 2 : 4; " is 269.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The length of the statement  "			offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]); " is 146.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,RvaToOffset,The length of the statement  "	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownVirtualAddress' virtualAddress)); " is 136.
Long Statement,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,RvaToOffset,The length of the statement  "	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownVirtualAddress' +virtualAddress)); " is 137.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int constantParentRefSize = this.constantParentRefSize = tableSize [(int)TableIndices.Param] < 0x4000 && tableSize [(int)TableIndices.Field] < 0x4000 && tableSize [(int)TableIndices.Property] < 0x4000 ? 2 : 4; " is 209.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 && tableSize [(int)TableIndices.GenericParam] < 0x0800 && tableSize [(int)TableIndices.MethodSpec] < 0x0800 && tableSize [(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4; " is 1176.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int customAttributeConstructorRefSize = this.customAttributeConstructorRefSize = tableSize [(int)TableIndices.Method] < 0x2000 && tableSize [(int)TableIndices.MemberRef] < 0x2000 ? 2 : 4; " is 187.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int declSecurityParentRefSize = this.declSecurityParentRefSize = tableSize [(int)TableIndices.TypeDef] < 0x4000 && tableSize [(int)TableIndices.Method] < 0x4000 && tableSize [(int)TableIndices.Assembly] < 0x4000 ? 2 : 4; " is 220.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int fieldMarshalParentRefSize = this.fieldMarshalParentRefSize = tableSize [(int)TableIndices.Field] < 0x8000 && tableSize [(int)TableIndices.Param] < 0x8000 ? 2 : 4; " is 166.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int hasSemanticRefSize = this.hasSemanticRefSize = tableSize [(int)TableIndices.Event] < 0x8000 && tableSize [(int)TableIndices.Property] < 0x8000 ? 2 : 4; " is 155.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int implementationRefSize = this.implementationRefSize = tableSize [(int)TableIndices.File] < 0x4000 && tableSize [(int)TableIndices.AssemblyRef] < 0x4000 && tableSize [(int)TableIndices.ExportedType] < 0x4000 ? 2 : 4; " is 218.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int methodDefOrRefSize = this.methodDefOrRefSize = tableSize [(int)TableIndices.Method] < 0x8000 && tableSize [(int)TableIndices.MemberRef] < 0x8000 ? 2 : 4; " is 157.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int memberRefParentSize = this.memberRefParentSize = tableSize [(int)TableIndices.TypeDef] < 0x2000 && tableSize [(int)TableIndices.TypeRef] < 0x2000 && tableSize [(int)TableIndices.ModuleRef] < 0x2000 && tableSize [(int)TableIndices.Method] < 0x2000 && tableSize [(int)TableIndices.TypeSpec] < 0x2000 ? 2 : 4; " is 310.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int memberForwardedRefSize = this.memberForwardedRefSize = tableSize [(int)TableIndices.Field] < 0x8000 && tableSize [(int)TableIndices.Method] < 0x8000 ? 2 : 4; " is 161.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int typeDefOrMethodDefSize = this.typeDefOrMethodDefSize = tableSize [(int)TableIndices.TypeDef] < 0x8000 && tableSize [(int)TableIndices.Method] < 0x8000 ? 2 : 4; " is 163.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int typeDefOrRefOrSpecSize = this.typeDefOrRefOrSpecSize = tableSize [(int)TableIndices.TypeDef] < 0x4000 && tableSize [(int)TableIndices.TypeRef] < 0x4000 && tableSize [(int)TableIndices.TypeSpec] < 0x4000 ? 2 : 4; " is 215.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "	int resolutionScopeRefSize = this.resolutionScopeRefSize = tableSize [(int)TableIndices.Module] < 0x4000 && tableSize [(int)TableIndices.ModuleRef] < 0x4000 && tableSize [(int)TableIndices.AssemblyRef] < 0x4000 && tableSize [(int)TableIndices.TypeRef] < 0x4000 ? 2 : 4; " is 269.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The length of the statement  "			length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]); " is 146.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The length of the statement  "		int vaddr = sdataSection.virtualAddress = previousSection.virtualAddress + n * (int)Math.Ceiling (previousSection.sizeOfRawData / (double)n); " is 141.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The length of the statement  "		sdataSection.pointerToRawData = previousSection.pointerToRawData + m * (int)Math.Ceiling (previousSection.sizeOfRawData / (double)m); " is 133.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The length of the statement  "		int vaddr = tlsSection.virtualAddress = previousSection.virtualAddress + n * (int)Math.Ceiling (previousSection.sizeOfRawData / (double)n); " is 139.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The length of the statement  "		tlsSection.pointerToRawData = previousSection.pointerToRawData + m * (int)Math.Ceiling (previousSection.sizeOfRawData / (double)m); " is 131.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The length of the statement  "		rsrcSection.virtualAddress = previousSection.virtualAddress + n * (int)Math.Ceiling (previousSection.sizeOfRawData / (double)n); " is 128.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The length of the statement  "		rsrcSection.pointerToRawData = previousSection.pointerToRawData + m * (int)Math.Ceiling (previousSection.sizeOfRawData / (double)m); " is 132.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The length of the statement  "	relocSection.virtualAddress = previousSection.virtualAddress + n * (int)Math.Ceiling (previousSection.sizeOfRawData / (double)n); " is 129.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The length of the statement  "	relocSection.pointerToRawData = previousSection.pointerToRawData + m * (int)Math.Ceiling (previousSection.sizeOfRawData / (double)m); " is 133.
Long Statement,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteNTHeader,The length of the statement  "	int sectionPages = (int)(Math.Ceiling (this.sectionHeaders [this.sectionHeaders.Length - 1].virtualSize / (double)ntHeader.sectionAlignment) * ntHeader.sectionAlignment); " is 170.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,SetupReader,The length of the statement  "		using (System.IO.FileStream inputStream = new System.IO.FileStream (this.fileName' System.IO.FileMode.Open' System.IO.FileAccess.Read' System.IO.FileShare.Read)) { " is 163.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ReadFileIntoUnmanagedBuffer,The length of the statement  "	            if (!Reader.ReadFile(inputStream.SafeFileHandle.DangerousGetHandle()' pb' n' &n' IntPtr.Zero)) throw new System.IO.FileLoadException();" is 135.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,SetupDebugReader,The length of the statement  "				throw new InvalidOperationException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.PdbAssociatedWithFileIsOutOfDate' filename)); " is 142.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,SetupDebugReader,The length of the statement  "			throw new InvalidOperationException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.GetReaderForFileReturnedUnexpectedHResult' hresult.ToString ("X"))); " is 165.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ReadAssembly,The length of the statement  "		AssemblyNode assembly = new AssemblyNode (new Module.TypeNodeProvider (this.GetTypeFromName)' new Module.TypeNodeListProvider (this.GetTypeList)' new Module.CustomAttributeProvider (this.GetCustomAttributesFor)' new Module.ResourceProvider (this.GetResources)' this.directory); " is 277.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "	//if (CoreSystemTypes.SystemAssembly != null && CoreSystemTypes.SystemAssembly.Name == assembly.Name && CoreSystemTypes.SystemAssembly.reader != null) { " is 152.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "	//    if (this.getDebugSymbols && !CoreSystemTypes.SystemAssembly.reader.getDebugSymbols && !CoreSystemTypes.SystemAssembly.reader.getDebugSymbolsFailed) " is 153.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "			AssemblyReference aRef = (AssemblyReference)TargetPlatform.AssemblyReferenceFor [Identifier.For (assemblyReference.Name).UniqueIdKey]; " is 134.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "			if (aRef != null && assemblyReference.Version != null && aRef.Version >= assemblyReference.Version && aRef.MatchesIgnoringVersion (assemblyReference)) { " is 152.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "							HandleError (assembly' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.BadTargetPlatformLocation' assembly.Name' TargetPlatform.PlatformAssembliesLocation' assembly.Version' aRef.Version)); " is 201.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "					platformAssembly = AssemblyNode.GetAssembly (aRef.Location' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 123.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "				if (aRef == null && assembly.FileLastWriteTimeUtc > cachedAssembly.FileLastWriteTimeUtc && assembly.Location != null && cachedAssembly.Location != null && assembly.Location == cachedAssembly.Location) { " is 202.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "				if (assembly.FileLastWriteTimeUtc > cachedAssembly.FileLastWriteTimeUtc && assembly.Location != null && cachedAssembly.Location != null && assembly.Location == cachedAssembly.Location) { " is 186.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ReadModule,The length of the statement  "				if (cachedAssembly != null && cachedAssembly.FileLastWriteTimeUtc == System.IO.File.GetLastWriteTimeUtc (this.fileName)) { " is 122.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ReadModule,The length of the statement  "			if (cachedAssembly != null && cachedAssembly.FileLastWriteTimeUtc == System.IO.File.GetLastWriteTimeUtc (this.fileName)) { " is 122.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ReadModule,The length of the statement  "		Module module = this.module = new Module (new Module.TypeNodeProvider (this.GetTypeFromName)' new Module.TypeNodeListProvider (this.GetTypeList)' new Module.CustomAttributeProvider (this.GetCustomAttributesFor)' new Module.ResourceProvider (this.GetResources)); " is 261.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ReadAssemblyProperties,The length of the statement  "	assembly.Version = new System.Version (assemblyRow.MajorVersion' assemblyRow.MinorVersion' assemblyRow.BuildNumber' assemblyRow.RevisionNumber); " is 144.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMethodsToType,The length of the statement  "		if (method != null && ((method.Flags & MethodFlags.RTSpecialName) == 0 || method.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey)) " is 135.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddPropertiesToType,The length of the statement  "		if ((property.Flags & PropertyFlags.RTSpecialName) == 0 || property.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey) { " is 123.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "		if (SystemAssemblyLocation.ParsedAssembly != null && (assemblyReference.Name == "mscorlib" || assemblyReference.Name == "basetypes" || assemblyReference.Name == "ioconfig" || assemblyReference.Name == "singularity.v1")) " is 219.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "			AssemblyReference aRef = (AssemblyReference)TargetPlatform.AssemblyReferenceFor [Identifier.For (assemblyReference.Name).UniqueIdKey]; " is 134.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "			if (aRef != null && assemblyReference.Version != null && aRef.Version >= assemblyReference.Version && aRef.MatchesIgnoringVersion (assemblyReference)) { " is 152.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "					platformAssembly = AssemblyNode.GetAssembly (aRef.Location' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 123.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "				assembly = AssemblyNode.GetAssembly (fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 135.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "				assembly = AssemblyNode.GetAssembly (fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 135.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "				assembly = AssemblyNode.GetAssembly (fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 135.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "				assembly = AssemblyNode.GetAssembly (fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 135.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "				assembly = AssemblyNode.GetAssembly (fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 135.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "				assembly = AssemblyNode.GetAssembly (gacLocation' this.useStaticCache ? Reader.StaticAssemblyCache : this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 189.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "				HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.AssemblyReferenceNotResolved' assemblyReference.StrongName)); " is 147.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetPermissionAttribute2,The length of the statement  "		HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotResolveType' serializedTypeName)); " is 128.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetPermissionAttribute2,The length of the statement  "		HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.SecurityAttributeTypeDoesNotHaveADefaultConstructor' serializedTypeName)); " is 160.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,HandleError,The length of the statement  "	      throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture' ExceptionStrings.ModuleError' mod.Name' errorMessage));" is 132.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The length of the statement  "	//Get here after "rootType[" has been parsed. What follows is either an array type specifier or some generic type arguments. " is 124.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The length of the statement  "			retVal = this.ParseArrayOrGenericType (typeName.Substring (lastCharPos + 2' typeName.Length - 1 - lastCharPos - 1)' retVal); " is 124.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetLocalSourceNames,The length of the statement  "		ISymUnmanagedVariable local = (ISymUnmanagedVariable)System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown (localPtrs [i]' typeof(ISymUnmanagedVariable)); " is 165.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetLocalSourceNames,The length of the statement  "		ISymUnmanagedScope subscope = (ISymUnmanagedScope)System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown (subscopes [i]' typeof(ISymUnmanagedScope)); " is 159.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The length of the statement  "	if ((((MethodFlags)meth.Flags) & MethodFlags.SpecialName) != 0 && (((MethodFlags)meth.Flags) & MethodFlags.SpecialName) != 0) { " is 127.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The length of the statement  "	TypeNodeList paramTypes = this.ParseParameterTypes (out varArgTypes' sigReader' paramCount' ref genericParameterEncountered); " is 125.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The length of the statement  "			if (typeParamCount != int.MinValue && (!m.IsGeneric || m.TemplateParameters == null || m.TemplateParameters.Count != typeParamCount)) " is 133.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The length of the statement  "		HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotResolveMemberReference' parent.FullName + "::" + memberName)); " is 156.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,CanCacheMember,The length of the statement  "	return (member.DeclaringType == null || CanCacheTypeNode (member.DeclaringType)) && (member.NodeType != NodeType.Method || CanCacheMethodHelper ((Method)member)); " is 162.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeFromDefHelper,The length of the statement  "	TypeNode result = this.ConstructCorrectTypeNodeSubclass (i' namesp' firstInterfaceIndex' lastInterfaceIndex' (TypeFlags)typeDef.Flags' interfaces' typeDef.Extends' name.UniqueIdKey == StandardIds.Enum.UniqueIdKey && namesp.UniqueIdKey == StandardIds.System.UniqueIdKey); " is 270.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,The length of the statement  "          isTemplateParameter = CoreSystemTypes.IsInitialized && lastInterface != null && lastInterface == ExtendedRuntimeTypes.ITemplateParameter;" is 137.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,The length of the statement  "              result = this.GetTypeExtensionFromDef(nestedTypeProvider' attributeProvider' memberProvider' i' baseClass' lastInterface);" is 122.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,The length of the statement  "            result = this.GetTypeExtensionFromDef(nestedTypeProvider' attributeProvider' memberProvider' i' baseClass' lastInterface);" is 122.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeExtensionFromDef,The length of the statement  "					HandleError (this.module' string.Format (CultureInfo.CurrentCulture' ExceptionStrings.CannotLoadTypeExtension' lastInterface.FullName' compilerDllName)); " is 153.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetDummyTypeNode,The length of the statement  "		HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotResolveTypeReference' "[" + modName + "]" + namesp + "." + name)); " is 160.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetDummyTypeNode,The length of the statement  "	if (name != null && name.ToString ().StartsWith ("I") && name.ToString ().Length > 1 && char.IsUpper (name.ToString () [1])) " is 124.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetNestedModule,The length of the statement  "		HandleError (module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindReferencedModule' modLocation)); " is 125.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The length of the statement  "				HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation)); " is 156.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The length of the statement  "				HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName)); " is 159.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The length of the statement  "				HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName)); " is 150.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseTypeSignature,The length of the statement  "			HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.BadTypeParameterInPositionForType' pnum' this.currentType == null ? "" : this.currentType.FullName)); " is 187.
Long Statement,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseTypeSignature,The length of the statement  "			HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.BadMethodTypeParameterInPosition' pnum)); " is 127.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayElementLoadAddress,The length of the statement  "	return new UnaryExpression (this.ParseArrayElementLoad (0' elemType)' this.isReadOnly ? NodeType.ReadOnlyAddressOf : NodeType.AddressOf' elemType.GetReferenceType ()); " is 167.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseBranch,The length of the statement  "	Expression condition = operandCount > 1 ? (Expression)new BinaryExpression (operand1' operand2' operatorType) : (operandCount > 0 ? (operatorType == NodeType.Nop ? operand1 : (Expression)new UnaryExpression (operand1' operatorType)) : null); " is 241.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseCopyObject,The length of the statement  "	return new AssignmentStatement (new AddressDereference (lhaddr' type' this.isVolatile' this.alignment)' new AddressDereference (rhaddr' type)); " is 143.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseLoadRuntimeMetadataToken,The length of the statement  "		exprType = (member.NodeType == NodeType.Field) ? CoreSystemTypes.RuntimeFieldHandle : CoreSystemTypes.RuntimeMethodHandle; " is 122.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInitObject,The length of the statement  "	return new AssignmentStatement (new AddressDereference (lhaddr' type' this.isVolatile' this.alignment)' new Literal (null' CoreSystemTypes.Object)); " is 148.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The length of the statement  "			expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf)); " is 154.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The length of the statement  "			expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf)); " is 145.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The length of the statement  "			statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ()); " is 139.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The length of the statement  "			expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); " is 152.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The length of the statement  "			expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); " is 170.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The length of the statement  "			expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr); " is 122.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The length of the statement  "			expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); " is 142.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The length of the statement  "			expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); " is 132.
Long Statement,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStoreField,The length of the statement  "	AssignmentStatement s = new AssignmentStatement (new MemberBinding (thisob' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' rhvalue); " is 147.
Long Statement,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The length of the statement  "		throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x"))); " is 146.
Complex Conditional,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitMemberReference,The conditional expression  "method != null && method.Template != null && method.TemplateArguments != null && method.TemplateArguments.Count > 0"  is complex.
Complex Conditional,System.Compiler,Duplicator,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Duplicator.cs,VisitTypeReference,The conditional expression  "type.Template != null && type.Template != type && (type.TemplateArguments != null || (!this.RecordOriginalAsTemplate && type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Combine,The conditional expression  "ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || (path2.Length >= 2 && path2 [1] == BetterPath.VolumeSeparatorChar)"  is complex.
Complex Conditional,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Matches,The conditional expression  "this.Version != version && this.Version != null && (version == null || !this.Version.Equals (version))"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetTemplateInstance,The conditional expression  "module == null || templateArguments == null || (declaringType == null && (templateParameters == null || templateParameters.Count == 0))"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetOpFalse,The conditional expression  "!opFalse.IsSpecialName || !opFalse.IsStatic || !opFalse.IsPublic || opFalse.ReturnType != CoreSystemTypes.Boolean || opFalse.Parameters == null || opFalse.Parameters.Count != 1"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetOpTrue,The conditional expression  "!opTrue.IsSpecialName || !opTrue.IsStatic || !opTrue.IsPublic || opTrue.ReturnType != CoreSystemTypes.Boolean || opTrue.Parameters == null || opTrue.Parameters.Count != 1"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetImplementingMethod,The conditional expression  "locM == null || !locM.IsVirtual || (checkPublic && !locM.IsPublic)"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetImplementingMethod,The conditional expression  "(locM.ReturnType != meth.ReturnType && !(locM.ReturnType != null && locM.ReturnType.IsStructurallyEquivalentTo (meth.ReturnType))) || !locM.ParametersMatchStructurally (meth.Parameters)"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The conditional expression  "targetType == CoreSystemTypes.Object || this.IsStructurallyEquivalentTo (targetType) || this.BaseType != null && (this.BaseType.IsAssignableTo (targetType))"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The conditional expression  "this.BaseType != null && this.ConsolidatedTemplateParameters != null && this.BaseType.Template != null && this.BaseType.Template.IsAssignableTo (targetType)"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableToInstanceOf,The conditional expression  "targetTemplate.IsStructurallyEquivalentTo (this.Template == null ? this : this.Template) || this.BaseType != null && (this.BaseType.IsAssignableToInstanceOf (targetTemplate) || this.BaseType.Template != null && this.BaseType.Template.IsAssignableToInstanceOf (targetTemplate))"  is complex.
Complex Conditional,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsStructurallyEquivalentTo,The conditional expression  "this.DeclaringType != null && (this.TemplateArguments == null || this.TemplateArguments.Count == 0) && (type.TemplateArguments == null || type.TemplateArguments.Count == 0)"  is complex.
Complex Conditional,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAliasFor,The conditional expression  "name == null || this.AssociatedNamespace == null || this.AssociatedModule == null || this.aliasFor == null"  is complex.
Complex Conditional,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetConflictingAlias,The conditional expression  "name == null || this.typeFor == null || this.AssociatedNamespace == null || this.AssociatedModule == null"  is complex.
Complex Conditional,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetNamespaceFullNameFor,The conditional expression  "name == null || this.AssociatedNamespace == null || this.AssociatedModule == null || this.nestedNamespaceFullName == null"  is complex.
Complex Conditional,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The conditional expression  "Namespace == null || name == null || this.AssociatedNamespace == null || this.AssociatedModule == null"  is complex.
Complex Conditional,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The conditional expression  "name == null || this.typeFor == null || this.AssociatedNamespace == null || this.AssociatedModule == null"  is complex.
Complex Conditional,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The conditional expression  "result == null && returnNullIfHiddenByNestedNamespace && nsScope != null && nsScope.AliasedNamespace != null && nsScope.AliasedNamespace [name.UniqueIdKey] != null"  is complex.
Complex Conditional,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The conditional expression  "duplicates != null && duplicates.Count > 1 && this.AssociatedNamespace != null && this.AssociatedNamespace.Name != null && this.AssociatedNamespace.Name.Name != null"  is complex.
Complex Conditional,System.Compiler,NamespaceScope,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetReferencedTypes,The conditional expression  "Namespace == null || name == null || types == null || this.AssociatedModule == null"  is complex.
Complex Conditional,System.Compiler,ArrayType,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,IsAssignableTo,The conditional expression  "targetType == this || targetType == CoreSystemTypes.Object || targetType == CoreSystemTypes.Array || targetType == SystemTypes.ICloneable"  is complex.
Complex Conditional,System.Compiler,Method,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetDocumentationId,The conditional expression  "this.IsSpecialName && this.ReturnType != null && this.Name != null && (this.Name.UniqueIdKey == StandardIds.opExplicit.UniqueIdKey || this.Name.UniqueIdKey == StandardIds.opImplicit.UniqueIdKey)"  is complex.
Complex Conditional,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,GetCorrespondingMember,The conditional expression  "unspecializedMember != null && specializedMember == null && unspecializedOffset == i && !(unspecializedMember is TypeParameter || unspecializedMember is ClassParameter)"  is complex.
Complex Conditional,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,GetCorrespondingMember,The conditional expression  "unspecializedMember == null && specializedMember != null && specializedOffset == i && !(specializedMember is TypeParameter || specializedMember is ClassParameter)"  is complex.
Complex Conditional,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeNode,The conditional expression  "savedCurrentType != null && savedCurrentType.TemplateArguments != null && savedCurrentType.TemplateArguments.Count > 0 && typeNode.Template != null && (typeNode.Template.TemplateParameters == null || typeNode.Template.TemplateParameters.Count == 0)"  is complex.
Complex Conditional,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The conditional expression  "arguments != null && arguments.Count > 0 && nt.ConsolidatedTemplateParameters != null && nt.ConsolidatedTemplateParameters.Count > 0"  is complex.
Complex Conditional,System.Compiler,Specializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitTypeReference,The conditional expression  "!type.IsNotFullySpecialized && (!type.IsNormalized || (this.CurrentType != null && type.DeclaringModule == this.CurrentType.DeclaringModule))"  is complex.
Complex Conditional,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitAssignmentStatement,The conditional expression  "!sType.IsValueType && !(sType == CoreSystemTypes.Object && source is Literal && target.NodeType == NodeType.AddressDereference)"  is complex.
Complex Conditional,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitBinaryExpression,The conditional expression  "lit != null && lit.Value == null && opnd1 != null && opnd1.Type != null && opnd1.Type.IsValueType"  is complex.
Complex Conditional,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitBinaryExpression,The conditional expression  "lit != null && lit.Value == null && opnd2 != null && opnd2.Type != null && opnd2.Type.IsValueType"  is complex.
Complex Conditional,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitBinaryExpression,The conditional expression  "lit != null && lit.Value == null && opnd1 != null && opnd1.Type != null && opnd1.Type.IsValueType"  is complex.
Complex Conditional,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitBinaryExpression,The conditional expression  "lit != null && lit.Value == null && opnd2 != null && opnd2.Type != null && opnd2.Type.IsValueType"  is complex.
Complex Conditional,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitBranch,The conditional expression  "ct != null && !ct.IsPrimitiveInteger && ct != CoreSystemTypes.Boolean && ct.IsValueType"  is complex.
Complex Conditional,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitMethodCall,The conditional expression  "meth.ReturnType != null && call.Type != null && meth.ReturnType.IsValueType && !call.Type.IsValueType"  is complex.
Complex Conditional,System.Compiler,MethodBodySpecializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Specializer.cs,VisitReturn,The conditional expression  "rval == null || rval.Type == null || this.CurrentMethod == null || this.CurrentMethod.ReturnType == null"  is complex.
Complex Conditional,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The conditional expression  "TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 || (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999)"  is complex.
Complex Conditional,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetDummyTypeNode,The conditional expression  "name.EndsWith ("Callback") || name.EndsWith ("Delegate") || name == "ThreadStart" || name == "FrameGuardGetter" || name == "GuardThreadStart""  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The conditional expression  "field != null && field.DeclaringType != null && field.DeclaringType.Template != null && field.DeclaringType.Template.IsGeneric"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The conditional expression  "this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,IsStructural,The conditional expression  "this.UseGenerics && (type.IsGeneric || type.Template != null && type.Template.IsGeneric)"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeToken,The conditional expression  "this.IsStructural (type) && (!type.IsGeneric || (type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefToken,The conditional expression  "this.IsStructural (type) && (!type.IsGeneric || (type.Template != null && type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The conditional expression  "this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMethodTable,The conditional expression  "m.IsAbstract || m.Body == null || m.Body.Statements == null || m.Body.Statements.Count == 0"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The conditional expression  "adrType != null && (adrType.IsValueType || this.UseGenerics && (adrType is ITypeParameter))"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The conditional expression  "n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The conditional expression  "eh == null || eh.HandlerStartBlock == null || (eh.HandlerType != NodeType.Catch && eh.HandlerType != NodeType.Filter)"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The conditional expression  "tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff"  is complex.
Complex Conditional,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DefineSequencePoint,The conditional expression  "this.symWriter != null && node != null && node.SourceContext.Document != null && !node.SourceContext.Document.Hidden"  is complex.
Complex Conditional,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,ParseVersion,The conditional expression  "major == UInt16.MaxValue && minor == UInt16.MaxValue && build == UInt16.MaxValue && revision == UInt16.MaxValue"  is complex.
Complex Conditional,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The conditional expression  "typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID"  is complex.
Complex Conditional,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The conditional expression  "aRef != null && assemblyReference.Version != null && aRef.Version >= assemblyReference.Version && aRef.MatchesIgnoringVersion (assemblyReference)"  is complex.
Complex Conditional,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The conditional expression  "aRef == null && assembly.FileLastWriteTimeUtc > cachedAssembly.FileLastWriteTimeUtc && assembly.Location != null && cachedAssembly.Location != null && assembly.Location == cachedAssembly.Location"  is complex.
Complex Conditional,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCachedAssembly,The conditional expression  "assembly.FileLastWriteTimeUtc > cachedAssembly.FileLastWriteTimeUtc && assembly.Location != null && cachedAssembly.Location != null && assembly.Location == cachedAssembly.Location"  is complex.
Complex Conditional,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The conditional expression  "SystemAssemblyLocation.ParsedAssembly != null && (assemblyReference.Name == "mscorlib" || assemblyReference.Name == "basetypes" || assemblyReference.Name == "ioconfig" || assemblyReference.Name == "singularity.v1")"  is complex.
Complex Conditional,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetAssemblyFromReference,The conditional expression  "aRef != null && assemblyReference.Version != null && aRef.Version >= assemblyReference.Version && aRef.MatchesIgnoringVersion (assemblyReference)"  is complex.
Complex Conditional,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseSimpleTypeName,The conditional expression  "ch == '.' || ch == '+' || ch == '&' || ch == '*' || ch == '[' || ch == '!'"  is complex.
Complex Conditional,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The conditional expression  "typeParamCount != int.MinValue && (!m.IsGeneric || m.TemplateParameters == null || m.TemplateParameters.Count != typeParamCount)"  is complex.
Complex Conditional,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetDummyTypeNode,The conditional expression  "name != null && name.ToString ().StartsWith ("I") && name.ToString ().Length > 1 && char.IsUpper (name.ToString () [1])"  is complex.
Virtual Method Call from Constructor,System.Compiler,SourceContext,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,SourceContext,The constructor "SourceContext" calls a virtual method "GetOffsets".
Virtual Method Call from Constructor,System.Compiler,ConstructArray,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ConstructArray,The constructor "ConstructArray" calls a virtual method "GetArrayType".
Virtual Method Call from Constructor,System.Compiler,ConstructArray,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ConstructArray,The constructor "ConstructArray" calls a virtual method "GetArrayType".
Empty Catch Block,System.Compiler,GlobalAssemblyCache,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,Contains,The method has an empty catch block.
Empty Catch Block,System.Compiler,CollectibleSourceText,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ReadFile,The method has an empty catch block.
Empty Catch Block,System.Compiler,Node,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetVisitorFor,The method has an empty catch block.
Empty Catch Block,System.Compiler,Node,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetVisitorFor,The method has an empty catch block.
Empty Catch Block,System.Compiler,Node,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetVisitorFor,The method has an empty catch block.
Empty Catch Block,System.Compiler,AttributeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,SetAttributeProperty,The method has an empty catch block.
Empty Catch Block,System.Compiler,AttributeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ConstructAttribute,The method has an empty catch block.
Empty Catch Block,System.Compiler,SecurityAttribute,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,CreatePermission,The method has an empty catch block.
Empty Catch Block,System.Compiler,PlatformHelpers,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TryParseInt32,The method has an empty catch block.
Empty Catch Block,System.Compiler,PlatformHelpers,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TryParseInt32,The method has an empty catch block.
Empty Catch Block,System.Compiler,PlatformHelpers,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TryParseInt32,The method has an empty catch block.
Empty Catch Block,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateFileTable,The method has an empty catch block.
Empty Catch Block,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetPublicKey,The method has an empty catch block.
Empty Catch Block,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetPermissionAttribute2,The method has an empty catch block.
Empty Catch Block,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodDebugSymbols,The method has an empty catch block.
Empty Catch Block,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodDebugSymbols,The method has an empty catch block.
Empty Catch Block,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodDebugSymbols,The method has an empty catch block.
Empty Catch Block,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The method has an empty catch block.
Empty Catch Block,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The method has an empty catch block.
Empty Catch Block,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The method has an empty catch block.
Magic Number,System.Compiler,GlobalAssemblyCache,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,GetLocation,The following statement contains a magic number: lock (GlobalAssemblyCache.Lock) {  	if (!GlobalAssemblyCache.FusionLoaded) {  		GlobalAssemblyCache.FusionLoaded = true;  		System.Reflection.Assembly systemAssembly = typeof(object).Assembly;  		//^ assume systemAssembly != null && systemAssembly.Location != null;  		string dir = Path.GetDirectoryName (systemAssembly.Location);  		//^ assume dir != null;  		GlobalAssemblyCache.LoadLibrary (Path.Combine (dir' "fusion.dll"));  	}  	IAssemblyEnum assemblyEnum;  	CreateAssemblyEnum (out assemblyEnum' null' null' ASM_CACHE.GAC' 0);  	if (assemblyEnum == null)  		return null;  	IApplicationContext applicationContext;  	IAssemblyName currentName;  	while (assemblyEnum.GetNextAssembly (out applicationContext' out currentName' 0) == 0) {  		//^ assume currentName != null;  		AssemblyName aName = new AssemblyName (currentName);  		if (assemblyReference.Matches (aName.Name' aName.Version' aName.Culture' aName.PublicKeyToken)) {  			string codeBase = aName.CodeBase;  			if (codeBase != null && codeBase.StartsWith ("file:///"))  				return codeBase.Substring (8);  			return aName.GetLocation ();  		}  	}  	return null;  }  
Magic Number,System.Compiler,GlobalAssemblyCache,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,GetLocation,The following statement contains a magic number: while (assemblyEnum.GetNextAssembly (out applicationContext' out currentName' 0) == 0) {  	//^ assume currentName != null;  	AssemblyName aName = new AssemblyName (currentName);  	if (assemblyReference.Matches (aName.Name' aName.Version' aName.Culture' aName.PublicKeyToken)) {  		string codeBase = aName.CodeBase;  		if (codeBase != null && codeBase.StartsWith ("file:///"))  			return codeBase.Substring (8);  		return aName.GetLocation ();  	}  }  
Magic Number,System.Compiler,GlobalAssemblyCache,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,GetLocation,The following statement contains a magic number: if (assemblyReference.Matches (aName.Name' aName.Version' aName.Culture' aName.PublicKeyToken)) {  	string codeBase = aName.CodeBase;  	if (codeBase != null && codeBase.StartsWith ("file:///"))  		return codeBase.Substring (8);  	return aName.GetLocation ();  }  
Magic Number,System.Compiler,GlobalAssemblyCache,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,GetLocation,The following statement contains a magic number: if (codeBase != null && codeBase.StartsWith ("file:///"))  	return codeBase.Substring (8);  
Magic Number,System.Compiler,GlobalAssemblyCache,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\AssemblyCache.cs,GetLocation,The following statement contains a magic number: return codeBase.Substring (8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	if (ch < 0x80) {  		m.Position = i + 1;  		m.Buffer [i] = (byte)ch;  	} else  		this.Write (new char[] {  			ch  		});  } else {  	m.Position = i + 2;  	byte[] buffer = m.Buffer;  	buffer [i++] = (byte)ch;  	buffer [i] = (byte)(ch >> 8);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	if (ch < 0x80) {  		m.Position = i + 1;  		m.Buffer [i] = (byte)ch;  	} else  		this.Write (new char[] {  			ch  		});  } else {  	m.Position = i + 2;  	byte[] buffer = m.Buffer;  	buffer [i++] = (byte)ch;  	buffer [i] = (byte)(ch >> 8);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i] = (byte)(ch >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: ch32 = (ch & 0x3FF) << 10;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 3;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + n * 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = 0; j < n; j++) {  	char ch = chars [j];  	buffer [i++] = (byte)ch;  	buffer [i++] = (byte)(ch >> 8);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(ch >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 8;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i] = (byte)(value >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i] = (byte)(value >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(value >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(value >> 16);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i] = (byte)(value >> 24);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(value >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(value >> 16);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i] = (byte)(value >> 24);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 8;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 16);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 24);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(hi >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(hi >> 16);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i] = (byte)(hi >> 24);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 8;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 16);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 24);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(hi >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(hi >> 16);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i] = (byte)(hi >> 24);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (!emitNullTerminator) {  	if (this.UTF8)  		Ir2md.WriteCompressedInt (this' this.GetUTF8ByteCount (str));  	else  		Ir2md.WriteCompressedInt (this' n * 2);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8)  	Ir2md.WriteCompressedInt (this' this.GetUTF8ByteCount (str));  else  	Ir2md.WriteCompressedInt (this' n * 2);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: Ir2md.WriteCompressedInt (this' n * 2);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		} else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		} else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		} else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		} else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  } else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = n - (m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	} else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	} else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  } else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: ch32 = (ch & 0x3FF) << 10;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  } else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 3;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + n * 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: for (int j = 0; j < n; j++) {  	char ch = str [j];  	buffer [i++] = (byte)ch;  	buffer [i++] = (byte)(ch >> 8);  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer [i++] = (byte)(ch >> 8);  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (emitNullTerminator) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = 0;  	buffer [i] = 0;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str == null ? 0 : str.Length; i < n; i++) {  	//^ assume str != null;  	char ch = str [i];  	if (ch < 0x80) {  		count += 1;  	} else if (ch < 0x800) {  		count += 2;  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		count += 2;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		count += 2;  	} else {  		count += 3;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str == null ? 0 : str.Length; i < n; i++) {  	//^ assume str != null;  	char ch = str [i];  	if (ch < 0x80) {  		count += 1;  	} else if (ch < 0x800) {  		count += 2;  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		count += 2;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		count += 2;  	} else {  		count += 3;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str == null ? 0 : str.Length; i < n; i++) {  	//^ assume str != null;  	char ch = str [i];  	if (ch < 0x80) {  		count += 1;  	} else if (ch < 0x800) {  		count += 2;  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		count += 2;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		count += 2;  	} else {  		count += 3;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str == null ? 0 : str.Length; i < n; i++) {  	//^ assume str != null;  	char ch = str [i];  	if (ch < 0x80) {  		count += 1;  	} else if (ch < 0x800) {  		count += 2;  	} else if (0xD800 <= ch && ch <= 0xDBFF) {  		count += 2;  	} else if (0xDC00 <= ch && ch <= 0xDFFF) {  		count += 2;  	} else {  		count += 3;  	}  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x80) {  	count += 1;  } else if (ch < 0x800) {  	count += 2;  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x80) {  	count += 1;  } else if (ch < 0x800) {  	count += 2;  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x80) {  	count += 1;  } else if (ch < 0x800) {  	count += 2;  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x80) {  	count += 1;  } else if (ch < 0x800) {  	count += 2;  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x800) {  	count += 2;  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x800) {  	count += 2;  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x800) {  	count += 2;  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x800) {  	count += 2;  } else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: count += 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  } else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: count += 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  } else {  	count += 3;  }  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: count += 2;  
Magic Number,System.Compiler,BinaryWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: count += 3;  
Magic Number,System.Compiler,MemoryStream,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,MemoryStream,The following statement contains a magic number: this.Buffer = new byte[64];  
Magic Number,System.Compiler,MemoryStream,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Grow,The following statement contains a magic number: while (m >= n2)  	n2 = n2 * 2;  
Magic Number,System.Compiler,MemoryStream,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Grow,The following statement contains a magic number: n2 = n2 * 2;  
Magic Number,System.Compiler,BetterPath,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\FastFileIO.cs,Combine,The following statement contains a magic number: if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || (path2.Length >= 2 && path2 [1] == BetterPath.VolumeSeparatorChar))  	return path2;  
Magic Number,System.Compiler,AliasDefinitionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AliasDefinitionList,The following statement contains a magic number: this.elements = new AliasDefinition[4];  
Magic Number,System.Compiler,AliasDefinitionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AliasDefinition[] newElements = new AliasDefinition[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AliasDefinitionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AliasDefinition[] newElements = new AliasDefinition[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AliasDefinitionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AliasDefinition[] newElements = new AliasDefinition[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AliasDefinitionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,AliasDefinitionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,AliasDefinitionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,AssemblyNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AssemblyNodeList,The following statement contains a magic number: this.elements = new AssemblyNode[4];  
Magic Number,System.Compiler,AssemblyNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AssemblyNode[] newElements = new AssemblyNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AssemblyNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AssemblyNode[] newElements = new AssemblyNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AssemblyNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AssemblyNode[] newElements = new AssemblyNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AssemblyNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,AssemblyNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,AssemblyNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,AssemblyReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AssemblyReferenceList,The following statement contains a magic number: this.elements = new AssemblyReference[4];  
Magic Number,System.Compiler,AssemblyReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AssemblyReference[] newElements = new AssemblyReference[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AssemblyReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AssemblyReference[] newElements = new AssemblyReference[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AssemblyReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	AssemblyReference[] newElements = new AssemblyReference[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AssemblyReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,AssemblyReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,AssemblyReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,AttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AttributeList,The following statement contains a magic number: this.elements = new AttributeNode[8];  
Magic Number,System.Compiler,AttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	AttributeNode[] newElements = new AttributeNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	AttributeNode[] newElements = new AttributeNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	AttributeNode[] newElements = new AttributeNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,AttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,AttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,AttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,BlockList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,BlockList,The following statement contains a magic number: this.elements = new Block[4];  
Magic Number,System.Compiler,BlockList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Block[] newElements = new Block[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,BlockList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Block[] newElements = new Block[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,BlockList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Block[] newElements = new Block[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,BlockList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,BlockList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,BlockList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,CatchList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,CatchList,The following statement contains a magic number: this.elements = new Catch[4];  
Magic Number,System.Compiler,CatchList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Catch[] newElements = new Catch[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CatchList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Catch[] newElements = new Catch[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CatchList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Catch[] newElements = new Catch[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CatchList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,CatchList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,CatchList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,CompilationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,CompilationList,The following statement contains a magic number: this.elements = new Compilation[4];  
Magic Number,System.Compiler,CompilationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Compilation[] newElements = new Compilation[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Compilation[] newElements = new Compilation[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Compilation[] newElements = new Compilation[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,CompilationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,CompilationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,CompilationUnitList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,CompilationUnitList,The following statement contains a magic number: this.elements = new CompilationUnit[4];  
Magic Number,System.Compiler,CompilationUnitList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	CompilationUnit[] newElements = new CompilationUnit[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationUnitList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	CompilationUnit[] newElements = new CompilationUnit[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationUnitList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	CompilationUnit[] newElements = new CompilationUnit[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationUnitList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,CompilationUnitList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,CompilationUnitList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,CompilationUnitSnippetList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,CompilationUnitSnippetList,The following statement contains a magic number: this.elements = new CompilationUnitSnippet[4];  
Magic Number,System.Compiler,CompilationUnitSnippetList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	CompilationUnitSnippet[] newElements = new CompilationUnitSnippet[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationUnitSnippetList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	CompilationUnitSnippet[] newElements = new CompilationUnitSnippet[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationUnitSnippetList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	CompilationUnitSnippet[] newElements = new CompilationUnitSnippet[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,CompilationUnitSnippetList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,CompilationUnitSnippetList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,CompilationUnitSnippetList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,EventList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,EventList,The following statement contains a magic number: this.elements = new Event[8];  
Magic Number,System.Compiler,EventList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Event[] newElements = new Event[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,EventList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Event[] newElements = new Event[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,EventList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Event[] newElements = new Event[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,EventList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,EventList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,EventList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,ErrorNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,ErrorNodeList,The following statement contains a magic number: this.elements = new ErrorNode[8];  
Magic Number,System.Compiler,ErrorNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	ErrorNode[] newElements = new ErrorNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ErrorNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	ErrorNode[] newElements = new ErrorNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ErrorNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	ErrorNode[] newElements = new ErrorNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ErrorNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,ErrorNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,ErrorNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,ExpressionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,ExpressionList,The following statement contains a magic number: this.elements = new Expression[8];  
Magic Number,System.Compiler,ExpressionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Expression[] newElements = new Expression[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ExpressionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Expression[] newElements = new Expression[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ExpressionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Expression[] newElements = new Expression[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ExpressionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,ExpressionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,ExpressionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,ExceptionHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ExceptionHandler[] newElements = new ExceptionHandler[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ExceptionHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ExceptionHandler[] newElements = new ExceptionHandler[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ExceptionHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ExceptionHandler[] newElements = new ExceptionHandler[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ExceptionHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ExceptionHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ExceptionHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,FaultHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,FaultHandlerList,The following statement contains a magic number: this.elements = new FaultHandler[4];  
Magic Number,System.Compiler,FaultHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	FaultHandler[] newElements = new FaultHandler[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FaultHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	FaultHandler[] newElements = new FaultHandler[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FaultHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	FaultHandler[] newElements = new FaultHandler[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FaultHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,FaultHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,FaultHandlerList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,FieldList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,FieldList,The following statement contains a magic number: this.elements = new Field[8];  
Magic Number,System.Compiler,FieldList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Field[] newElements = new Field[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FieldList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Field[] newElements = new Field[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FieldList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Field[] newElements = new Field[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FieldList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,FieldList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,FieldList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,FilterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,FilterList,The following statement contains a magic number: this.elements = new Filter[4];  
Magic Number,System.Compiler,FilterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Filter[] newElements = new Filter[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FilterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Filter[] newElements = new Filter[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FilterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Filter[] newElements = new Filter[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,FilterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,FilterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,FilterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,IdentifierList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,IdentifierList,The following statement contains a magic number: this.elements = new Identifier[8];  
Magic Number,System.Compiler,IdentifierList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Identifier[] newElements = new Identifier[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,IdentifierList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Identifier[] newElements = new Identifier[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,IdentifierList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Identifier[] newElements = new Identifier[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,IdentifierList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,IdentifierList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,IdentifierList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,InstructionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,InstructionList,The following statement contains a magic number: this.elements = new Instruction[32];  
Magic Number,System.Compiler,InstructionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Instruction[] newElements = new Instruction[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,InstructionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Instruction[] newElements = new Instruction[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,InstructionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Instruction[] newElements = new Instruction[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,InstructionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,InstructionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,InstructionList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 32;  
Magic Number,System.Compiler,InterfaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,InterfaceList,The following statement contains a magic number: this.elements = new Interface[8];  
Magic Number,System.Compiler,InterfaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Interface[] newElements = new Interface[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,InterfaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Interface[] newElements = new Interface[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,InterfaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Interface[] newElements = new Interface[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,InterfaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,InterfaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,InterfaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,Int32List,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Int32List,The following statement contains a magic number: this.elements = new Int32[8];  
Magic Number,System.Compiler,Int32List,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Int32[] newElements = new Int32[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,Int32List,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Int32[] newElements = new Int32[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,Int32List,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Int32[] newElements = new Int32[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,Int32List,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,Int32List,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,Int32List,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,ISourceTextList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,ISourceTextList,The following statement contains a magic number: this.elements = new ISourceText[4];  
Magic Number,System.Compiler,ISourceTextList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ISourceText[] newElements = new ISourceText[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ISourceTextList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ISourceText[] newElements = new ISourceText[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ISourceTextList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ISourceText[] newElements = new ISourceText[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ISourceTextList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ISourceTextList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ISourceTextList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,LocalDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,LocalDeclarationList,The following statement contains a magic number: this.elements = new LocalDeclaration[8];  
Magic Number,System.Compiler,LocalDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	LocalDeclaration[] newElements = new LocalDeclaration[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,LocalDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	LocalDeclaration[] newElements = new LocalDeclaration[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,LocalDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	LocalDeclaration[] newElements = new LocalDeclaration[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,LocalDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,LocalDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,LocalDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,LocalList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,LocalList,The following statement contains a magic number: this.elements = new Local[8];  
Magic Number,System.Compiler,LocalList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Local[] newElements = new Local[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,LocalList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Local[] newElements = new Local[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,LocalList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Local[] newElements = new Local[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,LocalList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,LocalList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,LocalList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,MemberList,The following statement contains a magic number: this.elements = new Member[16];  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	Member[] newElements = new Member[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	Member[] newElements = new Member[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	Member[] newElements = new Member[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 16)  	m = 16;  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 16)  	m = 16;  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 16;  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AddList,The following statement contains a magic number: if (newN > n) {  	int m = newN;  	if (m < 16)  		m = 16;  	Member[] newElements = new Member[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AddList,The following statement contains a magic number: if (newN > n) {  	int m = newN;  	if (m < 16)  		m = 16;  	Member[] newElements = new Member[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AddList,The following statement contains a magic number: if (m < 16)  	m = 16;  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AddList,The following statement contains a magic number: if (m < 16)  	m = 16;  
Magic Number,System.Compiler,MemberList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,AddList,The following statement contains a magic number: m = 16;  
Magic Number,System.Compiler,MemberBindingList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,MemberBindingList,The following statement contains a magic number: this.elements = new MemberBinding[8];  
Magic Number,System.Compiler,MemberBindingList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	MemberBinding[] newElements = new MemberBinding[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MemberBindingList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	MemberBinding[] newElements = new MemberBinding[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MemberBindingList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	MemberBinding[] newElements = new MemberBinding[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MemberBindingList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,MemberBindingList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,MemberBindingList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,MethodList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,MethodList,The following statement contains a magic number: this.elements = new Method[8];  
Magic Number,System.Compiler,MethodList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Method[] newElements = new Method[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MethodList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Method[] newElements = new Method[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MethodList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Method[] newElements = new Method[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,MethodList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,MethodList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,MethodList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,ModuleList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,ModuleList,The following statement contains a magic number: this.elements = new Module[4];  
Magic Number,System.Compiler,ModuleList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Module[] newElements = new Module[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ModuleList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Module[] newElements = new Module[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ModuleList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Module[] newElements = new Module[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ModuleList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ModuleList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ModuleList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,ModuleReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,ModuleReferenceList,The following statement contains a magic number: this.elements = new ModuleReference[4];  
Magic Number,System.Compiler,ModuleReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ModuleReference[] newElements = new ModuleReference[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ModuleReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ModuleReference[] newElements = new ModuleReference[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ModuleReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	ModuleReference[] newElements = new ModuleReference[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ModuleReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ModuleReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ModuleReferenceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,NamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,NamespaceList,The following statement contains a magic number: this.elements = new Namespace[4];  
Magic Number,System.Compiler,NamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Namespace[] newElements = new Namespace[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,NamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Namespace[] newElements = new Namespace[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,NamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Namespace[] newElements = new Namespace[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,NamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,NamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,NamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,NodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,NodeList,The following statement contains a magic number: this.elements = new Node[4];  
Magic Number,System.Compiler,NodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Node[] newElements = new Node[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,NodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Node[] newElements = new Node[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,NodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Node[] newElements = new Node[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,NodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,NodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,NodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,ParameterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,ParameterList,The following statement contains a magic number: this.elements = new Parameter[8];  
Magic Number,System.Compiler,ParameterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Parameter[] newElements = new Parameter[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ParameterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Parameter[] newElements = new Parameter[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ParameterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Parameter[] newElements = new Parameter[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ParameterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,ParameterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,ParameterList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,PropertyList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,PropertyList,The following statement contains a magic number: this.elements = new Property[8];  
Magic Number,System.Compiler,PropertyList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Property[] newElements = new Property[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,PropertyList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Property[] newElements = new Property[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,PropertyList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	Property[] newElements = new Property[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,PropertyList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,PropertyList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,PropertyList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,ResourceList,The following statement contains a magic number: this.elements = new Resource[4];  
Magic Number,System.Compiler,ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Resource[] newElements = new Resource[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Resource[] newElements = new Resource[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Resource[] newElements = new Resource[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,ScopeList,The following statement contains a magic number: this.elements = new Scope[32];  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Scope[] newElements = new Scope[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Scope[] newElements = new Scope[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Scope[] newElements = new Scope[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 32;  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Scope[] newElements = new Scope[m];  	for (int j = 0; j < index; j++)  		newElements [j] = elements [j];  	newElements [index] = element;  	for (int j = index; j < n; j++)  		newElements [j + 1] = elements [j];  	return;  }  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Scope[] newElements = new Scope[m];  	for (int j = 0; j < index; j++)  		newElements [j] = elements [j];  	newElements [index] = element;  	for (int j = index; j < n; j++)  		newElements [j + 1] = elements [j];  	return;  }  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Scope[] newElements = new Scope[m];  	for (int j = 0; j < index; j++)  		newElements [j] = elements [j];  	newElements [index] = element;  	for (int j = index; j < n; j++)  		newElements [j + 1] = elements [j];  	return;  }  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,ScopeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: m = 32;  
Magic Number,System.Compiler,SecurityAttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,SecurityAttributeList,The following statement contains a magic number: this.elements = new SecurityAttribute[8];  
Magic Number,System.Compiler,SecurityAttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	SecurityAttribute[] newElements = new SecurityAttribute[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SecurityAttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	SecurityAttribute[] newElements = new SecurityAttribute[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SecurityAttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 8)  		m = 8;  	SecurityAttribute[] newElements = new SecurityAttribute[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SecurityAttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,SecurityAttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 8)  	m = 8;  
Magic Number,System.Compiler,SecurityAttributeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 8;  
Magic Number,System.Compiler,SourceChangeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,SourceChangeList,The following statement contains a magic number: this.elements = new SourceChange[4];  
Magic Number,System.Compiler,SourceChangeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	SourceChange[] newElements = new SourceChange[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SourceChangeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	SourceChange[] newElements = new SourceChange[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SourceChangeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	SourceChange[] newElements = new SourceChange[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SourceChangeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,SourceChangeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,SourceChangeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,StatementList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,StatementList,The following statement contains a magic number: this.elements = new Statement[32];  
Magic Number,System.Compiler,StatementList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Statement[] newElements = new Statement[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,StatementList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Statement[] newElements = new Statement[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,StatementList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	Statement[] newElements = new Statement[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,StatementList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,StatementList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,StatementList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 32;  
Magic Number,System.Compiler,StringList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,StringList,The following statement contains a magic number: this.elements = new string[4];  
Magic Number,System.Compiler,StringList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	String[] newElements = new String[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,StringList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	String[] newElements = new String[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,StringList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	String[] newElements = new String[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,StringList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,StringList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,StringList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,SwitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,SwitchCaseList,The following statement contains a magic number: this.elements = new SwitchCase[16];  
Magic Number,System.Compiler,SwitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	SwitchCase[] newElements = new SwitchCase[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SwitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	SwitchCase[] newElements = new SwitchCase[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SwitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	SwitchCase[] newElements = new SwitchCase[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,SwitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 16)  	m = 16;  
Magic Number,System.Compiler,SwitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 16)  	m = 16;  
Magic Number,System.Compiler,SwitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 16;  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,TypeNodeList,The following statement contains a magic number: this.elements = new TypeNode[32];  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	TypeNode[] newElements = new TypeNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	TypeNode[] newElements = new TypeNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	TypeNode[] newElements = new TypeNode[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 32;  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	TypeNode[] newElements = new TypeNode[m];  	for (int j = 0; j < index; j++)  		newElements [j] = elements [j];  	newElements [index] = element;  	for (int j = index; j < n; j++)  		newElements [j + 1] = elements [j];  	return;  }  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	TypeNode[] newElements = new TypeNode[m];  	for (int j = 0; j < index; j++)  		newElements [j] = elements [j];  	newElements [index] = element;  	for (int j = index; j < n; j++)  		newElements [j + 1] = elements [j];  	return;  }  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 32)  		m = 32;  	TypeNode[] newElements = new TypeNode[m];  	for (int j = 0; j < index; j++)  		newElements [j] = elements [j];  	newElements [index] = element;  	for (int j = index; j < n; j++)  		newElements [j + 1] = elements [j];  	return;  }  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (m < 32)  	m = 32;  
Magic Number,System.Compiler,TypeNodeList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: m = 32;  
Magic Number,System.Compiler,TypeswitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,TypeswitchCaseList,The following statement contains a magic number: this.elements = new TypeswitchCase[16];  
Magic Number,System.Compiler,TypeswitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	TypeswitchCase[] newElements = new TypeswitchCase[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,TypeswitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	TypeswitchCase[] newElements = new TypeswitchCase[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,TypeswitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 16)  		m = 16;  	TypeswitchCase[] newElements = new TypeswitchCase[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,TypeswitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 16)  	m = 16;  
Magic Number,System.Compiler,TypeswitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 16)  	m = 16;  
Magic Number,System.Compiler,TypeswitchCaseList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 16;  
Magic Number,System.Compiler,UsedNamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,UsedNamespaceList,The following statement contains a magic number: this.elements = new UsedNamespace[4];  
Magic Number,System.Compiler,UsedNamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	UsedNamespace[] newElements = new UsedNamespace[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,UsedNamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	UsedNamespace[] newElements = new UsedNamespace[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,UsedNamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	UsedNamespace[] newElements = new UsedNamespace[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,UsedNamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,UsedNamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,UsedNamespaceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,VariableDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,VariableDeclarationList,The following statement contains a magic number: this.elements = new VariableDeclaration[4];  
Magic Number,System.Compiler,VariableDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	VariableDeclaration[] newElements = new VariableDeclaration[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,VariableDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	VariableDeclaration[] newElements = new VariableDeclaration[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,VariableDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	VariableDeclaration[] newElements = new VariableDeclaration[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,VariableDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,VariableDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,VariableDeclarationList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,Win32ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Win32ResourceList,The following statement contains a magic number: this.elements = new Win32Resource[4];  
Magic Number,System.Compiler,Win32ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Win32Resource[] newElements = new Win32Resource[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,Win32ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Win32Resource[] newElements = new Win32Resource[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,Win32ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n) {  	int m = n * 2;  	if (m < 4)  		m = 4;  	Win32Resource[] newElements = new Win32Resource[m];  	for (int j = 0; j < n; j++)  		newElements [j] = elements [j];  	this.elements = newElements;  }  
Magic Number,System.Compiler,Win32ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,Win32ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (m < 4)  	m = 4;  
Magic Number,System.Compiler,Win32ResourceList,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\ListTemplate.cs,Add,The following statement contains a magic number: m = 4;  
Magic Number,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Search,The following statement contains a magic number: while (low < high) {  	mid = (low + high) / 2;  	if (lineOffsets [mid] <= offset) {  		if (offset < lineOffsets [mid + 1])  			return mid;  		else  			low = mid + 1;  	} else  		high = mid;  }  
Magic Number,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Search,The following statement contains a magic number: mid = (low + high) / 2;  
Magic Number,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AddOffset,The following statement contains a magic number: if (this.lines >= this.lineOffsets.Length) {  	int n = this.lineOffsets.Length;  	if (n <= 0)  		n = 16;  	int[] newLineOffsets = new int[n * 2];  	Array.Copy (this.lineOffsets' newLineOffsets' this.lineOffsets.Length);  	this.lineOffsets = newLineOffsets;  }  
Magic Number,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AddOffset,The following statement contains a magic number: if (this.lines >= this.lineOffsets.Length) {  	int n = this.lineOffsets.Length;  	if (n <= 0)  		n = 16;  	int[] newLineOffsets = new int[n * 2];  	Array.Copy (this.lineOffsets' newLineOffsets' this.lineOffsets.Length);  	this.lineOffsets = newLineOffsets;  }  
Magic Number,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AddOffset,The following statement contains a magic number: if (n <= 0)  	n = 16;  
Magic Number,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AddOffset,The following statement contains a magic number: n = 16;  
Magic Number,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ComputeLineOffsets,The following statement contains a magic number: this.lineOffsets = new int[n / 10 + 1];  
Magic Number,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ComputeLineOffsets,The following statement contains a magic number: this.AddOffset (n + 2);  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: if (idoc != null) {  	try {  		#if !FxCop  		idoc.GetDocumentType (out this.DocumentType);  		idoc.GetLanguage (out this.Language);  		idoc.GetLanguageVendor (out this.LanguageVendor);  		#endif  		uint capacity = 1024;  		uint len = 0;  		char[] buffer = new char[capacity];  		while (capacity >= 1024) {  			idoc.GetURL (capacity' out len' buffer);  			if (len < capacity)  				break;  			capacity += 1024;  			buffer = new char[capacity];  		}  		if (len > 0)  			this.Name = new String (buffer' 0' (int)len - 1);  	} finally {  		System.Runtime.InteropServices.Marshal.ReleaseComObject (idoc);  	}  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: if (idoc != null) {  	try {  		#if !FxCop  		idoc.GetDocumentType (out this.DocumentType);  		idoc.GetLanguage (out this.Language);  		idoc.GetLanguageVendor (out this.LanguageVendor);  		#endif  		uint capacity = 1024;  		uint len = 0;  		char[] buffer = new char[capacity];  		while (capacity >= 1024) {  			idoc.GetURL (capacity' out len' buffer);  			if (len < capacity)  				break;  			capacity += 1024;  			buffer = new char[capacity];  		}  		if (len > 0)  			this.Name = new String (buffer' 0' (int)len - 1);  	} finally {  		System.Runtime.InteropServices.Marshal.ReleaseComObject (idoc);  	}  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: if (idoc != null) {  	try {  		#if !FxCop  		idoc.GetDocumentType (out this.DocumentType);  		idoc.GetLanguage (out this.Language);  		idoc.GetLanguageVendor (out this.LanguageVendor);  		#endif  		uint capacity = 1024;  		uint len = 0;  		char[] buffer = new char[capacity];  		while (capacity >= 1024) {  			idoc.GetURL (capacity' out len' buffer);  			if (len < capacity)  				break;  			capacity += 1024;  			buffer = new char[capacity];  		}  		if (len > 0)  			this.Name = new String (buffer' 0' (int)len - 1);  	} finally {  		System.Runtime.InteropServices.Marshal.ReleaseComObject (idoc);  	}  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: try {  	#if !FxCop  	idoc.GetDocumentType (out this.DocumentType);  	idoc.GetLanguage (out this.Language);  	idoc.GetLanguageVendor (out this.LanguageVendor);  	#endif  	uint capacity = 1024;  	uint len = 0;  	char[] buffer = new char[capacity];  	while (capacity >= 1024) {  		idoc.GetURL (capacity' out len' buffer);  		if (len < capacity)  			break;  		capacity += 1024;  		buffer = new char[capacity];  	}  	if (len > 0)  		this.Name = new String (buffer' 0' (int)len - 1);  } finally {  	System.Runtime.InteropServices.Marshal.ReleaseComObject (idoc);  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: try {  	#if !FxCop  	idoc.GetDocumentType (out this.DocumentType);  	idoc.GetLanguage (out this.Language);  	idoc.GetLanguageVendor (out this.LanguageVendor);  	#endif  	uint capacity = 1024;  	uint len = 0;  	char[] buffer = new char[capacity];  	while (capacity >= 1024) {  		idoc.GetURL (capacity' out len' buffer);  		if (len < capacity)  			break;  		capacity += 1024;  		buffer = new char[capacity];  	}  	if (len > 0)  		this.Name = new String (buffer' 0' (int)len - 1);  } finally {  	System.Runtime.InteropServices.Marshal.ReleaseComObject (idoc);  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: try {  	#if !FxCop  	idoc.GetDocumentType (out this.DocumentType);  	idoc.GetLanguage (out this.Language);  	idoc.GetLanguageVendor (out this.LanguageVendor);  	#endif  	uint capacity = 1024;  	uint len = 0;  	char[] buffer = new char[capacity];  	while (capacity >= 1024) {  		idoc.GetURL (capacity' out len' buffer);  		if (len < capacity)  			break;  		capacity += 1024;  		buffer = new char[capacity];  	}  	if (len > 0)  		this.Name = new String (buffer' 0' (int)len - 1);  } finally {  	System.Runtime.InteropServices.Marshal.ReleaseComObject (idoc);  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: while (capacity >= 1024) {  	idoc.GetURL (capacity' out len' buffer);  	if (len < capacity)  		break;  	capacity += 1024;  	buffer = new char[capacity];  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: while (capacity >= 1024) {  	idoc.GetURL (capacity' out len' buffer);  	if (len < capacity)  		break;  	capacity += 1024;  	buffer = new char[capacity];  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: capacity += 1024;  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,BinarySearch,The following statement contains a magic number: while (low < high) {  	mid = low + (high - low) / 2;  	if (list [mid] <= value) {  		if (list [mid + 1] > value)  			return mid;  		else  			low = mid + 1;  	} else  		high = mid;  }  
Magic Number,System.Compiler,UnmanagedDocument,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,BinarySearch,The following statement contains a magic number: mid = low + (high - low) / 2;  
Magic Number,System.Compiler,TrivialHashtable,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TrivialHashtable,The following statement contains a magic number: this.entries = new HashEntry[16];  
Magic Number,System.Compiler,TrivialHashtable,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TrivialHashtable,The following statement contains a magic number: if (initialSize < 0)  	initialSize = 16;  
Magic Number,System.Compiler,TrivialHashtable,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TrivialHashtable,The following statement contains a magic number: initialSize = 16;  
Magic Number,System.Compiler,TrivialHashtableUsingWeakReferences,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TrivialHashtableUsingWeakReferences,The following statement contains a magic number: this.entries = new HashEntry[16];  
Magic Number,System.Compiler,TrivialHashtableUsingWeakReferences,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TrivialHashtableUsingWeakReferences,The following statement contains a magic number: if (initialSize < 0)  	initialSize = 16;  
Magic Number,System.Compiler,TrivialHashtableUsingWeakReferences,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,TrivialHashtableUsingWeakReferences,The following statement contains a magic number: initialSize = 16;  
Magic Number,System.Compiler,TrivialHashtableUsingWeakReferences,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Contract,The following statement contains a magic number: if (m < 16)  	return;  
Magic Number,System.Compiler,Literal,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Initialize,The following statement contains a magic number: Literal.Int32Two = new Literal (2' CoreSystemTypes.Int32);  
Magic Number,System.Compiler,Literal,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Initialize,The following statement contains a magic number: Literal.Int32Sixteen = new Literal (16' CoreSystemTypes.Int32);  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = offset' n = length + i; i < n; i++) {  	char ch = text [i];  	hcode = hcode * 17 + ch;  }  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: hcode = hcode * 17 + ch;  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	char ch = name [i];  	hcode = hcode * 17 + ch;  }  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: hcode = hcode * 17 + ch;  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = offset; ; i++) {  	byte b = *(pointer + i);  	if (b == 0)  		break;  	if ((b & 0x80) != 0)  		isASCII = false;  	hcode = hcode * 17 + b;  	length++;  }  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: hcode = hcode * 17 + b;  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = 0' n = this.length = name.Length; i < n; i++) {  	char ch = name [i];  	hcode = hcode * 17 + ch;  }  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: hcode = hcode * 17 + ch;  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (uint i = 0; i < length; i++) {  	byte b = *(pointer + i);  	if ((b & 0x80) != 0)  		goto doUTF8decoding;  	hcode = hcode * 17 + b;  }  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: hcode = hcode * 17 + b;  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = 0' n = this.length = name.Length; i < n; i++) {  	char ch = name [i];  	hcode = hcode * 17 + ch;  }  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,Identifier,The following statement contains a magic number: hcode = hcode * 17 + ch;  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetUniqueIdKey,The following statement contains a magic number: lock (Identifier.Lock) {  	int hcode = this.hashCode;  	CanonicalIdentifier[] hTable = Identifier.HashTable;  	int length = hTable.Length;  	int i = hcode % length;  	CanonicalIdentifier id = hTable [i];  	while (id.Name != null) {  		if (this.HasSameNameAs (id))  			return id.UniqueIdKey;  		i = (i + 1) % length;  		id = hTable [i];  	}  	int count = Identifier.count;  	int countp1 = count + 1;  	Identifier.count = countp1;  	string name = this.Name;  	//Get a local copy of the name and drop any reference to a DocumentText instance  	hTable [i] = new CanonicalIdentifier (name' countp1' hcode);  	if (countp1 > length / 2)  		Rehash ();  	//Threshold exceeded' need to rehash          	return countp1;  }  
Magic Number,System.Compiler,Identifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetUniqueIdKey,The following statement contains a magic number: if (countp1 > length / 2)  	Rehash ();  
Magic Number,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The following statement contains a magic number: if (nsTable != null) {  	result = (TypeNode)nsTable [name.UniqueIdKey];  	if (result == Class.DoesNotExist)  		return null;  	if (result != null)  		return result;  } else {  	lock (Module.GlobalLock) {  		nsTable = (TrivialHashtable)this.namespaceTable [@namespace.UniqueIdKey];  		if (nsTable == null)  			this.namespaceTable [@namespace.UniqueIdKey] = nsTable = new TrivialHashtable (32);  	}  }  
Magic Number,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The following statement contains a magic number: lock (Module.GlobalLock) {  	nsTable = (TrivialHashtable)this.namespaceTable [@namespace.UniqueIdKey];  	if (nsTable == null)  		this.namespaceTable [@namespace.UniqueIdKey] = nsTable = new TrivialHashtable (32);  }  
Magic Number,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The following statement contains a magic number: if (nsTable == null)  	this.namespaceTable [@namespace.UniqueIdKey] = nsTable = new TrivialHashtable (32);  
Magic Number,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetType,The following statement contains a magic number: this.namespaceTable [@namespace.UniqueIdKey] = nsTable = new TrivialHashtable (32);  
Magic Number,System.Compiler,Module,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,WriteDocumentation,The following statement contains a magic number: xwriter.Indentation = 2;  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.assemblyName == null) {  	System.Reflection.AssemblyName aName = new System.Reflection.AssemblyName ();  	if (this.Location != null && this.Location != "unknown:location") {  		StringBuilder sb = new StringBuilder ("file:///");  		sb.Append (Path.GetFullPath (this.Location));  		sb.Replace ('\\'' '/');  		aName.CodeBase = sb.ToString ();  	}  	aName.CultureInfo = new System.Globalization.CultureInfo (this.Culture);  	if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 8)  		aName.Flags = System.Reflection.AssemblyNameFlags.PublicKey;  	if ((this.Flags & AssemblyFlags.Retargetable) != 0)  		aName.Flags |= (System.Reflection.AssemblyNameFlags)AssemblyFlags.Retargetable;  	aName.HashAlgorithm = (System.Configuration.Assemblies.AssemblyHashAlgorithm)this.HashAlgorithm;  	if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 0)  		aName.SetPublicKey (this.PublicKeyOrToken);  	else  		aName.SetPublicKey (new byte[0]);  	aName.Name = this.Name;  	aName.Version = this.Version;  	switch (this.Flags & AssemblyFlags.CompatibilityMask) {  	case AssemblyFlags.NonSideBySideCompatible:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;  		break;  	case AssemblyFlags.NonSideBySideProcess:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;  		break;  	case AssemblyFlags.NonSideBySideMachine:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;  		break;  	}  	this.assemblyName = aName;  }  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 8)  	aName.Flags = System.Reflection.AssemblyNameFlags.PublicKey;  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n > 8) {  	#if !ROTOR  	System.Security.Cryptography.SHA1 sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	publicKey = sha1.ComputeHash (publicKey);  	byte[] token = new byte[8];  	for (int i = 0' m = publicKey.Length - 1; i < 8; i++)  		token [i] = publicKey [m - i];  	publicKey = token;  	n = 8;  	#else  	        n = 0; //TODO: figure out how to compute the token on ROTOR #endif  }  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n > 8) {  	#if !ROTOR  	System.Security.Cryptography.SHA1 sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	publicKey = sha1.ComputeHash (publicKey);  	byte[] token = new byte[8];  	for (int i = 0' m = publicKey.Length - 1; i < 8; i++)  		token [i] = publicKey [m - i];  	publicKey = token;  	n = 8;  	#else  	        n = 0; //TODO: figure out how to compute the token on ROTOR #endif  }  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n > 8) {  	#if !ROTOR  	System.Security.Cryptography.SHA1 sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	publicKey = sha1.ComputeHash (publicKey);  	byte[] token = new byte[8];  	for (int i = 0' m = publicKey.Length - 1; i < 8; i++)  		token [i] = publicKey [m - i];  	publicKey = token;  	n = 8;  	#else  	        n = 0; //TODO: figure out how to compute the token on ROTOR #endif  }  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n > 8) {  	#if !ROTOR  	System.Security.Cryptography.SHA1 sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	publicKey = sha1.ComputeHash (publicKey);  	byte[] token = new byte[8];  	for (int i = 0' m = publicKey.Length - 1; i < 8; i++)  		token [i] = publicKey [m - i];  	publicKey = token;  	n = 8;  	#else  	        n = 0; //TODO: figure out how to compute the token on ROTOR #endif  }  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: for (int i = 0' m = publicKey.Length - 1; i < 8; i++)  	token [i] = publicKey [m - i];  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: n = 8;  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n == 0)  	str = new StringBuilder ("' PublicKeyToken=null");  else  	str = new StringBuilder ("' PublicKeyToken="' n * 2 + 17);  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n == 0)  	str = new StringBuilder ("' PublicKeyToken=null");  else  	str = new StringBuilder ("' PublicKeyToken="' n * 2 + 17);  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: str = new StringBuilder ("' PublicKeyToken="' n * 2 + 17);  
Magic Number,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: str = new StringBuilder ("' PublicKeyToken="' n * 2 + 17);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (assembly.PublicKeyOrToken != null && assembly.PublicKeyOrToken.Length > 8)  	this.flags |= AssemblyFlags.PublicKey;  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0) {  	if (n > 16) {  		ArrayList tokArr = new ArrayList ();  		if (n % 2 == 1) {  			tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  			n--;  		}  		for (i = 0; i < n; i += 2) {  			#if WHIDBEY  			                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  			byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  			#endif  			tokArr.Add (b);  		}  		tok = (byte[])tokArr.ToArray (typeof(byte));  	} else {  		ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  		tok = new byte[8];  		tok [0] = (byte)(tk >> 56);  		tok [1] = (byte)(tk >> 48);  		tok [2] = (byte)(tk >> 40);  		tok [3] = (byte)(tk >> 32);  		tok [4] = (byte)(tk >> 24);  		tok [5] = (byte)(tk >> 16);  		tok [6] = (byte)(tk >> 8);  		tok [7] = (byte)tk;  	}  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n > 16) {  	ArrayList tokArr = new ArrayList ();  	if (n % 2 == 1) {  		tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  		n--;  	}  	for (i = 0; i < n; i += 2) {  		#if WHIDBEY  		                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  		byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  		#endif  		tokArr.Add (b);  	}  	tok = (byte[])tokArr.ToArray (typeof(byte));  } else {  	ulong tk = ulong.Parse (token' System.Globalization.NumberStyles.HexNumber' null);  	tok = new byte[8];  	tok [0] = (byte)(tk >> 56);  	tok [1] = (byte)(tk >> 48);  	tok [2] = (byte)(tk >> 40);  	tok [3] = (byte)(tk >> 32);  	tok [4] = (byte)(tk >> 24);  	tok [5] = (byte)(tk >> 16);  	tok [6] = (byte)(tk >> 8);  	tok [7] = (byte)tk;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (n % 2 == 1) {  	tokArr.Add (byte.Parse (token.Substring (0' 1)' System.Globalization.NumberStyles.HexNumber' null));  	n--;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: for (i = 0; i < n; i += 2) {  	#if WHIDBEY  	                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  	byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  	#endif  	tokArr.Add (b);  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: for (i = 0; i < n; i += 2) {  	#if WHIDBEY  	                        byte b = 0;                         bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);                         Debug.Assert(goodByte); #else  	byte b = byte.Parse (token.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber' null);  	#endif  	tokArr.Add (b);  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: i += 2
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok = new byte[8];  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [0] = (byte)(tk >> 56);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [1] = (byte)(tk >> 48);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [2] = (byte)(tk >> 40);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [2] = (byte)(tk >> 40);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [3] = (byte)(tk >> 32);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [3] = (byte)(tk >> 32);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [4] = (byte)(tk >> 24);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [4] = (byte)(tk >> 24);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [5] = (byte)(tk >> 16);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [5] = (byte)(tk >> 16);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [6] = (byte)(tk >> 8);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [6] = (byte)(tk >> 8);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: tok [7] = (byte)tk;  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.assemblyName == null) {  	System.Reflection.AssemblyName aName = new System.Reflection.AssemblyName ();  	aName.CultureInfo = new System.Globalization.CultureInfo (this.Culture == null ? "" : this.Culture);  	if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 8)  		aName.Flags = System.Reflection.AssemblyNameFlags.PublicKey;  	if ((this.Flags & AssemblyFlags.Retargetable) != 0)  		aName.Flags |= (System.Reflection.AssemblyNameFlags)AssemblyFlags.Retargetable;  	aName.HashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1;  	if (this.PublicKeyOrToken != null) {  		if (this.PublicKeyOrToken.Length > 8)  			aName.SetPublicKey (this.PublicKeyOrToken);  		else if (this.PublicKeyOrToken.Length > 0)  			aName.SetPublicKeyToken (this.PublicKeyOrToken);  	} else  		aName.SetPublicKey (new byte[0]);  	aName.Name = this.Name;  	aName.Version = this.Version;  	switch (this.Flags & AssemblyFlags.CompatibilityMask) {  	case AssemblyFlags.NonSideBySideCompatible:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;  		break;  	case AssemblyFlags.NonSideBySideProcess:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;  		break;  	case AssemblyFlags.NonSideBySideMachine:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;  		break;  	}  	this.assemblyName = aName;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.assemblyName == null) {  	System.Reflection.AssemblyName aName = new System.Reflection.AssemblyName ();  	aName.CultureInfo = new System.Globalization.CultureInfo (this.Culture == null ? "" : this.Culture);  	if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 8)  		aName.Flags = System.Reflection.AssemblyNameFlags.PublicKey;  	if ((this.Flags & AssemblyFlags.Retargetable) != 0)  		aName.Flags |= (System.Reflection.AssemblyNameFlags)AssemblyFlags.Retargetable;  	aName.HashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1;  	if (this.PublicKeyOrToken != null) {  		if (this.PublicKeyOrToken.Length > 8)  			aName.SetPublicKey (this.PublicKeyOrToken);  		else if (this.PublicKeyOrToken.Length > 0)  			aName.SetPublicKeyToken (this.PublicKeyOrToken);  	} else  		aName.SetPublicKey (new byte[0]);  	aName.Name = this.Name;  	aName.Version = this.Version;  	switch (this.Flags & AssemblyFlags.CompatibilityMask) {  	case AssemblyFlags.NonSideBySideCompatible:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;  		break;  	case AssemblyFlags.NonSideBySideProcess:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;  		break;  	case AssemblyFlags.NonSideBySideMachine:  		aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;  		break;  	}  	this.assemblyName = aName;  }  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 8)  	aName.Flags = System.Reflection.AssemblyNameFlags.PublicKey;  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.PublicKeyOrToken != null) {  	if (this.PublicKeyOrToken.Length > 8)  		aName.SetPublicKey (this.PublicKeyOrToken);  	else if (this.PublicKeyOrToken.Length > 0)  		aName.SetPublicKeyToken (this.PublicKeyOrToken);  } else  	aName.SetPublicKey (new byte[0]);  
Magic Number,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.PublicKeyOrToken.Length > 8)  	aName.SetPublicKey (this.PublicKeyOrToken);  else if (this.PublicKeyOrToken.Length > 0)  	aName.SetPublicKeyToken (this.PublicKeyOrToken);  
Magic Number,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AppendValue,The following statement contains a magic number: if (str != null) {  	str = str.Trim ();  	if (str.Length > 2 && str [1] == ':' && str.LastIndexOfAny (tags' 0' 1) == 0) {  		char tag = str [0];  		str = str.Substring (2);  		if (tag == 'T' && str.IndexOf (TargetPlatform.GenericTypeNamesMangleChar) >= 0) {  			Module mod = null;  			if (this.DeclaringType != null)  				mod = this.DeclaringType.DeclaringModule;  			else if (this is TypeNode)  				mod = ((TypeNode)this).DeclaringModule;  			if (mod != null) {  				Identifier ns;  				Identifier tn;  				int i = str.LastIndexOf ('.');  				if (i < 0 || i >= str.Length) {  					ns = Identifier.Empty;  					tn = Identifier.For (str);  				} else {  					ns = Identifier.For (str.Substring (0' i));  					tn = Identifier.For (str.Substring (i + 1));  				}  				TypeNode t = mod.GetType (ns' tn' true);  				if (t != null)  					str = t.GetFullUnmangledNameWithTypeParameters ();  			}  		}  	}  	if (str == null || str.Length == 0)  		return;  	bool lastCharWasSpace = false;  	if (sb.Length > 0 && !Char.IsPunctuation (str [0]) && !Char.IsWhiteSpace (str [0])) {  		sb.Append (' ');  		lastCharWasSpace = true;  	}  	foreach (char ch in str) {  		if (Char.IsWhiteSpace (ch)) {  			if (lastCharWasSpace)  				continue;  			lastCharWasSpace = true;  			sb.Append (' ');  		} else {  			lastCharWasSpace = false;  			sb.Append (ch);  		}  	}  	if (sb.Length > 0 && Char.IsWhiteSpace (sb [sb.Length - 1]))  		sb.Length -= 1;  }  
Magic Number,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AppendValue,The following statement contains a magic number: if (str != null) {  	str = str.Trim ();  	if (str.Length > 2 && str [1] == ':' && str.LastIndexOfAny (tags' 0' 1) == 0) {  		char tag = str [0];  		str = str.Substring (2);  		if (tag == 'T' && str.IndexOf (TargetPlatform.GenericTypeNamesMangleChar) >= 0) {  			Module mod = null;  			if (this.DeclaringType != null)  				mod = this.DeclaringType.DeclaringModule;  			else if (this is TypeNode)  				mod = ((TypeNode)this).DeclaringModule;  			if (mod != null) {  				Identifier ns;  				Identifier tn;  				int i = str.LastIndexOf ('.');  				if (i < 0 || i >= str.Length) {  					ns = Identifier.Empty;  					tn = Identifier.For (str);  				} else {  					ns = Identifier.For (str.Substring (0' i));  					tn = Identifier.For (str.Substring (i + 1));  				}  				TypeNode t = mod.GetType (ns' tn' true);  				if (t != null)  					str = t.GetFullUnmangledNameWithTypeParameters ();  			}  		}  	}  	if (str == null || str.Length == 0)  		return;  	bool lastCharWasSpace = false;  	if (sb.Length > 0 && !Char.IsPunctuation (str [0]) && !Char.IsWhiteSpace (str [0])) {  		sb.Append (' ');  		lastCharWasSpace = true;  	}  	foreach (char ch in str) {  		if (Char.IsWhiteSpace (ch)) {  			if (lastCharWasSpace)  				continue;  			lastCharWasSpace = true;  			sb.Append (' ');  		} else {  			lastCharWasSpace = false;  			sb.Append (ch);  		}  	}  	if (sb.Length > 0 && Char.IsWhiteSpace (sb [sb.Length - 1]))  		sb.Length -= 1;  }  
Magic Number,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AppendValue,The following statement contains a magic number: if (str.Length > 2 && str [1] == ':' && str.LastIndexOfAny (tags' 0' 1) == 0) {  	char tag = str [0];  	str = str.Substring (2);  	if (tag == 'T' && str.IndexOf (TargetPlatform.GenericTypeNamesMangleChar) >= 0) {  		Module mod = null;  		if (this.DeclaringType != null)  			mod = this.DeclaringType.DeclaringModule;  		else if (this is TypeNode)  			mod = ((TypeNode)this).DeclaringModule;  		if (mod != null) {  			Identifier ns;  			Identifier tn;  			int i = str.LastIndexOf ('.');  			if (i < 0 || i >= str.Length) {  				ns = Identifier.Empty;  				tn = Identifier.For (str);  			} else {  				ns = Identifier.For (str.Substring (0' i));  				tn = Identifier.For (str.Substring (i + 1));  			}  			TypeNode t = mod.GetType (ns' tn' true);  			if (t != null)  				str = t.GetFullUnmangledNameWithTypeParameters ();  		}  	}  }  
Magic Number,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AppendValue,The following statement contains a magic number: if (str.Length > 2 && str [1] == ':' && str.LastIndexOfAny (tags' 0' 1) == 0) {  	char tag = str [0];  	str = str.Substring (2);  	if (tag == 'T' && str.IndexOf (TargetPlatform.GenericTypeNamesMangleChar) >= 0) {  		Module mod = null;  		if (this.DeclaringType != null)  			mod = this.DeclaringType.DeclaringModule;  		else if (this is TypeNode)  			mod = ((TypeNode)this).DeclaringModule;  		if (mod != null) {  			Identifier ns;  			Identifier tn;  			int i = str.LastIndexOf ('.');  			if (i < 0 || i >= str.Length) {  				ns = Identifier.Empty;  				tn = Identifier.For (str);  			} else {  				ns = Identifier.For (str.Substring (0' i));  				tn = Identifier.For (str.Substring (i + 1));  			}  			TypeNode t = mod.GetType (ns' tn' true);  			if (t != null)  				str = t.GetFullUnmangledNameWithTypeParameters ();  		}  	}  }  
Magic Number,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AppendValue,The following statement contains a magic number: str = str.Substring (2);  
Magic Number,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UpdateMemberTable,The following statement contains a magic number: lock (this) {  	if (this.memberTable == null)  		this.memberTable = new TrivialHashtable (32);  	for (int i = this.memberCount; i < range; i++) {  		Member mem = thisMembers [i];  		if (mem == null || mem.Name == null)  			continue;  		MemberList members = (MemberList)this.memberTable [mem.Name.UniqueIdKey];  		if (members == null)  			this.memberTable [mem.Name.UniqueIdKey] = members = new MemberList ();  		members.Add (mem);  	}  	this.memberCount = range;  	this.constructors = null;  }  
Magic Number,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UpdateMemberTable,The following statement contains a magic number: if (this.memberTable == null)  	this.memberTable = new TrivialHashtable (32);  
Magic Number,System.Compiler,TypeNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,UpdateMemberTable,The following statement contains a magic number: this.memberTable = new TrivialHashtable (32);  
Magic Number,System.Compiler,DelegateNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ProvideMembers,The following statement contains a magic number: parameters = new ParameterList (n + 2);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 ();  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 ();  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 ();  	else  		TargetPlatform.SetToV2 ();  } else  	TargetPlatform.SetToV1 ();  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 ();  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 ();  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 ();  	else  		TargetPlatform.SetToV2 ();  } else  	TargetPlatform.SetToV1 ();  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 ();  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 ();  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 ();  	else  		TargetPlatform.SetToV2 ();  } else  	TargetPlatform.SetToV1 ();  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 ();  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 ();  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 ();  	else  		TargetPlatform.SetToV2 ();  } else  	TargetPlatform.SetToV1 ();  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 ();  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 ();  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 ();  	else  		TargetPlatform.SetToV2 ();  } else  	TargetPlatform.SetToV1 ();  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 3300)  	TargetPlatform.SetToV1 ();  else if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 ();  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 3300)  	TargetPlatform.SetToV1 ();  else if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 ();  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 3300)  	TargetPlatform.SetToV1 ();  else if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 ();  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 ();  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 ();  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (TargetPlatform.PlatformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 ();  	else  		TargetPlatform.SetToV2 ();  } else  	TargetPlatform.SetToV1 ();  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 ();  	else  		TargetPlatform.SetToV2 ();  } else  	TargetPlatform.SetToV1 ();  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 3600)  	TargetPlatform.SetToV2Beta1 ();  else  	TargetPlatform.SetToV2 ();  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 (platformAssembliesLocation);  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 (platformAssembliesLocation);  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 (platformAssembliesLocation);  	else  		TargetPlatform.SetToV2 (platformAssembliesLocation);  } else  	TargetPlatform.SetToV1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 (platformAssembliesLocation);  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 (platformAssembliesLocation);  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 (platformAssembliesLocation);  	else  		TargetPlatform.SetToV2 (platformAssembliesLocation);  } else  	TargetPlatform.SetToV1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 (platformAssembliesLocation);  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 (platformAssembliesLocation);  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 (platformAssembliesLocation);  	else  		TargetPlatform.SetToV2 (platformAssembliesLocation);  } else  	TargetPlatform.SetToV1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 (platformAssembliesLocation);  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 (platformAssembliesLocation);  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 (platformAssembliesLocation);  	else  		TargetPlatform.SetToV2 (platformAssembliesLocation);  } else  	TargetPlatform.SetToV1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {  	if (version.Minor == 0 && version.Build == 3300)  		TargetPlatform.SetToV1 (platformAssembliesLocation);  	else if (version.Minor == 0 && version.Build == 5000)  		TargetPlatform.SetToV1_1 (platformAssembliesLocation);  	else if (version.Minor == 1 && version.Build == 9999)  		TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  } else if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 (platformAssembliesLocation);  	else  		TargetPlatform.SetToV2 (platformAssembliesLocation);  } else  	TargetPlatform.SetToV1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 3300)  	TargetPlatform.SetToV1 (platformAssembliesLocation);  else if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 (platformAssembliesLocation);  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 3300)  	TargetPlatform.SetToV1 (platformAssembliesLocation);  else if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 (platformAssembliesLocation);  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 3300)  	TargetPlatform.SetToV1 (platformAssembliesLocation);  else if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 (platformAssembliesLocation);  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 (platformAssembliesLocation);  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 5000)  	TargetPlatform.SetToV1_1 (platformAssembliesLocation);  else if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 1 && version.Build == 9999)  	TargetPlatform.SetToPostV1_1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 (platformAssembliesLocation);  	else  		TargetPlatform.SetToV2 (platformAssembliesLocation);  } else  	TargetPlatform.SetToV1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 2) {  	if (version.Minor == 0 && version.Build == 3600)  		TargetPlatform.SetToV2Beta1 (platformAssembliesLocation);  	else  		TargetPlatform.SetToV2 (platformAssembliesLocation);  } else  	TargetPlatform.SetToV1 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Minor == 0 && version.Build == 3600)  	TargetPlatform.SetToV2Beta1 (platformAssembliesLocation);  else  	TargetPlatform.SetToV2 (platformAssembliesLocation);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version (1' 0' 3300);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV1_1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version (1' 0' 5000);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV2,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version (2' 0' 50727);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV2,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version (2' 0' 50727);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV2Beta1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version (2' 0' 3600);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToV2Beta1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version (2' 0' 3600);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToPostV1_1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version (1' 1' 9999);  
Magic Number,System.Compiler,TargetPlatform,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,SetToPostV1_1,The following statement contains a magic number: TargetPlatform.assemblyReferenceFor = new TrivialHashtable (46);  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (TargetPlatform.TargetVersion != null) {  	if (TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 || (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999)) {  		if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable`1")))  			TargetPlatform.GenericTypeNamesMangleChar = '`';  		else if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable!1")))  			TargetPlatform.GenericTypeNamesMangleChar = '!';  		else if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)  			TargetPlatform.GenericTypeNamesMangleChar = (char)0;  	}  }  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (TargetPlatform.TargetVersion != null) {  	if (TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 || (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999)) {  		if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable`1")))  			TargetPlatform.GenericTypeNamesMangleChar = '`';  		else if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable!1")))  			TargetPlatform.GenericTypeNamesMangleChar = '!';  		else if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)  			TargetPlatform.GenericTypeNamesMangleChar = (char)0;  	}  }  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 || (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999)) {  	if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable`1")))  		TargetPlatform.GenericTypeNamesMangleChar = '`';  	else if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable!1")))  		TargetPlatform.GenericTypeNamesMangleChar = '!';  	else if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)  		TargetPlatform.GenericTypeNamesMangleChar = (char)0;  }  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 || (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999)) {  	if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable`1")))  		TargetPlatform.GenericTypeNamesMangleChar = '`';  	else if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable!1")))  		TargetPlatform.GenericTypeNamesMangleChar = '!';  	else if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)  		TargetPlatform.GenericTypeNamesMangleChar = (char)0;  }  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable`1")))  	TargetPlatform.GenericTypeNamesMangleChar = '`';  else if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable!1")))  	TargetPlatform.GenericTypeNamesMangleChar = '!';  else if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)  	TargetPlatform.GenericTypeNamesMangleChar = (char)0;  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (SystemAssembly.IsValidTypeName (StandardIds.System' Identifier.For ("Nullable!1")))  	TargetPlatform.GenericTypeNamesMangleChar = '!';  else if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)  	TargetPlatform.GenericTypeNamesMangleChar = (char)0;  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)  	TargetPlatform.GenericTypeNamesMangleChar = (char)0;  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,InstantiateGenericInterfaces,The following statement contains a magic number: if (TargetPlatform.TargetVersion != null && (TargetPlatform.TargetVersion.Major < 2 && TargetPlatform.TargetVersion.Minor < 2))  	return;  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,InstantiateGenericInterfaces,The following statement contains a magic number: if (TargetPlatform.TargetVersion != null && (TargetPlatform.TargetVersion.Major < 2 && TargetPlatform.TargetVersion.Minor < 2))  	return;  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetSystemAssembly,The following statement contains a magic number: if (result != null) {  	result.TargetRuntimeVersion = TargetPlatform.TargetRuntimeVersion;  	result.MetadataFormatMajorVersion = 1;  	result.MetadataFormatMinorVersion = 1;  	result.LinkerMajorVersion = 8;  	result.LinkerMinorVersion = 0;  	return result;  }  
Magic Number,System.Compiler,CoreSystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,GetSystemAssembly,The following statement contains a magic number: result.LinkerMajorVersion = 8;  
Magic Number,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: GenericDictionary = (Class)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "Dictionary"' 2' ElementType.Class);  
Magic Number,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: GenericIDictionary = (Interface)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "IDictionary"' 2' ElementType.Class);  
Magic Number,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: GenericKeyValuePair = (Struct)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "KeyValuePair"' 2' ElementType.ValueType);  
Magic Number,System.Compiler,SystemTypes,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: GenericSortedDictionary = (Class)GetGenericRuntimeTypeNodeFor ("System.Collections.Generic"' "SortedDictionary"' 2' ElementType.Class);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (debugSymbolsLocation != null) {  	// If targeting RTM (Version.Major = 1 and Version.Minor = 0)  	// then use Symwriter.pdb as ProgID else use CorSymWriter_SxS  	// (Note that RTM version 1.0.3705 has Assembly version 1.0.3300'  	// hence the <= 3705 expression.  This also leaves room for RTM SP releases  	// with slightly different build numbers).  	Type t = null;  	if (v.Major == 1 && v.Minor == 0 && v.Build <= 3705) {  		try {  			t = Type.GetTypeFromProgID ("Symwriter.pdb"' false);  			this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance (t);  			if (this.symWriter != null)  				this.symWriter.Initialize (this' debugSymbolsLocation' null' true);  		} catch (Exception) {  			t = null;  			this.symWriter = null;  		}  	}  	if (t == null) {  		Debug.Assert (this.symWriter == null);  		t = Type.GetTypeFromProgID ("CorSymWriter_SxS"' false);  		if (t != null) {  			Guid guid = t.GUID;  			// If the compiler was built with Whidbey' then mscoree will pick a matching  			// diasymreader.dll out of the Whidbey directory.  But if we are cross-  			// compiling' this is *NOT* what we want.  Instead' we want to override  			// the shim's logic and explicitly pick a diasymreader.dll from the place  			// that matches the version of the output file we are emitting.  This is  			// strictly illegal by the CLR's rules.  However' the CLR does not yet  			// support cross-compilation' so we have little choice.  			if (!UseGenerics) {  				Version vcompiler = typeof(object).Assembly.GetName ().Version;  				if (vcompiler.Major >= 2) {  					// This is the only cross-compilation case we currently support.  					string server = Path.Combine (Path.GetDirectoryName (typeof(object).Assembly.Location)' "..\\v1.1.4322\\diasymreader.dll");  					object o = CrossCompileActivate (server' guid);  					this.symWriter = (ISymUnmanagedWriter)o;  				}  			}  			if (this.symWriter == null) {  				this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance (t);  			}  			if (this.symWriter != null)  				this.symWriter.Initialize (this' debugSymbolsLocation' null' true);  		} else {  			throw new DebugSymbolsCouldNotBeWrittenException ();  		}  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (debugSymbolsLocation != null) {  	// If targeting RTM (Version.Major = 1 and Version.Minor = 0)  	// then use Symwriter.pdb as ProgID else use CorSymWriter_SxS  	// (Note that RTM version 1.0.3705 has Assembly version 1.0.3300'  	// hence the <= 3705 expression.  This also leaves room for RTM SP releases  	// with slightly different build numbers).  	Type t = null;  	if (v.Major == 1 && v.Minor == 0 && v.Build <= 3705) {  		try {  			t = Type.GetTypeFromProgID ("Symwriter.pdb"' false);  			this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance (t);  			if (this.symWriter != null)  				this.symWriter.Initialize (this' debugSymbolsLocation' null' true);  		} catch (Exception) {  			t = null;  			this.symWriter = null;  		}  	}  	if (t == null) {  		Debug.Assert (this.symWriter == null);  		t = Type.GetTypeFromProgID ("CorSymWriter_SxS"' false);  		if (t != null) {  			Guid guid = t.GUID;  			// If the compiler was built with Whidbey' then mscoree will pick a matching  			// diasymreader.dll out of the Whidbey directory.  But if we are cross-  			// compiling' this is *NOT* what we want.  Instead' we want to override  			// the shim's logic and explicitly pick a diasymreader.dll from the place  			// that matches the version of the output file we are emitting.  This is  			// strictly illegal by the CLR's rules.  However' the CLR does not yet  			// support cross-compilation' so we have little choice.  			if (!UseGenerics) {  				Version vcompiler = typeof(object).Assembly.GetName ().Version;  				if (vcompiler.Major >= 2) {  					// This is the only cross-compilation case we currently support.  					string server = Path.Combine (Path.GetDirectoryName (typeof(object).Assembly.Location)' "..\\v1.1.4322\\diasymreader.dll");  					object o = CrossCompileActivate (server' guid);  					this.symWriter = (ISymUnmanagedWriter)o;  				}  			}  			if (this.symWriter == null) {  				this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance (t);  			}  			if (this.symWriter != null)  				this.symWriter.Initialize (this' debugSymbolsLocation' null' true);  		} else {  			throw new DebugSymbolsCouldNotBeWrittenException ();  		}  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (v.Major == 1 && v.Minor == 0 && v.Build <= 3705) {  	try {  		t = Type.GetTypeFromProgID ("Symwriter.pdb"' false);  		this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance (t);  		if (this.symWriter != null)  			this.symWriter.Initialize (this' debugSymbolsLocation' null' true);  	} catch (Exception) {  		t = null;  		this.symWriter = null;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (t == null) {  	Debug.Assert (this.symWriter == null);  	t = Type.GetTypeFromProgID ("CorSymWriter_SxS"' false);  	if (t != null) {  		Guid guid = t.GUID;  		// If the compiler was built with Whidbey' then mscoree will pick a matching  		// diasymreader.dll out of the Whidbey directory.  But if we are cross-  		// compiling' this is *NOT* what we want.  Instead' we want to override  		// the shim's logic and explicitly pick a diasymreader.dll from the place  		// that matches the version of the output file we are emitting.  This is  		// strictly illegal by the CLR's rules.  However' the CLR does not yet  		// support cross-compilation' so we have little choice.  		if (!UseGenerics) {  			Version vcompiler = typeof(object).Assembly.GetName ().Version;  			if (vcompiler.Major >= 2) {  				// This is the only cross-compilation case we currently support.  				string server = Path.Combine (Path.GetDirectoryName (typeof(object).Assembly.Location)' "..\\v1.1.4322\\diasymreader.dll");  				object o = CrossCompileActivate (server' guid);  				this.symWriter = (ISymUnmanagedWriter)o;  			}  		}  		if (this.symWriter == null) {  			this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance (t);  		}  		if (this.symWriter != null)  			this.symWriter.Initialize (this' debugSymbolsLocation' null' true);  	} else {  		throw new DebugSymbolsCouldNotBeWrittenException ();  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (t != null) {  	Guid guid = t.GUID;  	// If the compiler was built with Whidbey' then mscoree will pick a matching  	// diasymreader.dll out of the Whidbey directory.  But if we are cross-  	// compiling' this is *NOT* what we want.  Instead' we want to override  	// the shim's logic and explicitly pick a diasymreader.dll from the place  	// that matches the version of the output file we are emitting.  This is  	// strictly illegal by the CLR's rules.  However' the CLR does not yet  	// support cross-compilation' so we have little choice.  	if (!UseGenerics) {  		Version vcompiler = typeof(object).Assembly.GetName ().Version;  		if (vcompiler.Major >= 2) {  			// This is the only cross-compilation case we currently support.  			string server = Path.Combine (Path.GetDirectoryName (typeof(object).Assembly.Location)' "..\\v1.1.4322\\diasymreader.dll");  			object o = CrossCompileActivate (server' guid);  			this.symWriter = (ISymUnmanagedWriter)o;  		}  	}  	if (this.symWriter == null) {  		this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance (t);  	}  	if (this.symWriter != null)  		this.symWriter.Initialize (this' debugSymbolsLocation' null' true);  } else {  	throw new DebugSymbolsCouldNotBeWrittenException ();  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (!UseGenerics) {  	Version vcompiler = typeof(object).Assembly.GetName ().Version;  	if (vcompiler.Major >= 2) {  		// This is the only cross-compilation case we currently support.  		string server = Path.Combine (Path.GetDirectoryName (typeof(object).Assembly.Location)' "..\\v1.1.4322\\diasymreader.dll");  		object o = CrossCompileActivate (server' guid);  		this.symWriter = (ISymUnmanagedWriter)o;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (vcompiler.Major >= 2) {  	// This is the only cross-compilation case we currently support.  	string server = Path.Combine (Path.GetDirectoryName (typeof(object).Assembly.Location)' "..\\v1.1.4322\\diasymreader.dll");  	object o = CrossCompileActivate (server' guid);  	this.symWriter = (ISymUnmanagedWriter)o;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (writer.fileAlignment < 512)  	writer.fileAlignment = 512;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (writer.fileAlignment < 512)  	writer.fileAlignment = 512;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: writer.fileAlignment = 512;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch (lType.typeCode) {  case ElementType.Boolean:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToBoolean (null));  	break;  case ElementType.Char:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToChar (null));  	break;  case ElementType.Int8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToSByte (null));  	break;  case ElementType.UInt8:  	this.blobHeap.Write ((byte)1);  	this.blobHeap.Write (ic.ToByte (null));  	break;  case ElementType.Int16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToInt16 (null));  	break;  case ElementType.UInt16:  	this.blobHeap.Write ((byte)2);  	this.blobHeap.Write (ic.ToUInt16 (null));  	break;  case ElementType.Int32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToInt32 (null));  	break;  case ElementType.UInt32:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToUInt32 (null));  	break;  case ElementType.Int64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToInt64 (null));  	break;  case ElementType.UInt64:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToUInt64 (null));  	break;  case ElementType.Single:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write (ic.ToSingle (null));  	break;  case ElementType.Double:  	this.blobHeap.Write ((byte)8);  	this.blobHeap.Write (ic.ToDouble (null));  	break;  case ElementType.String:  	this.blobHeap.Write ((string)literal.Value' false);  	break;  case ElementType.Array:  case ElementType.Class:  case ElementType.Object:  case ElementType.Reference:  case ElementType.SzArray:  	this.blobHeap.Write ((byte)4);  	this.blobHeap.Write ((int)0);  	break;  //REVIEW: standard implies this should be 0' peverify thinks otherwise.  default:  	Debug.Assert (false' "Unexpected Literal type");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)2);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)2);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)2);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)4);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)4);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)8);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)8);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)4);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)8);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: this.blobHeap.Write ((byte)4);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return this.GetMethodIndex ((Method)node) << 5;  case NodeType.Field:  	return (this.GetFieldIndex ((Field)node) << 5) | 1;  case NodeType.Parameter:  	return (this.GetParamIndex ((Parameter)node) << 5) | 4;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		return (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		return (this.GetTypeDefIndex (t) << 5) | 3;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  case NodeType.Property:  	return (this.GetPropertyIndex ((Property)node) << 5) | 9;  case NodeType.Event:  	return (this.GetEventIndex ((Event)node) << 5) | 10;  case NodeType.Module:  	return (1 << 5) | 7;  case NodeType.Assembly:  	return (1 << 5) | 14;  default:  	Debug.Assert (false' "Unexpect custom attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return this.GetMethodIndex ((Method)node) << 5;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetFieldIndex ((Field)node) << 5) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetParamIndex ((Parameter)node) << 5) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetParamIndex ((Parameter)node) << 5) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  	return (this.GetTypeSpecIndex (t) << 5) | 13;  else  	return (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  	return (this.GetTypeSpecIndex (t) << 5) | 13;  else  	return (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  	return (this.GetTypeSpecIndex (t) << 5) | 13;  else  	return (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  	return (this.GetTypeSpecIndex (t) << 5) | 13;  else  	return (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetTypeSpecIndex (t) << 5) | 13;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetTypeSpecIndex (t) << 5) | 13;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetGenericParamIndex ((TypeNode)node) << 5) | 19;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetPropertyIndex ((Property)node) << 5) | 9;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetPropertyIndex ((Property)node) << 5) | 9;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetEventIndex ((Event)node) << 5) | 10;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetEventIndex ((Event)node) << 5) | 10;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (1 << 5) | 7;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (1 << 5) | 7;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (1 << 5) | 14;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: return (1 << 5) | 14;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (this.IsStructural (type))  	return (this.GetTypeSpecIndex (type) << 3) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (this.IsStructural (type))  	return (this.GetTypeSpecIndex (type) << 3) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: return (this.GetTypeSpecIndex (type) << 3) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: return (this.GetTypeSpecIndex (type) << 3) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (type.DeclaringModule == this.module)  	return this.GetTypeDefIndex (type) << 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: return this.GetTypeDefIndex (type) << 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (type.DeclaringModule != null)  	return (this.GetTypeRefIndex (type) << 3) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: return (this.GetTypeRefIndex (type) << 3) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (type.typeCode == ElementType.Class || type.typeCode == ElementType.ValueType)  	return this.GetTypeDefIndex (type) << 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: return this.GetTypeDefIndex (type) << 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMethodSpecIndex,The following statement contains a magic number: if (m.Template != null)  	structuralKey = (m.Template.UniqueKey << 8) + blobIndex;  else  	Debug.Assert (false);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetMethodSpecIndex,The following statement contains a magic number: structuralKey = (m.Template.UniqueKey << 8) + blobIndex;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (ob is int) {  	int targetAddress = (int)ob;  	int offset = targetAddress - (fixupLocation + 1);  	if (-128 > offset || offset > 127) {  		offset = targetAddress - (fixupLocation + 4);  		Debug.Assert (offset < -128' "Forward short branch out of range");  		shortOffset = false;  	} else  		shortOffset = true;  	return offset;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (ob is int) {  	int targetAddress = (int)ob;  	int offset = targetAddress - (fixupLocation + 1);  	if (-128 > offset || offset > 127) {  		offset = targetAddress - (fixupLocation + 4);  		Debug.Assert (offset < -128' "Forward short branch out of range");  		shortOffset = false;  	} else  		shortOffset = true;  	return offset;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (ob is int) {  	int targetAddress = (int)ob;  	int offset = targetAddress - (fixupLocation + 1);  	if (-128 > offset || offset > 127) {  		offset = targetAddress - (fixupLocation + 4);  		Debug.Assert (offset < -128' "Forward short branch out of range");  		shortOffset = false;  	} else  		shortOffset = true;  	return offset;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (ob is int) {  	int targetAddress = (int)ob;  	int offset = targetAddress - (fixupLocation + 1);  	if (-128 > offset || offset > 127) {  		offset = targetAddress - (fixupLocation + 4);  		Debug.Assert (offset < -128' "Forward short branch out of range");  		shortOffset = false;  	} else  		shortOffset = true;  	return offset;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (-128 > offset || offset > 127) {  	offset = targetAddress - (fixupLocation + 4);  	Debug.Assert (offset < -128' "Forward short branch out of range");  	shortOffset = false;  } else  	shortOffset = true;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (-128 > offset || offset > 127) {  	offset = targetAddress - (fixupLocation + 4);  	Debug.Assert (offset < -128' "Forward short branch out of range");  	shortOffset = false;  } else  	shortOffset = true;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (-128 > offset || offset > 127) {  	offset = targetAddress - (fixupLocation + 4);  	Debug.Assert (offset < -128' "Forward short branch out of range");  	shortOffset = false;  } else  	shortOffset = true;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (-128 > offset || offset > 127) {  	offset = targetAddress - (fixupLocation + 4);  	Debug.Assert (offset < -128' "Forward short branch out of range");  	shortOffset = false;  } else  	shortOffset = true;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: offset = targetAddress - (fixupLocation + 4);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: Debug.Assert (offset < -128' "Forward short branch out of range");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (shortOffset)  	fixup.addressOfNextInstruction += 1;  else  	fixup.addressOfNextInstruction += 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetOffset,The following statement contains a magic number: fixup.addressOfNextInstruction += 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return (this.GetMethodIndex ((Method)node) << 2) | 1;  case NodeType.Class:  case NodeType.Interface:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Struct:  	return (this.GetTypeDefIndex ((TypeNode)node) << 2) | 0;  case NodeType.Assembly:  	return (1 << 2) | 2;  default:  	Debug.Assert (false' "Unexpected security attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return (this.GetMethodIndex ((Method)node) << 2) | 1;  case NodeType.Class:  case NodeType.Interface:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Struct:  	return (this.GetTypeDefIndex ((TypeNode)node) << 2) | 0;  case NodeType.Assembly:  	return (1 << 2) | 2;  default:  	Debug.Assert (false' "Unexpected security attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return (this.GetMethodIndex ((Method)node) << 2) | 1;  case NodeType.Class:  case NodeType.Interface:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Struct:  	return (this.GetTypeDefIndex ((TypeNode)node) << 2) | 0;  case NodeType.Assembly:  	return (1 << 2) | 2;  default:  	Debug.Assert (false' "Unexpected security attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  case NodeType.Method:  	return (this.GetMethodIndex ((Method)node) << 2) | 1;  case NodeType.Class:  case NodeType.Interface:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Struct:  	return (this.GetTypeDefIndex ((TypeNode)node) << 2) | 0;  case NodeType.Assembly:  	return (1 << 2) | 2;  default:  	Debug.Assert (false' "Unexpected security attribute parent");  	return 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetMethodIndex ((Method)node) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: return (this.GetTypeDefIndex ((TypeNode)node) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: return (1 << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: return (1 << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetUserStringIndex,The following statement contains a magic number: if (index == null) {  	index = (int)this.userStringHeap.BaseStream.Position;  	Ir2md.WriteCompressedInt (this.userStringHeap' str.Length * 2 + 1);  	this.userStringHeap.Write (str.ToCharArray ());  	this.userStringHeapIndex [str] = index;  	//Write out a trailing byte indicating if the string is really quite simple  	ulong stringKind = 0;  	//no funny business  	foreach (char ch in str) {  		if (ch >= 0x7F)  			stringKind += 1;  		else  			switch ((int)ch) {  			case 0x1:  			case 0x2:  			case 0x3:  			case 0x4:  			case 0x5:  			case 0x6:  			case 0x7:  			case 0x8:  			case 0xE:  			case 0xF:  			case 0x10:  			case 0x11:  			case 0x12:  			case 0x13:  			case 0x14:  			case 0x15:  			case 0x16:  			case 0x17:  			case 0x18:  			case 0x19:  			case 0x1A:  			case 0x1B:  			case 0x1C:  			case 0x1D:  			case 0x1E:  			case 0x1F:  			case 0x27:  			case 0x2D:  				stringKind += 1;  				break;  			default:  				break;  			}  	}  	if (stringKind > 0)  		stringKind = 1;  	this.userStringHeap.Write ((byte)stringKind);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetUserStringIndex,The following statement contains a magic number: Ir2md.WriteCompressedInt (this.userStringHeap' str.Length * 2 + 1);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: if (this.IsStructural (type))  	return (this.GetTypeSpecIndex (type) << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: if (this.IsStructural (type))  	return (this.GetTypeSpecIndex (type) << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: return (this.GetTypeSpecIndex (type) << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: return (this.GetTypeSpecIndex (type) << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: if (type.DeclaringModule == this.module)  	return this.GetTypeDefIndex (type) << 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: return this.GetTypeDefIndex (type) << 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: return (this.GetTypeRefIndex (type) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeSpecIndex,The following statement contains a magic number: if (type.Template != null) {  	blobIndex = this.GetBlobIndex (type);  	structuralKey = ((type.Template.UniqueKey << 8) & int.MaxValue) + blobIndex;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetTypeSpecIndex,The following statement contains a magic number: structuralKey = ((type.Template.UniqueKey << 8) & int.MaxValue) + blobIndex;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateConstantTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Parameter p = this.constantTableEntries [i] as Parameter;  	if (p != null) {  		cr [i].Parent = (this.GetParamIndex (p) << 2) | 1;  		cr [i].Value = this.GetBlobIndex ((Literal)p.DefaultValue);  		TypeNode t = p.DefaultValue.Type;  		if (t.NodeType == NodeType.EnumNode)  			t = ((EnumNode)t).UnderlyingType;  		cr [i].Type = (int)t.typeCode;  		if (t is Reference || (t != p.Type && Literal.IsNullLiteral (p.DefaultValue)))  			cr [i].Type = (int)ElementType.Class;  	} else {  		Field f = (Field)this.constantTableEntries [i];  		cr [i].Parent = (this.GetFieldIndex (f) << 2);  		cr [i].Value = this.GetBlobIndex (f.DefaultValue);  		TypeNode t = f.DefaultValue.Type;  		if (t.NodeType == NodeType.EnumNode)  			t = ((EnumNode)t).UnderlyingType;  		cr [i].Type = (int)t.typeCode;  		if (t is Reference || (t != f.Type && Literal.IsNullLiteral (f.DefaultValue)))  			cr [i].Type = (int)ElementType.Class;  	}  	ConstantRow temp = cr [i];  	int parent = temp.Parent;  	for (int j = i - 1; j >= 0; j--) {  		if (cr [j].Parent > parent) {  			cr [j + 1] = cr [j];  			if (j == 0) {  				cr [0] = temp;  				break;  			}  		} else {  			if (j < i - 1)  				cr [j + 1] = temp;  			break;  		}  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateConstantTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Parameter p = this.constantTableEntries [i] as Parameter;  	if (p != null) {  		cr [i].Parent = (this.GetParamIndex (p) << 2) | 1;  		cr [i].Value = this.GetBlobIndex ((Literal)p.DefaultValue);  		TypeNode t = p.DefaultValue.Type;  		if (t.NodeType == NodeType.EnumNode)  			t = ((EnumNode)t).UnderlyingType;  		cr [i].Type = (int)t.typeCode;  		if (t is Reference || (t != p.Type && Literal.IsNullLiteral (p.DefaultValue)))  			cr [i].Type = (int)ElementType.Class;  	} else {  		Field f = (Field)this.constantTableEntries [i];  		cr [i].Parent = (this.GetFieldIndex (f) << 2);  		cr [i].Value = this.GetBlobIndex (f.DefaultValue);  		TypeNode t = f.DefaultValue.Type;  		if (t.NodeType == NodeType.EnumNode)  			t = ((EnumNode)t).UnderlyingType;  		cr [i].Type = (int)t.typeCode;  		if (t is Reference || (t != f.Type && Literal.IsNullLiteral (f.DefaultValue)))  			cr [i].Type = (int)ElementType.Class;  	}  	ConstantRow temp = cr [i];  	int parent = temp.Parent;  	for (int j = i - 1; j >= 0; j--) {  		if (cr [j].Parent > parent) {  			cr [j + 1] = cr [j];  			if (j == 0) {  				cr [0] = temp;  				break;  			}  		} else {  			if (j < i - 1)  				cr [j + 1] = temp;  			break;  		}  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateConstantTable,The following statement contains a magic number: if (p != null) {  	cr [i].Parent = (this.GetParamIndex (p) << 2) | 1;  	cr [i].Value = this.GetBlobIndex ((Literal)p.DefaultValue);  	TypeNode t = p.DefaultValue.Type;  	if (t.NodeType == NodeType.EnumNode)  		t = ((EnumNode)t).UnderlyingType;  	cr [i].Type = (int)t.typeCode;  	if (t is Reference || (t != p.Type && Literal.IsNullLiteral (p.DefaultValue)))  		cr [i].Type = (int)ElementType.Class;  } else {  	Field f = (Field)this.constantTableEntries [i];  	cr [i].Parent = (this.GetFieldIndex (f) << 2);  	cr [i].Value = this.GetBlobIndex (f.DefaultValue);  	TypeNode t = f.DefaultValue.Type;  	if (t.NodeType == NodeType.EnumNode)  		t = ((EnumNode)t).UnderlyingType;  	cr [i].Type = (int)t.typeCode;  	if (t is Reference || (t != f.Type && Literal.IsNullLiteral (f.DefaultValue)))  		cr [i].Type = (int)ElementType.Class;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateConstantTable,The following statement contains a magic number: if (p != null) {  	cr [i].Parent = (this.GetParamIndex (p) << 2) | 1;  	cr [i].Value = this.GetBlobIndex ((Literal)p.DefaultValue);  	TypeNode t = p.DefaultValue.Type;  	if (t.NodeType == NodeType.EnumNode)  		t = ((EnumNode)t).UnderlyingType;  	cr [i].Type = (int)t.typeCode;  	if (t is Reference || (t != p.Type && Literal.IsNullLiteral (p.DefaultValue)))  		cr [i].Type = (int)ElementType.Class;  } else {  	Field f = (Field)this.constantTableEntries [i];  	cr [i].Parent = (this.GetFieldIndex (f) << 2);  	cr [i].Value = this.GetBlobIndex (f.DefaultValue);  	TypeNode t = f.DefaultValue.Type;  	if (t.NodeType == NodeType.EnumNode)  		t = ((EnumNode)t).UnderlyingType;  	cr [i].Type = (int)t.typeCode;  	if (t is Reference || (t != f.Type && Literal.IsNullLiteral (f.DefaultValue)))  		cr [i].Type = (int)ElementType.Class;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateConstantTable,The following statement contains a magic number: cr [i].Parent = (this.GetParamIndex (p) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateConstantTable,The following statement contains a magic number: cr [i].Parent = (this.GetFieldIndex (f) << 2);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++) {  	AttributeList attrs = null;  	Node node = this.nodesWithCustomAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = this.GetMethodIndex (m) << 5;  		attrs = m.Attributes;  		break;  	case NodeType.Field:  		Field f = (Field)node;  		codedIndex = (this.GetFieldIndex (f) << 5) | 1;  		attrs = f.Attributes;  		break;  	case NodeType.Parameter:  		Parameter par = (Parameter)node;  		codedIndex = (this.GetParamIndex (par) << 5) | 4;  		attrs = par.Attributes;  		break;  	case NodeType.Class:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Interface:  	case NodeType.Struct:  	#if !MinimalReader  	case NodeType.TupleType:  	case NodeType.TypeAlias:  	case NodeType.TypeIntersection:  	case NodeType.TypeUnion:  		#endif  		TypeNode t = (TypeNode)node;  		if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  			codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  		else  			codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  		attrs = t.Attributes;  		break;  	case NodeType.ClassParameter:  	case NodeType.TypeParameter:  		if (!this.UseGenerics)  			goto case NodeType.Class;  		t = (TypeNode)node;  		codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  		attrs = t.Attributes;  		break;  	case NodeType.Property:  		Property p = (Property)node;  		codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  		attrs = p.Attributes;  		break;  	case NodeType.Event:  		Event e = (Event)node;  		codedIndex = (this.GetEventIndex (e) << 5) | 10;  		attrs = e.Attributes;  		break;  	case NodeType.Module:  	case NodeType.Assembly:  		codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  		attrs = ((Module)node).Attributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	if (UseGenerics) {  		Debug.Assert (codedIndex > prevCodedIndex);  	}  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		AttributeNode a = attrs [j];  		if (a == null)  			continue;  		table [k].Parent = codedIndex;  		Debug.Assert (a.Constructor is MemberBinding);  		Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  		if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  			table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  		else  			table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  		table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = this.GetMethodIndex (m) << 5;  	attrs = m.Attributes;  	break;  case NodeType.Field:  	Field f = (Field)node;  	codedIndex = (this.GetFieldIndex (f) << 5) | 1;  	attrs = f.Attributes;  	break;  case NodeType.Parameter:  	Parameter par = (Parameter)node;  	codedIndex = (this.GetParamIndex (par) << 5) | 4;  	attrs = par.Attributes;  	break;  case NodeType.Class:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Interface:  case NodeType.Struct:  #if !MinimalReader  case NodeType.TupleType:  case NodeType.TypeAlias:  case NodeType.TypeIntersection:  case NodeType.TypeUnion:  	#endif  	TypeNode t = (TypeNode)node;  	if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  		codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  	else  		codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  	attrs = t.Attributes;  	break;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	if (!this.UseGenerics)  		goto case NodeType.Class;  	t = (TypeNode)node;  	codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  	attrs = t.Attributes;  	break;  case NodeType.Property:  	Property p = (Property)node;  	codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  	attrs = p.Attributes;  	break;  case NodeType.Event:  	Event e = (Event)node;  	codedIndex = (this.GetEventIndex (e) << 5) | 10;  	attrs = e.Attributes;  	break;  case NodeType.Module:  case NodeType.Assembly:  	codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  	attrs = ((Module)node).Attributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = this.GetMethodIndex (m) << 5;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetFieldIndex (f) << 5) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetParamIndex (par) << 5) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetParamIndex (par) << 5) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  	codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  else  	codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  	codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  else  	codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  	codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  else  	codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: if (this.IsStructural (t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))  	codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  else  	codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetTypeSpecIndex (t) << 5) | 13;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetTypeDefIndex (t) << 5) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetGenericParamIndex (t) << 5) | 19;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetPropertyIndex (p) << 5) | 9;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetEventIndex (e) << 5) | 10;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (this.GetEventIndex (e) << 5) | 10;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: codedIndex = (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int j = 0' m = attrs.Count; j < m; j++) {  	AttributeNode a = attrs [j];  	if (a == null)  		continue;  	table [k].Parent = codedIndex;  	Debug.Assert (a.Constructor is MemberBinding);  	Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  	if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  		table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  	else  		table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  	table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  	k++;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int j = 0' m = attrs.Count; j < m; j++) {  	AttributeNode a = attrs [j];  	if (a == null)  		continue;  	table [k].Parent = codedIndex;  	Debug.Assert (a.Constructor is MemberBinding);  	Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  	if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  		table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  	else  		table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  	table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  	k++;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int j = 0' m = attrs.Count; j < m; j++) {  	AttributeNode a = attrs [j];  	if (a == null)  		continue;  	table [k].Parent = codedIndex;  	Debug.Assert (a.Constructor is MemberBinding);  	Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  	if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  		table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  	else  		table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  	table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  	k++;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int j = 0' m = attrs.Count; j < m; j++) {  	AttributeNode a = attrs [j];  	if (a == null)  		continue;  	table [k].Parent = codedIndex;  	Debug.Assert (a.Constructor is MemberBinding);  	Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;  	if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  		table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  	else  		table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  	table [k].Value = this.GetBlobIndex (a.Expressions' cons.Parameters);  	k++;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  	table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  else  	table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  	table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  else  	table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  	table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  else  	table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural (cons.DeclaringType))  	table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  else  	table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: table [k].Constructor = (this.GetMethodIndex (cons) << 3) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: table [k].Constructor = (this.GetMemberRefIndex (cons) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithSecurityAttributes.Count; i < n; i++) {  	SecurityAttributeList attrs = null;  	Node node = this.nodesWithSecurityAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = (this.GetMethodIndex (m) << 2) | 1;  		attrs = m.SecurityAttributes;  		break;  	case NodeType.Class:  	case NodeType.Interface:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Struct:  		TypeNode t = (TypeNode)node;  		codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  		attrs = t.SecurityAttributes;  		break;  	case NodeType.Assembly:  		codedIndex = (1 << 2) | 2;  		attrs = ((AssemblyNode)node).SecurityAttributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	Debug.Assert (codedIndex > prevCodedIndex);  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		SecurityAttribute a = attrs [j];  		if (a == null)  			continue;  		this.VisitReferencedType (CoreSystemTypes.SecurityAction);  		table [k].Action = (int)a.Action;  		table [k].Parent = codedIndex;  		if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1)  			table [k].PermissionSet = this.GetBlobIndex (a.SerializedPermissions);  		else {  			if (a.PermissionAttributes != null) {  				table [k].PermissionSet = this.GetBlobIndex (a.PermissionAttributes);  			} else {  				// Came across some assemblies that had a metadata version > 1.0' but still used  				// serialized security attributes. So might as well try to see if this is the case  				// if the PermissionAttributes are null.  				table [k].PermissionSet = this.GetBlobIndex (a.SerializedPermissions);  			}  		}  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithSecurityAttributes.Count; i < n; i++) {  	SecurityAttributeList attrs = null;  	Node node = this.nodesWithSecurityAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = (this.GetMethodIndex (m) << 2) | 1;  		attrs = m.SecurityAttributes;  		break;  	case NodeType.Class:  	case NodeType.Interface:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Struct:  		TypeNode t = (TypeNode)node;  		codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  		attrs = t.SecurityAttributes;  		break;  	case NodeType.Assembly:  		codedIndex = (1 << 2) | 2;  		attrs = ((AssemblyNode)node).SecurityAttributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	Debug.Assert (codedIndex > prevCodedIndex);  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		SecurityAttribute a = attrs [j];  		if (a == null)  			continue;  		this.VisitReferencedType (CoreSystemTypes.SecurityAction);  		table [k].Action = (int)a.Action;  		table [k].Parent = codedIndex;  		if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1)  			table [k].PermissionSet = this.GetBlobIndex (a.SerializedPermissions);  		else {  			if (a.PermissionAttributes != null) {  				table [k].PermissionSet = this.GetBlobIndex (a.PermissionAttributes);  			} else {  				// Came across some assemblies that had a metadata version > 1.0' but still used  				// serialized security attributes. So might as well try to see if this is the case  				// if the PermissionAttributes are null.  				table [k].PermissionSet = this.GetBlobIndex (a.SerializedPermissions);  			}  		}  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithSecurityAttributes.Count; i < n; i++) {  	SecurityAttributeList attrs = null;  	Node node = this.nodesWithSecurityAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = (this.GetMethodIndex (m) << 2) | 1;  		attrs = m.SecurityAttributes;  		break;  	case NodeType.Class:  	case NodeType.Interface:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Struct:  		TypeNode t = (TypeNode)node;  		codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  		attrs = t.SecurityAttributes;  		break;  	case NodeType.Assembly:  		codedIndex = (1 << 2) | 2;  		attrs = ((AssemblyNode)node).SecurityAttributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	Debug.Assert (codedIndex > prevCodedIndex);  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		SecurityAttribute a = attrs [j];  		if (a == null)  			continue;  		this.VisitReferencedType (CoreSystemTypes.SecurityAction);  		table [k].Action = (int)a.Action;  		table [k].Parent = codedIndex;  		if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1)  			table [k].PermissionSet = this.GetBlobIndex (a.SerializedPermissions);  		else {  			if (a.PermissionAttributes != null) {  				table [k].PermissionSet = this.GetBlobIndex (a.PermissionAttributes);  			} else {  				// Came across some assemblies that had a metadata version > 1.0' but still used  				// serialized security attributes. So might as well try to see if this is the case  				// if the PermissionAttributes are null.  				table [k].PermissionSet = this.GetBlobIndex (a.SerializedPermissions);  			}  		}  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithSecurityAttributes.Count; i < n; i++) {  	SecurityAttributeList attrs = null;  	Node node = this.nodesWithSecurityAttributes [i];  	int codedIndex = 0;  	switch (node.NodeType) {  	case NodeType.Method:  	case NodeType.InstanceInitializer:  	case NodeType.StaticInitializer:  		Method m = (Method)node;  		codedIndex = (this.GetMethodIndex (m) << 2) | 1;  		attrs = m.SecurityAttributes;  		break;  	case NodeType.Class:  	case NodeType.Interface:  	case NodeType.DelegateNode:  	case NodeType.EnumNode:  	case NodeType.Struct:  		TypeNode t = (TypeNode)node;  		codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  		attrs = t.SecurityAttributes;  		break;  	case NodeType.Assembly:  		codedIndex = (1 << 2) | 2;  		attrs = ((AssemblyNode)node).SecurityAttributes;  		break;  	default:  		Debug.Assert (false);  		break;  	}  	if (attrs == null)  		continue;  	Debug.Assert (codedIndex > prevCodedIndex);  	prevCodedIndex = codedIndex;  	for (int j = 0' m = attrs.Count; j < m; j++) {  		SecurityAttribute a = attrs [j];  		if (a == null)  			continue;  		this.VisitReferencedType (CoreSystemTypes.SecurityAction);  		table [k].Action = (int)a.Action;  		table [k].Parent = codedIndex;  		if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1)  			table [k].PermissionSet = this.GetBlobIndex (a.SerializedPermissions);  		else {  			if (a.PermissionAttributes != null) {  				table [k].PermissionSet = this.GetBlobIndex (a.PermissionAttributes);  			} else {  				// Came across some assemblies that had a metadata version > 1.0' but still used  				// serialized security attributes. So might as well try to see if this is the case  				// if the PermissionAttributes are null.  				table [k].PermissionSet = this.GetBlobIndex (a.SerializedPermissions);  			}  		}  		k++;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = (this.GetMethodIndex (m) << 2) | 1;  	attrs = m.SecurityAttributes;  	break;  case NodeType.Class:  case NodeType.Interface:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Struct:  	TypeNode t = (TypeNode)node;  	codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  	attrs = t.SecurityAttributes;  	break;  case NodeType.Assembly:  	codedIndex = (1 << 2) | 2;  	attrs = ((AssemblyNode)node).SecurityAttributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = (this.GetMethodIndex (m) << 2) | 1;  	attrs = m.SecurityAttributes;  	break;  case NodeType.Class:  case NodeType.Interface:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Struct:  	TypeNode t = (TypeNode)node;  	codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  	attrs = t.SecurityAttributes;  	break;  case NodeType.Assembly:  	codedIndex = (1 << 2) | 2;  	attrs = ((AssemblyNode)node).SecurityAttributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = (this.GetMethodIndex (m) << 2) | 1;  	attrs = m.SecurityAttributes;  	break;  case NodeType.Class:  case NodeType.Interface:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Struct:  	TypeNode t = (TypeNode)node;  	codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  	attrs = t.SecurityAttributes;  	break;  case NodeType.Assembly:  	codedIndex = (1 << 2) | 2;  	attrs = ((AssemblyNode)node).SecurityAttributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: switch (node.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method m = (Method)node;  	codedIndex = (this.GetMethodIndex (m) << 2) | 1;  	attrs = m.SecurityAttributes;  	break;  case NodeType.Class:  case NodeType.Interface:  case NodeType.DelegateNode:  case NodeType.EnumNode:  case NodeType.Struct:  	TypeNode t = (TypeNode)node;  	codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  	attrs = t.SecurityAttributes;  	break;  case NodeType.Assembly:  	codedIndex = (1 << 2) | 2;  	attrs = ((AssemblyNode)node).SecurityAttributes;  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: codedIndex = (this.GetMethodIndex (m) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: codedIndex = (this.GetTypeDefIndex (t) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: codedIndex = (1 << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: codedIndex = (1 << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode et = exportedTypes [i];  	if (et == null || et.Namespace == null || et.Name == null)  		continue;  	ett [i].TypeDefId = 0;  	ett [i].TypeNamespace = this.GetStringIndex (et.Namespace.ToString ());  	ett [i].TypeName = this.GetStringIndex (et.Name.ToString ());  	ett [i].Flags = (int)(et.Flags & TypeFlags.VisibilityMask);  	if (et.DeclaringType != null) {  		for (int j = 0; j < i; j++) {  			if (exportedTypes [j] == et.DeclaringType) {  				ett [i].Implementation = (j << 2) | 2;  				break;  			}  		}  	} else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  		ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  		ett [i].Flags = (int)TypeFlags.Forwarder;  	} else  		ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode et = exportedTypes [i];  	if (et == null || et.Namespace == null || et.Name == null)  		continue;  	ett [i].TypeDefId = 0;  	ett [i].TypeNamespace = this.GetStringIndex (et.Namespace.ToString ());  	ett [i].TypeName = this.GetStringIndex (et.Name.ToString ());  	ett [i].Flags = (int)(et.Flags & TypeFlags.VisibilityMask);  	if (et.DeclaringType != null) {  		for (int j = 0; j < i; j++) {  			if (exportedTypes [j] == et.DeclaringType) {  				ett [i].Implementation = (j << 2) | 2;  				break;  			}  		}  	} else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  		ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  		ett [i].Flags = (int)TypeFlags.Forwarder;  	} else  		ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode et = exportedTypes [i];  	if (et == null || et.Namespace == null || et.Name == null)  		continue;  	ett [i].TypeDefId = 0;  	ett [i].TypeNamespace = this.GetStringIndex (et.Namespace.ToString ());  	ett [i].TypeName = this.GetStringIndex (et.Name.ToString ());  	ett [i].Flags = (int)(et.Flags & TypeFlags.VisibilityMask);  	if (et.DeclaringType != null) {  		for (int j = 0; j < i; j++) {  			if (exportedTypes [j] == et.DeclaringType) {  				ett [i].Implementation = (j << 2) | 2;  				break;  			}  		}  	} else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  		ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  		ett [i].Flags = (int)TypeFlags.Forwarder;  	} else  		ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode et = exportedTypes [i];  	if (et == null || et.Namespace == null || et.Name == null)  		continue;  	ett [i].TypeDefId = 0;  	ett [i].TypeNamespace = this.GetStringIndex (et.Namespace.ToString ());  	ett [i].TypeName = this.GetStringIndex (et.Name.ToString ());  	ett [i].Flags = (int)(et.Flags & TypeFlags.VisibilityMask);  	if (et.DeclaringType != null) {  		for (int j = 0; j < i; j++) {  			if (exportedTypes [j] == et.DeclaringType) {  				ett [i].Implementation = (j << 2) | 2;  				break;  			}  		}  	} else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  		ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  		ett [i].Flags = (int)TypeFlags.Forwarder;  	} else  		ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: if (et.DeclaringType != null) {  	for (int j = 0; j < i; j++) {  		if (exportedTypes [j] == et.DeclaringType) {  			ett [i].Implementation = (j << 2) | 2;  			break;  		}  	}  } else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  	ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  	ett [i].Flags = (int)TypeFlags.Forwarder;  } else  	ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: if (et.DeclaringType != null) {  	for (int j = 0; j < i; j++) {  		if (exportedTypes [j] == et.DeclaringType) {  			ett [i].Implementation = (j << 2) | 2;  			break;  		}  	}  } else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  	ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  	ett [i].Flags = (int)TypeFlags.Forwarder;  } else  	ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: if (et.DeclaringType != null) {  	for (int j = 0; j < i; j++) {  		if (exportedTypes [j] == et.DeclaringType) {  			ett [i].Implementation = (j << 2) | 2;  			break;  		}  	}  } else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  	ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  	ett [i].Flags = (int)TypeFlags.Forwarder;  } else  	ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: if (et.DeclaringType != null) {  	for (int j = 0; j < i; j++) {  		if (exportedTypes [j] == et.DeclaringType) {  			ett [i].Implementation = (j << 2) | 2;  			break;  		}  	}  } else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  	ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  	ett [i].Flags = (int)TypeFlags.Forwarder;  } else  	ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int j = 0; j < i; j++) {  	if (exportedTypes [j] == et.DeclaringType) {  		ett [i].Implementation = (j << 2) | 2;  		break;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int j = 0; j < i; j++) {  	if (exportedTypes [j] == et.DeclaringType) {  		ett [i].Implementation = (j << 2) | 2;  		break;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: if (exportedTypes [j] == et.DeclaringType) {  	ett [i].Implementation = (j << 2) | 2;  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: if (exportedTypes [j] == et.DeclaringType) {  	ett [i].Implementation = (j << 2) | 2;  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: ett [i].Implementation = (j << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: ett [i].Implementation = (j << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  	ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  	ett [i].Flags = (int)TypeFlags.Forwarder;  } else  	ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {  	ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  	ett [i].Flags = (int)TypeFlags.Forwarder;  } else  	ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: ett [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)et.DeclaringModule) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: ett [i].Implementation = (this.GetFileTableIndex (et.DeclaringModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Resource r = resources [i];  	mresources [i].Flags = r.IsPublic ? 1 : 2;  	mresources [i].Name = this.GetStringIndex (r.Name);  	if (r.Data != null)  		mresources [i].Offset = this.GetResourceDataIndex (r.Data);  	else if (r.DefiningModule is AssemblyNode)  		mresources [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)r.DefiningModule) << 2) | 1;  	else  		mresources [i].Implementation = (this.GetFileTableIndex (r.DefiningModule) << 2) | 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Resource r = resources [i];  	mresources [i].Flags = r.IsPublic ? 1 : 2;  	mresources [i].Name = this.GetStringIndex (r.Name);  	if (r.Data != null)  		mresources [i].Offset = this.GetResourceDataIndex (r.Data);  	else if (r.DefiningModule is AssemblyNode)  		mresources [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)r.DefiningModule) << 2) | 1;  	else  		mresources [i].Implementation = (this.GetFileTableIndex (r.DefiningModule) << 2) | 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Resource r = resources [i];  	mresources [i].Flags = r.IsPublic ? 1 : 2;  	mresources [i].Name = this.GetStringIndex (r.Name);  	if (r.Data != null)  		mresources [i].Offset = this.GetResourceDataIndex (r.Data);  	else if (r.DefiningModule is AssemblyNode)  		mresources [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)r.DefiningModule) << 2) | 1;  	else  		mresources [i].Implementation = (this.GetFileTableIndex (r.DefiningModule) << 2) | 0;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: mresources [i].Flags = r.IsPublic ? 1 : 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: if (r.Data != null)  	mresources [i].Offset = this.GetResourceDataIndex (r.Data);  else if (r.DefiningModule is AssemblyNode)  	mresources [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)r.DefiningModule) << 2) | 1;  else  	mresources [i].Implementation = (this.GetFileTableIndex (r.DefiningModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: if (r.Data != null)  	mresources [i].Offset = this.GetResourceDataIndex (r.Data);  else if (r.DefiningModule is AssemblyNode)  	mresources [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)r.DefiningModule) << 2) | 1;  else  	mresources [i].Implementation = (this.GetFileTableIndex (r.DefiningModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: if (r.DefiningModule is AssemblyNode)  	mresources [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)r.DefiningModule) << 2) | 1;  else  	mresources [i].Implementation = (this.GetFileTableIndex (r.DefiningModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: if (r.DefiningModule is AssemblyNode)  	mresources [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)r.DefiningModule) << 2) | 1;  else  	mresources [i].Implementation = (this.GetFileTableIndex (r.DefiningModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: mresources [i].Implementation = (this.GetAssemblyRefIndex ((AssemblyNode)r.DefiningModule) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: mresources [i].Implementation = (this.GetFileTableIndex (r.DefiningModule) << 2) | 0;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Member member = this.memberRefEntries [i];  	if (member == null || member.Name == null)  		continue;  	mr [i].Name = this.GetStringIndex (member.Name.ToString ());  	Field f = member as Field;  	if (f != null)  		mr [i].Signature = this.GetBlobIndex (f);  	else {  		FunctionPointer fp = member as FunctionPointer;  		if (fp != null) {  			mr [i].Signature = this.GetBlobIndex (fp);  			if (fp is VarargMethodCallSignature) {  				Method m = ((VarargMethodCallSignature)member).method;  				if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  					mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  					continue;  				}  			}  		} else {  			Method m = (Method)member;  			if (m.IsGeneric && m.Template != null)  				m = this.GetUnspecializedMethod (m);  			mr [i].Signature = this.GetBlobIndex (m' false);  			if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  			//TODO: if the declaring type is the special global members type of another module' set class to a module ref  		}  	}  	int j = mr [i].Class = this.GetMemberRefParentEncoded (member.DeclaringType);  	if ((j & 0x3) == 2)  		mr [i].Class = (j & ~0x3) | 4;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Member member = this.memberRefEntries [i];  	if (member == null || member.Name == null)  		continue;  	mr [i].Name = this.GetStringIndex (member.Name.ToString ());  	Field f = member as Field;  	if (f != null)  		mr [i].Signature = this.GetBlobIndex (f);  	else {  		FunctionPointer fp = member as FunctionPointer;  		if (fp != null) {  			mr [i].Signature = this.GetBlobIndex (fp);  			if (fp is VarargMethodCallSignature) {  				Method m = ((VarargMethodCallSignature)member).method;  				if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  					mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  					continue;  				}  			}  		} else {  			Method m = (Method)member;  			if (m.IsGeneric && m.Template != null)  				m = this.GetUnspecializedMethod (m);  			mr [i].Signature = this.GetBlobIndex (m' false);  			if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  			//TODO: if the declaring type is the special global members type of another module' set class to a module ref  		}  	}  	int j = mr [i].Class = this.GetMemberRefParentEncoded (member.DeclaringType);  	if ((j & 0x3) == 2)  		mr [i].Class = (j & ~0x3) | 4;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Member member = this.memberRefEntries [i];  	if (member == null || member.Name == null)  		continue;  	mr [i].Name = this.GetStringIndex (member.Name.ToString ());  	Field f = member as Field;  	if (f != null)  		mr [i].Signature = this.GetBlobIndex (f);  	else {  		FunctionPointer fp = member as FunctionPointer;  		if (fp != null) {  			mr [i].Signature = this.GetBlobIndex (fp);  			if (fp is VarargMethodCallSignature) {  				Method m = ((VarargMethodCallSignature)member).method;  				if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  					mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  					continue;  				}  			}  		} else {  			Method m = (Method)member;  			if (m.IsGeneric && m.Template != null)  				m = this.GetUnspecializedMethod (m);  			mr [i].Signature = this.GetBlobIndex (m' false);  			if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  			//TODO: if the declaring type is the special global members type of another module' set class to a module ref  		}  	}  	int j = mr [i].Class = this.GetMemberRefParentEncoded (member.DeclaringType);  	if ((j & 0x3) == 2)  		mr [i].Class = (j & ~0x3) | 4;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Member member = this.memberRefEntries [i];  	if (member == null || member.Name == null)  		continue;  	mr [i].Name = this.GetStringIndex (member.Name.ToString ());  	Field f = member as Field;  	if (f != null)  		mr [i].Signature = this.GetBlobIndex (f);  	else {  		FunctionPointer fp = member as FunctionPointer;  		if (fp != null) {  			mr [i].Signature = this.GetBlobIndex (fp);  			if (fp is VarargMethodCallSignature) {  				Method m = ((VarargMethodCallSignature)member).method;  				if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  					mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  					continue;  				}  			}  		} else {  			Method m = (Method)member;  			if (m.IsGeneric && m.Template != null)  				m = this.GetUnspecializedMethod (m);  			mr [i].Signature = this.GetBlobIndex (m' false);  			if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  			//TODO: if the declaring type is the special global members type of another module' set class to a module ref  		}  	}  	int j = mr [i].Class = this.GetMemberRefParentEncoded (member.DeclaringType);  	if ((j & 0x3) == 2)  		mr [i].Class = (j & ~0x3) | 4;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Member member = this.memberRefEntries [i];  	if (member == null || member.Name == null)  		continue;  	mr [i].Name = this.GetStringIndex (member.Name.ToString ());  	Field f = member as Field;  	if (f != null)  		mr [i].Signature = this.GetBlobIndex (f);  	else {  		FunctionPointer fp = member as FunctionPointer;  		if (fp != null) {  			mr [i].Signature = this.GetBlobIndex (fp);  			if (fp is VarargMethodCallSignature) {  				Method m = ((VarargMethodCallSignature)member).method;  				if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  					mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  					continue;  				}  			}  		} else {  			Method m = (Method)member;  			if (m.IsGeneric && m.Template != null)  				m = this.GetUnspecializedMethod (m);  			mr [i].Signature = this.GetBlobIndex (m' false);  			if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  			//TODO: if the declaring type is the special global members type of another module' set class to a module ref  		}  	}  	int j = mr [i].Class = this.GetMemberRefParentEncoded (member.DeclaringType);  	if ((j & 0x3) == 2)  		mr [i].Class = (j & ~0x3) | 4;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Member member = this.memberRefEntries [i];  	if (member == null || member.Name == null)  		continue;  	mr [i].Name = this.GetStringIndex (member.Name.ToString ());  	Field f = member as Field;  	if (f != null)  		mr [i].Signature = this.GetBlobIndex (f);  	else {  		FunctionPointer fp = member as FunctionPointer;  		if (fp != null) {  			mr [i].Signature = this.GetBlobIndex (fp);  			if (fp is VarargMethodCallSignature) {  				Method m = ((VarargMethodCallSignature)member).method;  				if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  					mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  					continue;  				}  			}  		} else {  			Method m = (Method)member;  			if (m.IsGeneric && m.Template != null)  				m = this.GetUnspecializedMethod (m);  			mr [i].Signature = this.GetBlobIndex (m' false);  			if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  			//TODO: if the declaring type is the special global members type of another module' set class to a module ref  		}  	}  	int j = mr [i].Class = this.GetMemberRefParentEncoded (member.DeclaringType);  	if ((j & 0x3) == 2)  		mr [i].Class = (j & ~0x3) | 4;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (f != null)  	mr [i].Signature = this.GetBlobIndex (f);  else {  	FunctionPointer fp = member as FunctionPointer;  	if (fp != null) {  		mr [i].Signature = this.GetBlobIndex (fp);  		if (fp is VarargMethodCallSignature) {  			Method m = ((VarargMethodCallSignature)member).method;  			if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  		}  	} else {  		Method m = (Method)member;  		if (m.IsGeneric && m.Template != null)  			m = this.GetUnspecializedMethod (m);  		mr [i].Signature = this.GetBlobIndex (m' false);  		if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  			mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  			continue;  		}  		//TODO: if the declaring type is the special global members type of another module' set class to a module ref  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (f != null)  	mr [i].Signature = this.GetBlobIndex (f);  else {  	FunctionPointer fp = member as FunctionPointer;  	if (fp != null) {  		mr [i].Signature = this.GetBlobIndex (fp);  		if (fp is VarargMethodCallSignature) {  			Method m = ((VarargMethodCallSignature)member).method;  			if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  		}  	} else {  		Method m = (Method)member;  		if (m.IsGeneric && m.Template != null)  			m = this.GetUnspecializedMethod (m);  		mr [i].Signature = this.GetBlobIndex (m' false);  		if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  			mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  			continue;  		}  		//TODO: if the declaring type is the special global members type of another module' set class to a module ref  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (f != null)  	mr [i].Signature = this.GetBlobIndex (f);  else {  	FunctionPointer fp = member as FunctionPointer;  	if (fp != null) {  		mr [i].Signature = this.GetBlobIndex (fp);  		if (fp is VarargMethodCallSignature) {  			Method m = ((VarargMethodCallSignature)member).method;  			if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  		}  	} else {  		Method m = (Method)member;  		if (m.IsGeneric && m.Template != null)  			m = this.GetUnspecializedMethod (m);  		mr [i].Signature = this.GetBlobIndex (m' false);  		if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  			mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  			continue;  		}  		//TODO: if the declaring type is the special global members type of another module' set class to a module ref  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (f != null)  	mr [i].Signature = this.GetBlobIndex (f);  else {  	FunctionPointer fp = member as FunctionPointer;  	if (fp != null) {  		mr [i].Signature = this.GetBlobIndex (fp);  		if (fp is VarargMethodCallSignature) {  			Method m = ((VarargMethodCallSignature)member).method;  			if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  				mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  				continue;  			}  		}  	} else {  		Method m = (Method)member;  		if (m.IsGeneric && m.Template != null)  			m = this.GetUnspecializedMethod (m);  		mr [i].Signature = this.GetBlobIndex (m' false);  		if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  			mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  			continue;  		}  		//TODO: if the declaring type is the special global members type of another module' set class to a module ref  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (fp != null) {  	mr [i].Signature = this.GetBlobIndex (fp);  	if (fp is VarargMethodCallSignature) {  		Method m = ((VarargMethodCallSignature)member).method;  		if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  			mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  			continue;  		}  	}  } else {  	Method m = (Method)member;  	if (m.IsGeneric && m.Template != null)  		m = this.GetUnspecializedMethod (m);  	mr [i].Signature = this.GetBlobIndex (m' false);  	if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  		mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  		continue;  	}  	//TODO: if the declaring type is the special global members type of another module' set class to a module ref  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (fp != null) {  	mr [i].Signature = this.GetBlobIndex (fp);  	if (fp is VarargMethodCallSignature) {  		Method m = ((VarargMethodCallSignature)member).method;  		if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  			mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  			continue;  		}  	}  } else {  	Method m = (Method)member;  	if (m.IsGeneric && m.Template != null)  		m = this.GetUnspecializedMethod (m);  	mr [i].Signature = this.GetBlobIndex (m' false);  	if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  		mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  		continue;  	}  	//TODO: if the declaring type is the special global members type of another module' set class to a module ref  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (fp != null) {  	mr [i].Signature = this.GetBlobIndex (fp);  	if (fp is VarargMethodCallSignature) {  		Method m = ((VarargMethodCallSignature)member).method;  		if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  			mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  			continue;  		}  	}  } else {  	Method m = (Method)member;  	if (m.IsGeneric && m.Template != null)  		m = this.GetUnspecializedMethod (m);  	mr [i].Signature = this.GetBlobIndex (m' false);  	if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  		mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  		continue;  	}  	//TODO: if the declaring type is the special global members type of another module' set class to a module ref  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (fp != null) {  	mr [i].Signature = this.GetBlobIndex (fp);  	if (fp is VarargMethodCallSignature) {  		Method m = ((VarargMethodCallSignature)member).method;  		if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  			mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  			continue;  		}  	}  } else {  	Method m = (Method)member;  	if (m.IsGeneric && m.Template != null)  		m = this.GetUnspecializedMethod (m);  	mr [i].Signature = this.GetBlobIndex (m' false);  	if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  		mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  		continue;  	}  	//TODO: if the declaring type is the special global members type of another module' set class to a module ref  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (fp is VarargMethodCallSignature) {  	Method m = ((VarargMethodCallSignature)member).method;  	if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  		mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  		continue;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (fp is VarargMethodCallSignature) {  	Method m = ((VarargMethodCallSignature)member).method;  	if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  		mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  		continue;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  	mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  	continue;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType)) {  	mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  	continue;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  	mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  	continue;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural (m.DeclaringType) && !m.IsGeneric) {  	mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  	continue;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: mr [i].Class = (this.GetMethodIndex (m) << 3) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if ((j & 0x3) == 2)  	mr [i].Class = (j & ~0x3) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: if ((j & 0x3) == 2)  	mr [i].Class = (j & ~0x3) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: mr [i].Class = (j & ~0x3) | 4;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMethodSemanticsTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Member owner = this.methodSemanticsEntries [i];  	Property ownerProperty = owner as Property;  	if (ownerProperty != null) {  		msr [i].Association = (this.GetPropertyIndex (ownerProperty) << 1) | 1;  		if (owner != previousOwner) {  			previousOwner = owner;  			index = -1;  			if (ownerProperty.Getter != null) {  				msr [i].Method = this.GetMethodIndex (ownerProperty.Getter);  				msr [i].Semantics = 0x0002;  				continue;  			}  		}  		if (index == -1) {  			index = 0;  			if (ownerProperty.Setter != null) {  				msr [i].Method = this.GetMethodIndex (ownerProperty.Setter);  				msr [i].Semantics = 0x0001;  				continue;  			}  		}  		msr [i].Method = this.GetMethodIndex (ownerProperty.OtherMethods [index]);  		msr [i].Semantics = 0x0004;  		index++;  		continue;  	}  	Event ownerEvent = owner as Event;  	if (ownerEvent == null) {  		Debug.Fail ("");  		continue;  	}  	msr [i].Association = this.GetEventIndex (ownerEvent) << 1;  	if (owner != previousOwner) {  		previousOwner = owner;  		index = -2;  		if (ownerEvent.HandlerAdder != null) {  			msr [i].Method = this.GetMethodIndex (ownerEvent.HandlerAdder);  			msr [i].Semantics = 0x0008;  			continue;  		}  	}  	if (index == -2) {  		index = -1;  		if (ownerEvent.HandlerRemover != null) {  			msr [i].Method = this.GetMethodIndex (ownerEvent.HandlerRemover);  			msr [i].Semantics = 0x0010;  			continue;  		}  	}  	if (index == -1) {  		index = 0;  		if (ownerEvent.HandlerCaller != null) {  			msr [i].Method = this.GetMethodIndex (ownerEvent.HandlerCaller);  			msr [i].Semantics = 0x0020;  			continue;  		}  	}  	msr [i].Method = this.GetMethodIndex (ownerEvent.OtherMethods [i]);  	msr [i].Semantics = 0x0004;  	index++;  	continue;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMethodSemanticsTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Member owner = this.methodSemanticsEntries [i];  	Property ownerProperty = owner as Property;  	if (ownerProperty != null) {  		msr [i].Association = (this.GetPropertyIndex (ownerProperty) << 1) | 1;  		if (owner != previousOwner) {  			previousOwner = owner;  			index = -1;  			if (ownerProperty.Getter != null) {  				msr [i].Method = this.GetMethodIndex (ownerProperty.Getter);  				msr [i].Semantics = 0x0002;  				continue;  			}  		}  		if (index == -1) {  			index = 0;  			if (ownerProperty.Setter != null) {  				msr [i].Method = this.GetMethodIndex (ownerProperty.Setter);  				msr [i].Semantics = 0x0001;  				continue;  			}  		}  		msr [i].Method = this.GetMethodIndex (ownerProperty.OtherMethods [index]);  		msr [i].Semantics = 0x0004;  		index++;  		continue;  	}  	Event ownerEvent = owner as Event;  	if (ownerEvent == null) {  		Debug.Fail ("");  		continue;  	}  	msr [i].Association = this.GetEventIndex (ownerEvent) << 1;  	if (owner != previousOwner) {  		previousOwner = owner;  		index = -2;  		if (ownerEvent.HandlerAdder != null) {  			msr [i].Method = this.GetMethodIndex (ownerEvent.HandlerAdder);  			msr [i].Semantics = 0x0008;  			continue;  		}  	}  	if (index == -2) {  		index = -1;  		if (ownerEvent.HandlerRemover != null) {  			msr [i].Method = this.GetMethodIndex (ownerEvent.HandlerRemover);  			msr [i].Semantics = 0x0010;  			continue;  		}  	}  	if (index == -1) {  		index = 0;  		if (ownerEvent.HandlerCaller != null) {  			msr [i].Method = this.GetMethodIndex (ownerEvent.HandlerCaller);  			msr [i].Semantics = 0x0020;  			continue;  		}  	}  	msr [i].Method = this.GetMethodIndex (ownerEvent.OtherMethods [i]);  	msr [i].Semantics = 0x0004;  	index++;  	continue;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMethodSemanticsTable,The following statement contains a magic number: if (owner != previousOwner) {  	previousOwner = owner;  	index = -2;  	if (ownerEvent.HandlerAdder != null) {  		msr [i].Method = this.GetMethodIndex (ownerEvent.HandlerAdder);  		msr [i].Semantics = 0x0008;  		continue;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMethodSemanticsTable,The following statement contains a magic number: index = -2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateMethodSemanticsTable,The following statement contains a magic number: if (index == -2) {  	index = -1;  	if (ownerEvent.HandlerRemover != null) {  		msr [i].Method = this.GetMethodIndex (ownerEvent.HandlerRemover);  		msr [i].Semantics = 0x0010;  		continue;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode t = this.typeRefEntries [i];  	if (t == null || t.Name == null || t.Namespace == null)  		continue;  	trr [i].Name = this.GetStringIndex (t.Name.ToString ());  	trr [i].Namespace = this.GetStringIndex (t.Namespace.ToString ());  	if (t.DeclaringType == null)  		if (t.DeclaringModule is AssemblyNode)  			trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  		else  			trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  	else  		trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode t = this.typeRefEntries [i];  	if (t == null || t.Name == null || t.Namespace == null)  		continue;  	trr [i].Name = this.GetStringIndex (t.Name.ToString ());  	trr [i].Namespace = this.GetStringIndex (t.Namespace.ToString ());  	if (t.DeclaringType == null)  		if (t.DeclaringModule is AssemblyNode)  			trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  		else  			trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  	else  		trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode t = this.typeRefEntries [i];  	if (t == null || t.Name == null || t.Namespace == null)  		continue;  	trr [i].Name = this.GetStringIndex (t.Name.ToString ());  	trr [i].Namespace = this.GetStringIndex (t.Namespace.ToString ());  	if (t.DeclaringType == null)  		if (t.DeclaringModule is AssemblyNode)  			trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  		else  			trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  	else  		trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode t = this.typeRefEntries [i];  	if (t == null || t.Name == null || t.Namespace == null)  		continue;  	trr [i].Name = this.GetStringIndex (t.Name.ToString ());  	trr [i].Namespace = this.GetStringIndex (t.Namespace.ToString ());  	if (t.DeclaringType == null)  		if (t.DeclaringModule is AssemblyNode)  			trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  		else  			trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  	else  		trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	TypeNode t = this.typeRefEntries [i];  	if (t == null || t.Name == null || t.Namespace == null)  		continue;  	trr [i].Name = this.GetStringIndex (t.Name.ToString ());  	trr [i].Namespace = this.GetStringIndex (t.Namespace.ToString ());  	if (t.DeclaringType == null)  		if (t.DeclaringModule is AssemblyNode)  			trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  		else  			trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  	else  		trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: if (t.DeclaringType == null)  	if (t.DeclaringModule is AssemblyNode)  		trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  	else  		trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  else  	trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: if (t.DeclaringType == null)  	if (t.DeclaringModule is AssemblyNode)  		trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  	else  		trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  else  	trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: if (t.DeclaringType == null)  	if (t.DeclaringModule is AssemblyNode)  		trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  	else  		trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  else  	trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: if (t.DeclaringType == null)  	if (t.DeclaringModule is AssemblyNode)  		trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  	else  		trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  else  	trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: if (t.DeclaringType == null)  	if (t.DeclaringModule is AssemblyNode)  		trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  	else  		trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  else  	trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: if (t.DeclaringModule is AssemblyNode)  	trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  else  	trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: if (t.DeclaringModule is AssemblyNode)  	trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  else  	trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: if (t.DeclaringModule is AssemblyNode)  	trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  else  	trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: trr [i].ResolutionScope = (this.GetAssemblyRefIndex ((AssemblyNode)t.DeclaringModule) << 2) | 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: trr [i].ResolutionScope = (this.GetModuleRefIndex (t.DeclaringModule) << 2) | 1;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: trr [i].ResolutionScope = (this.GetTypeRefIndex (t.DeclaringType) << 2) | 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAddressOf,The following statement contains a magic number: switch (operand.NodeType) {  case NodeType.Indexer:  	Indexer indexer = (Indexer)operand;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	if (expr.NodeType == NodeType.ReadOnlyAddressOf) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x1e);  	}  	this.methodBodyHeap.Write ((byte)0x8f);  	this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight--;  	return;  case NodeType.Local:  	int li = this.GetLocalVarIndex ((Local)operand);  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0d);  		this.methodBodyHeap.Write ((ushort)li);  	}  	this.IncrementStackHeight ();  	return;  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)operand;  	if (mb.TargetObject != null) {  		this.Visit (mb.TargetObject);  		this.methodBodyHeap.Write ((byte)0x7c);  	} else {  		this.methodBodyHeap.Write ((byte)0x7f);  		this.IncrementStackHeight ();  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = operand as ParameterBinding;  	if (pb != null)  		operand = pb.BoundParameter;  	#endif  	int pi = ((Parameter)operand).ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x0f);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0a);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.IncrementStackHeight ();  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAddressOf,The following statement contains a magic number: switch (operand.NodeType) {  case NodeType.Indexer:  	Indexer indexer = (Indexer)operand;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	if (expr.NodeType == NodeType.ReadOnlyAddressOf) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x1e);  	}  	this.methodBodyHeap.Write ((byte)0x8f);  	this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight--;  	return;  case NodeType.Local:  	int li = this.GetLocalVarIndex ((Local)operand);  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0d);  		this.methodBodyHeap.Write ((ushort)li);  	}  	this.IncrementStackHeight ();  	return;  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)operand;  	if (mb.TargetObject != null) {  		this.Visit (mb.TargetObject);  		this.methodBodyHeap.Write ((byte)0x7c);  	} else {  		this.methodBodyHeap.Write ((byte)0x7f);  		this.IncrementStackHeight ();  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = operand as ParameterBinding;  	if (pb != null)  		operand = pb.BoundParameter;  	#endif  	int pi = ((Parameter)operand).ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x0f);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0a);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.IncrementStackHeight ();  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAddressOf,The following statement contains a magic number: if (li < 256) {  	this.methodBodyHeap.Write ((byte)0x12);  	this.methodBodyHeap.Write ((byte)li);  } else {  	this.methodBodyHeap.Write ((byte)0xfe);  	this.methodBodyHeap.Write ((byte)0x0d);  	this.methodBodyHeap.Write ((ushort)li);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAddressOf,The following statement contains a magic number: if (pi < 256) {  	this.methodBodyHeap.Write ((byte)0x0f);  	this.methodBodyHeap.Write ((byte)pi);  } else {  	this.methodBodyHeap.Write ((byte)0xfe);  	this.methodBodyHeap.Write ((byte)0x0a);  	this.methodBodyHeap.Write ((ushort)pi);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (assignment.Target.NodeType) {  case NodeType.Local:  	Local loc = (Local)target;  	this.Visit (assignment.Source);  	this.stackHeight--;  	int li = this.GetLocalVarIndex (loc);  	switch (li) {  	case 0:  		this.methodBodyHeap.Write ((byte)0x0a);  		return;  	case 1:  		this.methodBodyHeap.Write ((byte)0x0b);  		return;  	case 2:  		this.methodBodyHeap.Write ((byte)0x0c);  		return;  	case 3:  		this.methodBodyHeap.Write ((byte)0x0d);  		return;  	default:  		if (li < 256) {  			this.methodBodyHeap.Write ((byte)0x13);  			this.methodBodyHeap.Write ((byte)li);  		} else {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x0e);  			this.methodBodyHeap.Write ((ushort)li);  		}  		return;  	}  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)target;  	if (mb.TargetObject != null)  		this.Visit (mb.TargetObject);  	this.Visit (assignment.Source);  	if (mb.TargetObject != null) {  		if (mb.Alignment != -1) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x12);  			this.methodBodyHeap.Write ((byte)mb.Alignment);  		}  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x7d);  	} else {  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x80);  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	if (mb.TargetObject != null)  		this.stackHeight -= 2;  	else  		this.stackHeight--;  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = target as ParameterBinding;  	if (pb != null)  		target = pb.BoundParameter;  	#endif  	Parameter par = (Parameter)target;  	this.Visit (assignment.Source);  	int pi = par.ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x10);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0b);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.stackHeight--;  	return;  case NodeType.Indexer:  	Indexer indexer = (Indexer)target;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	this.Visit (assignment.Source);  	byte opCode;  	switch (indexer.ElementType.typeCode) {  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		opCode = 0x9b;  		break;  	case ElementType.Boolean:  	case ElementType.Int8:  	case ElementType.UInt8:  		opCode = 0x9c;  		break;  	case ElementType.Char:  	case ElementType.Int16:  	case ElementType.UInt16:  		opCode = 0x9d;  		break;  	case ElementType.Int32:  	case ElementType.UInt32:  		opCode = 0x9e;  		break;  	case ElementType.Int64:  	case ElementType.UInt64:  		opCode = 0x9f;  		break;  	case ElementType.Single:  		opCode = 0xa0;  		break;  	case ElementType.Double:  		opCode = 0xa1;  		break;  	default:  		if (this.UseGenerics && (indexer.ElementType is ITypeParameter))  			opCode = 0xa4;  		else if (TypeNode.StripModifiers (indexer.ElementType) is Pointer)  			opCode = 0x9b;  		else  			opCode = 0xa2;  		break;  	}  	this.methodBodyHeap.Write ((byte)opCode);  	if (opCode == 0xa4)  		this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight -= 3;  	return;  case NodeType.AddressDereference:  	AddressDereference adr = (AddressDereference)target;  	this.Visit (adr.Address);  	if (adr.Type.IsValueType || adr.Type is ITypeParameter) {  		Literal lit = assignment.Source as Literal;  		if (lit != null && lit.Value == null) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x15);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adr.Type));  			this.stackHeight--;  			return;  		}  	}  	this.Visit (assignment.Source);  	this.stackHeight -= 2;  	if (adr.Alignment > 0) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)adr.Alignment);  	}  	if (adr.Volatile) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x13);  	}  	TypeNode adrType = TypeNode.StripModifiers (adr.Type);  	if (adrType == null)  		return;  	switch (adrType.typeCode) {  	case ElementType.Int8:  	case ElementType.UInt8:  		this.methodBodyHeap.Write ((byte)0x52);  		return;  	case ElementType.Int16:  	case ElementType.UInt16:  		this.methodBodyHeap.Write ((byte)0x53);  		return;  	case ElementType.Int32:  	case ElementType.UInt32:  		this.methodBodyHeap.Write ((byte)0x54);  		return;  	case ElementType.Int64:  	case ElementType.UInt64:  		this.methodBodyHeap.Write ((byte)0x55);  		return;  	case ElementType.Single:  		this.methodBodyHeap.Write ((byte)0x56);  		return;  	case ElementType.Double:  		this.methodBodyHeap.Write ((byte)0x57);  		return;  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		this.methodBodyHeap.Write ((byte)0xdf);  		return;  	default:  		if (adrType != null && (adrType.IsValueType || this.UseGenerics && (adrType is ITypeParameter))) {  			this.methodBodyHeap.Write ((byte)0x81);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adrType));  			return;  		}  		if (adrType.NodeType == NodeType.Pointer) {  			this.methodBodyHeap.Write ((byte)0xdf);  			return;  		}  		this.methodBodyHeap.Write ((byte)0x51);  		return;  	}  default:  	Debug.Assert (false' "unexpected assignment target");  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (assignment.Target.NodeType) {  case NodeType.Local:  	Local loc = (Local)target;  	this.Visit (assignment.Source);  	this.stackHeight--;  	int li = this.GetLocalVarIndex (loc);  	switch (li) {  	case 0:  		this.methodBodyHeap.Write ((byte)0x0a);  		return;  	case 1:  		this.methodBodyHeap.Write ((byte)0x0b);  		return;  	case 2:  		this.methodBodyHeap.Write ((byte)0x0c);  		return;  	case 3:  		this.methodBodyHeap.Write ((byte)0x0d);  		return;  	default:  		if (li < 256) {  			this.methodBodyHeap.Write ((byte)0x13);  			this.methodBodyHeap.Write ((byte)li);  		} else {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x0e);  			this.methodBodyHeap.Write ((ushort)li);  		}  		return;  	}  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)target;  	if (mb.TargetObject != null)  		this.Visit (mb.TargetObject);  	this.Visit (assignment.Source);  	if (mb.TargetObject != null) {  		if (mb.Alignment != -1) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x12);  			this.methodBodyHeap.Write ((byte)mb.Alignment);  		}  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x7d);  	} else {  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x80);  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	if (mb.TargetObject != null)  		this.stackHeight -= 2;  	else  		this.stackHeight--;  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = target as ParameterBinding;  	if (pb != null)  		target = pb.BoundParameter;  	#endif  	Parameter par = (Parameter)target;  	this.Visit (assignment.Source);  	int pi = par.ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x10);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0b);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.stackHeight--;  	return;  case NodeType.Indexer:  	Indexer indexer = (Indexer)target;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	this.Visit (assignment.Source);  	byte opCode;  	switch (indexer.ElementType.typeCode) {  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		opCode = 0x9b;  		break;  	case ElementType.Boolean:  	case ElementType.Int8:  	case ElementType.UInt8:  		opCode = 0x9c;  		break;  	case ElementType.Char:  	case ElementType.Int16:  	case ElementType.UInt16:  		opCode = 0x9d;  		break;  	case ElementType.Int32:  	case ElementType.UInt32:  		opCode = 0x9e;  		break;  	case ElementType.Int64:  	case ElementType.UInt64:  		opCode = 0x9f;  		break;  	case ElementType.Single:  		opCode = 0xa0;  		break;  	case ElementType.Double:  		opCode = 0xa1;  		break;  	default:  		if (this.UseGenerics && (indexer.ElementType is ITypeParameter))  			opCode = 0xa4;  		else if (TypeNode.StripModifiers (indexer.ElementType) is Pointer)  			opCode = 0x9b;  		else  			opCode = 0xa2;  		break;  	}  	this.methodBodyHeap.Write ((byte)opCode);  	if (opCode == 0xa4)  		this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight -= 3;  	return;  case NodeType.AddressDereference:  	AddressDereference adr = (AddressDereference)target;  	this.Visit (adr.Address);  	if (adr.Type.IsValueType || adr.Type is ITypeParameter) {  		Literal lit = assignment.Source as Literal;  		if (lit != null && lit.Value == null) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x15);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adr.Type));  			this.stackHeight--;  			return;  		}  	}  	this.Visit (assignment.Source);  	this.stackHeight -= 2;  	if (adr.Alignment > 0) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)adr.Alignment);  	}  	if (adr.Volatile) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x13);  	}  	TypeNode adrType = TypeNode.StripModifiers (adr.Type);  	if (adrType == null)  		return;  	switch (adrType.typeCode) {  	case ElementType.Int8:  	case ElementType.UInt8:  		this.methodBodyHeap.Write ((byte)0x52);  		return;  	case ElementType.Int16:  	case ElementType.UInt16:  		this.methodBodyHeap.Write ((byte)0x53);  		return;  	case ElementType.Int32:  	case ElementType.UInt32:  		this.methodBodyHeap.Write ((byte)0x54);  		return;  	case ElementType.Int64:  	case ElementType.UInt64:  		this.methodBodyHeap.Write ((byte)0x55);  		return;  	case ElementType.Single:  		this.methodBodyHeap.Write ((byte)0x56);  		return;  	case ElementType.Double:  		this.methodBodyHeap.Write ((byte)0x57);  		return;  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		this.methodBodyHeap.Write ((byte)0xdf);  		return;  	default:  		if (adrType != null && (adrType.IsValueType || this.UseGenerics && (adrType is ITypeParameter))) {  			this.methodBodyHeap.Write ((byte)0x81);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adrType));  			return;  		}  		if (adrType.NodeType == NodeType.Pointer) {  			this.methodBodyHeap.Write ((byte)0xdf);  			return;  		}  		this.methodBodyHeap.Write ((byte)0x51);  		return;  	}  default:  	Debug.Assert (false' "unexpected assignment target");  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (assignment.Target.NodeType) {  case NodeType.Local:  	Local loc = (Local)target;  	this.Visit (assignment.Source);  	this.stackHeight--;  	int li = this.GetLocalVarIndex (loc);  	switch (li) {  	case 0:  		this.methodBodyHeap.Write ((byte)0x0a);  		return;  	case 1:  		this.methodBodyHeap.Write ((byte)0x0b);  		return;  	case 2:  		this.methodBodyHeap.Write ((byte)0x0c);  		return;  	case 3:  		this.methodBodyHeap.Write ((byte)0x0d);  		return;  	default:  		if (li < 256) {  			this.methodBodyHeap.Write ((byte)0x13);  			this.methodBodyHeap.Write ((byte)li);  		} else {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x0e);  			this.methodBodyHeap.Write ((ushort)li);  		}  		return;  	}  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)target;  	if (mb.TargetObject != null)  		this.Visit (mb.TargetObject);  	this.Visit (assignment.Source);  	if (mb.TargetObject != null) {  		if (mb.Alignment != -1) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x12);  			this.methodBodyHeap.Write ((byte)mb.Alignment);  		}  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x7d);  	} else {  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x80);  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	if (mb.TargetObject != null)  		this.stackHeight -= 2;  	else  		this.stackHeight--;  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = target as ParameterBinding;  	if (pb != null)  		target = pb.BoundParameter;  	#endif  	Parameter par = (Parameter)target;  	this.Visit (assignment.Source);  	int pi = par.ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x10);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0b);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.stackHeight--;  	return;  case NodeType.Indexer:  	Indexer indexer = (Indexer)target;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	this.Visit (assignment.Source);  	byte opCode;  	switch (indexer.ElementType.typeCode) {  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		opCode = 0x9b;  		break;  	case ElementType.Boolean:  	case ElementType.Int8:  	case ElementType.UInt8:  		opCode = 0x9c;  		break;  	case ElementType.Char:  	case ElementType.Int16:  	case ElementType.UInt16:  		opCode = 0x9d;  		break;  	case ElementType.Int32:  	case ElementType.UInt32:  		opCode = 0x9e;  		break;  	case ElementType.Int64:  	case ElementType.UInt64:  		opCode = 0x9f;  		break;  	case ElementType.Single:  		opCode = 0xa0;  		break;  	case ElementType.Double:  		opCode = 0xa1;  		break;  	default:  		if (this.UseGenerics && (indexer.ElementType is ITypeParameter))  			opCode = 0xa4;  		else if (TypeNode.StripModifiers (indexer.ElementType) is Pointer)  			opCode = 0x9b;  		else  			opCode = 0xa2;  		break;  	}  	this.methodBodyHeap.Write ((byte)opCode);  	if (opCode == 0xa4)  		this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight -= 3;  	return;  case NodeType.AddressDereference:  	AddressDereference adr = (AddressDereference)target;  	this.Visit (adr.Address);  	if (adr.Type.IsValueType || adr.Type is ITypeParameter) {  		Literal lit = assignment.Source as Literal;  		if (lit != null && lit.Value == null) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x15);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adr.Type));  			this.stackHeight--;  			return;  		}  	}  	this.Visit (assignment.Source);  	this.stackHeight -= 2;  	if (adr.Alignment > 0) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)adr.Alignment);  	}  	if (adr.Volatile) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x13);  	}  	TypeNode adrType = TypeNode.StripModifiers (adr.Type);  	if (adrType == null)  		return;  	switch (adrType.typeCode) {  	case ElementType.Int8:  	case ElementType.UInt8:  		this.methodBodyHeap.Write ((byte)0x52);  		return;  	case ElementType.Int16:  	case ElementType.UInt16:  		this.methodBodyHeap.Write ((byte)0x53);  		return;  	case ElementType.Int32:  	case ElementType.UInt32:  		this.methodBodyHeap.Write ((byte)0x54);  		return;  	case ElementType.Int64:  	case ElementType.UInt64:  		this.methodBodyHeap.Write ((byte)0x55);  		return;  	case ElementType.Single:  		this.methodBodyHeap.Write ((byte)0x56);  		return;  	case ElementType.Double:  		this.methodBodyHeap.Write ((byte)0x57);  		return;  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		this.methodBodyHeap.Write ((byte)0xdf);  		return;  	default:  		if (adrType != null && (adrType.IsValueType || this.UseGenerics && (adrType is ITypeParameter))) {  			this.methodBodyHeap.Write ((byte)0x81);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adrType));  			return;  		}  		if (adrType.NodeType == NodeType.Pointer) {  			this.methodBodyHeap.Write ((byte)0xdf);  			return;  		}  		this.methodBodyHeap.Write ((byte)0x51);  		return;  	}  default:  	Debug.Assert (false' "unexpected assignment target");  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (assignment.Target.NodeType) {  case NodeType.Local:  	Local loc = (Local)target;  	this.Visit (assignment.Source);  	this.stackHeight--;  	int li = this.GetLocalVarIndex (loc);  	switch (li) {  	case 0:  		this.methodBodyHeap.Write ((byte)0x0a);  		return;  	case 1:  		this.methodBodyHeap.Write ((byte)0x0b);  		return;  	case 2:  		this.methodBodyHeap.Write ((byte)0x0c);  		return;  	case 3:  		this.methodBodyHeap.Write ((byte)0x0d);  		return;  	default:  		if (li < 256) {  			this.methodBodyHeap.Write ((byte)0x13);  			this.methodBodyHeap.Write ((byte)li);  		} else {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x0e);  			this.methodBodyHeap.Write ((ushort)li);  		}  		return;  	}  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)target;  	if (mb.TargetObject != null)  		this.Visit (mb.TargetObject);  	this.Visit (assignment.Source);  	if (mb.TargetObject != null) {  		if (mb.Alignment != -1) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x12);  			this.methodBodyHeap.Write ((byte)mb.Alignment);  		}  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x7d);  	} else {  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x80);  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	if (mb.TargetObject != null)  		this.stackHeight -= 2;  	else  		this.stackHeight--;  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = target as ParameterBinding;  	if (pb != null)  		target = pb.BoundParameter;  	#endif  	Parameter par = (Parameter)target;  	this.Visit (assignment.Source);  	int pi = par.ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x10);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0b);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.stackHeight--;  	return;  case NodeType.Indexer:  	Indexer indexer = (Indexer)target;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	this.Visit (assignment.Source);  	byte opCode;  	switch (indexer.ElementType.typeCode) {  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		opCode = 0x9b;  		break;  	case ElementType.Boolean:  	case ElementType.Int8:  	case ElementType.UInt8:  		opCode = 0x9c;  		break;  	case ElementType.Char:  	case ElementType.Int16:  	case ElementType.UInt16:  		opCode = 0x9d;  		break;  	case ElementType.Int32:  	case ElementType.UInt32:  		opCode = 0x9e;  		break;  	case ElementType.Int64:  	case ElementType.UInt64:  		opCode = 0x9f;  		break;  	case ElementType.Single:  		opCode = 0xa0;  		break;  	case ElementType.Double:  		opCode = 0xa1;  		break;  	default:  		if (this.UseGenerics && (indexer.ElementType is ITypeParameter))  			opCode = 0xa4;  		else if (TypeNode.StripModifiers (indexer.ElementType) is Pointer)  			opCode = 0x9b;  		else  			opCode = 0xa2;  		break;  	}  	this.methodBodyHeap.Write ((byte)opCode);  	if (opCode == 0xa4)  		this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight -= 3;  	return;  case NodeType.AddressDereference:  	AddressDereference adr = (AddressDereference)target;  	this.Visit (adr.Address);  	if (adr.Type.IsValueType || adr.Type is ITypeParameter) {  		Literal lit = assignment.Source as Literal;  		if (lit != null && lit.Value == null) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x15);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adr.Type));  			this.stackHeight--;  			return;  		}  	}  	this.Visit (assignment.Source);  	this.stackHeight -= 2;  	if (adr.Alignment > 0) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)adr.Alignment);  	}  	if (adr.Volatile) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x13);  	}  	TypeNode adrType = TypeNode.StripModifiers (adr.Type);  	if (adrType == null)  		return;  	switch (adrType.typeCode) {  	case ElementType.Int8:  	case ElementType.UInt8:  		this.methodBodyHeap.Write ((byte)0x52);  		return;  	case ElementType.Int16:  	case ElementType.UInt16:  		this.methodBodyHeap.Write ((byte)0x53);  		return;  	case ElementType.Int32:  	case ElementType.UInt32:  		this.methodBodyHeap.Write ((byte)0x54);  		return;  	case ElementType.Int64:  	case ElementType.UInt64:  		this.methodBodyHeap.Write ((byte)0x55);  		return;  	case ElementType.Single:  		this.methodBodyHeap.Write ((byte)0x56);  		return;  	case ElementType.Double:  		this.methodBodyHeap.Write ((byte)0x57);  		return;  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		this.methodBodyHeap.Write ((byte)0xdf);  		return;  	default:  		if (adrType != null && (adrType.IsValueType || this.UseGenerics && (adrType is ITypeParameter))) {  			this.methodBodyHeap.Write ((byte)0x81);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adrType));  			return;  		}  		if (adrType.NodeType == NodeType.Pointer) {  			this.methodBodyHeap.Write ((byte)0xdf);  			return;  		}  		this.methodBodyHeap.Write ((byte)0x51);  		return;  	}  default:  	Debug.Assert (false' "unexpected assignment target");  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (assignment.Target.NodeType) {  case NodeType.Local:  	Local loc = (Local)target;  	this.Visit (assignment.Source);  	this.stackHeight--;  	int li = this.GetLocalVarIndex (loc);  	switch (li) {  	case 0:  		this.methodBodyHeap.Write ((byte)0x0a);  		return;  	case 1:  		this.methodBodyHeap.Write ((byte)0x0b);  		return;  	case 2:  		this.methodBodyHeap.Write ((byte)0x0c);  		return;  	case 3:  		this.methodBodyHeap.Write ((byte)0x0d);  		return;  	default:  		if (li < 256) {  			this.methodBodyHeap.Write ((byte)0x13);  			this.methodBodyHeap.Write ((byte)li);  		} else {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x0e);  			this.methodBodyHeap.Write ((ushort)li);  		}  		return;  	}  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)target;  	if (mb.TargetObject != null)  		this.Visit (mb.TargetObject);  	this.Visit (assignment.Source);  	if (mb.TargetObject != null) {  		if (mb.Alignment != -1) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x12);  			this.methodBodyHeap.Write ((byte)mb.Alignment);  		}  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x7d);  	} else {  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x80);  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	if (mb.TargetObject != null)  		this.stackHeight -= 2;  	else  		this.stackHeight--;  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = target as ParameterBinding;  	if (pb != null)  		target = pb.BoundParameter;  	#endif  	Parameter par = (Parameter)target;  	this.Visit (assignment.Source);  	int pi = par.ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x10);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0b);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.stackHeight--;  	return;  case NodeType.Indexer:  	Indexer indexer = (Indexer)target;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	this.Visit (assignment.Source);  	byte opCode;  	switch (indexer.ElementType.typeCode) {  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		opCode = 0x9b;  		break;  	case ElementType.Boolean:  	case ElementType.Int8:  	case ElementType.UInt8:  		opCode = 0x9c;  		break;  	case ElementType.Char:  	case ElementType.Int16:  	case ElementType.UInt16:  		opCode = 0x9d;  		break;  	case ElementType.Int32:  	case ElementType.UInt32:  		opCode = 0x9e;  		break;  	case ElementType.Int64:  	case ElementType.UInt64:  		opCode = 0x9f;  		break;  	case ElementType.Single:  		opCode = 0xa0;  		break;  	case ElementType.Double:  		opCode = 0xa1;  		break;  	default:  		if (this.UseGenerics && (indexer.ElementType is ITypeParameter))  			opCode = 0xa4;  		else if (TypeNode.StripModifiers (indexer.ElementType) is Pointer)  			opCode = 0x9b;  		else  			opCode = 0xa2;  		break;  	}  	this.methodBodyHeap.Write ((byte)opCode);  	if (opCode == 0xa4)  		this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight -= 3;  	return;  case NodeType.AddressDereference:  	AddressDereference adr = (AddressDereference)target;  	this.Visit (adr.Address);  	if (adr.Type.IsValueType || adr.Type is ITypeParameter) {  		Literal lit = assignment.Source as Literal;  		if (lit != null && lit.Value == null) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x15);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adr.Type));  			this.stackHeight--;  			return;  		}  	}  	this.Visit (assignment.Source);  	this.stackHeight -= 2;  	if (adr.Alignment > 0) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)adr.Alignment);  	}  	if (adr.Volatile) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x13);  	}  	TypeNode adrType = TypeNode.StripModifiers (adr.Type);  	if (adrType == null)  		return;  	switch (adrType.typeCode) {  	case ElementType.Int8:  	case ElementType.UInt8:  		this.methodBodyHeap.Write ((byte)0x52);  		return;  	case ElementType.Int16:  	case ElementType.UInt16:  		this.methodBodyHeap.Write ((byte)0x53);  		return;  	case ElementType.Int32:  	case ElementType.UInt32:  		this.methodBodyHeap.Write ((byte)0x54);  		return;  	case ElementType.Int64:  	case ElementType.UInt64:  		this.methodBodyHeap.Write ((byte)0x55);  		return;  	case ElementType.Single:  		this.methodBodyHeap.Write ((byte)0x56);  		return;  	case ElementType.Double:  		this.methodBodyHeap.Write ((byte)0x57);  		return;  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		this.methodBodyHeap.Write ((byte)0xdf);  		return;  	default:  		if (adrType != null && (adrType.IsValueType || this.UseGenerics && (adrType is ITypeParameter))) {  			this.methodBodyHeap.Write ((byte)0x81);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adrType));  			return;  		}  		if (adrType.NodeType == NodeType.Pointer) {  			this.methodBodyHeap.Write ((byte)0xdf);  			return;  		}  		this.methodBodyHeap.Write ((byte)0x51);  		return;  	}  default:  	Debug.Assert (false' "unexpected assignment target");  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (assignment.Target.NodeType) {  case NodeType.Local:  	Local loc = (Local)target;  	this.Visit (assignment.Source);  	this.stackHeight--;  	int li = this.GetLocalVarIndex (loc);  	switch (li) {  	case 0:  		this.methodBodyHeap.Write ((byte)0x0a);  		return;  	case 1:  		this.methodBodyHeap.Write ((byte)0x0b);  		return;  	case 2:  		this.methodBodyHeap.Write ((byte)0x0c);  		return;  	case 3:  		this.methodBodyHeap.Write ((byte)0x0d);  		return;  	default:  		if (li < 256) {  			this.methodBodyHeap.Write ((byte)0x13);  			this.methodBodyHeap.Write ((byte)li);  		} else {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x0e);  			this.methodBodyHeap.Write ((ushort)li);  		}  		return;  	}  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)target;  	if (mb.TargetObject != null)  		this.Visit (mb.TargetObject);  	this.Visit (assignment.Source);  	if (mb.TargetObject != null) {  		if (mb.Alignment != -1) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x12);  			this.methodBodyHeap.Write ((byte)mb.Alignment);  		}  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x7d);  	} else {  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x80);  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	if (mb.TargetObject != null)  		this.stackHeight -= 2;  	else  		this.stackHeight--;  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = target as ParameterBinding;  	if (pb != null)  		target = pb.BoundParameter;  	#endif  	Parameter par = (Parameter)target;  	this.Visit (assignment.Source);  	int pi = par.ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x10);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0b);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.stackHeight--;  	return;  case NodeType.Indexer:  	Indexer indexer = (Indexer)target;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	this.Visit (assignment.Source);  	byte opCode;  	switch (indexer.ElementType.typeCode) {  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		opCode = 0x9b;  		break;  	case ElementType.Boolean:  	case ElementType.Int8:  	case ElementType.UInt8:  		opCode = 0x9c;  		break;  	case ElementType.Char:  	case ElementType.Int16:  	case ElementType.UInt16:  		opCode = 0x9d;  		break;  	case ElementType.Int32:  	case ElementType.UInt32:  		opCode = 0x9e;  		break;  	case ElementType.Int64:  	case ElementType.UInt64:  		opCode = 0x9f;  		break;  	case ElementType.Single:  		opCode = 0xa0;  		break;  	case ElementType.Double:  		opCode = 0xa1;  		break;  	default:  		if (this.UseGenerics && (indexer.ElementType is ITypeParameter))  			opCode = 0xa4;  		else if (TypeNode.StripModifiers (indexer.ElementType) is Pointer)  			opCode = 0x9b;  		else  			opCode = 0xa2;  		break;  	}  	this.methodBodyHeap.Write ((byte)opCode);  	if (opCode == 0xa4)  		this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight -= 3;  	return;  case NodeType.AddressDereference:  	AddressDereference adr = (AddressDereference)target;  	this.Visit (adr.Address);  	if (adr.Type.IsValueType || adr.Type is ITypeParameter) {  		Literal lit = assignment.Source as Literal;  		if (lit != null && lit.Value == null) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x15);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adr.Type));  			this.stackHeight--;  			return;  		}  	}  	this.Visit (assignment.Source);  	this.stackHeight -= 2;  	if (adr.Alignment > 0) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)adr.Alignment);  	}  	if (adr.Volatile) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x13);  	}  	TypeNode adrType = TypeNode.StripModifiers (adr.Type);  	if (adrType == null)  		return;  	switch (adrType.typeCode) {  	case ElementType.Int8:  	case ElementType.UInt8:  		this.methodBodyHeap.Write ((byte)0x52);  		return;  	case ElementType.Int16:  	case ElementType.UInt16:  		this.methodBodyHeap.Write ((byte)0x53);  		return;  	case ElementType.Int32:  	case ElementType.UInt32:  		this.methodBodyHeap.Write ((byte)0x54);  		return;  	case ElementType.Int64:  	case ElementType.UInt64:  		this.methodBodyHeap.Write ((byte)0x55);  		return;  	case ElementType.Single:  		this.methodBodyHeap.Write ((byte)0x56);  		return;  	case ElementType.Double:  		this.methodBodyHeap.Write ((byte)0x57);  		return;  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		this.methodBodyHeap.Write ((byte)0xdf);  		return;  	default:  		if (adrType != null && (adrType.IsValueType || this.UseGenerics && (adrType is ITypeParameter))) {  			this.methodBodyHeap.Write ((byte)0x81);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adrType));  			return;  		}  		if (adrType.NodeType == NodeType.Pointer) {  			this.methodBodyHeap.Write ((byte)0xdf);  			return;  		}  		this.methodBodyHeap.Write ((byte)0x51);  		return;  	}  default:  	Debug.Assert (false' "unexpected assignment target");  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (assignment.Target.NodeType) {  case NodeType.Local:  	Local loc = (Local)target;  	this.Visit (assignment.Source);  	this.stackHeight--;  	int li = this.GetLocalVarIndex (loc);  	switch (li) {  	case 0:  		this.methodBodyHeap.Write ((byte)0x0a);  		return;  	case 1:  		this.methodBodyHeap.Write ((byte)0x0b);  		return;  	case 2:  		this.methodBodyHeap.Write ((byte)0x0c);  		return;  	case 3:  		this.methodBodyHeap.Write ((byte)0x0d);  		return;  	default:  		if (li < 256) {  			this.methodBodyHeap.Write ((byte)0x13);  			this.methodBodyHeap.Write ((byte)li);  		} else {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x0e);  			this.methodBodyHeap.Write ((ushort)li);  		}  		return;  	}  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)target;  	if (mb.TargetObject != null)  		this.Visit (mb.TargetObject);  	this.Visit (assignment.Source);  	if (mb.TargetObject != null) {  		if (mb.Alignment != -1) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x12);  			this.methodBodyHeap.Write ((byte)mb.Alignment);  		}  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x7d);  	} else {  		if (mb.Volatile) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x13);  		}  		this.methodBodyHeap.Write ((byte)0x80);  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	if (mb.TargetObject != null)  		this.stackHeight -= 2;  	else  		this.stackHeight--;  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = target as ParameterBinding;  	if (pb != null)  		target = pb.BoundParameter;  	#endif  	Parameter par = (Parameter)target;  	this.Visit (assignment.Source);  	int pi = par.ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x10);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0b);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.stackHeight--;  	return;  case NodeType.Indexer:  	Indexer indexer = (Indexer)target;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	this.Visit (assignment.Source);  	byte opCode;  	switch (indexer.ElementType.typeCode) {  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		opCode = 0x9b;  		break;  	case ElementType.Boolean:  	case ElementType.Int8:  	case ElementType.UInt8:  		opCode = 0x9c;  		break;  	case ElementType.Char:  	case ElementType.Int16:  	case ElementType.UInt16:  		opCode = 0x9d;  		break;  	case ElementType.Int32:  	case ElementType.UInt32:  		opCode = 0x9e;  		break;  	case ElementType.Int64:  	case ElementType.UInt64:  		opCode = 0x9f;  		break;  	case ElementType.Single:  		opCode = 0xa0;  		break;  	case ElementType.Double:  		opCode = 0xa1;  		break;  	default:  		if (this.UseGenerics && (indexer.ElementType is ITypeParameter))  			opCode = 0xa4;  		else if (TypeNode.StripModifiers (indexer.ElementType) is Pointer)  			opCode = 0x9b;  		else  			opCode = 0xa2;  		break;  	}  	this.methodBodyHeap.Write ((byte)opCode);  	if (opCode == 0xa4)  		this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight -= 3;  	return;  case NodeType.AddressDereference:  	AddressDereference adr = (AddressDereference)target;  	this.Visit (adr.Address);  	if (adr.Type.IsValueType || adr.Type is ITypeParameter) {  		Literal lit = assignment.Source as Literal;  		if (lit != null && lit.Value == null) {  			this.methodBodyHeap.Write ((byte)0xfe);  			this.methodBodyHeap.Write ((byte)0x15);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adr.Type));  			this.stackHeight--;  			return;  		}  	}  	this.Visit (assignment.Source);  	this.stackHeight -= 2;  	if (adr.Alignment > 0) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)adr.Alignment);  	}  	if (adr.Volatile) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x13);  	}  	TypeNode adrType = TypeNode.StripModifiers (adr.Type);  	if (adrType == null)  		return;  	switch (adrType.typeCode) {  	case ElementType.Int8:  	case ElementType.UInt8:  		this.methodBodyHeap.Write ((byte)0x52);  		return;  	case ElementType.Int16:  	case ElementType.UInt16:  		this.methodBodyHeap.Write ((byte)0x53);  		return;  	case ElementType.Int32:  	case ElementType.UInt32:  		this.methodBodyHeap.Write ((byte)0x54);  		return;  	case ElementType.Int64:  	case ElementType.UInt64:  		this.methodBodyHeap.Write ((byte)0x55);  		return;  	case ElementType.Single:  		this.methodBodyHeap.Write ((byte)0x56);  		return;  	case ElementType.Double:  		this.methodBodyHeap.Write ((byte)0x57);  		return;  	case ElementType.UIntPtr:  	case ElementType.IntPtr:  		this.methodBodyHeap.Write ((byte)0xdf);  		return;  	default:  		if (adrType != null && (adrType.IsValueType || this.UseGenerics && (adrType is ITypeParameter))) {  			this.methodBodyHeap.Write ((byte)0x81);  			this.methodBodyHeap.Write ((int)this.GetTypeToken (adrType));  			return;  		}  		if (adrType.NodeType == NodeType.Pointer) {  			this.methodBodyHeap.Write ((byte)0xdf);  			return;  		}  		this.methodBodyHeap.Write ((byte)0x51);  		return;  	}  default:  	Debug.Assert (false' "unexpected assignment target");  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (li) {  case 0:  	this.methodBodyHeap.Write ((byte)0x0a);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x0b);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x0c);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x0d);  	return;  default:  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x13);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0e);  		this.methodBodyHeap.Write ((ushort)li);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (li) {  case 0:  	this.methodBodyHeap.Write ((byte)0x0a);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x0b);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x0c);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x0d);  	return;  default:  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x13);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0e);  		this.methodBodyHeap.Write ((ushort)li);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (li) {  case 0:  	this.methodBodyHeap.Write ((byte)0x0a);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x0b);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x0c);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x0d);  	return;  default:  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x13);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0e);  		this.methodBodyHeap.Write ((ushort)li);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: if (li < 256) {  	this.methodBodyHeap.Write ((byte)0x13);  	this.methodBodyHeap.Write ((byte)li);  } else {  	this.methodBodyHeap.Write ((byte)0xfe);  	this.methodBodyHeap.Write ((byte)0x0e);  	this.methodBodyHeap.Write ((ushort)li);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: if (mb.TargetObject != null)  	this.stackHeight -= 2;  else  	this.stackHeight--;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: this.stackHeight -= 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: if (pi < 256) {  	this.methodBodyHeap.Write ((byte)0x10);  	this.methodBodyHeap.Write ((byte)pi);  } else {  	this.methodBodyHeap.Write ((byte)0xfe);  	this.methodBodyHeap.Write ((byte)0x0b);  	this.methodBodyHeap.Write ((ushort)pi);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: this.stackHeight -= 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: this.stackHeight -= 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBranch,The following statement contains a magic number: if (bex != null) {  	switch (bex.NodeType) {  	case NodeType.Eq:  	case NodeType.Ge:  	case NodeType.Gt:  	case NodeType.Le:  	case NodeType.Lt:  	case NodeType.Ne:  		this.Visit (bex.Operand1);  		this.Visit (bex.Operand2);  		typeOfCondition = bex.NodeType;  		this.stackHeight -= 2;  		break;  	case NodeType.And:  	case NodeType.Or:  	case NodeType.Xor:  	case NodeType.Isinst:  	case NodeType.Castclass:  		typeOfCondition = bex.NodeType;  		goto default;  	default:  		this.Visit (branch.Condition);  		this.stackHeight--;  		break;  	}  } else {  	uex = branch.Condition as UnaryExpression;  	if (uex != null && uex.NodeType == NodeType.LogicalNot) {  		this.Visit (uex.Operand);  		typeOfCondition = NodeType.LogicalNot;  		this.stackHeight--;  	} else if (branch.Condition != null) {  		// Undefined is used here simply as a sentinel value  		typeOfCondition = NodeType.Undefined;  		this.Visit (branch.Condition);  		this.stackHeight--;  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBranch,The following statement contains a magic number: switch (bex.NodeType) {  case NodeType.Eq:  case NodeType.Ge:  case NodeType.Gt:  case NodeType.Le:  case NodeType.Lt:  case NodeType.Ne:  	this.Visit (bex.Operand1);  	this.Visit (bex.Operand2);  	typeOfCondition = bex.NodeType;  	this.stackHeight -= 2;  	break;  case NodeType.And:  case NodeType.Or:  case NodeType.Xor:  case NodeType.Isinst:  case NodeType.Castclass:  	typeOfCondition = bex.NodeType;  	goto default;  default:  	this.Visit (branch.Condition);  	this.stackHeight--;  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBranch,The following statement contains a magic number: this.stackHeight -= 2;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodCall,The following statement contains a magic number: if ((method.CallingConvention & (CallingConventionFlags)7) == CallingConventionFlags.VarArg || (method.CallingConvention & (CallingConventionFlags)7) == CallingConventionFlags.C) {  	this.methodBodyHeap.Write ((int)this.GetMemberRefToken (method' arguments));  } else  	this.methodBodyHeap.Write ((int)this.GetMethodToken (method));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodCall,The following statement contains a magic number: if ((method.CallingConvention & (CallingConventionFlags)7) == CallingConventionFlags.VarArg || (method.CallingConvention & (CallingConventionFlags)7) == CallingConventionFlags.C) {  	this.methodBodyHeap.Write ((int)this.GetMemberRefToken (method' arguments));  } else  	this.methodBodyHeap.Write ((int)this.GetMethodToken (method));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitFixupList,The following statement contains a magic number: while (fixup != null) {  	this.methodBodyHeap.BaseStream.Position = fixup.fixupLocation;  	if (fixup.shortOffset) {  		int offset = targetAddress - fixup.addressOfNextInstruction;  		Debug.Assert (-128 <= offset && offset <= 127' "Invalid short branch");  		this.methodBodyHeap.Write ((byte)offset);  	} else  		this.methodBodyHeap.Write ((int)(targetAddress - fixup.addressOfNextInstruction));  	fixup = fixup.nextFixUp;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitFixupList,The following statement contains a magic number: while (fixup != null) {  	this.methodBodyHeap.BaseStream.Position = fixup.fixupLocation;  	if (fixup.shortOffset) {  		int offset = targetAddress - fixup.addressOfNextInstruction;  		Debug.Assert (-128 <= offset && offset <= 127' "Invalid short branch");  		this.methodBodyHeap.Write ((byte)offset);  	} else  		this.methodBodyHeap.Write ((int)(targetAddress - fixup.addressOfNextInstruction));  	fixup = fixup.nextFixUp;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitFixupList,The following statement contains a magic number: if (fixup.shortOffset) {  	int offset = targetAddress - fixup.addressOfNextInstruction;  	Debug.Assert (-128 <= offset && offset <= 127' "Invalid short branch");  	this.methodBodyHeap.Write ((byte)offset);  } else  	this.methodBodyHeap.Write ((int)(targetAddress - fixup.addressOfNextInstruction));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitFixupList,The following statement contains a magic number: if (fixup.shortOffset) {  	int offset = targetAddress - fixup.addressOfNextInstruction;  	Debug.Assert (-128 <= offset && offset <= 127' "Invalid short branch");  	this.methodBodyHeap.Write ((byte)offset);  } else  	this.methodBodyHeap.Write ((int)(targetAddress - fixup.addressOfNextInstruction));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitFixupList,The following statement contains a magic number: Debug.Assert (-128 <= offset && offset <= 127' "Invalid short branch");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitFixupList,The following statement contains a magic number: Debug.Assert (-128 <= offset && offset <= 127' "Invalid short branch");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLocal,The following statement contains a magic number: switch (li) {  case 0:  	this.methodBodyHeap.Write ((byte)0x06);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x07);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x08);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x09);  	return;  default:  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x11);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0c);  		this.methodBodyHeap.Write ((ushort)li);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLocal,The following statement contains a magic number: switch (li) {  case 0:  	this.methodBodyHeap.Write ((byte)0x06);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x07);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x08);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x09);  	return;  default:  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x11);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0c);  		this.methodBodyHeap.Write ((ushort)li);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLocal,The following statement contains a magic number: switch (li) {  case 0:  	this.methodBodyHeap.Write ((byte)0x06);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x07);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x08);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x09);  	return;  default:  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x11);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0c);  		this.methodBodyHeap.Write ((ushort)li);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLocal,The following statement contains a magic number: if (li < 256) {  	this.methodBodyHeap.Write ((byte)0x11);  	this.methodBodyHeap.Write ((byte)li);  } else {  	this.methodBodyHeap.Write ((byte)0xfe);  	this.methodBodyHeap.Write ((byte)0x0c);  	this.methodBodyHeap.Write ((ushort)li);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc) {  case TypeCode.Boolean:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  	long n = ic.ToInt64 (null);  	switch (n) {  	case -1:  		this.methodBodyHeap.Write ((byte)0x15);  		break;  	case 0:  		this.methodBodyHeap.Write ((byte)0x16);  		break;  	case 1:  		this.methodBodyHeap.Write ((byte)0x17);  		break;  	case 2:  		this.methodBodyHeap.Write ((byte)0x18);  		break;  	case 3:  		this.methodBodyHeap.Write ((byte)0x19);  		break;  	case 4:  		this.methodBodyHeap.Write ((byte)0x1a);  		break;  	case 5:  		this.methodBodyHeap.Write ((byte)0x1b);  		break;  	case 6:  		this.methodBodyHeap.Write ((byte)0x1c);  		break;  	case 7:  		this.methodBodyHeap.Write ((byte)0x1d);  		break;  	case 8:  		this.methodBodyHeap.Write ((byte)0x1e);  		break;  	default:  		if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  			this.methodBodyHeap.Write ((byte)0x1f);  			this.methodBodyHeap.Write ((byte)n);  		} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  			if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  				this.methodBodyHeap.Write ((byte)0x15);  			else {  				this.methodBodyHeap.Write ((byte)0x20);  				this.methodBodyHeap.Write ((int)n);  			}  		} else {  			this.methodBodyHeap.Write ((byte)0x21);  			this.methodBodyHeap.Write ((long)n);  			tc = TypeCode.Empty;  			//Suppress conversion to long  		}  		break;  	}  	if (tc == TypeCode.Int64)  		this.methodBodyHeap.Write ((byte)0x6a);  	return;  case TypeCode.UInt64:  	this.methodBodyHeap.Write ((byte)0x21);  	this.methodBodyHeap.Write (ic.ToUInt64 (null));  	return;  case TypeCode.Single:  	this.methodBodyHeap.Write ((byte)0x22);  	this.methodBodyHeap.Write (ic.ToSingle (null));  	return;  case TypeCode.Double:  	this.methodBodyHeap.Write ((byte)0x23);  	this.methodBodyHeap.Write (ic.ToDouble (null));  	return;  case TypeCode.String:  	this.methodBodyHeap.Write ((byte)0x72);  	this.methodBodyHeap.Write ((int)(this.GetUserStringIndex ((String)literal.Value) | 0x70000000));  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc) {  case TypeCode.Boolean:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  	long n = ic.ToInt64 (null);  	switch (n) {  	case -1:  		this.methodBodyHeap.Write ((byte)0x15);  		break;  	case 0:  		this.methodBodyHeap.Write ((byte)0x16);  		break;  	case 1:  		this.methodBodyHeap.Write ((byte)0x17);  		break;  	case 2:  		this.methodBodyHeap.Write ((byte)0x18);  		break;  	case 3:  		this.methodBodyHeap.Write ((byte)0x19);  		break;  	case 4:  		this.methodBodyHeap.Write ((byte)0x1a);  		break;  	case 5:  		this.methodBodyHeap.Write ((byte)0x1b);  		break;  	case 6:  		this.methodBodyHeap.Write ((byte)0x1c);  		break;  	case 7:  		this.methodBodyHeap.Write ((byte)0x1d);  		break;  	case 8:  		this.methodBodyHeap.Write ((byte)0x1e);  		break;  	default:  		if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  			this.methodBodyHeap.Write ((byte)0x1f);  			this.methodBodyHeap.Write ((byte)n);  		} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  			if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  				this.methodBodyHeap.Write ((byte)0x15);  			else {  				this.methodBodyHeap.Write ((byte)0x20);  				this.methodBodyHeap.Write ((int)n);  			}  		} else {  			this.methodBodyHeap.Write ((byte)0x21);  			this.methodBodyHeap.Write ((long)n);  			tc = TypeCode.Empty;  			//Suppress conversion to long  		}  		break;  	}  	if (tc == TypeCode.Int64)  		this.methodBodyHeap.Write ((byte)0x6a);  	return;  case TypeCode.UInt64:  	this.methodBodyHeap.Write ((byte)0x21);  	this.methodBodyHeap.Write (ic.ToUInt64 (null));  	return;  case TypeCode.Single:  	this.methodBodyHeap.Write ((byte)0x22);  	this.methodBodyHeap.Write (ic.ToSingle (null));  	return;  case TypeCode.Double:  	this.methodBodyHeap.Write ((byte)0x23);  	this.methodBodyHeap.Write (ic.ToDouble (null));  	return;  case TypeCode.String:  	this.methodBodyHeap.Write ((byte)0x72);  	this.methodBodyHeap.Write ((int)(this.GetUserStringIndex ((String)literal.Value) | 0x70000000));  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc) {  case TypeCode.Boolean:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  	long n = ic.ToInt64 (null);  	switch (n) {  	case -1:  		this.methodBodyHeap.Write ((byte)0x15);  		break;  	case 0:  		this.methodBodyHeap.Write ((byte)0x16);  		break;  	case 1:  		this.methodBodyHeap.Write ((byte)0x17);  		break;  	case 2:  		this.methodBodyHeap.Write ((byte)0x18);  		break;  	case 3:  		this.methodBodyHeap.Write ((byte)0x19);  		break;  	case 4:  		this.methodBodyHeap.Write ((byte)0x1a);  		break;  	case 5:  		this.methodBodyHeap.Write ((byte)0x1b);  		break;  	case 6:  		this.methodBodyHeap.Write ((byte)0x1c);  		break;  	case 7:  		this.methodBodyHeap.Write ((byte)0x1d);  		break;  	case 8:  		this.methodBodyHeap.Write ((byte)0x1e);  		break;  	default:  		if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  			this.methodBodyHeap.Write ((byte)0x1f);  			this.methodBodyHeap.Write ((byte)n);  		} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  			if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  				this.methodBodyHeap.Write ((byte)0x15);  			else {  				this.methodBodyHeap.Write ((byte)0x20);  				this.methodBodyHeap.Write ((int)n);  			}  		} else {  			this.methodBodyHeap.Write ((byte)0x21);  			this.methodBodyHeap.Write ((long)n);  			tc = TypeCode.Empty;  			//Suppress conversion to long  		}  		break;  	}  	if (tc == TypeCode.Int64)  		this.methodBodyHeap.Write ((byte)0x6a);  	return;  case TypeCode.UInt64:  	this.methodBodyHeap.Write ((byte)0x21);  	this.methodBodyHeap.Write (ic.ToUInt64 (null));  	return;  case TypeCode.Single:  	this.methodBodyHeap.Write ((byte)0x22);  	this.methodBodyHeap.Write (ic.ToSingle (null));  	return;  case TypeCode.Double:  	this.methodBodyHeap.Write ((byte)0x23);  	this.methodBodyHeap.Write (ic.ToDouble (null));  	return;  case TypeCode.String:  	this.methodBodyHeap.Write ((byte)0x72);  	this.methodBodyHeap.Write ((int)(this.GetUserStringIndex ((String)literal.Value) | 0x70000000));  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc) {  case TypeCode.Boolean:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  	long n = ic.ToInt64 (null);  	switch (n) {  	case -1:  		this.methodBodyHeap.Write ((byte)0x15);  		break;  	case 0:  		this.methodBodyHeap.Write ((byte)0x16);  		break;  	case 1:  		this.methodBodyHeap.Write ((byte)0x17);  		break;  	case 2:  		this.methodBodyHeap.Write ((byte)0x18);  		break;  	case 3:  		this.methodBodyHeap.Write ((byte)0x19);  		break;  	case 4:  		this.methodBodyHeap.Write ((byte)0x1a);  		break;  	case 5:  		this.methodBodyHeap.Write ((byte)0x1b);  		break;  	case 6:  		this.methodBodyHeap.Write ((byte)0x1c);  		break;  	case 7:  		this.methodBodyHeap.Write ((byte)0x1d);  		break;  	case 8:  		this.methodBodyHeap.Write ((byte)0x1e);  		break;  	default:  		if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  			this.methodBodyHeap.Write ((byte)0x1f);  			this.methodBodyHeap.Write ((byte)n);  		} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  			if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  				this.methodBodyHeap.Write ((byte)0x15);  			else {  				this.methodBodyHeap.Write ((byte)0x20);  				this.methodBodyHeap.Write ((int)n);  			}  		} else {  			this.methodBodyHeap.Write ((byte)0x21);  			this.methodBodyHeap.Write ((long)n);  			tc = TypeCode.Empty;  			//Suppress conversion to long  		}  		break;  	}  	if (tc == TypeCode.Int64)  		this.methodBodyHeap.Write ((byte)0x6a);  	return;  case TypeCode.UInt64:  	this.methodBodyHeap.Write ((byte)0x21);  	this.methodBodyHeap.Write (ic.ToUInt64 (null));  	return;  case TypeCode.Single:  	this.methodBodyHeap.Write ((byte)0x22);  	this.methodBodyHeap.Write (ic.ToSingle (null));  	return;  case TypeCode.Double:  	this.methodBodyHeap.Write ((byte)0x23);  	this.methodBodyHeap.Write (ic.ToDouble (null));  	return;  case TypeCode.String:  	this.methodBodyHeap.Write ((byte)0x72);  	this.methodBodyHeap.Write ((int)(this.GetUserStringIndex ((String)literal.Value) | 0x70000000));  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc) {  case TypeCode.Boolean:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  	long n = ic.ToInt64 (null);  	switch (n) {  	case -1:  		this.methodBodyHeap.Write ((byte)0x15);  		break;  	case 0:  		this.methodBodyHeap.Write ((byte)0x16);  		break;  	case 1:  		this.methodBodyHeap.Write ((byte)0x17);  		break;  	case 2:  		this.methodBodyHeap.Write ((byte)0x18);  		break;  	case 3:  		this.methodBodyHeap.Write ((byte)0x19);  		break;  	case 4:  		this.methodBodyHeap.Write ((byte)0x1a);  		break;  	case 5:  		this.methodBodyHeap.Write ((byte)0x1b);  		break;  	case 6:  		this.methodBodyHeap.Write ((byte)0x1c);  		break;  	case 7:  		this.methodBodyHeap.Write ((byte)0x1d);  		break;  	case 8:  		this.methodBodyHeap.Write ((byte)0x1e);  		break;  	default:  		if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  			this.methodBodyHeap.Write ((byte)0x1f);  			this.methodBodyHeap.Write ((byte)n);  		} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  			if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  				this.methodBodyHeap.Write ((byte)0x15);  			else {  				this.methodBodyHeap.Write ((byte)0x20);  				this.methodBodyHeap.Write ((int)n);  			}  		} else {  			this.methodBodyHeap.Write ((byte)0x21);  			this.methodBodyHeap.Write ((long)n);  			tc = TypeCode.Empty;  			//Suppress conversion to long  		}  		break;  	}  	if (tc == TypeCode.Int64)  		this.methodBodyHeap.Write ((byte)0x6a);  	return;  case TypeCode.UInt64:  	this.methodBodyHeap.Write ((byte)0x21);  	this.methodBodyHeap.Write (ic.ToUInt64 (null));  	return;  case TypeCode.Single:  	this.methodBodyHeap.Write ((byte)0x22);  	this.methodBodyHeap.Write (ic.ToSingle (null));  	return;  case TypeCode.Double:  	this.methodBodyHeap.Write ((byte)0x23);  	this.methodBodyHeap.Write (ic.ToDouble (null));  	return;  case TypeCode.String:  	this.methodBodyHeap.Write ((byte)0x72);  	this.methodBodyHeap.Write ((int)(this.GetUserStringIndex ((String)literal.Value) | 0x70000000));  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc) {  case TypeCode.Boolean:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  	long n = ic.ToInt64 (null);  	switch (n) {  	case -1:  		this.methodBodyHeap.Write ((byte)0x15);  		break;  	case 0:  		this.methodBodyHeap.Write ((byte)0x16);  		break;  	case 1:  		this.methodBodyHeap.Write ((byte)0x17);  		break;  	case 2:  		this.methodBodyHeap.Write ((byte)0x18);  		break;  	case 3:  		this.methodBodyHeap.Write ((byte)0x19);  		break;  	case 4:  		this.methodBodyHeap.Write ((byte)0x1a);  		break;  	case 5:  		this.methodBodyHeap.Write ((byte)0x1b);  		break;  	case 6:  		this.methodBodyHeap.Write ((byte)0x1c);  		break;  	case 7:  		this.methodBodyHeap.Write ((byte)0x1d);  		break;  	case 8:  		this.methodBodyHeap.Write ((byte)0x1e);  		break;  	default:  		if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  			this.methodBodyHeap.Write ((byte)0x1f);  			this.methodBodyHeap.Write ((byte)n);  		} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  			if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  				this.methodBodyHeap.Write ((byte)0x15);  			else {  				this.methodBodyHeap.Write ((byte)0x20);  				this.methodBodyHeap.Write ((int)n);  			}  		} else {  			this.methodBodyHeap.Write ((byte)0x21);  			this.methodBodyHeap.Write ((long)n);  			tc = TypeCode.Empty;  			//Suppress conversion to long  		}  		break;  	}  	if (tc == TypeCode.Int64)  		this.methodBodyHeap.Write ((byte)0x6a);  	return;  case TypeCode.UInt64:  	this.methodBodyHeap.Write ((byte)0x21);  	this.methodBodyHeap.Write (ic.ToUInt64 (null));  	return;  case TypeCode.Single:  	this.methodBodyHeap.Write ((byte)0x22);  	this.methodBodyHeap.Write (ic.ToSingle (null));  	return;  case TypeCode.Double:  	this.methodBodyHeap.Write ((byte)0x23);  	this.methodBodyHeap.Write (ic.ToDouble (null));  	return;  case TypeCode.String:  	this.methodBodyHeap.Write ((byte)0x72);  	this.methodBodyHeap.Write ((int)(this.GetUserStringIndex ((String)literal.Value) | 0x70000000));  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc) {  case TypeCode.Boolean:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  	long n = ic.ToInt64 (null);  	switch (n) {  	case -1:  		this.methodBodyHeap.Write ((byte)0x15);  		break;  	case 0:  		this.methodBodyHeap.Write ((byte)0x16);  		break;  	case 1:  		this.methodBodyHeap.Write ((byte)0x17);  		break;  	case 2:  		this.methodBodyHeap.Write ((byte)0x18);  		break;  	case 3:  		this.methodBodyHeap.Write ((byte)0x19);  		break;  	case 4:  		this.methodBodyHeap.Write ((byte)0x1a);  		break;  	case 5:  		this.methodBodyHeap.Write ((byte)0x1b);  		break;  	case 6:  		this.methodBodyHeap.Write ((byte)0x1c);  		break;  	case 7:  		this.methodBodyHeap.Write ((byte)0x1d);  		break;  	case 8:  		this.methodBodyHeap.Write ((byte)0x1e);  		break;  	default:  		if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  			this.methodBodyHeap.Write ((byte)0x1f);  			this.methodBodyHeap.Write ((byte)n);  		} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  			if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  				this.methodBodyHeap.Write ((byte)0x15);  			else {  				this.methodBodyHeap.Write ((byte)0x20);  				this.methodBodyHeap.Write ((int)n);  			}  		} else {  			this.methodBodyHeap.Write ((byte)0x21);  			this.methodBodyHeap.Write ((long)n);  			tc = TypeCode.Empty;  			//Suppress conversion to long  		}  		break;  	}  	if (tc == TypeCode.Int64)  		this.methodBodyHeap.Write ((byte)0x6a);  	return;  case TypeCode.UInt64:  	this.methodBodyHeap.Write ((byte)0x21);  	this.methodBodyHeap.Write (ic.ToUInt64 (null));  	return;  case TypeCode.Single:  	this.methodBodyHeap.Write ((byte)0x22);  	this.methodBodyHeap.Write (ic.ToSingle (null));  	return;  case TypeCode.Double:  	this.methodBodyHeap.Write ((byte)0x23);  	this.methodBodyHeap.Write (ic.ToDouble (null));  	return;  case TypeCode.String:  	this.methodBodyHeap.Write ((byte)0x72);  	this.methodBodyHeap.Write ((int)(this.GetUserStringIndex ((String)literal.Value) | 0x70000000));  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (n) {  case -1:  	this.methodBodyHeap.Write ((byte)0x15);  	break;  case 0:  	this.methodBodyHeap.Write ((byte)0x16);  	break;  case 1:  	this.methodBodyHeap.Write ((byte)0x17);  	break;  case 2:  	this.methodBodyHeap.Write ((byte)0x18);  	break;  case 3:  	this.methodBodyHeap.Write ((byte)0x19);  	break;  case 4:  	this.methodBodyHeap.Write ((byte)0x1a);  	break;  case 5:  	this.methodBodyHeap.Write ((byte)0x1b);  	break;  case 6:  	this.methodBodyHeap.Write ((byte)0x1c);  	break;  case 7:  	this.methodBodyHeap.Write ((byte)0x1d);  	break;  case 8:  	this.methodBodyHeap.Write ((byte)0x1e);  	break;  default:  	if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  		this.methodBodyHeap.Write ((byte)0x1f);  		this.methodBodyHeap.Write ((byte)n);  	} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  		if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  			this.methodBodyHeap.Write ((byte)0x15);  		else {  			this.methodBodyHeap.Write ((byte)0x20);  			this.methodBodyHeap.Write ((int)n);  		}  	} else {  		this.methodBodyHeap.Write ((byte)0x21);  		this.methodBodyHeap.Write ((long)n);  		tc = TypeCode.Empty;  		//Suppress conversion to long  	}  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (n) {  case -1:  	this.methodBodyHeap.Write ((byte)0x15);  	break;  case 0:  	this.methodBodyHeap.Write ((byte)0x16);  	break;  case 1:  	this.methodBodyHeap.Write ((byte)0x17);  	break;  case 2:  	this.methodBodyHeap.Write ((byte)0x18);  	break;  case 3:  	this.methodBodyHeap.Write ((byte)0x19);  	break;  case 4:  	this.methodBodyHeap.Write ((byte)0x1a);  	break;  case 5:  	this.methodBodyHeap.Write ((byte)0x1b);  	break;  case 6:  	this.methodBodyHeap.Write ((byte)0x1c);  	break;  case 7:  	this.methodBodyHeap.Write ((byte)0x1d);  	break;  case 8:  	this.methodBodyHeap.Write ((byte)0x1e);  	break;  default:  	if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  		this.methodBodyHeap.Write ((byte)0x1f);  		this.methodBodyHeap.Write ((byte)n);  	} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  		if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  			this.methodBodyHeap.Write ((byte)0x15);  		else {  			this.methodBodyHeap.Write ((byte)0x20);  			this.methodBodyHeap.Write ((int)n);  		}  	} else {  		this.methodBodyHeap.Write ((byte)0x21);  		this.methodBodyHeap.Write ((long)n);  		tc = TypeCode.Empty;  		//Suppress conversion to long  	}  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (n) {  case -1:  	this.methodBodyHeap.Write ((byte)0x15);  	break;  case 0:  	this.methodBodyHeap.Write ((byte)0x16);  	break;  case 1:  	this.methodBodyHeap.Write ((byte)0x17);  	break;  case 2:  	this.methodBodyHeap.Write ((byte)0x18);  	break;  case 3:  	this.methodBodyHeap.Write ((byte)0x19);  	break;  case 4:  	this.methodBodyHeap.Write ((byte)0x1a);  	break;  case 5:  	this.methodBodyHeap.Write ((byte)0x1b);  	break;  case 6:  	this.methodBodyHeap.Write ((byte)0x1c);  	break;  case 7:  	this.methodBodyHeap.Write ((byte)0x1d);  	break;  case 8:  	this.methodBodyHeap.Write ((byte)0x1e);  	break;  default:  	if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  		this.methodBodyHeap.Write ((byte)0x1f);  		this.methodBodyHeap.Write ((byte)n);  	} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  		if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  			this.methodBodyHeap.Write ((byte)0x15);  		else {  			this.methodBodyHeap.Write ((byte)0x20);  			this.methodBodyHeap.Write ((int)n);  		}  	} else {  		this.methodBodyHeap.Write ((byte)0x21);  		this.methodBodyHeap.Write ((long)n);  		tc = TypeCode.Empty;  		//Suppress conversion to long  	}  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (n) {  case -1:  	this.methodBodyHeap.Write ((byte)0x15);  	break;  case 0:  	this.methodBodyHeap.Write ((byte)0x16);  	break;  case 1:  	this.methodBodyHeap.Write ((byte)0x17);  	break;  case 2:  	this.methodBodyHeap.Write ((byte)0x18);  	break;  case 3:  	this.methodBodyHeap.Write ((byte)0x19);  	break;  case 4:  	this.methodBodyHeap.Write ((byte)0x1a);  	break;  case 5:  	this.methodBodyHeap.Write ((byte)0x1b);  	break;  case 6:  	this.methodBodyHeap.Write ((byte)0x1c);  	break;  case 7:  	this.methodBodyHeap.Write ((byte)0x1d);  	break;  case 8:  	this.methodBodyHeap.Write ((byte)0x1e);  	break;  default:  	if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  		this.methodBodyHeap.Write ((byte)0x1f);  		this.methodBodyHeap.Write ((byte)n);  	} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  		if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  			this.methodBodyHeap.Write ((byte)0x15);  		else {  			this.methodBodyHeap.Write ((byte)0x20);  			this.methodBodyHeap.Write ((int)n);  		}  	} else {  		this.methodBodyHeap.Write ((byte)0x21);  		this.methodBodyHeap.Write ((long)n);  		tc = TypeCode.Empty;  		//Suppress conversion to long  	}  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (n) {  case -1:  	this.methodBodyHeap.Write ((byte)0x15);  	break;  case 0:  	this.methodBodyHeap.Write ((byte)0x16);  	break;  case 1:  	this.methodBodyHeap.Write ((byte)0x17);  	break;  case 2:  	this.methodBodyHeap.Write ((byte)0x18);  	break;  case 3:  	this.methodBodyHeap.Write ((byte)0x19);  	break;  case 4:  	this.methodBodyHeap.Write ((byte)0x1a);  	break;  case 5:  	this.methodBodyHeap.Write ((byte)0x1b);  	break;  case 6:  	this.methodBodyHeap.Write ((byte)0x1c);  	break;  case 7:  	this.methodBodyHeap.Write ((byte)0x1d);  	break;  case 8:  	this.methodBodyHeap.Write ((byte)0x1e);  	break;  default:  	if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  		this.methodBodyHeap.Write ((byte)0x1f);  		this.methodBodyHeap.Write ((byte)n);  	} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  		if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  			this.methodBodyHeap.Write ((byte)0x15);  		else {  			this.methodBodyHeap.Write ((byte)0x20);  			this.methodBodyHeap.Write ((int)n);  		}  	} else {  		this.methodBodyHeap.Write ((byte)0x21);  		this.methodBodyHeap.Write ((long)n);  		tc = TypeCode.Empty;  		//Suppress conversion to long  	}  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (n) {  case -1:  	this.methodBodyHeap.Write ((byte)0x15);  	break;  case 0:  	this.methodBodyHeap.Write ((byte)0x16);  	break;  case 1:  	this.methodBodyHeap.Write ((byte)0x17);  	break;  case 2:  	this.methodBodyHeap.Write ((byte)0x18);  	break;  case 3:  	this.methodBodyHeap.Write ((byte)0x19);  	break;  case 4:  	this.methodBodyHeap.Write ((byte)0x1a);  	break;  case 5:  	this.methodBodyHeap.Write ((byte)0x1b);  	break;  case 6:  	this.methodBodyHeap.Write ((byte)0x1c);  	break;  case 7:  	this.methodBodyHeap.Write ((byte)0x1d);  	break;  case 8:  	this.methodBodyHeap.Write ((byte)0x1e);  	break;  default:  	if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  		this.methodBodyHeap.Write ((byte)0x1f);  		this.methodBodyHeap.Write ((byte)n);  	} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  		if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  			this.methodBodyHeap.Write ((byte)0x15);  		else {  			this.methodBodyHeap.Write ((byte)0x20);  			this.methodBodyHeap.Write ((int)n);  		}  	} else {  		this.methodBodyHeap.Write ((byte)0x21);  		this.methodBodyHeap.Write ((long)n);  		tc = TypeCode.Empty;  		//Suppress conversion to long  	}  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (n) {  case -1:  	this.methodBodyHeap.Write ((byte)0x15);  	break;  case 0:  	this.methodBodyHeap.Write ((byte)0x16);  	break;  case 1:  	this.methodBodyHeap.Write ((byte)0x17);  	break;  case 2:  	this.methodBodyHeap.Write ((byte)0x18);  	break;  case 3:  	this.methodBodyHeap.Write ((byte)0x19);  	break;  case 4:  	this.methodBodyHeap.Write ((byte)0x1a);  	break;  case 5:  	this.methodBodyHeap.Write ((byte)0x1b);  	break;  case 6:  	this.methodBodyHeap.Write ((byte)0x1c);  	break;  case 7:  	this.methodBodyHeap.Write ((byte)0x1d);  	break;  case 8:  	this.methodBodyHeap.Write ((byte)0x1e);  	break;  default:  	if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue) {  		this.methodBodyHeap.Write ((byte)0x1f);  		this.methodBodyHeap.Write ((byte)n);  	} else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue || n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)) {  		if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)  			this.methodBodyHeap.Write ((byte)0x15);  		else {  			this.methodBodyHeap.Write ((byte)0x20);  			this.methodBodyHeap.Write ((int)n);  		}  	} else {  		this.methodBodyHeap.Write ((byte)0x21);  		this.methodBodyHeap.Write ((long)n);  		tc = TypeCode.Empty;  		//Suppress conversion to long  	}  	break;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit fat header  	byte header = 0x03;  	if (method.InitLocals)  		header |= 0x10;  	if (exceptionHandlersCount > 0)  		header |= 0x08;  	this.methodBodiesHeap.Write ((byte)header);  	this.methodBodiesHeap.Write ((byte)0x30);  	//top 4 bits represent length of fat header in dwords. Heaven only knows why.  	this.methodBodiesHeap.Write ((short)maxStack);  	this.methodBodiesHeap.Write ((int)codeSize);  	if (localVarSigTok != 0) {  		if (this.methodInfo.localVarIndex.Count > 127) {  			//Need to make space for the two byte count  			this.methodInfo.localVarSignature.Write ((byte)0);  			byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  			int n = buf.Length;  			for (int i = n - 2; i > 1; i--)  				buf [i + 1] = buf [i];  		}  		this.methodInfo.localVarSignature.BaseStream.Position = 0;  		this.methodInfo.localVarSignature.Write ((byte)7);  		Ir2md.WriteCompressedInt (this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);  		Debug.Assert (this.methodInfo.localVarIndex.Count <= 0xFFFE);  	}  	this.methodBodiesHeap.Write ((int)localVarSigTok);  } else {  	//Emit tiny header  	this.methodBodiesHeap.Write ((byte)(codeSize << 2 | 2));  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit fat header  	byte header = 0x03;  	if (method.InitLocals)  		header |= 0x10;  	if (exceptionHandlersCount > 0)  		header |= 0x08;  	this.methodBodiesHeap.Write ((byte)header);  	this.methodBodiesHeap.Write ((byte)0x30);  	//top 4 bits represent length of fat header in dwords. Heaven only knows why.  	this.methodBodiesHeap.Write ((short)maxStack);  	this.methodBodiesHeap.Write ((int)codeSize);  	if (localVarSigTok != 0) {  		if (this.methodInfo.localVarIndex.Count > 127) {  			//Need to make space for the two byte count  			this.methodInfo.localVarSignature.Write ((byte)0);  			byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  			int n = buf.Length;  			for (int i = n - 2; i > 1; i--)  				buf [i + 1] = buf [i];  		}  		this.methodInfo.localVarSignature.BaseStream.Position = 0;  		this.methodInfo.localVarSignature.Write ((byte)7);  		Ir2md.WriteCompressedInt (this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);  		Debug.Assert (this.methodInfo.localVarIndex.Count <= 0xFFFE);  	}  	this.methodBodiesHeap.Write ((int)localVarSigTok);  } else {  	//Emit tiny header  	this.methodBodiesHeap.Write ((byte)(codeSize << 2 | 2));  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit fat header  	byte header = 0x03;  	if (method.InitLocals)  		header |= 0x10;  	if (exceptionHandlersCount > 0)  		header |= 0x08;  	this.methodBodiesHeap.Write ((byte)header);  	this.methodBodiesHeap.Write ((byte)0x30);  	//top 4 bits represent length of fat header in dwords. Heaven only knows why.  	this.methodBodiesHeap.Write ((short)maxStack);  	this.methodBodiesHeap.Write ((int)codeSize);  	if (localVarSigTok != 0) {  		if (this.methodInfo.localVarIndex.Count > 127) {  			//Need to make space for the two byte count  			this.methodInfo.localVarSignature.Write ((byte)0);  			byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  			int n = buf.Length;  			for (int i = n - 2; i > 1; i--)  				buf [i + 1] = buf [i];  		}  		this.methodInfo.localVarSignature.BaseStream.Position = 0;  		this.methodInfo.localVarSignature.Write ((byte)7);  		Ir2md.WriteCompressedInt (this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);  		Debug.Assert (this.methodInfo.localVarIndex.Count <= 0xFFFE);  	}  	this.methodBodiesHeap.Write ((int)localVarSigTok);  } else {  	//Emit tiny header  	this.methodBodiesHeap.Write ((byte)(codeSize << 2 | 2));  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit fat header  	byte header = 0x03;  	if (method.InitLocals)  		header |= 0x10;  	if (exceptionHandlersCount > 0)  		header |= 0x08;  	this.methodBodiesHeap.Write ((byte)header);  	this.methodBodiesHeap.Write ((byte)0x30);  	//top 4 bits represent length of fat header in dwords. Heaven only knows why.  	this.methodBodiesHeap.Write ((short)maxStack);  	this.methodBodiesHeap.Write ((int)codeSize);  	if (localVarSigTok != 0) {  		if (this.methodInfo.localVarIndex.Count > 127) {  			//Need to make space for the two byte count  			this.methodInfo.localVarSignature.Write ((byte)0);  			byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  			int n = buf.Length;  			for (int i = n - 2; i > 1; i--)  				buf [i + 1] = buf [i];  		}  		this.methodInfo.localVarSignature.BaseStream.Position = 0;  		this.methodInfo.localVarSignature.Write ((byte)7);  		Ir2md.WriteCompressedInt (this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);  		Debug.Assert (this.methodInfo.localVarIndex.Count <= 0xFFFE);  	}  	this.methodBodiesHeap.Write ((int)localVarSigTok);  } else {  	//Emit tiny header  	this.methodBodiesHeap.Write ((byte)(codeSize << 2 | 2));  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit fat header  	byte header = 0x03;  	if (method.InitLocals)  		header |= 0x10;  	if (exceptionHandlersCount > 0)  		header |= 0x08;  	this.methodBodiesHeap.Write ((byte)header);  	this.methodBodiesHeap.Write ((byte)0x30);  	//top 4 bits represent length of fat header in dwords. Heaven only knows why.  	this.methodBodiesHeap.Write ((short)maxStack);  	this.methodBodiesHeap.Write ((int)codeSize);  	if (localVarSigTok != 0) {  		if (this.methodInfo.localVarIndex.Count > 127) {  			//Need to make space for the two byte count  			this.methodInfo.localVarSignature.Write ((byte)0);  			byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  			int n = buf.Length;  			for (int i = n - 2; i > 1; i--)  				buf [i + 1] = buf [i];  		}  		this.methodInfo.localVarSignature.BaseStream.Position = 0;  		this.methodInfo.localVarSignature.Write ((byte)7);  		Ir2md.WriteCompressedInt (this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);  		Debug.Assert (this.methodInfo.localVarIndex.Count <= 0xFFFE);  	}  	this.methodBodiesHeap.Write ((int)localVarSigTok);  } else {  	//Emit tiny header  	this.methodBodiesHeap.Write ((byte)(codeSize << 2 | 2));  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (localVarSigTok != 0) {  	if (this.methodInfo.localVarIndex.Count > 127) {  		//Need to make space for the two byte count  		this.methodInfo.localVarSignature.Write ((byte)0);  		byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  		int n = buf.Length;  		for (int i = n - 2; i > 1; i--)  			buf [i + 1] = buf [i];  	}  	this.methodInfo.localVarSignature.BaseStream.Position = 0;  	this.methodInfo.localVarSignature.Write ((byte)7);  	Ir2md.WriteCompressedInt (this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);  	Debug.Assert (this.methodInfo.localVarIndex.Count <= 0xFFFE);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (localVarSigTok != 0) {  	if (this.methodInfo.localVarIndex.Count > 127) {  		//Need to make space for the two byte count  		this.methodInfo.localVarSignature.Write ((byte)0);  		byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  		int n = buf.Length;  		for (int i = n - 2; i > 1; i--)  			buf [i + 1] = buf [i];  	}  	this.methodInfo.localVarSignature.BaseStream.Position = 0;  	this.methodInfo.localVarSignature.Write ((byte)7);  	Ir2md.WriteCompressedInt (this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);  	Debug.Assert (this.methodInfo.localVarIndex.Count <= 0xFFFE);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (localVarSigTok != 0) {  	if (this.methodInfo.localVarIndex.Count > 127) {  		//Need to make space for the two byte count  		this.methodInfo.localVarSignature.Write ((byte)0);  		byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  		int n = buf.Length;  		for (int i = n - 2; i > 1; i--)  			buf [i + 1] = buf [i];  	}  	this.methodInfo.localVarSignature.BaseStream.Position = 0;  	this.methodInfo.localVarSignature.Write ((byte)7);  	Ir2md.WriteCompressedInt (this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);  	Debug.Assert (this.methodInfo.localVarIndex.Count <= 0xFFFE);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (this.methodInfo.localVarIndex.Count > 127) {  	//Need to make space for the two byte count  	this.methodInfo.localVarSignature.Write ((byte)0);  	byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  	int n = buf.Length;  	for (int i = n - 2; i > 1; i--)  		buf [i + 1] = buf [i];  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (this.methodInfo.localVarIndex.Count > 127) {  	//Need to make space for the two byte count  	this.methodInfo.localVarSignature.Write ((byte)0);  	byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;  	int n = buf.Length;  	for (int i = n - 2; i > 1; i--)  		buf [i + 1] = buf [i];  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: for (int i = n - 2; i > 1; i--)  	buf [i + 1] = buf [i];  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: this.methodInfo.localVarSignature.Write ((byte)7);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: this.methodBodiesHeap.Write ((byte)(codeSize << 2 | 2));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: this.methodBodiesHeap.Write ((byte)(codeSize << 2 | 2));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: while (pad % 4 != 0) {  	pad++;  	this.methodBodiesHeap.Write ((byte)0);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit exception handler entries  	int[] tryOffsets = new int[exceptionHandlersCount];  	int[] tryLengths = new int[exceptionHandlersCount];  	int[] handlerOffsets = new int[exceptionHandlersCount];  	int[] handlerLengths = new int[exceptionHandlersCount];  	bool fatFormat = false;  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		int tryOffset = tryOffsets [i] = (int)this.methodInfo.fixupIndex [eh.TryStartBlock.UniqueKey];  		int tryLength = tryLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;  		int handlerOffset = handlerOffsets [i] = (int)this.methodInfo.fixupIndex [eh.HandlerStartBlock.UniqueKey];  		int handlerLength = handlerLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;  		if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff)  			fatFormat = true;  	}  	if (exceptionHandlersCount * 12 > 0xff)  		fatFormat = true;  	if (fatFormat) {  		int dataSize = exceptionHandlersCount * 24 + 4;  		this.methodBodiesHeap.Write ((byte)0x41);  		this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  		this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  	} else {  		int dataSize = exceptionHandlersCount * 12 + 4;  		this.methodBodiesHeap.Write ((byte)0x01);  		this.methodBodiesHeap.Write ((byte)dataSize);  		this.methodBodiesHeap.Write ((short)0);  	}  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		byte flags = 0;  		switch (eh.HandlerType) {  		case NodeType.Filter:  			flags = 0x0001;  			break;  		case NodeType.Finally:  			flags = 0x0002;  			break;  		case NodeType.FaultHandler:  			flags = 0x0004;  			break;  		}  		if (fatFormat) {  			this.methodBodiesHeap.Write ((int)flags);  			this.methodBodiesHeap.Write ((int)tryOffsets [i]);  			this.methodBodiesHeap.Write ((int)tryLengths [i]);  			this.methodBodiesHeap.Write ((int)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((int)handlerLengths [i]);  		} else {  			this.methodBodiesHeap.Write ((short)flags);  			this.methodBodiesHeap.Write ((ushort)tryOffsets [i]);  			this.methodBodiesHeap.Write ((byte)tryLengths [i]);  			this.methodBodiesHeap.Write ((ushort)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((byte)handlerLengths [i]);  		}  		if (eh.FilterType != null)  			this.methodBodiesHeap.Write ((int)this.GetTypeToken (eh.FilterType));  		else if (eh.FilterExpression != null)  			this.methodBodiesHeap.Write ((int)this.methodInfo.fixupIndex [eh.FilterExpression.UniqueKey]);  		else  			this.methodBodiesHeap.Write ((int)0);  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit exception handler entries  	int[] tryOffsets = new int[exceptionHandlersCount];  	int[] tryLengths = new int[exceptionHandlersCount];  	int[] handlerOffsets = new int[exceptionHandlersCount];  	int[] handlerLengths = new int[exceptionHandlersCount];  	bool fatFormat = false;  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		int tryOffset = tryOffsets [i] = (int)this.methodInfo.fixupIndex [eh.TryStartBlock.UniqueKey];  		int tryLength = tryLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;  		int handlerOffset = handlerOffsets [i] = (int)this.methodInfo.fixupIndex [eh.HandlerStartBlock.UniqueKey];  		int handlerLength = handlerLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;  		if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff)  			fatFormat = true;  	}  	if (exceptionHandlersCount * 12 > 0xff)  		fatFormat = true;  	if (fatFormat) {  		int dataSize = exceptionHandlersCount * 24 + 4;  		this.methodBodiesHeap.Write ((byte)0x41);  		this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  		this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  	} else {  		int dataSize = exceptionHandlersCount * 12 + 4;  		this.methodBodiesHeap.Write ((byte)0x01);  		this.methodBodiesHeap.Write ((byte)dataSize);  		this.methodBodiesHeap.Write ((short)0);  	}  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		byte flags = 0;  		switch (eh.HandlerType) {  		case NodeType.Filter:  			flags = 0x0001;  			break;  		case NodeType.Finally:  			flags = 0x0002;  			break;  		case NodeType.FaultHandler:  			flags = 0x0004;  			break;  		}  		if (fatFormat) {  			this.methodBodiesHeap.Write ((int)flags);  			this.methodBodiesHeap.Write ((int)tryOffsets [i]);  			this.methodBodiesHeap.Write ((int)tryLengths [i]);  			this.methodBodiesHeap.Write ((int)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((int)handlerLengths [i]);  		} else {  			this.methodBodiesHeap.Write ((short)flags);  			this.methodBodiesHeap.Write ((ushort)tryOffsets [i]);  			this.methodBodiesHeap.Write ((byte)tryLengths [i]);  			this.methodBodiesHeap.Write ((ushort)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((byte)handlerLengths [i]);  		}  		if (eh.FilterType != null)  			this.methodBodiesHeap.Write ((int)this.GetTypeToken (eh.FilterType));  		else if (eh.FilterExpression != null)  			this.methodBodiesHeap.Write ((int)this.methodInfo.fixupIndex [eh.FilterExpression.UniqueKey]);  		else  			this.methodBodiesHeap.Write ((int)0);  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit exception handler entries  	int[] tryOffsets = new int[exceptionHandlersCount];  	int[] tryLengths = new int[exceptionHandlersCount];  	int[] handlerOffsets = new int[exceptionHandlersCount];  	int[] handlerLengths = new int[exceptionHandlersCount];  	bool fatFormat = false;  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		int tryOffset = tryOffsets [i] = (int)this.methodInfo.fixupIndex [eh.TryStartBlock.UniqueKey];  		int tryLength = tryLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;  		int handlerOffset = handlerOffsets [i] = (int)this.methodInfo.fixupIndex [eh.HandlerStartBlock.UniqueKey];  		int handlerLength = handlerLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;  		if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff)  			fatFormat = true;  	}  	if (exceptionHandlersCount * 12 > 0xff)  		fatFormat = true;  	if (fatFormat) {  		int dataSize = exceptionHandlersCount * 24 + 4;  		this.methodBodiesHeap.Write ((byte)0x41);  		this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  		this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  	} else {  		int dataSize = exceptionHandlersCount * 12 + 4;  		this.methodBodiesHeap.Write ((byte)0x01);  		this.methodBodiesHeap.Write ((byte)dataSize);  		this.methodBodiesHeap.Write ((short)0);  	}  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		byte flags = 0;  		switch (eh.HandlerType) {  		case NodeType.Filter:  			flags = 0x0001;  			break;  		case NodeType.Finally:  			flags = 0x0002;  			break;  		case NodeType.FaultHandler:  			flags = 0x0004;  			break;  		}  		if (fatFormat) {  			this.methodBodiesHeap.Write ((int)flags);  			this.methodBodiesHeap.Write ((int)tryOffsets [i]);  			this.methodBodiesHeap.Write ((int)tryLengths [i]);  			this.methodBodiesHeap.Write ((int)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((int)handlerLengths [i]);  		} else {  			this.methodBodiesHeap.Write ((short)flags);  			this.methodBodiesHeap.Write ((ushort)tryOffsets [i]);  			this.methodBodiesHeap.Write ((byte)tryLengths [i]);  			this.methodBodiesHeap.Write ((ushort)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((byte)handlerLengths [i]);  		}  		if (eh.FilterType != null)  			this.methodBodiesHeap.Write ((int)this.GetTypeToken (eh.FilterType));  		else if (eh.FilterExpression != null)  			this.methodBodiesHeap.Write ((int)this.methodInfo.fixupIndex [eh.FilterExpression.UniqueKey]);  		else  			this.methodBodiesHeap.Write ((int)0);  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit exception handler entries  	int[] tryOffsets = new int[exceptionHandlersCount];  	int[] tryLengths = new int[exceptionHandlersCount];  	int[] handlerOffsets = new int[exceptionHandlersCount];  	int[] handlerLengths = new int[exceptionHandlersCount];  	bool fatFormat = false;  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		int tryOffset = tryOffsets [i] = (int)this.methodInfo.fixupIndex [eh.TryStartBlock.UniqueKey];  		int tryLength = tryLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;  		int handlerOffset = handlerOffsets [i] = (int)this.methodInfo.fixupIndex [eh.HandlerStartBlock.UniqueKey];  		int handlerLength = handlerLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;  		if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff)  			fatFormat = true;  	}  	if (exceptionHandlersCount * 12 > 0xff)  		fatFormat = true;  	if (fatFormat) {  		int dataSize = exceptionHandlersCount * 24 + 4;  		this.methodBodiesHeap.Write ((byte)0x41);  		this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  		this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  	} else {  		int dataSize = exceptionHandlersCount * 12 + 4;  		this.methodBodiesHeap.Write ((byte)0x01);  		this.methodBodiesHeap.Write ((byte)dataSize);  		this.methodBodiesHeap.Write ((short)0);  	}  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		byte flags = 0;  		switch (eh.HandlerType) {  		case NodeType.Filter:  			flags = 0x0001;  			break;  		case NodeType.Finally:  			flags = 0x0002;  			break;  		case NodeType.FaultHandler:  			flags = 0x0004;  			break;  		}  		if (fatFormat) {  			this.methodBodiesHeap.Write ((int)flags);  			this.methodBodiesHeap.Write ((int)tryOffsets [i]);  			this.methodBodiesHeap.Write ((int)tryLengths [i]);  			this.methodBodiesHeap.Write ((int)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((int)handlerLengths [i]);  		} else {  			this.methodBodiesHeap.Write ((short)flags);  			this.methodBodiesHeap.Write ((ushort)tryOffsets [i]);  			this.methodBodiesHeap.Write ((byte)tryLengths [i]);  			this.methodBodiesHeap.Write ((ushort)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((byte)handlerLengths [i]);  		}  		if (eh.FilterType != null)  			this.methodBodiesHeap.Write ((int)this.GetTypeToken (eh.FilterType));  		else if (eh.FilterExpression != null)  			this.methodBodiesHeap.Write ((int)this.methodInfo.fixupIndex [eh.FilterExpression.UniqueKey]);  		else  			this.methodBodiesHeap.Write ((int)0);  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit exception handler entries  	int[] tryOffsets = new int[exceptionHandlersCount];  	int[] tryLengths = new int[exceptionHandlersCount];  	int[] handlerOffsets = new int[exceptionHandlersCount];  	int[] handlerLengths = new int[exceptionHandlersCount];  	bool fatFormat = false;  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		int tryOffset = tryOffsets [i] = (int)this.methodInfo.fixupIndex [eh.TryStartBlock.UniqueKey];  		int tryLength = tryLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;  		int handlerOffset = handlerOffsets [i] = (int)this.methodInfo.fixupIndex [eh.HandlerStartBlock.UniqueKey];  		int handlerLength = handlerLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;  		if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff)  			fatFormat = true;  	}  	if (exceptionHandlersCount * 12 > 0xff)  		fatFormat = true;  	if (fatFormat) {  		int dataSize = exceptionHandlersCount * 24 + 4;  		this.methodBodiesHeap.Write ((byte)0x41);  		this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  		this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  	} else {  		int dataSize = exceptionHandlersCount * 12 + 4;  		this.methodBodiesHeap.Write ((byte)0x01);  		this.methodBodiesHeap.Write ((byte)dataSize);  		this.methodBodiesHeap.Write ((short)0);  	}  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		byte flags = 0;  		switch (eh.HandlerType) {  		case NodeType.Filter:  			flags = 0x0001;  			break;  		case NodeType.Finally:  			flags = 0x0002;  			break;  		case NodeType.FaultHandler:  			flags = 0x0004;  			break;  		}  		if (fatFormat) {  			this.methodBodiesHeap.Write ((int)flags);  			this.methodBodiesHeap.Write ((int)tryOffsets [i]);  			this.methodBodiesHeap.Write ((int)tryLengths [i]);  			this.methodBodiesHeap.Write ((int)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((int)handlerLengths [i]);  		} else {  			this.methodBodiesHeap.Write ((short)flags);  			this.methodBodiesHeap.Write ((ushort)tryOffsets [i]);  			this.methodBodiesHeap.Write ((byte)tryLengths [i]);  			this.methodBodiesHeap.Write ((ushort)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((byte)handlerLengths [i]);  		}  		if (eh.FilterType != null)  			this.methodBodiesHeap.Write ((int)this.GetTypeToken (eh.FilterType));  		else if (eh.FilterExpression != null)  			this.methodBodiesHeap.Write ((int)this.methodInfo.fixupIndex [eh.FilterExpression.UniqueKey]);  		else  			this.methodBodiesHeap.Write ((int)0);  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {  	//Emit exception handler entries  	int[] tryOffsets = new int[exceptionHandlersCount];  	int[] tryLengths = new int[exceptionHandlersCount];  	int[] handlerOffsets = new int[exceptionHandlersCount];  	int[] handlerLengths = new int[exceptionHandlersCount];  	bool fatFormat = false;  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		int tryOffset = tryOffsets [i] = (int)this.methodInfo.fixupIndex [eh.TryStartBlock.UniqueKey];  		int tryLength = tryLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;  		int handlerOffset = handlerOffsets [i] = (int)this.methodInfo.fixupIndex [eh.HandlerStartBlock.UniqueKey];  		int handlerLength = handlerLengths [i] = ((int)this.methodInfo.fixupIndex [eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;  		if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff)  			fatFormat = true;  	}  	if (exceptionHandlersCount * 12 > 0xff)  		fatFormat = true;  	if (fatFormat) {  		int dataSize = exceptionHandlersCount * 24 + 4;  		this.methodBodiesHeap.Write ((byte)0x41);  		this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  		this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  	} else {  		int dataSize = exceptionHandlersCount * 12 + 4;  		this.methodBodiesHeap.Write ((byte)0x01);  		this.methodBodiesHeap.Write ((byte)dataSize);  		this.methodBodiesHeap.Write ((short)0);  	}  	for (int i = 0; i < exceptionHandlersCount; i++) {  		ExceptionHandler eh = method.ExceptionHandlers [i];  		byte flags = 0;  		switch (eh.HandlerType) {  		case NodeType.Filter:  			flags = 0x0001;  			break;  		case NodeType.Finally:  			flags = 0x0002;  			break;  		case NodeType.FaultHandler:  			flags = 0x0004;  			break;  		}  		if (fatFormat) {  			this.methodBodiesHeap.Write ((int)flags);  			this.methodBodiesHeap.Write ((int)tryOffsets [i]);  			this.methodBodiesHeap.Write ((int)tryLengths [i]);  			this.methodBodiesHeap.Write ((int)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((int)handlerLengths [i]);  		} else {  			this.methodBodiesHeap.Write ((short)flags);  			this.methodBodiesHeap.Write ((ushort)tryOffsets [i]);  			this.methodBodiesHeap.Write ((byte)tryLengths [i]);  			this.methodBodiesHeap.Write ((ushort)handlerOffsets [i]);  			this.methodBodiesHeap.Write ((byte)handlerLengths [i]);  		}  		if (eh.FilterType != null)  			this.methodBodiesHeap.Write ((int)this.GetTypeToken (eh.FilterType));  		else if (eh.FilterExpression != null)  			this.methodBodiesHeap.Write ((int)this.methodInfo.fixupIndex [eh.FilterExpression.UniqueKey]);  		else  			this.methodBodiesHeap.Write ((int)0);  	}  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (exceptionHandlersCount * 12 > 0xff)  	fatFormat = true;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatFormat) {  	int dataSize = exceptionHandlersCount * 24 + 4;  	this.methodBodiesHeap.Write ((byte)0x41);  	this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  	this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  } else {  	int dataSize = exceptionHandlersCount * 12 + 4;  	this.methodBodiesHeap.Write ((byte)0x01);  	this.methodBodiesHeap.Write ((byte)dataSize);  	this.methodBodiesHeap.Write ((short)0);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatFormat) {  	int dataSize = exceptionHandlersCount * 24 + 4;  	this.methodBodiesHeap.Write ((byte)0x41);  	this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  	this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  } else {  	int dataSize = exceptionHandlersCount * 12 + 4;  	this.methodBodiesHeap.Write ((byte)0x01);  	this.methodBodiesHeap.Write ((byte)dataSize);  	this.methodBodiesHeap.Write ((short)0);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatFormat) {  	int dataSize = exceptionHandlersCount * 24 + 4;  	this.methodBodiesHeap.Write ((byte)0x41);  	this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  	this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  } else {  	int dataSize = exceptionHandlersCount * 12 + 4;  	this.methodBodiesHeap.Write ((byte)0x01);  	this.methodBodiesHeap.Write ((byte)dataSize);  	this.methodBodiesHeap.Write ((short)0);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatFormat) {  	int dataSize = exceptionHandlersCount * 24 + 4;  	this.methodBodiesHeap.Write ((byte)0x41);  	this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  	this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  } else {  	int dataSize = exceptionHandlersCount * 12 + 4;  	this.methodBodiesHeap.Write ((byte)0x01);  	this.methodBodiesHeap.Write ((byte)dataSize);  	this.methodBodiesHeap.Write ((short)0);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatFormat) {  	int dataSize = exceptionHandlersCount * 24 + 4;  	this.methodBodiesHeap.Write ((byte)0x41);  	this.methodBodiesHeap.Write ((byte)(dataSize & 0xff));  	this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  } else {  	int dataSize = exceptionHandlersCount * 12 + 4;  	this.methodBodiesHeap.Write ((byte)0x01);  	this.methodBodiesHeap.Write ((byte)dataSize);  	this.methodBodiesHeap.Write ((short)0);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: this.methodBodiesHeap.Write ((short)((dataSize >> 8) & 0xffff));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitParameter,The following statement contains a magic number: switch (pi) {  case 0:  	this.methodBodyHeap.Write ((byte)0x02);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x03);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x04);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x05);  	return;  default:  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x0e);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x09);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitParameter,The following statement contains a magic number: switch (pi) {  case 0:  	this.methodBodyHeap.Write ((byte)0x02);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x03);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x04);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x05);  	return;  default:  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x0e);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x09);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitParameter,The following statement contains a magic number: switch (pi) {  case 0:  	this.methodBodyHeap.Write ((byte)0x02);  	return;  case 1:  	this.methodBodyHeap.Write ((byte)0x03);  	return;  case 2:  	this.methodBodyHeap.Write ((byte)0x04);  	return;  case 3:  	this.methodBodyHeap.Write ((byte)0x05);  	return;  default:  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x0e);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x09);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	return;  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitParameter,The following statement contains a magic number: if (pi < 256) {  	this.methodBodyHeap.Write ((byte)0x0e);  	this.methodBodyHeap.Write ((byte)pi);  } else {  	this.methodBodyHeap.Write ((byte)0xfe);  	this.methodBodyHeap.Write ((byte)0x09);  	this.methodBodyHeap.Write ((ushort)pi);  }  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitTernaryExpression,The following statement contains a magic number: this.stackHeight -= 3;  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val <= 0x7f)  	target.Write ((byte)val);  else if (val < 0x3fff) {  	target.Write ((byte)((val >> 8) | 0x80));  	target.Write ((byte)(val & 0xff));  } else if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val <= 0x7f)  	target.Write ((byte)val);  else if (val < 0x3fff) {  	target.Write ((byte)((val >> 8) | 0x80));  	target.Write ((byte)(val & 0xff));  } else if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val <= 0x7f)  	target.Write ((byte)val);  else if (val < 0x3fff) {  	target.Write ((byte)((val >> 8) | 0x80));  	target.Write ((byte)(val & 0xff));  } else if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val <= 0x7f)  	target.Write ((byte)val);  else if (val < 0x3fff) {  	target.Write ((byte)((val >> 8) | 0x80));  	target.Write ((byte)(val & 0xff));  } else if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val < 0x3fff) {  	target.Write ((byte)((val >> 8) | 0x80));  	target.Write ((byte)(val & 0xff));  } else if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val < 0x3fff) {  	target.Write ((byte)((val >> 8) | 0x80));  	target.Write ((byte)(val & 0xff));  } else if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val < 0x3fff) {  	target.Write ((byte)((val >> 8) | 0x80));  	target.Write ((byte)(val & 0xff));  } else if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val < 0x3fff) {  	target.Write ((byte)((val >> 8) | 0x80));  	target.Write ((byte)(val & 0xff));  } else if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: target.Write ((byte)((val >> 8) | 0x80));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val < 0x1fffffff) {  	target.Write ((byte)((val >> 24) | 0xc0));  	target.Write ((byte)((val & 0xff0000) >> 16));  	target.Write ((byte)((val & 0xff00) >> 8));  	target.Write ((byte)(val & 0xff));  } else  	Debug.Assert (false' "index too large for compression");  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: target.Write ((byte)((val >> 24) | 0xc0));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: target.Write ((byte)((val & 0xff0000) >> 16));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: target.Write ((byte)((val & 0xff00) >> 8));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteTypeDefEncoded,The following statement contains a magic number: Ir2md.WriteCompressedInt (target' (tok << 2));  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteTypeRefEncoded,The following statement contains a magic number: Ir2md.WriteCompressedInt (target' (tok << 2) | 1);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteTypeSpecEncoded,The following statement contains a magic number: Ir2md.WriteCompressedInt (target' (tok << 2) | 2);  
Magic Number,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteTypeSpecEncoded,The following statement contains a magic number: Ir2md.WriteCompressedInt (target' (tok << 2) | 2);  
Magic Number,System.Compiler,ByteArrayHasher,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0' n = xa.Length; i < n; i++)  	hcode = hcode * 17 + xa [i];  
Magic Number,System.Compiler,ByteArrayHasher,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetHashCode,The following statement contains a magic number: hcode = hcode * 17 + xa [i];  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WritePE,The following statement contains a magic number: if (options == null)  	Writer.WritePE (module.Location' compilerParameters.IncludeDebugInformation' module' false' null' null);  else {  	if (options.FileAlignment > 512)  		module.FileAlignment = options.FileAlignment;  	Writer.WritePE (module.Location' options.IncludeDebugInformation' module' options.DelaySign' options.AssemblyKeyFile' options.AssemblyKeyName);  }  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WritePE,The following statement contains a magic number: if (options.FileAlignment > 512)  	module.FileAlignment = options.FileAlignment;  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: for (int i = 0; i < imageCount; i++) {  	resource = new Win32Resource ();  	resource.CodePage = 0;  	resource.Id = module.Win32Resources.Count + 2;  	resource.LanguageId = 0;  	resource.Name = null;  	resource.TypeId = 3;  	resource.TypeName = null;  	indexHeap.Write (cursor.ReadByte ());  	//width  	indexHeap.Write (cursor.ReadByte ());  	//height  	indexHeap.Write (cursor.ReadByte ());  	//color count  	indexHeap.Write (cursor.ReadByte ());  	//reserved  	indexHeap.Write (cursor.ReadUInt16 ());  	//planes  	indexHeap.Write (cursor.ReadUInt16 ());  	//bit count  	int len = cursor.ReadInt32 ();  	int offset = cursor.ReadInt32 ();  	indexHeap.Write ((int)len);  	indexHeap.Write ((int)module.Win32Resources.Count + 2);  	MemoryCursor c = new MemoryCursor (cursor);  	c.Position = offset;  	resource.Data = c.ReadBytes (len);  	module.Win32Resources.Add (resource);  }  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: for (int i = 0; i < imageCount; i++) {  	resource = new Win32Resource ();  	resource.CodePage = 0;  	resource.Id = module.Win32Resources.Count + 2;  	resource.LanguageId = 0;  	resource.Name = null;  	resource.TypeId = 3;  	resource.TypeName = null;  	indexHeap.Write (cursor.ReadByte ());  	//width  	indexHeap.Write (cursor.ReadByte ());  	//height  	indexHeap.Write (cursor.ReadByte ());  	//color count  	indexHeap.Write (cursor.ReadByte ());  	//reserved  	indexHeap.Write (cursor.ReadUInt16 ());  	//planes  	indexHeap.Write (cursor.ReadUInt16 ());  	//bit count  	int len = cursor.ReadInt32 ();  	int offset = cursor.ReadInt32 ();  	indexHeap.Write ((int)len);  	indexHeap.Write ((int)module.Win32Resources.Count + 2);  	MemoryCursor c = new MemoryCursor (cursor);  	c.Position = offset;  	resource.Data = c.ReadBytes (len);  	module.Win32Resources.Add (resource);  }  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: for (int i = 0; i < imageCount; i++) {  	resource = new Win32Resource ();  	resource.CodePage = 0;  	resource.Id = module.Win32Resources.Count + 2;  	resource.LanguageId = 0;  	resource.Name = null;  	resource.TypeId = 3;  	resource.TypeName = null;  	indexHeap.Write (cursor.ReadByte ());  	//width  	indexHeap.Write (cursor.ReadByte ());  	//height  	indexHeap.Write (cursor.ReadByte ());  	//color count  	indexHeap.Write (cursor.ReadByte ());  	//reserved  	indexHeap.Write (cursor.ReadUInt16 ());  	//planes  	indexHeap.Write (cursor.ReadUInt16 ());  	//bit count  	int len = cursor.ReadInt32 ();  	int offset = cursor.ReadInt32 ();  	indexHeap.Write ((int)len);  	indexHeap.Write ((int)module.Win32Resources.Count + 2);  	MemoryCursor c = new MemoryCursor (cursor);  	c.Position = offset;  	resource.Data = c.ReadBytes (len);  	module.Win32Resources.Add (resource);  }  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: resource.Id = module.Win32Resources.Count + 2;  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: resource.TypeId = 3;  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: indexHeap.Write ((int)module.Win32Resources.Count + 2);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,FillInVsVersionStructure,The following statement contains a magic number: if (options.GenerateExecutable)  	data.Write ((uint)1);  //App  else  	data.Write ((uint)2);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,FillInVsVersionStructure,The following statement contains a magic number: data.Write ((uint)2);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += key.Length * 2;  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += 4 - (totalLength % 4);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += 4 - (totalLength % 4);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += value.Length * 2;  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += 4 - (totalLength % 4);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += 4 - (totalLength % 4);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: if (data.BaseStream.Position % 4 != 0)  	data.Write ((char)0);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: if (data.BaseStream.Position % 4 != 0)  	data.Write ((char)0);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,DaysSince2000,The following statement contains a magic number: return (ushort)(DateTime.Now - new DateTime (2000' 1' 1)).Days;  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SecondsSinceMidnight,The following statement contains a magic number: return (ushort)((sinceMidnight.Hours * 60 * 60 + sinceMidnight.Minutes * 60 + sinceMidnight.Seconds) / 2);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SecondsSinceMidnight,The following statement contains a magic number: return (ushort)((sinceMidnight.Hours * 60 * 60 + sinceMidnight.Minutes * 60 + sinceMidnight.Seconds) / 2);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SecondsSinceMidnight,The following statement contains a magic number: return (ushort)((sinceMidnight.Hours * 60 * 60 + sinceMidnight.Minutes * 60 + sinceMidnight.Seconds) / 2);  
Magic Number,System.Compiler,Writer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,SecondsSinceMidnight,The following statement contains a magic number: return (ushort)((sinceMidnight.Hours * 60 * 60 + sinceMidnight.Minutes * 60 + sinceMidnight.Seconds) / 2);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert (size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert (size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert (size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert (size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert (size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert (size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadReference,The following statement contains a magic number: if (refSize == 2)  	return ReadUInt16 ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: result = ((headerByte & 0x3f) << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (ReadByte () << 16) | (ReadByte () << 8) | ReadByte ();  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	length = headerByte;  else if ((headerByte & 0x40) == 0x00)  	length = (uint)((headerByte & 0x3f) << 8) | *pb++;  else  	length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	length = headerByte;  else if ((headerByte & 0x40) == 0x00)  	length = (uint)((headerByte & 0x3f) << 8) | *pb++;  else  	length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	length = headerByte;  else if ((headerByte & 0x40) == 0x00)  	length = (uint)((headerByte & 0x3f) << 8) | *pb++;  else  	length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	length = headerByte;  else if ((headerByte & 0x40) == 0x00)  	length = (uint)((headerByte & 0x3f) << 8) | *pb++;  else  	length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	length = (uint)((headerByte & 0x3f) << 8) | *pb++;  else  	length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	length = (uint)((headerByte & 0x3f) << 8) | *pb++;  else  	length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	length = (uint)((headerByte & 0x3f) << 8) | *pb++;  else  	length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	length = (uint)((headerByte & 0x3f) << 8) | *pb++;  else  	length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: length = (uint)((headerByte & 0x3f) << 8) | *pb++;  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if (bytesToRead == 0) {  	//Dangling lead bytes' do not decompose  	buffer [j++] = (char)((b << 8) | b1);  	break;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: buffer [j++] = (char)((b << 8) | b1);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if (bytesToRead == 0) {  	//Dangling lead bytes' do not decompose  	buffer [j++] = (char)((b << 8) | b1);  	buffer [j++] = (char)b2;  	break;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: buffer [j++] = (char)((b << 8) | b1);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((ch32 & 0xFFFF0000) == 0)  	ch = (char)ch32;  else {  	//break up into UTF16 surrogate pair  	buffer [j++] = (char)((ch32 >> 10) | 0xD800);  	ch = (char)((ch32 & 0x3FF) | 0xDC00);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: buffer [j++] = (char)((ch32 >> 10) | 0xD800);  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for (; ;) {  	b = *pb++;  	if (b == 0)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pb++;  	if (b1 == 0) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	} else {  		byte b2 = *pb++;  		if (b2 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pb++;  			if (b3 == 0) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  } else {  	byte b2 = *pb++;  	if (b2 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pb++;  		if (b3 == 0) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if (b2 == 0) {  	//Dangling lead bytes' do not decompose  	sb.Append ((char)((b << 8) | b1));  	break;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: sb.Append ((char)((b << 8) | b1));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pb++;  	if (b3 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pb++;  	if (b3 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pb++;  	if (b3 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pb++;  	if (b3 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pb++;  	if (b3 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pb++;  	if (b3 == 0) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if (b3 == 0) {  	//Dangling lead bytes' do not decompose  	sb.Append ((char)((b << 8) | b1));  	sb.Append ((char)b2);  	break;  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: sb.Append ((char)((b << 8) | b1));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: if ((ch32 & 0xFFFF0000) == 0)  	ch = (char)ch32;  else {  	//break up into UTF16 surrogate pair  	sb.Append ((char)((ch32 >> 10) | 0xD800));  	ch = (char)((ch32 & 0x3FF) | 0xDC00);  }  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: sb.Append ((char)((ch32 >> 10) | 0xD800));  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadUTF16,The following statement contains a magic number: this.pb += (result.Length + 1) * 2;  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadASCII,The following statement contains a magic number: if (bytesToRead == -1)  	c = 128;  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadASCII,The following statement contains a magic number: c = 128;  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadASCII,The following statement contains a magic number: if (bytesToRead == -1) {  	if (b != 0) {  		char[] newBuffer = new char[c *= 2];  		for (int copy = 0; copy < j; copy++)  			newBuffer [copy] = buffer [copy];  		buffer = newBuffer;  		goto Restart;  	}  	this.pb = pb;  } else  	this.pb += bytesToRead;  
Magic Number,System.Compiler.Metadata,MemoryCursor,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\MemoryMappedFile.cs,ReadASCII,The following statement contains a magic number: if (b != 0) {  	char[] newBuffer = new char[c *= 2];  	for (int copy = 0; copy < j; copy++)  		newBuffer [copy] = buffer [copy];  	buffer = newBuffer;  	goto Restart;  }  
Magic Number,System.Compiler.Metadata,CLIHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,CLIHeader,The following statement contains a magic number: this.cb = 72;  
Magic Number,System.Compiler.Metadata,CLIHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,CLIHeader,The following statement contains a magic number: this.majorRuntimeVersion = 2;  
Magic Number,System.Compiler.Metadata,CLIHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,CLIHeader,The following statement contains a magic number: this.minorRuntimeVersion = 5;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfOptionalHeader = 224;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.majorLinkerVersion = 6;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sectionAlignment = 8192;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.fileAlignment = 512;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.majorOperatingSystemVersion = 4;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.majorSubsystemVersion = 4;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfStackReserve = 1048576;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfStackCommit = 4096;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfHeapReserve = 1048576;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfHeapCommit = 4096;  
Magic Number,System.Compiler.Metadata,NTHeader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.numberOfDataDirectories = 16;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,AlignTo32BitBoundary,The following statement contains a magic number: this.cursor.Align (4);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetGuid,The following statement contains a magic number: if (guidOffset < 16 || this.guidHeap.size < guidOffset)  	throw new System.ArgumentOutOfRangeException ("guidIndex"' ExceptionStrings.BadGuidHeapIndex);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetGuid,The following statement contains a magic number: c.Position = this.mdOffset + this.guidHeap.offset + guidOffset - 16;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetGuid,The following statement contains a magic number: return new System.Guid (c.ReadBytes (16));  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetUserString,The following statement contains a magic number: return c.ReadUTF16 (strLength / 2);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetBlobString,The following statement contains a magic number: return c.ReadUTF16 (blobLength / 2);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetValueFromBlob,The following statement contains a magic number: switch ((ElementType)type) {  case ElementType.Boolean:  	return c.ReadBoolean ();  case ElementType.Char:  	return (char)c.ReadUInt16 ();  case ElementType.Double:  	return c.ReadDouble ();  case ElementType.Single:  	return c.ReadSingle ();  case ElementType.Int16:  	return c.ReadInt16 ();  case ElementType.Int32:  	return c.ReadInt32 ();  case ElementType.Int64:  	return c.ReadInt64 ();  case ElementType.Int8:  	return c.ReadSByte ();  case ElementType.UInt16:  	return c.ReadUInt16 ();  case ElementType.UInt32:  	return c.ReadUInt32 ();  case ElementType.UInt64:  	return c.ReadUInt64 ();  case ElementType.UInt8:  	return c.ReadByte ();  case ElementType.Class:  	return null;  case ElementType.String:  	return c.ReadUTF16 (blobLength / 2);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetValueFromBlob,The following statement contains a magic number: return c.ReadUTF16 (blobLength / 2);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch (ntHeader.machine) {  case 0x0200:  	this.peKind |= PEKindFlags.Requires64bits;  	break;  case 0x8664:  	this.peKind |= PEKindFlags.Requires64bits | PEKindFlags.AMD;  	break;  default:  	if (ntHeader.magic == 0x20B)  		//Optional header magic for PE32+  		this.peKind |= PEKindFlags.Requires64bits;  	else if ((cliHeader.flags & 2) != 0)  		this.peKind |= PEKindFlags.Requires32bits;  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (ntHeader.magic == 0x20B)  	//Optional header magic for PE32+  	this.peKind |= PEKindFlags.Requires64bits;  else if ((cliHeader.flags & 2) != 0)  	this.peKind |= PEKindFlags.Requires32bits;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if ((cliHeader.flags & 2) != 0)  	this.peKind |= PEKindFlags.Requires32bits;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++) {  	if (valid % 2 == 1) {  		int m = tableSize [i] = countArray [j++];  		tableRefSize [i] = m < 0x10000 ? 2 : 4;  	} else  		tableRefSize [i] = 2;  	valid /= 2;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++) {  	if (valid % 2 == 1) {  		int m = tableSize [i] = countArray [j++];  		tableRefSize [i] = m < 0x10000 ? 2 : 4;  	} else  		tableRefSize [i] = 2;  	valid /= 2;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++) {  	if (valid % 2 == 1) {  		int m = tableSize [i] = countArray [j++];  		tableRefSize [i] = m < 0x10000 ? 2 : 4;  	} else  		tableRefSize [i] = 2;  	valid /= 2;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++) {  	if (valid % 2 == 1) {  		int m = tableSize [i] = countArray [j++];  		tableRefSize [i] = m < 0x10000 ? 2 : 4;  	} else  		tableRefSize [i] = 2;  	valid /= 2;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++) {  	if (valid % 2 == 1) {  		int m = tableSize [i] = countArray [j++];  		tableRefSize [i] = m < 0x10000 ? 2 : 4;  	} else  		tableRefSize [i] = 2;  	valid /= 2;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (valid % 2 == 1) {  	int m = tableSize [i] = countArray [j++];  	tableRefSize [i] = m < 0x10000 ? 2 : 4;  } else  	tableRefSize [i] = 2;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (valid % 2 == 1) {  	int m = tableSize [i] = countArray [j++];  	tableRefSize [i] = m < 0x10000 ? 2 : 4;  } else  	tableRefSize [i] = 2;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (valid % 2 == 1) {  	int m = tableSize [i] = countArray [j++];  	tableRefSize [i] = m < 0x10000 ? 2 : 4;  } else  	tableRefSize [i] = 2;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (valid % 2 == 1) {  	int m = tableSize [i] = countArray [j++];  	tableRefSize [i] = m < 0x10000 ? 2 : 4;  } else  	tableRefSize [i] = 2;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: tableRefSize [i] = m < 0x10000 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: tableRefSize [i] = m < 0x10000 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: tableRefSize [i] = 2;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: valid /= 2;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion > 1 || this.metadataFormatMinorVersion > 0) {  	customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 && tableSize [(int)TableIndices.GenericParam] < 0x0800 && tableSize [(int)TableIndices.MethodSpec] < 0x0800 && tableSize [(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;  } else {  	customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion > 1 || this.metadataFormatMinorVersion > 0) {  	customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 && tableSize [(int)TableIndices.GenericParam] < 0x0800 && tableSize [(int)TableIndices.MethodSpec] < 0x0800 && tableSize [(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;  } else {  	customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion > 1 || this.metadataFormatMinorVersion > 0) {  	customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 && tableSize [(int)TableIndices.GenericParam] < 0x0800 && tableSize [(int)TableIndices.MethodSpec] < 0x0800 && tableSize [(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;  } else {  	customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion > 1 || this.metadataFormatMinorVersion > 0) {  	customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 && tableSize [(int)TableIndices.GenericParam] < 0x0800 && tableSize [(int)TableIndices.MethodSpec] < 0x0800 && tableSize [(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;  } else {  	customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 && tableSize [(int)TableIndices.GenericParam] < 0x0800 && tableSize [(int)TableIndices.MethodSpec] < 0x0800 && tableSize [(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 && tableSize [(int)TableIndices.GenericParam] < 0x0800 && tableSize [(int)TableIndices.MethodSpec] < 0x0800 && tableSize [(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: customAttributeParentRefSize = this.customAttributeParentRefSize = tableSize [(int)TableIndices.Method] < 0x0800 && tableSize [(int)TableIndices.Field] < 0x0800 && tableSize [(int)TableIndices.TypeRef] < 0x0800 && tableSize [(int)TableIndices.TypeDef] < 0x0800 && tableSize [(int)TableIndices.Param] < 0x0800 && tableSize [(int)TableIndices.InterfaceImpl] < 0x0800 && tableSize [(int)TableIndices.MemberRef] < 0x0800 && tableSize [(int)TableIndices.Module] < 0x0800 && tableSize [(int)TableIndices.DeclSecurity] < 0x0800 && tableSize [(int)TableIndices.Property] < 0x0800 && tableSize [(int)TableIndices.Event] < 0x0800 && tableSize [(int)TableIndices.StandAloneSig] < 0x0800 && tableSize [(int)TableIndices.ModuleRef] < 0x0800 && tableSize [(int)TableIndices.TypeSpec] < 0x0800 && tableSize [(int)TableIndices.Assembly] < 0x0800 && tableSize [(int)TableIndices.File] < 0x0800 && tableSize [(int)TableIndices.ExportedType] < 0x0800 && tableSize [(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	tableOffset [i] = offset;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		offset += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.FieldPtr:  		offset += m * (tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.Field:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodPtr:  		offset += m * (tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Method:  		offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.ParamPtr:  		offset += m * (tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		offset += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		offset += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		offset += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		offset += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		offset += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.EventPtr:  		offset += m * (tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.PropertyPtr:  		offset += m * (tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		offset += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		offset += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		offset += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		offset += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyProcessor:  		offset += m * (4);  		break;  	case TableIndices.AssemblyOS:  		offset += m * (12);  		break;  	case TableIndices.AssemblyRef:  		offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRefProcessor:  		offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.AssemblyRefOS:  		offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  		break;  	case TableIndices.File:  		offset += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		offset += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		offset += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  			offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		offset += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  	}  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	offset += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.FieldPtr:  	offset += m * (tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.Field:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodPtr:  	offset += m * (tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Method:  	offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.ParamPtr:  	offset += m * (tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	offset += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	offset += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	offset += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	offset += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	offset += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	offset += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.EventPtr:  	offset += m * (tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.PropertyPtr:  	offset += m * (tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	offset += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	offset += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	offset += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	offset += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyProcessor:  	offset += m * (4);  	break;  case TableIndices.AssemblyOS:  	offset += m * (12);  	break;  case TableIndices.AssemblyRef:  	offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRefProcessor:  	offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.AssemblyRefOS:  	offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  	break;  case TableIndices.File:  	offset += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	offset += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	offset += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  		offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	offset += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	offset += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnsupportedTableEncountered);  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + stringRefSize + 3 * guidRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + stringRefSize + 3 * guidRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (resolutionScopeRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + stringRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + constantParentRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + declSecurityParentRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + stringRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + tableRefSize [(int)TableIndices.Field]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (16 + blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (16 + blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (12);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + tableRefSize [(int)TableIndices.AssemblyRef]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (12 + tableRefSize [(int)TableIndices.AssemblyRef]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + stringRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (8 + 2 * stringRefSize + implementationRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (8 + 2 * stringRefSize + implementationRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (8 + stringRefSize + implementationRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  	offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  	offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)  	offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadCLIHeader,The following statement contains a magic number: c.SkipUInt16 (2);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadCLIHeader,The following statement contains a magic number: c.SkipInt32 (2);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadCLIHeader,The following statement contains a magic number: if (header.majorRuntimeVersion < 2)  	throw new InvalidMetadataException (ExceptionStrings.BadCLIHeader);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadDirectoryEntry,The following statement contains a magic number: c.SkipInt32 (2);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadMetadataHeader,The following statement contains a magic number: while (len++ % 4 != 0)  	c.ReadByte ();  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.name = c.ReadASCII (8);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.sizeOfRawData = c.Int32 (2);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.pointerToRawData = c.Int32 (3);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.pointerToRelocations = c.Int32 (4);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.pointerToLinenumbers = c.Int32 (5);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: c.SkipInt32 (6);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: c.SkipInt16 (2);  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadStreamHeader,The following statement contains a magic number: c.Position += (4 - (n % 4)) % 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadStreamHeader,The following statement contains a magic number: c.Position += (4 - (n % 4)) % 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadStreamHeader,The following statement contains a magic number: c.Position += (4 - (n % 4)) % 4;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadTablesHeader,The following statement contains a magic number: while (mask != 0) {  	if (mask % 2 == 1)  		n++;  	mask /= 2;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadTablesHeader,The following statement contains a magic number: while (mask != 0) {  	if (mask % 2 == 1)  		n++;  	mask /= 2;  }  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadTablesHeader,The following statement contains a magic number: if (mask % 2 == 1)  	n++;  
Magic Number,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,ReadTablesHeader,The following statement contains a magic number: mask /= 2;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (tableOffset % 4 != 0) {  	writer.Write ((byte)0);  	tableOffset++;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.PublicKey != null && 0 < this.PublicKey.Length) {  	this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase + 72 + tableOffset;  	int keysize = this.PublicKey.Length - 32;  	if (keysize < 128)  		keysize = 128;  	this.cliHeader.strongNameSignature.size = keysize;  	tableOffset += keysize;  	writer.BaseStream.Position += keysize;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.PublicKey != null && 0 < this.PublicKey.Length) {  	this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase + 72 + tableOffset;  	int keysize = this.PublicKey.Length - 32;  	if (keysize < 128)  		keysize = 128;  	this.cliHeader.strongNameSignature.size = keysize;  	tableOffset += keysize;  	writer.BaseStream.Position += keysize;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.PublicKey != null && 0 < this.PublicKey.Length) {  	this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase + 72 + tableOffset;  	int keysize = this.PublicKey.Length - 32;  	if (keysize < 128)  		keysize = 128;  	this.cliHeader.strongNameSignature.size = keysize;  	tableOffset += keysize;  	writer.BaseStream.Position += keysize;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.PublicKey != null && 0 < this.PublicKey.Length) {  	this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase + 72 + tableOffset;  	int keysize = this.PublicKey.Length - 32;  	if (keysize < 128)  		keysize = 128;  	this.cliHeader.strongNameSignature.size = keysize;  	tableOffset += keysize;  	writer.BaseStream.Position += keysize;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase + 72 + tableOffset;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (keysize < 128)  	keysize = 128;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (keysize < 128)  	keysize = 128;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: keysize = 128;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.ResourceDataHeap.Length > 0) {  	this.cliHeader.resources.virtualAddress = virtualAddressBase + 72 + tableOffset;  	this.ResourceDataHeap.WriteTo (writer.BaseStream);  	int sizeOfResources = (int)this.ResourceDataHeap.Length;  	while (sizeOfResources % 4 != 0) {  		writer.Write ((byte)0);  		sizeOfResources++;  	}  	this.cliHeader.resources.size = sizeOfResources;  	tableOffset += sizeOfResources;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.ResourceDataHeap.Length > 0) {  	this.cliHeader.resources.virtualAddress = virtualAddressBase + 72 + tableOffset;  	this.ResourceDataHeap.WriteTo (writer.BaseStream);  	int sizeOfResources = (int)this.ResourceDataHeap.Length;  	while (sizeOfResources % 4 != 0) {  		writer.Write ((byte)0);  		sizeOfResources++;  	}  	this.cliHeader.resources.size = sizeOfResources;  	tableOffset += sizeOfResources;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: this.cliHeader.resources.virtualAddress = virtualAddressBase + 72 + tableOffset;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (sizeOfResources % 4 != 0) {  	writer.Write ((byte)0);  	sizeOfResources++;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: this.cliHeader.metaData.virtualAddress = virtualAddressBase + 72 + tableOffset;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: writer.Write ((int)12);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: Array.Copy (aversion' 0' version' 0' Math.Min (12' aversion.Length));  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: writer.Write ((short)5);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (offsetFromStartOfMetadata % 4 != 0) {  	offsetFromStartOfMetadata++;  	cbStringHeapPad++;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (offsetFromStartOfMetadata % 4 != 0) {  	offsetFromStartOfMetadata++;  	cbUserStringHeapPad++;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (offsetFromStartOfMetadata % 4 != 0)  	offsetFromStartOfMetadata++;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: writer.Write ((int)this.GuidHeap.Length * 16);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: offsetFromStartOfMetadata += this.GuidHeap.Length * 16;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (p % 4 != 0) {  	writer.Write ((byte)0);  	p++;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (p % 4 != 0) {  	writer.Write ((byte)0);  	p++;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (p % 4 != 0) {  	writer.Write ((byte)0);  	p++;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: this.SerializeTables (writer' virtualAddressBase + 72' sdataFixup' tlsFixup);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteReferenceToPDBFile,The following statement contains a magic number: this.ntHeader.debugTable.size = 28;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteReferenceToPDBFile,The following statement contains a magic number: writer.Write ((int)startPos + 28 - fileBase + virtualAddressBase);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteReferenceToPDBFile,The following statement contains a magic number: writer.Write ((int)startPos + 28);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++)  	tableRefSize [i] = tableSize [i] < 0x10000 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++)  	tableRefSize [i] = tableSize [i] < 0x10000 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: tableRefSize [i] = tableSize [i] < 0x10000 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: tableRefSize [i] = tableSize [i] < 0x10000 ? 2 : 4;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++) {  	int m = tableSize [i];  	if (m == 0)  		continue;  	switch ((TableIndices)i) {  	case TableIndices.Module:  		length += m * (2 + stringRefSize + 3 * guidRefSize);  		break;  	case TableIndices.TypeRef:  		length += m * (resolutionScopeRefSize + 2 * stringRefSize);  		break;  	case TableIndices.TypeDef:  		length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  		break;  	case TableIndices.Field:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.Method:  		length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  		break;  	case TableIndices.Param:  		length += m * (4 + stringRefSize);  		break;  	case TableIndices.InterfaceImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.MemberRef:  		length += m * (memberRefParentSize + stringRefSize + blobRefSize);  		break;  	case TableIndices.Constant:  		length += m * (2 + constantParentRefSize + blobRefSize);  		break;  	case TableIndices.CustomAttribute:  		length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  		break;  	case TableIndices.FieldMarshal:  		length += m * (fieldMarshalParentRefSize + blobRefSize);  		break;  	case TableIndices.DeclSecurity:  		length += m * (2 + declSecurityParentRefSize + blobRefSize);  		break;  	case TableIndices.ClassLayout:  		length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.FieldLayout:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.StandAloneSig:  		length += m * (blobRefSize);  		break;  	case TableIndices.EventMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  		break;  	case TableIndices.Event:  		length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  		break;  	case TableIndices.PropertyMap:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  		break;  	case TableIndices.Property:  		length += m * (2 + stringRefSize + blobRefSize);  		break;  	case TableIndices.MethodSemantics:  		length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  		break;  	case TableIndices.MethodImpl:  		length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  		break;  	case TableIndices.ModuleRef:  		length += m * (stringRefSize);  		break;  	case TableIndices.TypeSpec:  		length += m * (blobRefSize);  		break;  	case TableIndices.ImplMap:  		length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  		break;  	case TableIndices.FieldRva:  		length += m * (4 + tableRefSize [(int)TableIndices.Field]);  		break;  	case TableIndices.EncLog:  		throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  	case TableIndices.EncMap:  		throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  	case TableIndices.Assembly:  		length += m * (16 + blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.AssemblyRef:  		length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  		break;  	case TableIndices.File:  		length += m * (4 + stringRefSize + blobRefSize);  		break;  	case TableIndices.ExportedType:  		length += m * (8 + 2 * stringRefSize + implementationRefSize);  		break;  	case TableIndices.ManifestResource:  		length += m * (8 + stringRefSize + implementationRefSize);  		break;  	case TableIndices.NestedClass:  		length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  		break;  	case TableIndices.GenericParam:  		if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  			length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  		else  			length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  		break;  	case TableIndices.MethodSpec:  		length += m * (methodDefOrRefSize + blobRefSize);  		break;  	case TableIndices.GenericParamConstraint:  		length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + stringRefSize + 3 * guidRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + stringRefSize + 3 * guidRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (resolutionScopeRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + stringRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (4 + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + constantParentRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + declSecurityParentRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (4 + tableRefSize [(int)TableIndices.Field]);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + stringRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (4 + tableRefSize [(int)TableIndices.Field]);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (16 + blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (16 + blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (4 + stringRefSize + blobRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (8 + 2 * stringRefSize + implementationRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (8 + 2 * stringRefSize + implementationRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (8 + stringRefSize + implementationRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  	length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  	length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  	length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  else  	length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += 24 + (tableCount * 4);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += 24 + (tableCount * 4);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: switch (this.moduleKind) {  case ModuleKindFlags.ConsoleApplication:  	this.ntHeader.subsystem = 3;  	break;  case ModuleKindFlags.DynamicallyLinkedLibrary:  	this.ntHeader.characteristics |= 0x2000;  	this.ntHeader.subsystem = 3;  	break;  case ModuleKindFlags.WindowsApplication:  	this.ntHeader.subsystem = 2;  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: switch (this.moduleKind) {  case ModuleKindFlags.ConsoleApplication:  	this.ntHeader.subsystem = 3;  	break;  case ModuleKindFlags.DynamicallyLinkedLibrary:  	this.ntHeader.characteristics |= 0x2000;  	this.ntHeader.subsystem = 3;  	break;  case ModuleKindFlags.WindowsApplication:  	this.ntHeader.subsystem = 2;  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: switch (this.moduleKind) {  case ModuleKindFlags.ConsoleApplication:  	this.ntHeader.subsystem = 3;  	break;  case ModuleKindFlags.DynamicallyLinkedLibrary:  	this.ntHeader.characteristics |= 0x2000;  	this.ntHeader.subsystem = 3;  	break;  case ModuleKindFlags.WindowsApplication:  	this.ntHeader.subsystem = 2;  	break;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: this.ntHeader.subsystem = 3;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: this.ntHeader.subsystem = 3;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: this.ntHeader.subsystem = 2;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: textSection.virtualAddress = 8192;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.BaseStream.Position = textSection.pointerToRawData + 72;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: this.ntHeader.cliHeaderTable.size = 72;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: relocSection.virtualSize = 12;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.Write ((int)((RVAofEntryPointJumpTarget / 4096) * 4096));  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.Write ((int)((RVAofEntryPointJumpTarget / 4096) * 4096));  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.Write ((int)12);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.BaseStream.Position += m - 13;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: for (int i = 0' n = rsrcs.Count; i < n; i++) {  	Win32Resource r = rsrcs [i];  	bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;  	if (typeDifferent) {  		lastTypeID = r.TypeId;  		lastTypeName = r.TypeName;  		if (lastTypeID < 0)  			TypeDirectory.NumberOfNamedEntries++;  		else  			TypeDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		TypeDirectory.Entries.Add (NameDirectory = new Directory (lastTypeName' lastTypeID));  	}  	//^ assume NameDirectory != null;  	if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {  		lastID = r.Id;  		lastName = r.Name;  		if (lastID < 0)  			NameDirectory.NumberOfNamedEntries++;  		else  			NameDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		NameDirectory.Entries.Add (LanguageDirectory = new Directory (lastName' lastID));  	}  	//^ assume LanguageDirectory != null;  	LanguageDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 8;  	LanguageDirectory.Entries.Add (r);  	continue;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: for (int i = 0' n = rsrcs.Count; i < n; i++) {  	Win32Resource r = rsrcs [i];  	bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;  	if (typeDifferent) {  		lastTypeID = r.TypeId;  		lastTypeName = r.TypeName;  		if (lastTypeID < 0)  			TypeDirectory.NumberOfNamedEntries++;  		else  			TypeDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		TypeDirectory.Entries.Add (NameDirectory = new Directory (lastTypeName' lastTypeID));  	}  	//^ assume NameDirectory != null;  	if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {  		lastID = r.Id;  		lastName = r.Name;  		if (lastID < 0)  			NameDirectory.NumberOfNamedEntries++;  		else  			NameDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		NameDirectory.Entries.Add (LanguageDirectory = new Directory (lastName' lastID));  	}  	//^ assume LanguageDirectory != null;  	LanguageDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 8;  	LanguageDirectory.Entries.Add (r);  	continue;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: for (int i = 0' n = rsrcs.Count; i < n; i++) {  	Win32Resource r = rsrcs [i];  	bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;  	if (typeDifferent) {  		lastTypeID = r.TypeId;  		lastTypeName = r.TypeName;  		if (lastTypeID < 0)  			TypeDirectory.NumberOfNamedEntries++;  		else  			TypeDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		TypeDirectory.Entries.Add (NameDirectory = new Directory (lastTypeName' lastTypeID));  	}  	//^ assume NameDirectory != null;  	if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {  		lastID = r.Id;  		lastName = r.Name;  		if (lastID < 0)  			NameDirectory.NumberOfNamedEntries++;  		else  			NameDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		NameDirectory.Entries.Add (LanguageDirectory = new Directory (lastName' lastID));  	}  	//^ assume LanguageDirectory != null;  	LanguageDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 8;  	LanguageDirectory.Entries.Add (r);  	continue;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: if (typeDifferent) {  	lastTypeID = r.TypeId;  	lastTypeName = r.TypeName;  	if (lastTypeID < 0)  		TypeDirectory.NumberOfNamedEntries++;  	else  		TypeDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 24;  	TypeDirectory.Entries.Add (NameDirectory = new Directory (lastTypeName' lastTypeID));  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: sizeOfDirectoryTree += 24;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {  	lastID = r.Id;  	lastName = r.Name;  	if (lastID < 0)  		NameDirectory.NumberOfNamedEntries++;  	else  		NameDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 24;  	NameDirectory.Entries.Add (LanguageDirectory = new Directory (lastName' lastID));  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: sizeOfDirectoryTree += 24;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: sizeOfDirectoryTree += 8;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int id = int.MinValue;  	string name = null;  	int nOff = dataHeap.BaseStream.Position + sizeOfDirectoryTree;  	int dOff = k;  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		id = subDir.ID;  		name = subDir.Name;  		if (level == 0)  			k += this.SizeOfDirectory (subDir);  		else  			k += 16 + 8 * subDir.Entries.Count;  	} else {  		Win32Resource r = (Win32Resource)directory.Entries [i];  		id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;  		name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  		dataHeap.Write ((int)(virtualAddressBase + sizeOfDirectoryTree + 16 + dataHeap.BaseStream.Position));  		dataHeap.Write ((int)r.Data.Length);  		dataHeap.Write ((int)r.CodePage);  		dataHeap.Write ((int)0);  		dataHeap.Write (r.Data);  	}  	if (id >= 0)  		writer.Write (id);  	else {  		if (name == null)  			name = "";  		writer.Write (((uint)nOff) | 0x80000000);  		dataHeap.Write ((ushort)name.Length);  		dataHeap.Write (name.ToCharArray ());  		//REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?  	}  	if (subDir != null)  		writer.Write (((uint)dOff) | 0x80000000);  	else  		writer.Write (nOff);  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int id = int.MinValue;  	string name = null;  	int nOff = dataHeap.BaseStream.Position + sizeOfDirectoryTree;  	int dOff = k;  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		id = subDir.ID;  		name = subDir.Name;  		if (level == 0)  			k += this.SizeOfDirectory (subDir);  		else  			k += 16 + 8 * subDir.Entries.Count;  	} else {  		Win32Resource r = (Win32Resource)directory.Entries [i];  		id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;  		name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  		dataHeap.Write ((int)(virtualAddressBase + sizeOfDirectoryTree + 16 + dataHeap.BaseStream.Position));  		dataHeap.Write ((int)r.Data.Length);  		dataHeap.Write ((int)r.CodePage);  		dataHeap.Write ((int)0);  		dataHeap.Write (r.Data);  	}  	if (id >= 0)  		writer.Write (id);  	else {  		if (name == null)  			name = "";  		writer.Write (((uint)nOff) | 0x80000000);  		dataHeap.Write ((ushort)name.Length);  		dataHeap.Write (name.ToCharArray ());  		//REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?  	}  	if (subDir != null)  		writer.Write (((uint)dOff) | 0x80000000);  	else  		writer.Write (nOff);  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int id = int.MinValue;  	string name = null;  	int nOff = dataHeap.BaseStream.Position + sizeOfDirectoryTree;  	int dOff = k;  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		id = subDir.ID;  		name = subDir.Name;  		if (level == 0)  			k += this.SizeOfDirectory (subDir);  		else  			k += 16 + 8 * subDir.Entries.Count;  	} else {  		Win32Resource r = (Win32Resource)directory.Entries [i];  		id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;  		name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  		dataHeap.Write ((int)(virtualAddressBase + sizeOfDirectoryTree + 16 + dataHeap.BaseStream.Position));  		dataHeap.Write ((int)r.Data.Length);  		dataHeap.Write ((int)r.CodePage);  		dataHeap.Write ((int)0);  		dataHeap.Write (r.Data);  	}  	if (id >= 0)  		writer.Write (id);  	else {  		if (name == null)  			name = "";  		writer.Write (((uint)nOff) | 0x80000000);  		dataHeap.Write ((ushort)name.Length);  		dataHeap.Write (name.ToCharArray ());  		//REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?  	}  	if (subDir != null)  		writer.Write (((uint)dOff) | 0x80000000);  	else  		writer.Write (nOff);  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	id = subDir.ID;  	name = subDir.Name;  	if (level == 0)  		k += this.SizeOfDirectory (subDir);  	else  		k += 16 + 8 * subDir.Entries.Count;  } else {  	Win32Resource r = (Win32Resource)directory.Entries [i];  	id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;  	name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  	dataHeap.Write ((int)(virtualAddressBase + sizeOfDirectoryTree + 16 + dataHeap.BaseStream.Position));  	dataHeap.Write ((int)r.Data.Length);  	dataHeap.Write ((int)r.CodePage);  	dataHeap.Write ((int)0);  	dataHeap.Write (r.Data);  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	id = subDir.ID;  	name = subDir.Name;  	if (level == 0)  		k += this.SizeOfDirectory (subDir);  	else  		k += 16 + 8 * subDir.Entries.Count;  } else {  	Win32Resource r = (Win32Resource)directory.Entries [i];  	id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;  	name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  	dataHeap.Write ((int)(virtualAddressBase + sizeOfDirectoryTree + 16 + dataHeap.BaseStream.Position));  	dataHeap.Write ((int)r.Data.Length);  	dataHeap.Write ((int)r.CodePage);  	dataHeap.Write ((int)0);  	dataHeap.Write (r.Data);  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	id = subDir.ID;  	name = subDir.Name;  	if (level == 0)  		k += this.SizeOfDirectory (subDir);  	else  		k += 16 + 8 * subDir.Entries.Count;  } else {  	Win32Resource r = (Win32Resource)directory.Entries [i];  	id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;  	name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  	dataHeap.Write ((int)(virtualAddressBase + sizeOfDirectoryTree + 16 + dataHeap.BaseStream.Position));  	dataHeap.Write ((int)r.Data.Length);  	dataHeap.Write ((int)r.CodePage);  	dataHeap.Write ((int)0);  	dataHeap.Write (r.Data);  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (level == 0)  	k += this.SizeOfDirectory (subDir);  else  	k += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (level == 0)  	k += this.SizeOfDirectory (subDir);  else  	k += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: k += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: k += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: dataHeap.Write ((int)(virtualAddressBase + sizeOfDirectoryTree + 16 + dataHeap.BaseStream.Position));  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: k = offset + 16 + n * 8;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: k = offset + 16 + n * 8;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		this.WriteDirectory (subDir' writer' k' level + 1' sizeOfDirectoryTree' virtualAddressBase' dataHeap);  		if (level == 0)  			k += this.SizeOfDirectory (subDir);  		else  			k += 16 + 8 * subDir.Entries.Count;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		this.WriteDirectory (subDir' writer' k' level + 1' sizeOfDirectoryTree' virtualAddressBase' dataHeap);  		if (level == 0)  			k += this.SizeOfDirectory (subDir);  		else  			k += 16 + 8 * subDir.Entries.Count;  	}  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	this.WriteDirectory (subDir' writer' k' level + 1' sizeOfDirectoryTree' virtualAddressBase' dataHeap);  	if (level == 0)  		k += this.SizeOfDirectory (subDir);  	else  		k += 16 + 8 * subDir.Entries.Count;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	this.WriteDirectory (subDir' writer' k' level + 1' sizeOfDirectoryTree' virtualAddressBase' dataHeap);  	if (level == 0)  		k += this.SizeOfDirectory (subDir);  	else  		k += 16 + 8 * subDir.Entries.Count;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (level == 0)  	k += this.SizeOfDirectory (subDir);  else  	k += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: if (level == 0)  	k += this.SizeOfDirectory (subDir);  else  	k += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: k += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: k += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null)  		size += 16 + 8 * subDir.Entries.Count;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null)  		size += 16 + 8 * subDir.Entries.Count;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: if (subDir != null)  	size += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: if (subDir != null)  	size += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: size += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: size += 16 + 8 * subDir.Entries.Count;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteNTHeader,The following statement contains a magic number: if ((this.peKind & PEKindFlags.Requires64bits) == 0) {  	ntHeader.magic = 0x10B;  	//PE32  	ntHeader.machine = 0x014c;  	//I386  } else {  	ntHeader.characteristics &= 0xFEFF;  	//Not 32-bit  	ntHeader.characteristics |= 0x0020;  	//Can handle >2gb addresses  	ntHeader.magic = 0x20B;  	//PE32+  	if ((this.peKind & PEKindFlags.AMD) != 0)  		ntHeader.machine = 0x8664;  	//AMD64  	else  		ntHeader.machine = 0x0200;  	//IA64  	ntHeader.sizeOfOptionalHeader += 16;  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteNTHeader,The following statement contains a magic number: ntHeader.sizeOfOptionalHeader += 16;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteSectionHeaders,The following statement contains a magic number: for (int i = 0' n = this.sectionHeaders.Length; i < n; i++) {  	SectionHeader hdr = sectionHeaders [i];  	//^ assume hdr.name != null;  	for (int j = 0' m = hdr.name.Length; j < 8; j++)  		if (j < m)  			writer.Write (hdr.name [j]);  		else  			writer.Write ((byte)0);  	writer.Write (hdr.virtualSize);  	writer.Write (hdr.virtualAddress);  	writer.Write (hdr.sizeOfRawData);  	writer.Write (hdr.pointerToRawData);  	writer.Write (hdr.pointerToRelocations);  	writer.Write (hdr.pointerToLinenumbers);  	writer.Write (hdr.numberOfRelocations);  	writer.Write (hdr.numberOfLinenumbers);  	writer.Write (hdr.characteristics);  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteSectionHeaders,The following statement contains a magic number: for (int j = 0' m = hdr.name.Length; j < 8; j++)  	if (j < m)  		writer.Write (hdr.name [j]);  	else  		writer.Write ((byte)0);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteCLIHeader,The following statement contains a magic number: writer.Write ((ushort)2);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteCLIHeader,The following statement contains a magic number: if (this.UseGenerics)  	writer.Write ((ushort)5);  //Violates the ECMA standard (25.3.3 of Partition II)' but apparently necessary  else  	writer.Write ((ushort)0);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteCLIHeader,The following statement contains a magic number: writer.Write ((ushort)5);  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteCLIHeader,The following statement contains a magic number: if ((this.peKind & PEKindFlags.Requires32bits) != 0)  	hdr.flags |= 2;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteCLIHeader,The following statement contains a magic number: hdr.flags |= 2;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: while (pos % 4 != 0) {  	pos++;  	writer.Write ((byte)0);  }  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: this.ntHeader.addressOfEntryPoint = ITArva - rvasize - 2;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: this.ntHeader.importTable.size = this.ntHeader.addressOfEntryPoint - ITrva - 2;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: this.ntHeader.importAddressTable.size = 8;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: writer.BaseStream.Position += 20;  
Magic Number,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WriteReference,The following statement contains a magic number: if (refSize == 2)  	writer.Write ((short)index);  else  	writer.Write (index);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetUnderlyingTypeOfEnumNode,The following statement contains a magic number: for (int i = start; i < end; i++) {  	int ii = i;  	if (fieldPtrs.Length > 0)  		ii = fieldPtrs [i - 1].Field;  	FieldRow fld = fieldDefs [ii - 1];  	if (fld.Field != null && !fld.Field.IsStatic) {  		underlyingType = fld.Field.Type;  		break;  	}  	FieldFlags fieldFlags = (FieldFlags)fld.Flags;  	if ((fieldFlags & FieldFlags.Static) == 0) {  		this.tables.GetSignatureLength (fld.Signature);  		MemoryCursor sigReader = this.tables.GetNewCursor ();  		GetAndCheckSignatureToken (6' sigReader);  		underlyingType = this.ParseTypeSignature (sigReader);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetUnderlyingTypeOfEnumNode,The following statement contains a magic number: if ((fieldFlags & FieldFlags.Static) == 0) {  	this.tables.GetSignatureLength (fld.Signature);  	MemoryCursor sigReader = this.tables.GetNewCursor ();  	GetAndCheckSignatureToken (6' sigReader);  	underlyingType = this.ParseTypeSignature (sigReader);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetUnderlyingTypeOfEnumNode,The following statement contains a magic number: GetAndCheckSignatureToken (6' sigReader);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++) {  	ParamRow pr = pars [i - 1];  	if (pr.Sequence == 0 && method != null) {  		//The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value  		method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  		if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)  			method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  		this.AddMoreStuffToParameters (null' parameters' start + 1' end);  		return;  	}  	int j = pr.Sequence;  	if (j < 1 || j > n)  		continue;  	//Bad metadata' ignore  	if (parameters == null)  		continue;  	Parameter par = parameters [j - 1];  	par.Attributes = this.GetCustomAttributesFor ((i << 5) | 4);  	par.Flags = (ParameterFlags)pr.Flags;  	if ((par.Flags & ParameterFlags.HasDefault) != 0)  		par.DefaultValue = this.GetLiteral ((i << 2) | 1' par.Type);  	if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)  		par.MarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  	par.Name = tables.GetIdentifier (pr.Name);  	#if ExtendedRuntime  	        for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {           if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {             Reference r = par.Type as Reference;             if (r != null){               // need to make it a reference to a non-null type and not a non-null wrapper around the reference               // also *must* make it a new Reference.               OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);               par.Type = om.GetReferenceType();             }else{               par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);             }             // Someone putting an attribute directly on the "real" method is still a             // kind of out-of-band contract.             // This marking is the way to signal that any override or implementing method being compiled             // should not have its non-null annotations persisted as optional modifiers.             par.DeclaringMethod.HasOutOfBandContract = true;             break;           }         } #endif  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++) {  	ParamRow pr = pars [i - 1];  	if (pr.Sequence == 0 && method != null) {  		//The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value  		method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  		if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)  			method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  		this.AddMoreStuffToParameters (null' parameters' start + 1' end);  		return;  	}  	int j = pr.Sequence;  	if (j < 1 || j > n)  		continue;  	//Bad metadata' ignore  	if (parameters == null)  		continue;  	Parameter par = parameters [j - 1];  	par.Attributes = this.GetCustomAttributesFor ((i << 5) | 4);  	par.Flags = (ParameterFlags)pr.Flags;  	if ((par.Flags & ParameterFlags.HasDefault) != 0)  		par.DefaultValue = this.GetLiteral ((i << 2) | 1' par.Type);  	if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)  		par.MarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  	par.Name = tables.GetIdentifier (pr.Name);  	#if ExtendedRuntime  	        for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {           if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {             Reference r = par.Type as Reference;             if (r != null){               // need to make it a reference to a non-null type and not a non-null wrapper around the reference               // also *must* make it a new Reference.               OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);               par.Type = om.GetReferenceType();             }else{               par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);             }             // Someone putting an attribute directly on the "real" method is still a             // kind of out-of-band contract.             // This marking is the way to signal that any override or implementing method being compiled             // should not have its non-null annotations persisted as optional modifiers.             par.DeclaringMethod.HasOutOfBandContract = true;             break;           }         } #endif  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++) {  	ParamRow pr = pars [i - 1];  	if (pr.Sequence == 0 && method != null) {  		//The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value  		method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  		if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)  			method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  		this.AddMoreStuffToParameters (null' parameters' start + 1' end);  		return;  	}  	int j = pr.Sequence;  	if (j < 1 || j > n)  		continue;  	//Bad metadata' ignore  	if (parameters == null)  		continue;  	Parameter par = parameters [j - 1];  	par.Attributes = this.GetCustomAttributesFor ((i << 5) | 4);  	par.Flags = (ParameterFlags)pr.Flags;  	if ((par.Flags & ParameterFlags.HasDefault) != 0)  		par.DefaultValue = this.GetLiteral ((i << 2) | 1' par.Type);  	if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)  		par.MarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  	par.Name = tables.GetIdentifier (pr.Name);  	#if ExtendedRuntime  	        for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {           if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {             Reference r = par.Type as Reference;             if (r != null){               // need to make it a reference to a non-null type and not a non-null wrapper around the reference               // also *must* make it a new Reference.               OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);               par.Type = om.GetReferenceType();             }else{               par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);             }             // Someone putting an attribute directly on the "real" method is still a             // kind of out-of-band contract.             // This marking is the way to signal that any override or implementing method being compiled             // should not have its non-null annotations persisted as optional modifiers.             par.DeclaringMethod.HasOutOfBandContract = true;             break;           }         } #endif  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++) {  	ParamRow pr = pars [i - 1];  	if (pr.Sequence == 0 && method != null) {  		//The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value  		method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  		if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)  			method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  		this.AddMoreStuffToParameters (null' parameters' start + 1' end);  		return;  	}  	int j = pr.Sequence;  	if (j < 1 || j > n)  		continue;  	//Bad metadata' ignore  	if (parameters == null)  		continue;  	Parameter par = parameters [j - 1];  	par.Attributes = this.GetCustomAttributesFor ((i << 5) | 4);  	par.Flags = (ParameterFlags)pr.Flags;  	if ((par.Flags & ParameterFlags.HasDefault) != 0)  		par.DefaultValue = this.GetLiteral ((i << 2) | 1' par.Type);  	if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)  		par.MarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  	par.Name = tables.GetIdentifier (pr.Name);  	#if ExtendedRuntime  	        for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {           if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {             Reference r = par.Type as Reference;             if (r != null){               // need to make it a reference to a non-null type and not a non-null wrapper around the reference               // also *must* make it a new Reference.               OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);               par.Type = om.GetReferenceType();             }else{               par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);             }             // Someone putting an attribute directly on the "real" method is still a             // kind of out-of-band contract.             // This marking is the way to signal that any override or implementing method being compiled             // should not have its non-null annotations persisted as optional modifiers.             par.DeclaringMethod.HasOutOfBandContract = true;             break;           }         } #endif  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++) {  	ParamRow pr = pars [i - 1];  	if (pr.Sequence == 0 && method != null) {  		//The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value  		method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  		if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)  			method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  		this.AddMoreStuffToParameters (null' parameters' start + 1' end);  		return;  	}  	int j = pr.Sequence;  	if (j < 1 || j > n)  		continue;  	//Bad metadata' ignore  	if (parameters == null)  		continue;  	Parameter par = parameters [j - 1];  	par.Attributes = this.GetCustomAttributesFor ((i << 5) | 4);  	par.Flags = (ParameterFlags)pr.Flags;  	if ((par.Flags & ParameterFlags.HasDefault) != 0)  		par.DefaultValue = this.GetLiteral ((i << 2) | 1' par.Type);  	if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)  		par.MarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  	par.Name = tables.GetIdentifier (pr.Name);  	#if ExtendedRuntime  	        for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {           if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {             Reference r = par.Type as Reference;             if (r != null){               // need to make it a reference to a non-null type and not a non-null wrapper around the reference               // also *must* make it a new Reference.               OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);               par.Type = om.GetReferenceType();             }else{               par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);             }             // Someone putting an attribute directly on the "real" method is still a             // kind of out-of-band contract.             // This marking is the way to signal that any override or implementing method being compiled             // should not have its non-null annotations persisted as optional modifiers.             par.DeclaringMethod.HasOutOfBandContract = true;             break;           }         } #endif  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: if (pr.Sequence == 0 && method != null) {  	//The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value  	method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  	if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)  		method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  	this.AddMoreStuffToParameters (null' parameters' start + 1' end);  	return;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: if (pr.Sequence == 0 && method != null) {  	//The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value  	method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  	if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)  		method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation ((i << 1) | 1);  	this.AddMoreStuffToParameters (null' parameters' start + 1' end);  	return;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: method.ReturnAttributes = this.GetCustomAttributesFor ((i << 5) | 4);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: par.Attributes = this.GetCustomAttributesFor ((i << 5) | 4);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: par.Attributes = this.GetCustomAttributesFor ((i << 5) | 4);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: if ((par.Flags & ParameterFlags.HasDefault) != 0)  	par.DefaultValue = this.GetLiteral ((i << 2) | 1' par.Type);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: par.DefaultValue = this.GetLiteral ((i << 2) | 1' par.Type);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddPropertiesToType,The following statement contains a magic number: for (int i = start; i < end; i++) {  	int ii = i;  	if (propertyPtrs.Length > 0)  		ii = propertyPtrs [i - 1].Property;  	PropertyRow prop = propertyDefs [ii - 1];  	Property property = new Property ();  	property.Attributes = this.GetCustomAttributesFor ((ii << 5) | 9);  	property.DeclaringType = type;  	property.Flags = (PropertyFlags)prop.Flags;  	property.Name = tables.GetIdentifier (prop.Name);  	if ((property.Flags & PropertyFlags.RTSpecialName) == 0 || property.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey) {  		this.AddMethodsToProperty (ii' property);  		type.members.Add (property);  	}  	//REVIEW: the signature seems to be redundant. Is there any point in retrieving it?  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddPropertiesToType,The following statement contains a magic number: for (int i = start; i < end; i++) {  	int ii = i;  	if (propertyPtrs.Length > 0)  		ii = propertyPtrs [i - 1].Property;  	PropertyRow prop = propertyDefs [ii - 1];  	Property property = new Property ();  	property.Attributes = this.GetCustomAttributesFor ((ii << 5) | 9);  	property.DeclaringType = type;  	property.Flags = (PropertyFlags)prop.Flags;  	property.Name = tables.GetIdentifier (prop.Name);  	if ((property.Flags & PropertyFlags.RTSpecialName) == 0 || property.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey) {  		this.AddMethodsToProperty (ii' property);  		type.members.Add (property);  	}  	//REVIEW: the signature seems to be redundant. Is there any point in retrieving it?  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddPropertiesToType,The following statement contains a magic number: property.Attributes = this.GetCustomAttributesFor ((ii << 5) | 9);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddPropertiesToType,The following statement contains a magic number: property.Attributes = this.GetCustomAttributesFor ((ii << 5) | 9);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMethodsToProperty,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (methodSemantics [k].Association < codedPropIndex)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && methodSemantics [i - 1].Association == codedPropIndex)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMethodsToProperty,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (methodSemantics [k].Association < codedPropIndex)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddEventsToType,The following statement contains a magic number: for (int i = start; i < end; i++) {  	int ii = i;  	if (eventPtrs.Length > 0)  		ii = eventPtrs [i].Event;  	EventRow ev = eventDefs [ii - 1];  	Event evnt = new Event ();  	evnt.Attributes = this.GetCustomAttributesFor ((ii << 5) | 10);  	evnt.DeclaringType = type;  	evnt.Flags = (EventFlags)ev.Flags;  	evnt.HandlerType = this.DecodeAndGetTypeDefOrRefOrSpec (ev.EventType);  	evnt.Name = tables.GetIdentifier (ev.Name);  	if ((evnt.Flags & EventFlags.RTSpecialName) == 0 || evnt.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey) {  		this.AddMethodsToEvent (ii' evnt);  		type.Members.Add (evnt);  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddEventsToType,The following statement contains a magic number: for (int i = start; i < end; i++) {  	int ii = i;  	if (eventPtrs.Length > 0)  		ii = eventPtrs [i].Event;  	EventRow ev = eventDefs [ii - 1];  	Event evnt = new Event ();  	evnt.Attributes = this.GetCustomAttributesFor ((ii << 5) | 10);  	evnt.DeclaringType = type;  	evnt.Flags = (EventFlags)ev.Flags;  	evnt.HandlerType = this.DecodeAndGetTypeDefOrRefOrSpec (ev.EventType);  	evnt.Name = tables.GetIdentifier (ev.Name);  	if ((evnt.Flags & EventFlags.RTSpecialName) == 0 || evnt.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey) {  		this.AddMethodsToEvent (ii' evnt);  		type.Members.Add (evnt);  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddEventsToType,The following statement contains a magic number: evnt.Attributes = this.GetCustomAttributesFor ((ii << 5) | 10);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddEventsToType,The following statement contains a magic number: evnt.Attributes = this.GetCustomAttributesFor ((ii << 5) | 10);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMethodsToEvent,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (methodSemantics [k].Association < codedEventIndex)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && methodSemantics [i - 1].Association == codedEventIndex)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddMethodsToEvent,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (methodSemantics [k].Association < codedEventIndex)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.TypeDefIsClass (codedIndex >> 2);  case 0x01:  	TypeNode t = this.GetTypeFromRef (codedIndex >> 2);  	return t is Class;  case 0x02:  	return this.TypeSpecIsClass (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.TypeDefIsClass (codedIndex >> 2);  case 0x01:  	TypeNode t = this.GetTypeFromRef (codedIndex >> 2);  	return t is Class;  case 0x02:  	return this.TypeSpecIsClass (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.TypeDefIsClass (codedIndex >> 2);  case 0x01:  	TypeNode t = this.GetTypeFromRef (codedIndex >> 2);  	return t is Class;  case 0x02:  	return this.TypeSpecIsClass (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following statement contains a magic number: return this.TypeDefIsClass (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following statement contains a magic number: return this.TypeSpecIsClass (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.TypeDefIsClassButNotValueTypeBaseClass (codedIndex >> 2);  case 0x01:  	TypeNode t = this.GetTypeFromRef (codedIndex >> 2);  	return t != CoreSystemTypes.ValueType && t != CoreSystemTypes.Enum && t is Class;  case 0x02:  	return this.TypeSpecIsClass (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.TypeDefIsClassButNotValueTypeBaseClass (codedIndex >> 2);  case 0x01:  	TypeNode t = this.GetTypeFromRef (codedIndex >> 2);  	return t != CoreSystemTypes.ValueType && t != CoreSystemTypes.Enum && t is Class;  case 0x02:  	return this.TypeSpecIsClass (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.TypeDefIsClassButNotValueTypeBaseClass (codedIndex >> 2);  case 0x01:  	TypeNode t = this.GetTypeFromRef (codedIndex >> 2);  	return t != CoreSystemTypes.ValueType && t != CoreSystemTypes.Enum && t is Class;  case 0x02:  	return this.TypeSpecIsClass (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following statement contains a magic number: return this.TypeDefIsClassButNotValueTypeBaseClass (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following statement contains a magic number: return this.TypeSpecIsClass (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2);  case 0x02:  	return this.GetTypeFromSpec (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2);  case 0x02:  	return this.GetTypeFromSpec (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2);  case 0x02:  	return this.GetTypeFromSpec (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: return this.GetTypeFromDef (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: return this.GetTypeFromRef (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: return this.GetTypeFromSpec (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2' expectStruct);  case 0x02:  	return this.GetTypeFromSpec (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2' expectStruct);  case 0x02:  	return this.GetTypeFromSpec (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2' expectStruct);  case 0x02:  	return this.GetTypeFromSpec (codedIndex >> 2);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: return this.GetTypeFromDef (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: return this.GetTypeFromRef (codedIndex >> 2' expectStruct);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: return this.GetTypeFromSpec (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeIfNotGenericInstance,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2' false);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeIfNotGenericInstance,The following statement contains a magic number: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2' false);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeIfNotGenericInstance,The following statement contains a magic number: return this.GetTypeFromDef (codedIndex >> 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeIfNotGenericInstance,The following statement contains a magic number: return this.GetTypeFromRef (codedIndex >> 2' false);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetConstructorDefOrRef,The following statement contains a magic number: switch (codedIndex & 0x7) {  case 0x02:  	return this.GetMethodFromDef (codedIndex >> 3);  case 0x03:  	return (Method)this.GetMemberFromRef (codedIndex >> 3' out varArgTypes);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetConstructorDefOrRef,The following statement contains a magic number: switch (codedIndex & 0x7) {  case 0x02:  	return this.GetMethodFromDef (codedIndex >> 3);  case 0x03:  	return (Method)this.GetMemberFromRef (codedIndex >> 3' out varArgTypes);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetConstructorDefOrRef,The following statement contains a magic number: return this.GetMethodFromDef (codedIndex >> 3);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetConstructorDefOrRef,The following statement contains a magic number: return (Method)this.GetMemberFromRef (codedIndex >> 3' out varArgTypes);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	ManifestResourceRow mrr = manifestResourceTable [i];  	Resource r = new Resource ();  	r.Name = this.tables.GetString (mrr.Name);  	r.IsPublic = (mrr.Flags & 7) == 1;  	int impl = mrr.Implementation;  	if (impl != 0) {  		switch (impl & 0x3) {  		case 0x0:  			string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  			if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  				r.DefiningModule = new Module ();  				r.DefiningModule.Directory = module.Directory;  				r.DefiningModule.Location = Path.Combine (module.Directory' modName);  				r.DefiningModule.Name = modName;  				r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  				r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  				r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  			} else {  				string modLocation = modName;  				r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  			}  			break;  		case 0x1:  			r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  			break;  		}  	} else {  		r.DefiningModule = module;  		r.Data = this.tables.GetResourceData (mrr.Offset);  	}  	resources.Add (r);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	ManifestResourceRow mrr = manifestResourceTable [i];  	Resource r = new Resource ();  	r.Name = this.tables.GetString (mrr.Name);  	r.IsPublic = (mrr.Flags & 7) == 1;  	int impl = mrr.Implementation;  	if (impl != 0) {  		switch (impl & 0x3) {  		case 0x0:  			string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  			if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  				r.DefiningModule = new Module ();  				r.DefiningModule.Directory = module.Directory;  				r.DefiningModule.Location = Path.Combine (module.Directory' modName);  				r.DefiningModule.Name = modName;  				r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  				r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  				r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  			} else {  				string modLocation = modName;  				r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  			}  			break;  		case 0x1:  			r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  			break;  		}  	} else {  		r.DefiningModule = module;  		r.Data = this.tables.GetResourceData (mrr.Offset);  	}  	resources.Add (r);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	ManifestResourceRow mrr = manifestResourceTable [i];  	Resource r = new Resource ();  	r.Name = this.tables.GetString (mrr.Name);  	r.IsPublic = (mrr.Flags & 7) == 1;  	int impl = mrr.Implementation;  	if (impl != 0) {  		switch (impl & 0x3) {  		case 0x0:  			string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  			if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  				r.DefiningModule = new Module ();  				r.DefiningModule.Directory = module.Directory;  				r.DefiningModule.Location = Path.Combine (module.Directory' modName);  				r.DefiningModule.Name = modName;  				r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  				r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  				r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  			} else {  				string modLocation = modName;  				r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  			}  			break;  		case 0x1:  			r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  			break;  		}  	} else {  		r.DefiningModule = module;  		r.Data = this.tables.GetResourceData (mrr.Offset);  	}  	resources.Add (r);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	ManifestResourceRow mrr = manifestResourceTable [i];  	Resource r = new Resource ();  	r.Name = this.tables.GetString (mrr.Name);  	r.IsPublic = (mrr.Flags & 7) == 1;  	int impl = mrr.Implementation;  	if (impl != 0) {  		switch (impl & 0x3) {  		case 0x0:  			string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  			if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  				r.DefiningModule = new Module ();  				r.DefiningModule.Directory = module.Directory;  				r.DefiningModule.Location = Path.Combine (module.Directory' modName);  				r.DefiningModule.Name = modName;  				r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  				r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  				r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  			} else {  				string modLocation = modName;  				r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  			}  			break;  		case 0x1:  			r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  			break;  		}  	} else {  		r.DefiningModule = module;  		r.Data = this.tables.GetResourceData (mrr.Offset);  	}  	resources.Add (r);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	ManifestResourceRow mrr = manifestResourceTable [i];  	Resource r = new Resource ();  	r.Name = this.tables.GetString (mrr.Name);  	r.IsPublic = (mrr.Flags & 7) == 1;  	int impl = mrr.Implementation;  	if (impl != 0) {  		switch (impl & 0x3) {  		case 0x0:  			string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  			if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  				r.DefiningModule = new Module ();  				r.DefiningModule.Directory = module.Directory;  				r.DefiningModule.Location = Path.Combine (module.Directory' modName);  				r.DefiningModule.Name = modName;  				r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  				r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  				r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  			} else {  				string modLocation = modName;  				r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  			}  			break;  		case 0x1:  			r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  			break;  		}  	} else {  		r.DefiningModule = module;  		r.Data = this.tables.GetResourceData (mrr.Offset);  	}  	resources.Add (r);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: r.IsPublic = (mrr.Flags & 7) == 1;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: if (impl != 0) {  	switch (impl & 0x3) {  	case 0x0:  		string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  		if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  			r.DefiningModule = new Module ();  			r.DefiningModule.Directory = module.Directory;  			r.DefiningModule.Location = Path.Combine (module.Directory' modName);  			r.DefiningModule.Name = modName;  			r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  			r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  			r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  		} else {  			string modLocation = modName;  			r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  		}  		break;  	case 0x1:  		r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  		break;  	}  } else {  	r.DefiningModule = module;  	r.Data = this.tables.GetResourceData (mrr.Offset);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: if (impl != 0) {  	switch (impl & 0x3) {  	case 0x0:  		string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  		if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  			r.DefiningModule = new Module ();  			r.DefiningModule.Directory = module.Directory;  			r.DefiningModule.Location = Path.Combine (module.Directory' modName);  			r.DefiningModule.Name = modName;  			r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  			r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  			r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  		} else {  			string modLocation = modName;  			r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  		}  		break;  	case 0x1:  		r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  		break;  	}  } else {  	r.DefiningModule = module;  	r.Data = this.tables.GetResourceData (mrr.Offset);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: if (impl != 0) {  	switch (impl & 0x3) {  	case 0x0:  		string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  		if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  			r.DefiningModule = new Module ();  			r.DefiningModule.Directory = module.Directory;  			r.DefiningModule.Location = Path.Combine (module.Directory' modName);  			r.DefiningModule.Name = modName;  			r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  			r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  			r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  		} else {  			string modLocation = modName;  			r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  		}  		break;  	case 0x1:  		r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  		break;  	}  } else {  	r.DefiningModule = module;  	r.Data = this.tables.GetResourceData (mrr.Offset);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: if (impl != 0) {  	switch (impl & 0x3) {  	case 0x0:  		string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  		if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  			r.DefiningModule = new Module ();  			r.DefiningModule.Directory = module.Directory;  			r.DefiningModule.Location = Path.Combine (module.Directory' modName);  			r.DefiningModule.Name = modName;  			r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  			r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  			r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  		} else {  			string modLocation = modName;  			r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  		}  		break;  	case 0x1:  		r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  		break;  	}  } else {  	r.DefiningModule = module;  	r.Data = this.tables.GetResourceData (mrr.Offset);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: switch (impl & 0x3) {  case 0x0:  	string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  	if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  		r.DefiningModule = new Module ();  		r.DefiningModule.Directory = module.Directory;  		r.DefiningModule.Location = Path.Combine (module.Directory' modName);  		r.DefiningModule.Name = modName;  		r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  		r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  		r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  	} else {  		string modLocation = modName;  		r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  	}  	break;  case 0x1:  	r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: switch (impl & 0x3) {  case 0x0:  	string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  	if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  		r.DefiningModule = new Module ();  		r.DefiningModule.Directory = module.Directory;  		r.DefiningModule.Location = Path.Combine (module.Directory' modName);  		r.DefiningModule.Name = modName;  		r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  		r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  		r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  	} else {  		string modLocation = modName;  		r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  	}  	break;  case 0x1:  	r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: switch (impl & 0x3) {  case 0x0:  	string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  	if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  		r.DefiningModule = new Module ();  		r.DefiningModule.Directory = module.Directory;  		r.DefiningModule.Location = Path.Combine (module.Directory' modName);  		r.DefiningModule.Name = modName;  		r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  		r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  		r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  	} else {  		string modLocation = modName;  		r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  	}  	break;  case 0x1:  	r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: switch (impl & 0x3) {  case 0x0:  	string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  	if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  		r.DefiningModule = new Module ();  		r.DefiningModule.Directory = module.Directory;  		r.DefiningModule.Location = Path.Combine (module.Directory' modName);  		r.DefiningModule.Name = modName;  		r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  		r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  		r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  	} else {  		string modLocation = modName;  		r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  	}  	break;  case 0x1:  	r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  	r.DefiningModule = new Module ();  	r.DefiningModule.Directory = module.Directory;  	r.DefiningModule.Location = Path.Combine (module.Directory' modName);  	r.DefiningModule.Name = modName;  	r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  	r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  	r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  } else {  	string modLocation = modName;  	r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  	r.DefiningModule = new Module ();  	r.DefiningModule.Directory = module.Directory;  	r.DefiningModule.Location = Path.Combine (module.Directory' modName);  	r.DefiningModule.Name = modName;  	r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  	r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  	r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  } else {  	string modLocation = modName;  	r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following statement contains a magic number: r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [0] == ']') {  	//Single dimensional array with zero lower bound  	if (typeName.Length == 1)  		return rootType.GetArrayType (1);  	if (typeName [1] == '[' && typeName.Length > 2)  		return this.ParseArrayOrGenericType (typeName.Substring (2)' rootType.GetArrayType (1));  	throw new InvalidMetadataException (ExceptionStrings.BadSerializedTypeName);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [0] == ']') {  	//Single dimensional array with zero lower bound  	if (typeName.Length == 1)  		return rootType.GetArrayType (1);  	if (typeName [1] == '[' && typeName.Length > 2)  		return this.ParseArrayOrGenericType (typeName.Substring (2)' rootType.GetArrayType (1));  	throw new InvalidMetadataException (ExceptionStrings.BadSerializedTypeName);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [1] == '[' && typeName.Length > 2)  	return this.ParseArrayOrGenericType (typeName.Substring (2)' rootType.GetArrayType (1));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [1] == '[' && typeName.Length > 2)  	return this.ParseArrayOrGenericType (typeName.Substring (2)' rootType.GetArrayType (1));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: return this.ParseArrayOrGenericType (typeName.Substring (2)' rootType.GetArrayType (1));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [0] == '*') {  	//Single dimensional array with unknown lower bound  	if (typeName.Length > 1 && typeName [1] == ']') {  		if (typeName.Length == 2)  			return rootType.GetArrayType (1' true);  		if (typeName [2] == '[' && typeName.Length > 3)  			return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  	}  	throw new InvalidMetadataException (ExceptionStrings.BadSerializedTypeName);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [0] == '*') {  	//Single dimensional array with unknown lower bound  	if (typeName.Length > 1 && typeName [1] == ']') {  		if (typeName.Length == 2)  			return rootType.GetArrayType (1' true);  		if (typeName [2] == '[' && typeName.Length > 3)  			return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  	}  	throw new InvalidMetadataException (ExceptionStrings.BadSerializedTypeName);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [0] == '*') {  	//Single dimensional array with unknown lower bound  	if (typeName.Length > 1 && typeName [1] == ']') {  		if (typeName.Length == 2)  			return rootType.GetArrayType (1' true);  		if (typeName [2] == '[' && typeName.Length > 3)  			return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  	}  	throw new InvalidMetadataException (ExceptionStrings.BadSerializedTypeName);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [0] == '*') {  	//Single dimensional array with unknown lower bound  	if (typeName.Length > 1 && typeName [1] == ']') {  		if (typeName.Length == 2)  			return rootType.GetArrayType (1' true);  		if (typeName [2] == '[' && typeName.Length > 3)  			return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  	}  	throw new InvalidMetadataException (ExceptionStrings.BadSerializedTypeName);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName.Length > 1 && typeName [1] == ']') {  	if (typeName.Length == 2)  		return rootType.GetArrayType (1' true);  	if (typeName [2] == '[' && typeName.Length > 3)  		return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName.Length > 1 && typeName [1] == ']') {  	if (typeName.Length == 2)  		return rootType.GetArrayType (1' true);  	if (typeName [2] == '[' && typeName.Length > 3)  		return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName.Length > 1 && typeName [1] == ']') {  	if (typeName.Length == 2)  		return rootType.GetArrayType (1' true);  	if (typeName [2] == '[' && typeName.Length > 3)  		return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName.Length > 1 && typeName [1] == ']') {  	if (typeName.Length == 2)  		return rootType.GetArrayType (1' true);  	if (typeName [2] == '[' && typeName.Length > 3)  		return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName.Length == 2)  	return rootType.GetArrayType (1' true);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [2] == '[' && typeName.Length > 3)  	return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [2] == '[' && typeName.Length > 3)  	return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [2] == '[' && typeName.Length > 3)  	return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: return this.ParseArrayOrGenericType (typeName.Substring (3)' rootType.GetArrayType (1' true));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [0] == ''') {  	//Muti dimensional array  	int rank = 1;  	while (rank < typeName.Length && typeName [rank] == ''')  		rank++;  	if (rank < typeName.Length && typeName [rank] == ']') {  		if (typeName.Length == rank + 1)  			return rootType.GetArrayType (rank + 1);  		if (typeName [rank + 1] == '[' && typeName.Length > rank + 2)  			return this.ParseArrayOrGenericType (typeName.Substring (rank + 2)' rootType.GetArrayType (rank));  	}  	throw new InvalidMetadataException (ExceptionStrings.BadSerializedTypeName);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [0] == ''') {  	//Muti dimensional array  	int rank = 1;  	while (rank < typeName.Length && typeName [rank] == ''')  		rank++;  	if (rank < typeName.Length && typeName [rank] == ']') {  		if (typeName.Length == rank + 1)  			return rootType.GetArrayType (rank + 1);  		if (typeName [rank + 1] == '[' && typeName.Length > rank + 2)  			return this.ParseArrayOrGenericType (typeName.Substring (rank + 2)' rootType.GetArrayType (rank));  	}  	throw new InvalidMetadataException (ExceptionStrings.BadSerializedTypeName);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (rank < typeName.Length && typeName [rank] == ']') {  	if (typeName.Length == rank + 1)  		return rootType.GetArrayType (rank + 1);  	if (typeName [rank + 1] == '[' && typeName.Length > rank + 2)  		return this.ParseArrayOrGenericType (typeName.Substring (rank + 2)' rootType.GetArrayType (rank));  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (rank < typeName.Length && typeName [rank] == ']') {  	if (typeName.Length == rank + 1)  		return rootType.GetArrayType (rank + 1);  	if (typeName [rank + 1] == '[' && typeName.Length > rank + 2)  		return this.ParseArrayOrGenericType (typeName.Substring (rank + 2)' rootType.GetArrayType (rank));  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [rank + 1] == '[' && typeName.Length > rank + 2)  	return this.ParseArrayOrGenericType (typeName.Substring (rank + 2)' rootType.GetArrayType (rank));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName [rank + 1] == '[' && typeName.Length > rank + 2)  	return this.ParseArrayOrGenericType (typeName.Substring (rank + 2)' rootType.GetArrayType (rank));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: return this.ParseArrayOrGenericType (typeName.Substring (rank + 2)' rootType.GetArrayType (rank));  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (lastCharPos + 1 < typeName.Length) {  	//The generic type is complete' but there is yet more to the type  	char ch = typeName [lastCharPos + 1];  	if (ch == '+')  		retVal = this.GetTypeFromSerializedName (typeName.Substring (lastCharPos + 2)' retVal);  	if (ch == '&')  		retVal = retVal.GetReferenceType ();  	if (ch == '*')  		retVal = retVal.GetPointerType ();  	if (ch == '[')  		retVal = this.ParseArrayOrGenericType (typeName.Substring (lastCharPos + 2' typeName.Length - 1 - lastCharPos - 1)' retVal);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (lastCharPos + 1 < typeName.Length) {  	//The generic type is complete' but there is yet more to the type  	char ch = typeName [lastCharPos + 1];  	if (ch == '+')  		retVal = this.GetTypeFromSerializedName (typeName.Substring (lastCharPos + 2)' retVal);  	if (ch == '&')  		retVal = retVal.GetReferenceType ();  	if (ch == '*')  		retVal = retVal.GetPointerType ();  	if (ch == '[')  		retVal = this.ParseArrayOrGenericType (typeName.Substring (lastCharPos + 2' typeName.Length - 1 - lastCharPos - 1)' retVal);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (ch == '+')  	retVal = this.GetTypeFromSerializedName (typeName.Substring (lastCharPos + 2)' retVal);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: retVal = this.GetTypeFromSerializedName (typeName.Substring (lastCharPos + 2)' retVal);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (ch == '[')  	retVal = this.ParseArrayOrGenericType (typeName.Substring (lastCharPos + 2' typeName.Length - 1 - lastCharPos - 1)' retVal);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: retVal = this.ParseArrayOrGenericType (typeName.Substring (lastCharPos + 2' typeName.Length - 1 - lastCharPos - 1)' retVal);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	if (this.tables.entryPointToken != 0)  		module.EntryPoint = (Method)this.GetMemberFromToken (this.tables.entryPointToken);  	else  		module.EntryPoint = Module.NoSuchMethod;  	if (module.NodeType == NodeType.Module) {  		module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  		return;  	}  	AssemblyNode assembly = (AssemblyNode)module;  	assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  	assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  	assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  	module.Attributes = new AttributeList (0);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	if (this.tables.entryPointToken != 0)  		module.EntryPoint = (Method)this.GetMemberFromToken (this.tables.entryPointToken);  	else  		module.EntryPoint = Module.NoSuchMethod;  	if (module.NodeType == NodeType.Module) {  		module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  		return;  	}  	AssemblyNode assembly = (AssemblyNode)module;  	assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  	assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  	assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  	module.Attributes = new AttributeList (0);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	if (this.tables.entryPointToken != 0)  		module.EntryPoint = (Method)this.GetMemberFromToken (this.tables.entryPointToken);  	else  		module.EntryPoint = Module.NoSuchMethod;  	if (module.NodeType == NodeType.Module) {  		module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  		return;  	}  	AssemblyNode assembly = (AssemblyNode)module;  	assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  	assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  	assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  	module.Attributes = new AttributeList (0);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	if (this.tables.entryPointToken != 0)  		module.EntryPoint = (Method)this.GetMemberFromToken (this.tables.entryPointToken);  	else  		module.EntryPoint = Module.NoSuchMethod;  	if (module.NodeType == NodeType.Module) {  		module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  		return;  	}  	AssemblyNode assembly = (AssemblyNode)module;  	assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  	assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  	assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  	module.Attributes = new AttributeList (0);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	if (this.tables.entryPointToken != 0)  		module.EntryPoint = (Method)this.GetMemberFromToken (this.tables.entryPointToken);  	else  		module.EntryPoint = Module.NoSuchMethod;  	if (module.NodeType == NodeType.Module) {  		module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  		return;  	}  	AssemblyNode assembly = (AssemblyNode)module;  	assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  	assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  	assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  	module.Attributes = new AttributeList (0);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	if (this.tables.entryPointToken != 0)  		module.EntryPoint = (Method)this.GetMemberFromToken (this.tables.entryPointToken);  	else  		module.EntryPoint = Module.NoSuchMethod;  	if (module.NodeType == NodeType.Module) {  		module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  		return;  	}  	AssemblyNode assembly = (AssemblyNode)module;  	assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  	assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  	assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  	module.Attributes = new AttributeList (0);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	if (this.tables.entryPointToken != 0)  		module.EntryPoint = (Method)this.GetMemberFromToken (this.tables.entryPointToken);  	else  		module.EntryPoint = Module.NoSuchMethod;  	if (module.NodeType == NodeType.Module) {  		module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  		return;  	}  	AssemblyNode assembly = (AssemblyNode)module;  	assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  	assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  	assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  	module.Attributes = new AttributeList (0);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	if (this.tables.entryPointToken != 0)  		module.EntryPoint = (Method)this.GetMemberFromToken (this.tables.entryPointToken);  	else  		module.EntryPoint = Module.NoSuchMethod;  	if (module.NodeType == NodeType.Module) {  		module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  		return;  	}  	AssemblyNode assembly = (AssemblyNode)module;  	assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  	assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  	assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  	module.Attributes = new AttributeList (0);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: if (module.NodeType == NodeType.Module) {  	module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	return;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: if (module.NodeType == NodeType.Module) {  	module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  	return;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: module.Attributes = this.GetCustomAttributesFor ((1 << 5) | 7);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: assembly.SecurityAttributes = this.GetSecurityAttributesFor ((1 << 2) | 2);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: assembly.Attributes = this.GetCustomAttributesFor ((1 << 5) | 14);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: assembly.ModuleAttributes = this.GetCustomAttributesFor ((1 << 5) | 7);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	int i = 0' n = customAttributes.Length' j = n - 1;  	if (n == 0)  		return attributes;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.CustomAttribute) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (customAttributes [k].Parent < parentIndex)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && customAttributes [i - 1].Parent == parentIndex)  			i--;  	}  	for (; i < n; i++)  		if (customAttributes [i].Parent == parentIndex)  			attributes.Add (this.GetCustomAttribute (i));  		else if (sorted)  			break;  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return attributes;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try {  	int i = 0' n = customAttributes.Length' j = n - 1;  	if (n == 0)  		return attributes;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.CustomAttribute) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (customAttributes [k].Parent < parentIndex)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && customAttributes [i - 1].Parent == parentIndex)  			i--;  	}  	for (; i < n; i++)  		if (customAttributes [i].Parent == parentIndex)  			attributes.Add (this.GetCustomAttribute (i));  		else if (sorted)  			break;  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return attributes;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (customAttributes [k].Parent < parentIndex)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && customAttributes [i - 1].Parent == parentIndex)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (customAttributes [k].Parent < parentIndex)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSecurityAttributesFor,The following statement contains a magic number: try {  	int i = 0' n = securityAttributes.Length' j = n - 1;  	if (n == 0)  		return attributes;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.DeclSecurity) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (securityAttributes [k].Parent < parentIndex)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && securityAttributes [i - 1].Parent == parentIndex)  			i--;  	}  	for (; i < n; i++)  		if (securityAttributes [i].Parent == parentIndex)  			attributes.Add (this.GetSecurityAttribute (i));  		else if (sorted)  			break;  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return attributes;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSecurityAttributesFor,The following statement contains a magic number: try {  	int i = 0' n = securityAttributes.Length' j = n - 1;  	if (n == 0)  		return attributes;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.DeclSecurity) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (securityAttributes [k].Parent < parentIndex)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && securityAttributes [i - 1].Parent == parentIndex)  			i--;  	}  	for (; i < n; i++)  		if (securityAttributes [i].Parent == parentIndex)  			attributes.Add (this.GetSecurityAttribute (i));  		else if (sorted)  			break;  	#if !FxCop  } catch (Exception e) {  	if (this.module == null)  		return attributes;  	if (this.module.MetadataImportErrors == null)  		this.module.MetadataImportErrors = new ArrayList ();  	this.module.MetadataImportErrors.Add (e);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSecurityAttributesFor,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (securityAttributes [k].Parent < parentIndex)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && securityAttributes [i - 1].Parent == parentIndex)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSecurityAttributesFor,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (securityAttributes [k].Parent < parentIndex)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeParameterConstraints,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (genericParameters [k].Owner < parentIndex)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && genericParameters [i - 1].Owner == parentIndex)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeParameterConstraints,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (genericParameters [k].Owner < parentIndex)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeParametersFor,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (genericParameters [k].Owner < parentIndex)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && genericParameters [i - 1].Owner == parentIndex)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeParametersFor,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (genericParameters [k].Owner < parentIndex)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetGenericParameter,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (genericParameterConstraints [k].Param < index)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && genericParameterConstraints [i - 1].Param == index)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetGenericParameter,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (genericParameterConstraints [k].Param < index)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetGenericParameterConstraints,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (genericParameterConstraints [k].Param < index)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && genericParameterConstraints [i - 1].Param == index)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetGenericParameterConstraints,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (genericParameterConstraints [k].Param < index)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetFieldFromDef,The following statement contains a magic number: field.Attributes = this.GetCustomAttributesFor ((i << 5) | 1);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetFieldFromDef,The following statement contains a magic number: GetAndCheckSignatureToken (6' sigReader);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetFieldFromDef,The following statement contains a magic number: if ((field.Flags & FieldFlags.HasDefault) != 0)  	field.DefaultValue = this.GetLiteral (i << 2' field.Type);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetFieldFromDef,The following statement contains a magic number: field.DefaultValue = this.GetLiteral (i << 2' field.Type);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (fieldRvaTable [k].Field < fieldIndex)  			i = k + 1;  		else  			j = k;  	}  } else  	for (; i < j; i++)  		if (fieldRvaTable [i].Field == fieldIndex)  			break;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (fieldRvaTable [k].Field < fieldIndex)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0) {  	switch (fieldType.typeCode) {  	case ElementType.Boolean:  		size = 1;  		break;  	case ElementType.Char:  		size = 2;  		break;  	case ElementType.Double:  		size = 8;  		break;  	case ElementType.Int16:  		size = 2;  		break;  	case ElementType.Int32:  		size = 4;  		break;  	case ElementType.Int64:  		size = 8;  		break;  	case ElementType.Int8:  		size = 1;  		break;  	case ElementType.Single:  		size = 4;  		break;  	case ElementType.UInt16:  		size = 2;  		break;  	case ElementType.UInt32:  		size = 4;  		break;  	case ElementType.UInt64:  		size = 8;  		break;  	case ElementType.UInt8:  		size = 1;  		break;  	default:  		if (fieldType is Pointer || fieldType is FunctionPointer) {  			size = 4;  			break;  		}  		//TODO: this seems wrong  		if (i < n - 1)  			size = fieldRvaTable [i + 1].RVA - frr.RVA;  		else if (targetSection != PESection.Text)  			size = this.tables.GetOffsetToEndOfSection (frr.RVA);  		break;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: switch (fieldType.typeCode) {  case ElementType.Boolean:  	size = 1;  	break;  case ElementType.Char:  	size = 2;  	break;  case ElementType.Double:  	size = 8;  	break;  case ElementType.Int16:  	size = 2;  	break;  case ElementType.Int32:  	size = 4;  	break;  case ElementType.Int64:  	size = 8;  	break;  case ElementType.Int8:  	size = 1;  	break;  case ElementType.Single:  	size = 4;  	break;  case ElementType.UInt16:  	size = 2;  	break;  case ElementType.UInt32:  	size = 4;  	break;  case ElementType.UInt64:  	size = 8;  	break;  case ElementType.UInt8:  	size = 1;  	break;  default:  	if (fieldType is Pointer || fieldType is FunctionPointer) {  		size = 4;  		break;  	}  	//TODO: this seems wrong  	if (i < n - 1)  		size = fieldRvaTable [i + 1].RVA - frr.RVA;  	else if (targetSection != PESection.Text)  		size = this.tables.GetOffsetToEndOfSection (frr.RVA);  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 2;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 8;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 2;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 4;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 8;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 4;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 2;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 4;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 8;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (fieldType is Pointer || fieldType is FunctionPointer) {  	size = 4;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: size = 4;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (mtypes [k].Parent < parentCodedIndex)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && mtypes [i - 1].Parent == parentCodedIndex)  		i--;  } else  	for (; i < j; i++)  		if (mtypes [i].Parent == parentCodedIndex)  			break;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (mtypes [k].Parent < parentCodedIndex)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (result.NativeType == NativeType.CustomMarshaler) {  	c.ReadUInt16 ();  	//Skip over 0  	result.Class = ReadSerString (c);  	result.Cookie = ReadSerString (c);  } else if (blobSize > 1) {  	if (result.NativeType == NativeType.LPArray) {  		result.ElementType = (NativeType)c.ReadByte ();  		result.ParamIndex = -1;  		int bytesRead = 2;  		if (bytesRead < blobSize) {  			int pos = c.Position;  			result.ParamIndex = c.ReadCompressedInt ();  			bytesRead += c.Position - pos;  			if (bytesRead < blobSize) {  				pos = c.Position;  				result.ElementSize = c.ReadCompressedInt ();  				bytesRead += c.Position - pos;  				if (bytesRead < blobSize)  					result.NumberOfElements = c.ReadCompressedInt ();  			}  		}  	} else if (result.NativeType == NativeType.SafeArray) {  		result.ElementType = (NativeType)c.ReadByte ();  		//Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF?  		if (c.Position < initialPosition + blobSize - 1)  			result.Class = ReadSerString (c);  	} else {  		result.Size = c.ReadCompressedInt ();  		if (result.NativeType == NativeType.ByValArray) {  			if (blobSize > 2)  				result.ElementType = (NativeType)c.ReadByte ();  			else  				result.ElementType = NativeType.NotSpecified;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (result.NativeType == NativeType.CustomMarshaler) {  	c.ReadUInt16 ();  	//Skip over 0  	result.Class = ReadSerString (c);  	result.Cookie = ReadSerString (c);  } else if (blobSize > 1) {  	if (result.NativeType == NativeType.LPArray) {  		result.ElementType = (NativeType)c.ReadByte ();  		result.ParamIndex = -1;  		int bytesRead = 2;  		if (bytesRead < blobSize) {  			int pos = c.Position;  			result.ParamIndex = c.ReadCompressedInt ();  			bytesRead += c.Position - pos;  			if (bytesRead < blobSize) {  				pos = c.Position;  				result.ElementSize = c.ReadCompressedInt ();  				bytesRead += c.Position - pos;  				if (bytesRead < blobSize)  					result.NumberOfElements = c.ReadCompressedInt ();  			}  		}  	} else if (result.NativeType == NativeType.SafeArray) {  		result.ElementType = (NativeType)c.ReadByte ();  		//Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF?  		if (c.Position < initialPosition + blobSize - 1)  			result.Class = ReadSerString (c);  	} else {  		result.Size = c.ReadCompressedInt ();  		if (result.NativeType == NativeType.ByValArray) {  			if (blobSize > 2)  				result.ElementType = (NativeType)c.ReadByte ();  			else  				result.ElementType = NativeType.NotSpecified;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (blobSize > 1) {  	if (result.NativeType == NativeType.LPArray) {  		result.ElementType = (NativeType)c.ReadByte ();  		result.ParamIndex = -1;  		int bytesRead = 2;  		if (bytesRead < blobSize) {  			int pos = c.Position;  			result.ParamIndex = c.ReadCompressedInt ();  			bytesRead += c.Position - pos;  			if (bytesRead < blobSize) {  				pos = c.Position;  				result.ElementSize = c.ReadCompressedInt ();  				bytesRead += c.Position - pos;  				if (bytesRead < blobSize)  					result.NumberOfElements = c.ReadCompressedInt ();  			}  		}  	} else if (result.NativeType == NativeType.SafeArray) {  		result.ElementType = (NativeType)c.ReadByte ();  		//Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF?  		if (c.Position < initialPosition + blobSize - 1)  			result.Class = ReadSerString (c);  	} else {  		result.Size = c.ReadCompressedInt ();  		if (result.NativeType == NativeType.ByValArray) {  			if (blobSize > 2)  				result.ElementType = (NativeType)c.ReadByte ();  			else  				result.ElementType = NativeType.NotSpecified;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (blobSize > 1) {  	if (result.NativeType == NativeType.LPArray) {  		result.ElementType = (NativeType)c.ReadByte ();  		result.ParamIndex = -1;  		int bytesRead = 2;  		if (bytesRead < blobSize) {  			int pos = c.Position;  			result.ParamIndex = c.ReadCompressedInt ();  			bytesRead += c.Position - pos;  			if (bytesRead < blobSize) {  				pos = c.Position;  				result.ElementSize = c.ReadCompressedInt ();  				bytesRead += c.Position - pos;  				if (bytesRead < blobSize)  					result.NumberOfElements = c.ReadCompressedInt ();  			}  		}  	} else if (result.NativeType == NativeType.SafeArray) {  		result.ElementType = (NativeType)c.ReadByte ();  		//Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF?  		if (c.Position < initialPosition + blobSize - 1)  			result.Class = ReadSerString (c);  	} else {  		result.Size = c.ReadCompressedInt ();  		if (result.NativeType == NativeType.ByValArray) {  			if (blobSize > 2)  				result.ElementType = (NativeType)c.ReadByte ();  			else  				result.ElementType = NativeType.NotSpecified;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (result.NativeType == NativeType.LPArray) {  	result.ElementType = (NativeType)c.ReadByte ();  	result.ParamIndex = -1;  	int bytesRead = 2;  	if (bytesRead < blobSize) {  		int pos = c.Position;  		result.ParamIndex = c.ReadCompressedInt ();  		bytesRead += c.Position - pos;  		if (bytesRead < blobSize) {  			pos = c.Position;  			result.ElementSize = c.ReadCompressedInt ();  			bytesRead += c.Position - pos;  			if (bytesRead < blobSize)  				result.NumberOfElements = c.ReadCompressedInt ();  		}  	}  } else if (result.NativeType == NativeType.SafeArray) {  	result.ElementType = (NativeType)c.ReadByte ();  	//Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF?  	if (c.Position < initialPosition + blobSize - 1)  		result.Class = ReadSerString (c);  } else {  	result.Size = c.ReadCompressedInt ();  	if (result.NativeType == NativeType.ByValArray) {  		if (blobSize > 2)  			result.ElementType = (NativeType)c.ReadByte ();  		else  			result.ElementType = NativeType.NotSpecified;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (result.NativeType == NativeType.LPArray) {  	result.ElementType = (NativeType)c.ReadByte ();  	result.ParamIndex = -1;  	int bytesRead = 2;  	if (bytesRead < blobSize) {  		int pos = c.Position;  		result.ParamIndex = c.ReadCompressedInt ();  		bytesRead += c.Position - pos;  		if (bytesRead < blobSize) {  			pos = c.Position;  			result.ElementSize = c.ReadCompressedInt ();  			bytesRead += c.Position - pos;  			if (bytesRead < blobSize)  				result.NumberOfElements = c.ReadCompressedInt ();  		}  	}  } else if (result.NativeType == NativeType.SafeArray) {  	result.ElementType = (NativeType)c.ReadByte ();  	//Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF?  	if (c.Position < initialPosition + blobSize - 1)  		result.Class = ReadSerString (c);  } else {  	result.Size = c.ReadCompressedInt ();  	if (result.NativeType == NativeType.ByValArray) {  		if (blobSize > 2)  			result.ElementType = (NativeType)c.ReadByte ();  		else  			result.ElementType = NativeType.NotSpecified;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (result.NativeType == NativeType.SafeArray) {  	result.ElementType = (NativeType)c.ReadByte ();  	//Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF?  	if (c.Position < initialPosition + blobSize - 1)  		result.Class = ReadSerString (c);  } else {  	result.Size = c.ReadCompressedInt ();  	if (result.NativeType == NativeType.ByValArray) {  		if (blobSize > 2)  			result.ElementType = (NativeType)c.ReadByte ();  		else  			result.ElementType = NativeType.NotSpecified;  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (result.NativeType == NativeType.ByValArray) {  	if (blobSize > 2)  		result.ElementType = (NativeType)c.ReadByte ();  	else  		result.ElementType = NativeType.NotSpecified;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (blobSize > 2)  	result.ElementType = (NativeType)c.ReadByte ();  else  	result.ElementType = NativeType.NotSpecified;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (declaringType == null) {  	int indx = index;  	MethodPtrRow[] methodPtrs = this.tables.MethodPtrTable;  	int n = methodPtrs.Length' i = 0' j = n - 1;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodPtr) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (methodPtrs [k].Method < index)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && methodPtrs [i - 1].Method == index)  			i--;  	}  	for (; i < n; i++) {  		if (methodPtrs [i].Method == index) {  			indx = i + 1;  			break;  		}  	}  	TypeDefRow[] typeDefs = this.tables.TypeDefTable;  	n = typeDefs.Length;  	i = 0;  	j = n - 1;  	sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (typeDefs [k].MethodList < indx)  				i = k + 1;  			else  				j = k;  		}  		j = i;  		while (j < n - 1 && typeDefs [j + 1].MethodList == indx)  			j++;  	}  	for (; j >= 0; j--) {  		if (typeDefs [j].MethodList <= indx) {  			declaringType = this.GetTypeFromDef (j + 1);  			break;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (declaringType == null) {  	int indx = index;  	MethodPtrRow[] methodPtrs = this.tables.MethodPtrTable;  	int n = methodPtrs.Length' i = 0' j = n - 1;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodPtr) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (methodPtrs [k].Method < index)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && methodPtrs [i - 1].Method == index)  			i--;  	}  	for (; i < n; i++) {  		if (methodPtrs [i].Method == index) {  			indx = i + 1;  			break;  		}  	}  	TypeDefRow[] typeDefs = this.tables.TypeDefTable;  	n = typeDefs.Length;  	i = 0;  	j = n - 1;  	sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (typeDefs [k].MethodList < indx)  				i = k + 1;  			else  				j = k;  		}  		j = i;  		while (j < n - 1 && typeDefs [j + 1].MethodList == indx)  			j++;  	}  	for (; j >= 0; j--) {  		if (typeDefs [j].MethodList <= indx) {  			declaringType = this.GetTypeFromDef (j + 1);  			break;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (declaringType == null) {  	int indx = index;  	MethodPtrRow[] methodPtrs = this.tables.MethodPtrTable;  	int n = methodPtrs.Length' i = 0' j = n - 1;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodPtr) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (methodPtrs [k].Method < index)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && methodPtrs [i - 1].Method == index)  			i--;  	}  	for (; i < n; i++) {  		if (methodPtrs [i].Method == index) {  			indx = i + 1;  			break;  		}  	}  	TypeDefRow[] typeDefs = this.tables.TypeDefTable;  	n = typeDefs.Length;  	i = 0;  	j = n - 1;  	sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (typeDefs [k].MethodList < indx)  				i = k + 1;  			else  				j = k;  		}  		j = i;  		while (j < n - 1 && typeDefs [j + 1].MethodList == indx)  			j++;  	}  	for (; j >= 0; j--) {  		if (typeDefs [j].MethodList <= indx) {  			declaringType = this.GetTypeFromDef (j + 1);  			break;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (declaringType == null) {  	int indx = index;  	MethodPtrRow[] methodPtrs = this.tables.MethodPtrTable;  	int n = methodPtrs.Length' i = 0' j = n - 1;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodPtr) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (methodPtrs [k].Method < index)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && methodPtrs [i - 1].Method == index)  			i--;  	}  	for (; i < n; i++) {  		if (methodPtrs [i].Method == index) {  			indx = i + 1;  			break;  		}  	}  	TypeDefRow[] typeDefs = this.tables.TypeDefTable;  	n = typeDefs.Length;  	i = 0;  	j = n - 1;  	sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if (typeDefs [k].MethodList < indx)  				i = k + 1;  			else  				j = k;  		}  		j = i;  		while (j < n - 1 && typeDefs [j + 1].MethodList == indx)  			j++;  	}  	for (; j >= 0; j--) {  		if (typeDefs [j].MethodList <= indx) {  			declaringType = this.GetTypeFromDef (j + 1);  			break;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (methodPtrs [k].Method < index)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && methodPtrs [i - 1].Method == index)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (methodPtrs [k].Method < index)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if (typeDefs [k].MethodList < indx)  			i = k + 1;  		else  			j = k;  	}  	j = i;  	while (j < n - 1 && typeDefs [j + 1].MethodList == indx)  		j++;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if (typeDefs [k].MethodList < indx)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if ((method.Flags & MethodFlags.PInvokeImpl) != 0) {  	ImplMapRow[] implMaps = this.tables.ImplMapTable;  	int n = implMaps.Length' i = 0' j = n - 1;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.ImplMap) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if ((implMaps [k].MemberForwarded >> 1) < index)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && (implMaps [i - 1].MemberForwarded >> 1) == index)  			i--;  	}  	for (; i < n; i++) {  		ImplMapRow imr = implMaps [i];  		if (imr.MemberForwarded >> 1 == index) {  			method.PInvokeFlags = (PInvokeFlags)imr.MappingFlags;  			method.PInvokeImportName = tables.GetString (imr.ImportName);  			method.PInvokeModule = this.module.ModuleReferences [imr.ImportScope - 1].Module;  			break;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if ((method.Flags & MethodFlags.PInvokeImpl) != 0) {  	ImplMapRow[] implMaps = this.tables.ImplMapTable;  	int n = implMaps.Length' i = 0' j = n - 1;  	bool sorted = (this.sortedTablesMask >> (int)TableIndices.ImplMap) % 2 == 1;  	if (sorted) {  		while (i < j) {  			int k = (i + j) / 2;  			if ((implMaps [k].MemberForwarded >> 1) < index)  				i = k + 1;  			else  				j = k;  		}  		while (i > 0 && (implMaps [i - 1].MemberForwarded >> 1) == index)  			i--;  	}  	for (; i < n; i++) {  		ImplMapRow imr = implMaps [i];  		if (imr.MemberForwarded >> 1 == index) {  			method.PInvokeFlags = (PInvokeFlags)imr.MappingFlags;  			method.PInvokeImportName = tables.GetString (imr.ImportName);  			method.PInvokeModule = this.module.ModuleReferences [imr.ImportScope - 1].Module;  			break;  		}  	}  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (sorted) {  	while (i < j) {  		int k = (i + j) / 2;  		if ((implMaps [k].MemberForwarded >> 1) < index)  			i = k + 1;  		else  			j = k;  	}  	while (i > 0 && (implMaps [i - 1].MemberForwarded >> 1) == index)  		i--;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: while (i < j) {  	int k = (i + j) / 2;  	if ((implMaps [k].MemberForwarded >> 1) < index)  		i = k + 1;  	else  		j = k;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodAttributes,The following statement contains a magic number: try {  	MetadataReader tables = this.tables;  	int index = (int)handle;  	MethodRow[] methodDefs = tables.MethodTable;  	int n = methodDefs.Length;  	if (index < 1 || index > n)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	MethodRow md = methodDefs [index - 1];  	if (method != md.Method)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	//Get custom attributes     	method.Attributes = this.GetCustomAttributesFor ((index << 5) | 0);  	this.currentTypeParameters = savedCurrentTypeParameters;  	this.currentMethodTypeParameters = savedCurrentMethodTypeParameters;  	//Get security attributes  	if ((method.Flags & MethodFlags.HasSecurity) != 0)  		method.SecurityAttributes = this.GetSecurityAttributesFor ((index << 2) | 1);  	#if !FxCop  } catch (Exception e) {  	if (this.module != null) {  		if (this.module.MetadataImportErrors == null)  			this.module.MetadataImportErrors = new ArrayList ();  		this.module.MetadataImportErrors.Add (e);  	}  	method.Attributes = new AttributeList (0);  	this.currentTypeParameters = savedCurrentTypeParameters;  	this.currentMethodTypeParameters = savedCurrentMethodTypeParameters;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodAttributes,The following statement contains a magic number: try {  	MetadataReader tables = this.tables;  	int index = (int)handle;  	MethodRow[] methodDefs = tables.MethodTable;  	int n = methodDefs.Length;  	if (index < 1 || index > n)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	MethodRow md = methodDefs [index - 1];  	if (method != md.Method)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	//Get custom attributes     	method.Attributes = this.GetCustomAttributesFor ((index << 5) | 0);  	this.currentTypeParameters = savedCurrentTypeParameters;  	this.currentMethodTypeParameters = savedCurrentMethodTypeParameters;  	//Get security attributes  	if ((method.Flags & MethodFlags.HasSecurity) != 0)  		method.SecurityAttributes = this.GetSecurityAttributesFor ((index << 2) | 1);  	#if !FxCop  } catch (Exception e) {  	if (this.module != null) {  		if (this.module.MetadataImportErrors == null)  			this.module.MetadataImportErrors = new ArrayList ();  		this.module.MetadataImportErrors.Add (e);  	}  	method.Attributes = new AttributeList (0);  	this.currentTypeParameters = savedCurrentTypeParameters;  	this.currentMethodTypeParameters = savedCurrentMethodTypeParameters;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodAttributes,The following statement contains a magic number: method.Attributes = this.GetCustomAttributesFor ((index << 5) | 0);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodAttributes,The following statement contains a magic number: if ((method.Flags & MethodFlags.HasSecurity) != 0)  	method.SecurityAttributes = this.GetSecurityAttributesFor ((index << 2) | 1);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodAttributes,The following statement contains a magic number: method.SecurityAttributes = this.GetSecurityAttributesFor ((index << 2) | 1);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromToken,The following statement contains a magic number: switch ((TableIndices)(tok >> 24)) {  case TableIndices.Field:  	member = this.GetFieldFromDef (tok & 0xFFFFFF);  	break;  case TableIndices.Method:  	member = this.GetMethodFromDef (tok & 0xFFFFFF);  	break;  case TableIndices.MemberRef:  	member = this.GetMemberFromRef (tok & 0xFFFFFF' out varArgTypes);  	break;  case TableIndices.TypeDef:  	member = this.GetTypeFromDef (tok & 0xFFFFFF);  	break;  case TableIndices.TypeRef:  	member = this.GetTypeFromRef (tok & 0xFFFFFF);  	break;  case TableIndices.TypeSpec:  	member = this.GetTypeFromSpec (tok & 0xFFFFFF);  	break;  case TableIndices.MethodSpec:  	member = this.GetMethodFromSpec (tok & 0xFFFFFF);  	break;  default:  	throw new InvalidMetadataException (ExceptionStrings.BadMemberToken);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (codedIndex & 0x7) {  case 0x00:  	parent = this.GetTypeFromDef (codedIndex >> 3);  	break;  case 0x01:  	parent = this.GetTypeFromRef (codedIndex >> 3);  	break;  case 0x02:  	parent = this.GetTypeGlobalMemberContainerTypeFromModule (codedIndex >> 3);  	break;  case 0x03:  	result = this.GetMethodFromDef (codedIndex >> 3);  	if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0) {  		MemoryCursor sRdr = this.tables.GetBlobCursor (mref.Signature);  		sRdr.ReadByte ();  		//hdr  		int pCount = sRdr.ReadCompressedInt ();  		this.ParseTypeSignature (sRdr);  		//rType  		bool genParameterEncountered = false;  		this.ParseParameterTypes (out varArgTypes' sRdr' pCount' ref genParameterEncountered);  	}  	goto done;  case 0x04:  	parent = this.GetTypeFromSpec (codedIndex >> 3);  	break;  default:  	throw new InvalidMetadataException ("");  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (codedIndex & 0x7) {  case 0x00:  	parent = this.GetTypeFromDef (codedIndex >> 3);  	break;  case 0x01:  	parent = this.GetTypeFromRef (codedIndex >> 3);  	break;  case 0x02:  	parent = this.GetTypeGlobalMemberContainerTypeFromModule (codedIndex >> 3);  	break;  case 0x03:  	result = this.GetMethodFromDef (codedIndex >> 3);  	if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0) {  		MemoryCursor sRdr = this.tables.GetBlobCursor (mref.Signature);  		sRdr.ReadByte ();  		//hdr  		int pCount = sRdr.ReadCompressedInt ();  		this.ParseTypeSignature (sRdr);  		//rType  		bool genParameterEncountered = false;  		this.ParseParameterTypes (out varArgTypes' sRdr' pCount' ref genParameterEncountered);  	}  	goto done;  case 0x04:  	parent = this.GetTypeFromSpec (codedIndex >> 3);  	break;  default:  	throw new InvalidMetadataException ("");  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (codedIndex & 0x7) {  case 0x00:  	parent = this.GetTypeFromDef (codedIndex >> 3);  	break;  case 0x01:  	parent = this.GetTypeFromRef (codedIndex >> 3);  	break;  case 0x02:  	parent = this.GetTypeGlobalMemberContainerTypeFromModule (codedIndex >> 3);  	break;  case 0x03:  	result = this.GetMethodFromDef (codedIndex >> 3);  	if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0) {  		MemoryCursor sRdr = this.tables.GetBlobCursor (mref.Signature);  		sRdr.ReadByte ();  		//hdr  		int pCount = sRdr.ReadCompressedInt ();  		this.ParseTypeSignature (sRdr);  		//rType  		bool genParameterEncountered = false;  		this.ParseParameterTypes (out varArgTypes' sRdr' pCount' ref genParameterEncountered);  	}  	goto done;  case 0x04:  	parent = this.GetTypeFromSpec (codedIndex >> 3);  	break;  default:  	throw new InvalidMetadataException ("");  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (codedIndex & 0x7) {  case 0x00:  	parent = this.GetTypeFromDef (codedIndex >> 3);  	break;  case 0x01:  	parent = this.GetTypeFromRef (codedIndex >> 3);  	break;  case 0x02:  	parent = this.GetTypeGlobalMemberContainerTypeFromModule (codedIndex >> 3);  	break;  case 0x03:  	result = this.GetMethodFromDef (codedIndex >> 3);  	if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0) {  		MemoryCursor sRdr = this.tables.GetBlobCursor (mref.Signature);  		sRdr.ReadByte ();  		//hdr  		int pCount = sRdr.ReadCompressedInt ();  		this.ParseTypeSignature (sRdr);  		//rType  		bool genParameterEncountered = false;  		this.ParseParameterTypes (out varArgTypes' sRdr' pCount' ref genParameterEncountered);  	}  	goto done;  case 0x04:  	parent = this.GetTypeFromSpec (codedIndex >> 3);  	break;  default:  	throw new InvalidMetadataException ("");  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (codedIndex & 0x7) {  case 0x00:  	parent = this.GetTypeFromDef (codedIndex >> 3);  	break;  case 0x01:  	parent = this.GetTypeFromRef (codedIndex >> 3);  	break;  case 0x02:  	parent = this.GetTypeGlobalMemberContainerTypeFromModule (codedIndex >> 3);  	break;  case 0x03:  	result = this.GetMethodFromDef (codedIndex >> 3);  	if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0) {  		MemoryCursor sRdr = this.tables.GetBlobCursor (mref.Signature);  		sRdr.ReadByte ();  		//hdr  		int pCount = sRdr.ReadCompressedInt ();  		this.ParseTypeSignature (sRdr);  		//rType  		bool genParameterEncountered = false;  		this.ParseParameterTypes (out varArgTypes' sRdr' pCount' ref genParameterEncountered);  	}  	goto done;  case 0x04:  	parent = this.GetTypeFromSpec (codedIndex >> 3);  	break;  default:  	throw new InvalidMetadataException ("");  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: parent = this.GetTypeFromDef (codedIndex >> 3);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: parent = this.GetTypeFromRef (codedIndex >> 3);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: parent = this.GetTypeGlobalMemberContainerTypeFromModule (codedIndex >> 3);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: result = this.GetMethodFromDef (codedIndex >> 3);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: parent = this.GetTypeFromSpec (codedIndex >> 3);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7) {  case 1:  	callingConvention |= CallingConventionFlags.C;  	break;  case 2:  	callingConvention |= CallingConventionFlags.StandardCall;  	break;  case 3:  	callingConvention |= CallingConventionFlags.ThisCall;  	break;  case 4:  	callingConvention |= CallingConventionFlags.FastCall;  	break;  case 5:  	callingConvention |= CallingConventionFlags.VarArg;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7) {  case 1:  	callingConvention |= CallingConventionFlags.C;  	break;  case 2:  	callingConvention |= CallingConventionFlags.StandardCall;  	break;  case 3:  	callingConvention |= CallingConventionFlags.ThisCall;  	break;  case 4:  	callingConvention |= CallingConventionFlags.FastCall;  	break;  case 5:  	callingConvention |= CallingConventionFlags.VarArg;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7) {  case 1:  	callingConvention |= CallingConventionFlags.C;  	break;  case 2:  	callingConvention |= CallingConventionFlags.StandardCall;  	break;  case 3:  	callingConvention |= CallingConventionFlags.ThisCall;  	break;  case 4:  	callingConvention |= CallingConventionFlags.FastCall;  	break;  case 5:  	callingConvention |= CallingConventionFlags.VarArg;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7) {  case 1:  	callingConvention |= CallingConventionFlags.C;  	break;  case 2:  	callingConvention |= CallingConventionFlags.StandardCall;  	break;  case 3:  	callingConvention |= CallingConventionFlags.ThisCall;  	break;  case 4:  	callingConvention |= CallingConventionFlags.FastCall;  	break;  case 5:  	callingConvention |= CallingConventionFlags.VarArg;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7) {  case 1:  	callingConvention |= CallingConventionFlags.C;  	break;  case 2:  	callingConvention |= CallingConventionFlags.StandardCall;  	break;  case 3:  	callingConvention |= CallingConventionFlags.ThisCall;  	break;  case 4:  	callingConvention |= CallingConventionFlags.FastCall;  	break;  case 5:  	callingConvention |= CallingConventionFlags.VarArg;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetForwardedTypeFromName,The following statement contains a magic number: for (int i = 0' n = exportedTypes == null ? 0 : exportedTypes.Length; i < n; i++) {  	ExportedTypeRow etr = exportedTypes [i];  	if ((etr.Flags & (int)TypeFlags.Forwarder) == 0)  		continue;  	if (this.tables.GetString (etr.TypeNamespace) != Namespace.Name || this.tables.GetString (etr.TypeName) != name.Name)  		continue;  	int index = etr.Implementation >> 2;  	AssemblyRefRow arr = this.tables.AssemblyRefTable [index - 1];  	return arr.AssemblyReference.Assembly.GetType (Namespace' name);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeFromRef,The following statement contains a magic number: switch (resolutionScope & 0x3) {  case 0:  	declaringModule = this.module;  	//^ assume declaringModule != null;  	result = declaringModule.GetType (namesp' name);  	//REVIEW: deal with case where ref is in same (multi-module) assembly' but not the current module? index == 0  	break;  case 1:  	declaringModule = this.tables.ModuleRefTable [index - 1].Module;  	if (declaringModule != null)  		result = declaringModule.GetType (namesp' name);  	break;  case 2:  	declaringModule = this.tables.AssemblyRefTable [index - 1].AssemblyReference.Assembly;  	if (declaringModule != null)  		result = declaringModule.GetType (namesp' name);  	break;  case 3:  	declaringType = this.GetTypeFromRef (index);  	declaringModule = declaringType.DeclaringModule;  	if (namesp == null || namesp.length == 0)  		result = (TypeNode)declaringType.GetMembersNamed (name) [0];  	else  		result = (TypeNode)declaringType.GetMembersNamed (Identifier.For (namesp.Name + "." + name.Name)) [0];  	break;  default:  	declaringModule = this.module;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeFromRef,The following statement contains a magic number: switch (resolutionScope & 0x3) {  case 0:  	declaringModule = this.module;  	//^ assume declaringModule != null;  	result = declaringModule.GetType (namesp' name);  	//REVIEW: deal with case where ref is in same (multi-module) assembly' but not the current module? index == 0  	break;  case 1:  	declaringModule = this.tables.ModuleRefTable [index - 1].Module;  	if (declaringModule != null)  		result = declaringModule.GetType (namesp' name);  	break;  case 2:  	declaringModule = this.tables.AssemblyRefTable [index - 1].AssemblyReference.Assembly;  	if (declaringModule != null)  		result = declaringModule.GetType (namesp' name);  	break;  case 3:  	declaringType = this.GetTypeFromRef (index);  	declaringModule = declaringType.DeclaringModule;  	if (namesp == null || namesp.length == 0)  		result = (TypeNode)declaringType.GetMembersNamed (name) [0];  	else  		result = (TypeNode)declaringType.GetMembersNamed (Identifier.For (namesp.Name + "." + name.Name)) [0];  	break;  default:  	declaringModule = this.module;  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: for (int i = 0' n = exportedTypes.Length; i < n; i++) {  	ExportedTypeRow etr = exportedTypes [i];  	Identifier nameSpace = Identifier.For (this.tables.GetString (etr.TypeNamespace));  	Identifier typeName = Identifier.For (this.tables.GetString (etr.TypeName));  	TypeNode exportedType = null;  	switch (etr.Implementation & 0x3) {  	case 0:  		string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  		string modLocation = modName;  		Module mod = GetNestedModule (assem' modName' ref modLocation);  		if (mod == null) {  			Debug.Assert (false);  			break;  		}  		exportedType = mod.GetType (nameSpace' typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Namespace = nameSpace;  			exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  			exportedType.DeclaringModule = mod;  		}  		break;  	case 1:  		AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  		if (aref == null) {  			HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  			aref = new AssemblyReference ("dummy assembly for bad reference");  		}  		AssemblyNode a = aref.Assembly;  		if (a == null) {  			Debug.Assert (false);  			continue;  		}  		exportedType = a.GetType (nameSpace' typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Namespace = nameSpace;  			exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  			exportedType.DeclaringModule = a;  		}  		break;  	case 2:  		TypeNode parentType = types [(etr.Implementation >> 2) - 1];  		if (parentType == null) {  			HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  			parentType = new Class ();  			parentType.DeclaringModule = this.module;  			parentType.Name = Identifier.For ("Missing parent type");  		}  		exportedType = parentType.GetNestedType (typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  			exportedType.DeclaringType = parentType;  			exportedType.DeclaringModule = parentType.DeclaringModule;  		}  		break;  	}  	types.Add (exportedType);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: for (int i = 0' n = exportedTypes.Length; i < n; i++) {  	ExportedTypeRow etr = exportedTypes [i];  	Identifier nameSpace = Identifier.For (this.tables.GetString (etr.TypeNamespace));  	Identifier typeName = Identifier.For (this.tables.GetString (etr.TypeName));  	TypeNode exportedType = null;  	switch (etr.Implementation & 0x3) {  	case 0:  		string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  		string modLocation = modName;  		Module mod = GetNestedModule (assem' modName' ref modLocation);  		if (mod == null) {  			Debug.Assert (false);  			break;  		}  		exportedType = mod.GetType (nameSpace' typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Namespace = nameSpace;  			exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  			exportedType.DeclaringModule = mod;  		}  		break;  	case 1:  		AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  		if (aref == null) {  			HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  			aref = new AssemblyReference ("dummy assembly for bad reference");  		}  		AssemblyNode a = aref.Assembly;  		if (a == null) {  			Debug.Assert (false);  			continue;  		}  		exportedType = a.GetType (nameSpace' typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Namespace = nameSpace;  			exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  			exportedType.DeclaringModule = a;  		}  		break;  	case 2:  		TypeNode parentType = types [(etr.Implementation >> 2) - 1];  		if (parentType == null) {  			HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  			parentType = new Class ();  			parentType.DeclaringModule = this.module;  			parentType.Name = Identifier.For ("Missing parent type");  		}  		exportedType = parentType.GetNestedType (typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  			exportedType.DeclaringType = parentType;  			exportedType.DeclaringModule = parentType.DeclaringModule;  		}  		break;  	}  	types.Add (exportedType);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: for (int i = 0' n = exportedTypes.Length; i < n; i++) {  	ExportedTypeRow etr = exportedTypes [i];  	Identifier nameSpace = Identifier.For (this.tables.GetString (etr.TypeNamespace));  	Identifier typeName = Identifier.For (this.tables.GetString (etr.TypeName));  	TypeNode exportedType = null;  	switch (etr.Implementation & 0x3) {  	case 0:  		string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  		string modLocation = modName;  		Module mod = GetNestedModule (assem' modName' ref modLocation);  		if (mod == null) {  			Debug.Assert (false);  			break;  		}  		exportedType = mod.GetType (nameSpace' typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Namespace = nameSpace;  			exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  			exportedType.DeclaringModule = mod;  		}  		break;  	case 1:  		AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  		if (aref == null) {  			HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  			aref = new AssemblyReference ("dummy assembly for bad reference");  		}  		AssemblyNode a = aref.Assembly;  		if (a == null) {  			Debug.Assert (false);  			continue;  		}  		exportedType = a.GetType (nameSpace' typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Namespace = nameSpace;  			exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  			exportedType.DeclaringModule = a;  		}  		break;  	case 2:  		TypeNode parentType = types [(etr.Implementation >> 2) - 1];  		if (parentType == null) {  			HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  			parentType = new Class ();  			parentType.DeclaringModule = this.module;  			parentType.Name = Identifier.For ("Missing parent type");  		}  		exportedType = parentType.GetNestedType (typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  			exportedType.DeclaringType = parentType;  			exportedType.DeclaringModule = parentType.DeclaringModule;  		}  		break;  	}  	types.Add (exportedType);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: for (int i = 0' n = exportedTypes.Length; i < n; i++) {  	ExportedTypeRow etr = exportedTypes [i];  	Identifier nameSpace = Identifier.For (this.tables.GetString (etr.TypeNamespace));  	Identifier typeName = Identifier.For (this.tables.GetString (etr.TypeName));  	TypeNode exportedType = null;  	switch (etr.Implementation & 0x3) {  	case 0:  		string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  		string modLocation = modName;  		Module mod = GetNestedModule (assem' modName' ref modLocation);  		if (mod == null) {  			Debug.Assert (false);  			break;  		}  		exportedType = mod.GetType (nameSpace' typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Namespace = nameSpace;  			exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  			exportedType.DeclaringModule = mod;  		}  		break;  	case 1:  		AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  		if (aref == null) {  			HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  			aref = new AssemblyReference ("dummy assembly for bad reference");  		}  		AssemblyNode a = aref.Assembly;  		if (a == null) {  			Debug.Assert (false);  			continue;  		}  		exportedType = a.GetType (nameSpace' typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Namespace = nameSpace;  			exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  			exportedType.DeclaringModule = a;  		}  		break;  	case 2:  		TypeNode parentType = types [(etr.Implementation >> 2) - 1];  		if (parentType == null) {  			HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  			parentType = new Class ();  			parentType.DeclaringModule = this.module;  			parentType.Name = Identifier.For ("Missing parent type");  		}  		exportedType = parentType.GetNestedType (typeName);  		if (exportedType == null) {  			HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  			exportedType = new Class ();  			exportedType.Name = typeName;  			exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  			exportedType.DeclaringType = parentType;  			exportedType.DeclaringModule = parentType.DeclaringModule;  		}  		break;  	}  	types.Add (exportedType);  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: switch (etr.Implementation & 0x3) {  case 0:  	string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  	string modLocation = modName;  	Module mod = GetNestedModule (assem' modName' ref modLocation);  	if (mod == null) {  		Debug.Assert (false);  		break;  	}  	exportedType = mod.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = mod;  	}  	break;  case 1:  	AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  	if (aref == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  		aref = new AssemblyReference ("dummy assembly for bad reference");  	}  	AssemblyNode a = aref.Assembly;  	if (a == null) {  		Debug.Assert (false);  		continue;  	}  	exportedType = a.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = a;  	}  	break;  case 2:  	TypeNode parentType = types [(etr.Implementation >> 2) - 1];  	if (parentType == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  		parentType = new Class ();  		parentType.DeclaringModule = this.module;  		parentType.Name = Identifier.For ("Missing parent type");  	}  	exportedType = parentType.GetNestedType (typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  		exportedType.DeclaringType = parentType;  		exportedType.DeclaringModule = parentType.DeclaringModule;  	}  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: switch (etr.Implementation & 0x3) {  case 0:  	string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  	string modLocation = modName;  	Module mod = GetNestedModule (assem' modName' ref modLocation);  	if (mod == null) {  		Debug.Assert (false);  		break;  	}  	exportedType = mod.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = mod;  	}  	break;  case 1:  	AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  	if (aref == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  		aref = new AssemblyReference ("dummy assembly for bad reference");  	}  	AssemblyNode a = aref.Assembly;  	if (a == null) {  		Debug.Assert (false);  		continue;  	}  	exportedType = a.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = a;  	}  	break;  case 2:  	TypeNode parentType = types [(etr.Implementation >> 2) - 1];  	if (parentType == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  		parentType = new Class ();  		parentType.DeclaringModule = this.module;  		parentType.Name = Identifier.For ("Missing parent type");  	}  	exportedType = parentType.GetNestedType (typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  		exportedType.DeclaringType = parentType;  		exportedType.DeclaringModule = parentType.DeclaringModule;  	}  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: switch (etr.Implementation & 0x3) {  case 0:  	string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  	string modLocation = modName;  	Module mod = GetNestedModule (assem' modName' ref modLocation);  	if (mod == null) {  		Debug.Assert (false);  		break;  	}  	exportedType = mod.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = mod;  	}  	break;  case 1:  	AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  	if (aref == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  		aref = new AssemblyReference ("dummy assembly for bad reference");  	}  	AssemblyNode a = aref.Assembly;  	if (a == null) {  		Debug.Assert (false);  		continue;  	}  	exportedType = a.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = a;  	}  	break;  case 2:  	TypeNode parentType = types [(etr.Implementation >> 2) - 1];  	if (parentType == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  		parentType = new Class ();  		parentType.DeclaringModule = this.module;  		parentType.Name = Identifier.For ("Missing parent type");  	}  	exportedType = parentType.GetNestedType (typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  		exportedType.DeclaringType = parentType;  		exportedType.DeclaringModule = parentType.DeclaringModule;  	}  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: switch (etr.Implementation & 0x3) {  case 0:  	string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  	string modLocation = modName;  	Module mod = GetNestedModule (assem' modName' ref modLocation);  	if (mod == null) {  		Debug.Assert (false);  		break;  	}  	exportedType = mod.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = mod;  	}  	break;  case 1:  	AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  	if (aref == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  		aref = new AssemblyReference ("dummy assembly for bad reference");  	}  	AssemblyNode a = aref.Assembly;  	if (a == null) {  		Debug.Assert (false);  		continue;  	}  	exportedType = a.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = a;  	}  	break;  case 2:  	TypeNode parentType = types [(etr.Implementation >> 2) - 1];  	if (parentType == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  		parentType = new Class ();  		parentType.DeclaringModule = this.module;  		parentType.Name = Identifier.For ("Missing parent type");  	}  	exportedType = parentType.GetNestedType (typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  		exportedType.DeclaringType = parentType;  		exportedType.DeclaringModule = parentType.DeclaringModule;  	}  	break;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: try {  	MetadataReader tables = this.tables;  	int typeTableIndex = (int)handle;  	TypeDefRow[] typeDefs = tables.TypeDefTable;  	int n = typeDefs.Length;  	if (typeTableIndex < 1 || typeTableIndex > n)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	TypeDefRow td = typeDefs [typeTableIndex - 1];  	if (type != td.Type)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	//Get custom attributes     	type.Attributes = this.GetCustomAttributesFor ((typeTableIndex << 5) | 3);  	this.currentTypeParameters = savedCurrentTypeParameters;  	//Get security attributes  	if ((type.Flags & TypeFlags.HasSecurity) != 0)  		type.SecurityAttributes = this.GetSecurityAttributesFor ((typeTableIndex << 2) | 0);  	#if !FxCop  } catch (Exception e) {  	if (this.module != null) {  		if (this.module.MetadataImportErrors == null)  			this.module.MetadataImportErrors = new ArrayList ();  		this.module.MetadataImportErrors.Add (e);  	}  	type.Attributes = new AttributeList (0);  	this.currentTypeParameters = savedCurrentTypeParameters;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: try {  	MetadataReader tables = this.tables;  	int typeTableIndex = (int)handle;  	TypeDefRow[] typeDefs = tables.TypeDefTable;  	int n = typeDefs.Length;  	if (typeTableIndex < 1 || typeTableIndex > n)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	TypeDefRow td = typeDefs [typeTableIndex - 1];  	if (type != td.Type)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	//Get custom attributes     	type.Attributes = this.GetCustomAttributesFor ((typeTableIndex << 5) | 3);  	this.currentTypeParameters = savedCurrentTypeParameters;  	//Get security attributes  	if ((type.Flags & TypeFlags.HasSecurity) != 0)  		type.SecurityAttributes = this.GetSecurityAttributesFor ((typeTableIndex << 2) | 0);  	#if !FxCop  } catch (Exception e) {  	if (this.module != null) {  		if (this.module.MetadataImportErrors == null)  			this.module.MetadataImportErrors = new ArrayList ();  		this.module.MetadataImportErrors.Add (e);  	}  	type.Attributes = new AttributeList (0);  	this.currentTypeParameters = savedCurrentTypeParameters;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: try {  	MetadataReader tables = this.tables;  	int typeTableIndex = (int)handle;  	TypeDefRow[] typeDefs = tables.TypeDefTable;  	int n = typeDefs.Length;  	if (typeTableIndex < 1 || typeTableIndex > n)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	TypeDefRow td = typeDefs [typeTableIndex - 1];  	if (type != td.Type)  		throw new System.ArgumentOutOfRangeException ("handle"' ExceptionStrings.InvalidTypeTableIndex);  	//Get custom attributes     	type.Attributes = this.GetCustomAttributesFor ((typeTableIndex << 5) | 3);  	this.currentTypeParameters = savedCurrentTypeParameters;  	//Get security attributes  	if ((type.Flags & TypeFlags.HasSecurity) != 0)  		type.SecurityAttributes = this.GetSecurityAttributesFor ((typeTableIndex << 2) | 0);  	#if !FxCop  } catch (Exception e) {  	if (this.module != null) {  		if (this.module.MetadataImportErrors == null)  			this.module.MetadataImportErrors = new ArrayList ();  		this.module.MetadataImportErrors.Add (e);  	}  	type.Attributes = new AttributeList (0);  	this.currentTypeParameters = savedCurrentTypeParameters;  }  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: type.Attributes = this.GetCustomAttributesFor ((typeTableIndex << 5) | 3);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: type.Attributes = this.GetCustomAttributesFor ((typeTableIndex << 5) | 3);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: if ((type.Flags & TypeFlags.HasSecurity) != 0)  	type.SecurityAttributes = this.GetSecurityAttributesFor ((typeTableIndex << 2) | 0);  
Magic Number,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: type.SecurityAttributes = this.GetSecurityAttributesFor ((typeTableIndex << 2) | 0);  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2) {  	this.size = header >> 2;  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  } else {  	method.InitLocals = (header & 0x10) != 0;  	byte header2 = this.reader.tables.GetByte ();  	int fatHeaderSize = header2 >> 4;  	if (fatHeaderSize == 2)  		return;  	if (fatHeaderSize != 3)  		throw new InvalidMetadataException (ExceptionStrings.InvalidFatMethodHeader);  	this.reader.tables.Skip (2);  	//Skip over maxstack. No need to remember it.  	this.size = this.reader.tables.GetInt32 ();  	int localIndex = this.reader.tables.GetInt32 ();  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  	this.reader.tables.AlignTo32BitBoundary ();  	while ((header & 0x8) != 0) {  		header = this.reader.tables.GetByte ();  		if ((header & 3) != 1)  			throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  		if ((header & 0x80) != 0)  			throw new InvalidMetadataException (ExceptionStrings.TooManyMethodHeaderSections);  		this.ParseExceptionHandlerEntry ((header & 0x40) == 0);  	}  	Hashtable localSourceNames = new Hashtable ();  	#if UseSingularityPDB  	        if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {           PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);           if (pdbFunc != null)             this.GetLocalNames(pdbFunc.scopes' localSourceNames);         } #elif !ROTOR  	if (this.reader.getDebugSymbols && this.reader.debugReader != null) {  		ISymUnmanagedMethod methodInfo = null;  		try {  			try {  				this.reader.debugReader.GetMethod (0x6000000 | (uint)methodIndex' ref methodInfo);  				if (methodInfo != null) {  					ISymUnmanagedScope rootScope = methodInfo.GetRootScope ();  					try {  						this.reader.GetLocalSourceNames (rootScope' localSourceNames);  					} finally {  						if (rootScope != null)  							Marshal.ReleaseComObject (rootScope);  					}  				}  			} catch (COMException) {  			} catch (InvalidCastException) {  			} catch (System.Runtime.InteropServices.InvalidComObjectException) {  			}  		} finally {  			if (methodInfo != null)  				Marshal.ReleaseComObject (methodInfo);  		}  	}  	#endif  	this.reader.GetLocals (localIndex' this.locals' localSourceNames);  }  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2) {  	this.size = header >> 2;  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  } else {  	method.InitLocals = (header & 0x10) != 0;  	byte header2 = this.reader.tables.GetByte ();  	int fatHeaderSize = header2 >> 4;  	if (fatHeaderSize == 2)  		return;  	if (fatHeaderSize != 3)  		throw new InvalidMetadataException (ExceptionStrings.InvalidFatMethodHeader);  	this.reader.tables.Skip (2);  	//Skip over maxstack. No need to remember it.  	this.size = this.reader.tables.GetInt32 ();  	int localIndex = this.reader.tables.GetInt32 ();  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  	this.reader.tables.AlignTo32BitBoundary ();  	while ((header & 0x8) != 0) {  		header = this.reader.tables.GetByte ();  		if ((header & 3) != 1)  			throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  		if ((header & 0x80) != 0)  			throw new InvalidMetadataException (ExceptionStrings.TooManyMethodHeaderSections);  		this.ParseExceptionHandlerEntry ((header & 0x40) == 0);  	}  	Hashtable localSourceNames = new Hashtable ();  	#if UseSingularityPDB  	        if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {           PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);           if (pdbFunc != null)             this.GetLocalNames(pdbFunc.scopes' localSourceNames);         } #elif !ROTOR  	if (this.reader.getDebugSymbols && this.reader.debugReader != null) {  		ISymUnmanagedMethod methodInfo = null;  		try {  			try {  				this.reader.debugReader.GetMethod (0x6000000 | (uint)methodIndex' ref methodInfo);  				if (methodInfo != null) {  					ISymUnmanagedScope rootScope = methodInfo.GetRootScope ();  					try {  						this.reader.GetLocalSourceNames (rootScope' localSourceNames);  					} finally {  						if (rootScope != null)  							Marshal.ReleaseComObject (rootScope);  					}  				}  			} catch (COMException) {  			} catch (InvalidCastException) {  			} catch (System.Runtime.InteropServices.InvalidComObjectException) {  			}  		} finally {  			if (methodInfo != null)  				Marshal.ReleaseComObject (methodInfo);  		}  	}  	#endif  	this.reader.GetLocals (localIndex' this.locals' localSourceNames);  }  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2) {  	this.size = header >> 2;  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  } else {  	method.InitLocals = (header & 0x10) != 0;  	byte header2 = this.reader.tables.GetByte ();  	int fatHeaderSize = header2 >> 4;  	if (fatHeaderSize == 2)  		return;  	if (fatHeaderSize != 3)  		throw new InvalidMetadataException (ExceptionStrings.InvalidFatMethodHeader);  	this.reader.tables.Skip (2);  	//Skip over maxstack. No need to remember it.  	this.size = this.reader.tables.GetInt32 ();  	int localIndex = this.reader.tables.GetInt32 ();  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  	this.reader.tables.AlignTo32BitBoundary ();  	while ((header & 0x8) != 0) {  		header = this.reader.tables.GetByte ();  		if ((header & 3) != 1)  			throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  		if ((header & 0x80) != 0)  			throw new InvalidMetadataException (ExceptionStrings.TooManyMethodHeaderSections);  		this.ParseExceptionHandlerEntry ((header & 0x40) == 0);  	}  	Hashtable localSourceNames = new Hashtable ();  	#if UseSingularityPDB  	        if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {           PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);           if (pdbFunc != null)             this.GetLocalNames(pdbFunc.scopes' localSourceNames);         } #elif !ROTOR  	if (this.reader.getDebugSymbols && this.reader.debugReader != null) {  		ISymUnmanagedMethod methodInfo = null;  		try {  			try {  				this.reader.debugReader.GetMethod (0x6000000 | (uint)methodIndex' ref methodInfo);  				if (methodInfo != null) {  					ISymUnmanagedScope rootScope = methodInfo.GetRootScope ();  					try {  						this.reader.GetLocalSourceNames (rootScope' localSourceNames);  					} finally {  						if (rootScope != null)  							Marshal.ReleaseComObject (rootScope);  					}  				}  			} catch (COMException) {  			} catch (InvalidCastException) {  			} catch (System.Runtime.InteropServices.InvalidComObjectException) {  			}  		} finally {  			if (methodInfo != null)  				Marshal.ReleaseComObject (methodInfo);  		}  	}  	#endif  	this.reader.GetLocals (localIndex' this.locals' localSourceNames);  }  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2) {  	this.size = header >> 2;  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  } else {  	method.InitLocals = (header & 0x10) != 0;  	byte header2 = this.reader.tables.GetByte ();  	int fatHeaderSize = header2 >> 4;  	if (fatHeaderSize == 2)  		return;  	if (fatHeaderSize != 3)  		throw new InvalidMetadataException (ExceptionStrings.InvalidFatMethodHeader);  	this.reader.tables.Skip (2);  	//Skip over maxstack. No need to remember it.  	this.size = this.reader.tables.GetInt32 ();  	int localIndex = this.reader.tables.GetInt32 ();  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  	this.reader.tables.AlignTo32BitBoundary ();  	while ((header & 0x8) != 0) {  		header = this.reader.tables.GetByte ();  		if ((header & 3) != 1)  			throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  		if ((header & 0x80) != 0)  			throw new InvalidMetadataException (ExceptionStrings.TooManyMethodHeaderSections);  		this.ParseExceptionHandlerEntry ((header & 0x40) == 0);  	}  	Hashtable localSourceNames = new Hashtable ();  	#if UseSingularityPDB  	        if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {           PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);           if (pdbFunc != null)             this.GetLocalNames(pdbFunc.scopes' localSourceNames);         } #elif !ROTOR  	if (this.reader.getDebugSymbols && this.reader.debugReader != null) {  		ISymUnmanagedMethod methodInfo = null;  		try {  			try {  				this.reader.debugReader.GetMethod (0x6000000 | (uint)methodIndex' ref methodInfo);  				if (methodInfo != null) {  					ISymUnmanagedScope rootScope = methodInfo.GetRootScope ();  					try {  						this.reader.GetLocalSourceNames (rootScope' localSourceNames);  					} finally {  						if (rootScope != null)  							Marshal.ReleaseComObject (rootScope);  					}  				}  			} catch (COMException) {  			} catch (InvalidCastException) {  			} catch (System.Runtime.InteropServices.InvalidComObjectException) {  			}  		} finally {  			if (methodInfo != null)  				Marshal.ReleaseComObject (methodInfo);  		}  	}  	#endif  	this.reader.GetLocals (localIndex' this.locals' localSourceNames);  }  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2) {  	this.size = header >> 2;  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  } else {  	method.InitLocals = (header & 0x10) != 0;  	byte header2 = this.reader.tables.GetByte ();  	int fatHeaderSize = header2 >> 4;  	if (fatHeaderSize == 2)  		return;  	if (fatHeaderSize != 3)  		throw new InvalidMetadataException (ExceptionStrings.InvalidFatMethodHeader);  	this.reader.tables.Skip (2);  	//Skip over maxstack. No need to remember it.  	this.size = this.reader.tables.GetInt32 ();  	int localIndex = this.reader.tables.GetInt32 ();  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  	this.reader.tables.AlignTo32BitBoundary ();  	while ((header & 0x8) != 0) {  		header = this.reader.tables.GetByte ();  		if ((header & 3) != 1)  			throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  		if ((header & 0x80) != 0)  			throw new InvalidMetadataException (ExceptionStrings.TooManyMethodHeaderSections);  		this.ParseExceptionHandlerEntry ((header & 0x40) == 0);  	}  	Hashtable localSourceNames = new Hashtable ();  	#if UseSingularityPDB  	        if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {           PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);           if (pdbFunc != null)             this.GetLocalNames(pdbFunc.scopes' localSourceNames);         } #elif !ROTOR  	if (this.reader.getDebugSymbols && this.reader.debugReader != null) {  		ISymUnmanagedMethod methodInfo = null;  		try {  			try {  				this.reader.debugReader.GetMethod (0x6000000 | (uint)methodIndex' ref methodInfo);  				if (methodInfo != null) {  					ISymUnmanagedScope rootScope = methodInfo.GetRootScope ();  					try {  						this.reader.GetLocalSourceNames (rootScope' localSourceNames);  					} finally {  						if (rootScope != null)  							Marshal.ReleaseComObject (rootScope);  					}  				}  			} catch (COMException) {  			} catch (InvalidCastException) {  			} catch (System.Runtime.InteropServices.InvalidComObjectException) {  			}  		} finally {  			if (methodInfo != null)  				Marshal.ReleaseComObject (methodInfo);  		}  	}  	#endif  	this.reader.GetLocals (localIndex' this.locals' localSourceNames);  }  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2) {  	this.size = header >> 2;  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  } else {  	method.InitLocals = (header & 0x10) != 0;  	byte header2 = this.reader.tables.GetByte ();  	int fatHeaderSize = header2 >> 4;  	if (fatHeaderSize == 2)  		return;  	if (fatHeaderSize != 3)  		throw new InvalidMetadataException (ExceptionStrings.InvalidFatMethodHeader);  	this.reader.tables.Skip (2);  	//Skip over maxstack. No need to remember it.  	this.size = this.reader.tables.GetInt32 ();  	int localIndex = this.reader.tables.GetInt32 ();  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  	this.reader.tables.AlignTo32BitBoundary ();  	while ((header & 0x8) != 0) {  		header = this.reader.tables.GetByte ();  		if ((header & 3) != 1)  			throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  		if ((header & 0x80) != 0)  			throw new InvalidMetadataException (ExceptionStrings.TooManyMethodHeaderSections);  		this.ParseExceptionHandlerEntry ((header & 0x40) == 0);  	}  	Hashtable localSourceNames = new Hashtable ();  	#if UseSingularityPDB  	        if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {           PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);           if (pdbFunc != null)             this.GetLocalNames(pdbFunc.scopes' localSourceNames);         } #elif !ROTOR  	if (this.reader.getDebugSymbols && this.reader.debugReader != null) {  		ISymUnmanagedMethod methodInfo = null;  		try {  			try {  				this.reader.debugReader.GetMethod (0x6000000 | (uint)methodIndex' ref methodInfo);  				if (methodInfo != null) {  					ISymUnmanagedScope rootScope = methodInfo.GetRootScope ();  					try {  						this.reader.GetLocalSourceNames (rootScope' localSourceNames);  					} finally {  						if (rootScope != null)  							Marshal.ReleaseComObject (rootScope);  					}  				}  			} catch (COMException) {  			} catch (InvalidCastException) {  			} catch (System.Runtime.InteropServices.InvalidComObjectException) {  			}  		} finally {  			if (methodInfo != null)  				Marshal.ReleaseComObject (methodInfo);  		}  	}  	#endif  	this.reader.GetLocals (localIndex' this.locals' localSourceNames);  }  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2) {  	this.size = header >> 2;  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  } else {  	method.InitLocals = (header & 0x10) != 0;  	byte header2 = this.reader.tables.GetByte ();  	int fatHeaderSize = header2 >> 4;  	if (fatHeaderSize == 2)  		return;  	if (fatHeaderSize != 3)  		throw new InvalidMetadataException (ExceptionStrings.InvalidFatMethodHeader);  	this.reader.tables.Skip (2);  	//Skip over maxstack. No need to remember it.  	this.size = this.reader.tables.GetInt32 ();  	int localIndex = this.reader.tables.GetInt32 ();  	this.bodyReader = this.reader.tables.GetNewCursor ();  	this.reader.tables.Skip (size);  	this.reader.tables.AlignTo32BitBoundary ();  	while ((header & 0x8) != 0) {  		header = this.reader.tables.GetByte ();  		if ((header & 3) != 1)  			throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  		if ((header & 0x80) != 0)  			throw new InvalidMetadataException (ExceptionStrings.TooManyMethodHeaderSections);  		this.ParseExceptionHandlerEntry ((header & 0x40) == 0);  	}  	Hashtable localSourceNames = new Hashtable ();  	#if UseSingularityPDB  	        if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {           PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);           if (pdbFunc != null)             this.GetLocalNames(pdbFunc.scopes' localSourceNames);         } #elif !ROTOR  	if (this.reader.getDebugSymbols && this.reader.debugReader != null) {  		ISymUnmanagedMethod methodInfo = null;  		try {  			try {  				this.reader.debugReader.GetMethod (0x6000000 | (uint)methodIndex' ref methodInfo);  				if (methodInfo != null) {  					ISymUnmanagedScope rootScope = methodInfo.GetRootScope ();  					try {  						this.reader.GetLocalSourceNames (rootScope' localSourceNames);  					} finally {  						if (rootScope != null)  							Marshal.ReleaseComObject (rootScope);  					}  				}  			} catch (COMException) {  			} catch (InvalidCastException) {  			} catch (System.Runtime.InteropServices.InvalidComObjectException) {  			}  		} finally {  			if (methodInfo != null)  				Marshal.ReleaseComObject (methodInfo);  		}  	}  	#endif  	this.reader.GetLocals (localIndex' this.locals' localSourceNames);  }  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: this.size = header >> 2;  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if (fatHeaderSize == 2)  	return;  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if (fatHeaderSize != 3)  	throw new InvalidMetadataException (ExceptionStrings.InvalidFatMethodHeader);  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: this.reader.tables.Skip (2);  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: while ((header & 0x8) != 0) {  	header = this.reader.tables.GetByte ();  	if ((header & 3) != 1)  		throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  	if ((header & 0x80) != 0)  		throw new InvalidMetadataException (ExceptionStrings.TooManyMethodHeaderSections);  	this.ParseExceptionHandlerEntry ((header & 0x40) == 0);  }  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 3) != 1)  	throw new InvalidMetadataException (ExceptionStrings.BadMethodHeaderSection);  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInt16,The following statement contains a magic number: this.counter += 2;  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInt32,The following statement contains a magic number: this.counter += 4;  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetInt64,The following statement contains a magic number: this.counter += 8;  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetSingle,The following statement contains a magic number: this.counter += 4;  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetDouble,The following statement contains a magic number: this.counter += 8;  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetOpCode,The following statement contains a magic number: if (result == (int)OpCode.Prefix1)  	result = result << 8 | this.GetByte ();  
Magic Number,System.Compiler.Metadata,ILParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetOpCode,The following statement contains a magic number: result = result << 8 | this.GetByte ();  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)  	n = dataSize / 12;  else  	n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)  	n = dataSize / 12;  else  	n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)  	n = dataSize / 12;  else  	n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: n = dataSize / 12;  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true) {  	bool isStatement = false;  	startingAddress = this.counter + 1;  	//Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  	#if !FxCop  	OpCode opCode = this.GetOpCode ();  	#else  	        this.ilOffset = this.counter;         if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){           expr.sourceContext = sourceContext;           expr.ILOffset = this.ilOffset;           this.operandStack.Push(expr);         }         this.opCode = this.GetOpCode(); #endif  	switch (opCode) {  	case OpCode.Nop:  		statement = new Statement (NodeType.Nop);  		goto done;  	case OpCode.Break:  		statement = new Statement (NodeType.DebugBreak);  		goto done;  	case OpCode.Ldarg_0:  		expr = this.Parameters (0);  		break;  	case OpCode.Ldarg_1:  		expr = this.Parameters (1);  		break;  	case OpCode.Ldarg_2:  		expr = this.Parameters (2);  		break;  	case OpCode.Ldarg_3:  		expr = this.Parameters (3);  		break;  	case OpCode.Ldloc_0:  		expr = this.locals [0];  		break;  	case OpCode.Ldloc_1:  		expr = this.locals [1];  		break;  	case OpCode.Ldloc_2:  		expr = this.locals [2];  		break;  	case OpCode.Ldloc_3:  		expr = this.locals [3];  		break;  	case OpCode.Stloc_0:  		statement = new AssignmentStatement (this.locals [0]' PopOperand ());  		goto done;  	case OpCode.Stloc_1:  		statement = new AssignmentStatement (this.locals [1]' PopOperand ());  		goto done;  	case OpCode.Stloc_2:  		statement = new AssignmentStatement (this.locals [2]' PopOperand ());  		goto done;  	case OpCode.Stloc_3:  		statement = new AssignmentStatement (this.locals [3]' PopOperand ());  		goto done;  	case OpCode.Ldarg_S:  		expr = this.Parameters (this.GetByte ());  		break;  	case OpCode.Ldarga_S:  		expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  		break;  	case OpCode.Starg_S:  		statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  		goto done;  	case OpCode.Ldloc_S:  		expr = this.locals [this.GetByte ()];  		break;  	case OpCode.Ldloca_S:  		expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc_S:  		statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  		goto done;  	case OpCode.Ldnull:  		expr = new Literal (null' CoreSystemTypes.Object);  		break;  	case OpCode.Ldc_I4_M1:  		expr = new Literal (-1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_0:  		expr = new Literal (0' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_1:  		expr = new Literal (1' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_2:  		expr = new Literal (2' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_3:  		expr = new Literal (3' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_4:  		expr = new Literal (4' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_5:  		expr = new Literal (5' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_6:  		expr = new Literal (6' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_7:  		expr = new Literal (7' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_8:  		expr = new Literal (8' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4_S:  		expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I4:  		expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  		break;  	case OpCode.Ldc_I8:  		expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  		break;  	case OpCode.Ldc_R4:  		expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  		break;  	case OpCode.Ldc_R8:  		expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  		break;  	case OpCode.Dup:  		statement = new ExpressionStatement (new Expression (NodeType.Dup));  		goto done;  	case OpCode.Pop:  		statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  		goto done;  	case OpCode.Jmp:  		expr = this.ParseCall (NodeType.Jmp' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Call:  		expr = this.ParseCall (NodeType.Call' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Calli:  		expr = this.ParseCalli (out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Ret:  		Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  		statement = new Return (retVal);  		transferStatement = true;  		goto done;  	case OpCode.Br_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse_S:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue_S:  		statement = this.ParseBranch (NodeType.Nop' 1' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq_S:  		statement = this.ParseBranch (NodeType.Eq' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un_S:  		statement = this.ParseBranch (NodeType.Ne' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un_S:  		statement = this.ParseBranch (NodeType.Ge' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un_S:  		statement = this.ParseBranch (NodeType.Gt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un_S:  		statement = this.ParseBranch (NodeType.Le' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un_S:  		statement = this.ParseBranch (NodeType.Lt' 2' true' true);  		transferStatement = true;  		goto done;  	case OpCode.Br:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brfalse:  		statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Brtrue:  		statement = this.ParseBranch (NodeType.Nop' 1' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Beq:  		statement = this.ParseBranch (NodeType.Eq' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bge:  		statement = this.ParseBranch (NodeType.Ge' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bgt:  		statement = this.ParseBranch (NodeType.Gt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Ble:  		statement = this.ParseBranch (NodeType.Le' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Blt:  		statement = this.ParseBranch (NodeType.Lt' 2' false' false);  		transferStatement = true;  		goto done;  	case OpCode.Bne_Un:  		statement = this.ParseBranch (NodeType.Ne' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bge_Un:  		statement = this.ParseBranch (NodeType.Ge' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Bgt_Un:  		statement = this.ParseBranch (NodeType.Gt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Ble_Un:  		statement = this.ParseBranch (NodeType.Le' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Blt_Un:  		statement = this.ParseBranch (NodeType.Lt' 2' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Switch:  		statement = this.ParseSwitchInstruction ();  		transferStatement = true;  		goto done;  	case OpCode.Ldind_I1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U1:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U2:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_U4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_I:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R4:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_R8:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldind_Ref:  		expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  		break;  	case OpCode.Stind_Ref:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  		goto done;  	case OpCode.Stind_I1:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  		goto done;  	case OpCode.Stind_I2:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  		goto done;  	case OpCode.Stind_I4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  		goto done;  	case OpCode.Stind_I8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  		goto done;  	case OpCode.Stind_R4:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  		goto done;  	case OpCode.Stind_R8:  		statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  		goto done;  	case OpCode.Add:  		expr = this.ParseBinaryOperation (NodeType.Add);  		break;  	case OpCode.Sub:  		expr = this.ParseBinaryOperation (NodeType.Sub);  		break;  	case OpCode.Mul:  		expr = this.ParseBinaryOperation (NodeType.Mul);  		break;  	case OpCode.Div:  		expr = this.ParseBinaryOperation (NodeType.Div);  		break;  	case OpCode.Div_Un:  		expr = this.ParseBinaryOperation (NodeType.Div_Un);  		break;  	case OpCode.Rem:  		expr = this.ParseBinaryOperation (NodeType.Rem);  		break;  	case OpCode.Rem_Un:  		expr = this.ParseBinaryOperation (NodeType.Rem_Un);  		break;  	case OpCode.And:  		expr = this.ParseBinaryOperation (NodeType.And);  		break;  	case OpCode.Or:  		expr = this.ParseBinaryOperation (NodeType.Or);  		break;  	case OpCode.Xor:  		expr = this.ParseBinaryOperation (NodeType.Xor);  		break;  	case OpCode.Shl:  		expr = this.ParseBinaryOperation (NodeType.Shl);  		break;  	case OpCode.Shr:  		expr = this.ParseBinaryOperation (NodeType.Shr);  		break;  	case OpCode.Shr_Un:  		expr = this.ParseBinaryOperation (NodeType.Shr_Un);  		break;  	case OpCode.Neg:  		expr = this.ParseUnaryOperation (NodeType.Neg);  		break;  	case OpCode.Not:  		expr = this.ParseUnaryOperation (NodeType.Not);  		break;  	case OpCode.Conv_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_R4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  		break;  	case OpCode.Conv_R8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  		break;  	case OpCode.Conv_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Callvirt:  		expr = this.ParseCall (NodeType.Callvirt' out isStatement);  		if (isStatement)  			goto done;  		break;  	case OpCode.Cpobj:  		statement = this.ParseCopyObject ();  		goto done;  	case OpCode.Ldobj:  		expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldstr:  		expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  		break;  	case OpCode.Newobj:  		expr = this.ParseConstruct ();  		break;  	case OpCode.Castclass:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  		break;  	case OpCode.Isinst:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  		break;  	case OpCode.Conv_R_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  		break;  	case OpCode.Unbox:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  		break;  	case OpCode.Throw:  		statement = new Throw (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Ldfld:  		expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldflda:  		expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stfld:  		statement = this.ParseStoreField ();  		goto done;  	case OpCode.Ldsfld:  		expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  		break;  	case OpCode.Ldsflda:  		expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  		break;  	case OpCode.Stsfld:  		statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  		goto done;  	case OpCode.Stobj:  		statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  		goto done;  	case OpCode.Conv_Ovf_I1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_I2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_I4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_I8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U1_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_U2_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_U4_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_U8_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  		break;  	case OpCode.Conv_Ovf_I_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U_Un:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Box:  		TypeNode t = (TypeNode)this.GetMemberFromToken ();  		TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  		expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  		break;  	case OpCode.Newarr:  		expr = this.ParseNewArray ();  		break;  	case OpCode.Ldlen:  		expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Ldelema:  		expr = this.ParseArrayElementLoadAddress ();  		break;  	case OpCode.Ldelem_I1:  	case OpCode.Ldelem_U1:  	case OpCode.Ldelem_I2:  	case OpCode.Ldelem_U2:  	case OpCode.Ldelem_I4:  	case OpCode.Ldelem_U4:  	case OpCode.Ldelem_I8:  	case OpCode.Ldelem_I:  	case OpCode.Ldelem_R4:  	case OpCode.Ldelem_R8:  	case OpCode.Ldelem_Ref:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem_I:  	case OpCode.Stelem_I1:  	case OpCode.Stelem_I2:  	case OpCode.Stelem_I4:  	case OpCode.Stelem_I8:  	case OpCode.Stelem_R4:  	case OpCode.Stelem_R8:  	case OpCode.Stelem_Ref:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Ldelem:  		expr = this.ParseArrayElementLoad (opCode' null);  		break;  	case OpCode.Stelem:  		statement = this.ParseArrayElementAssignment (opCode);  		goto done;  	case OpCode.Unbox_Any:  		expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  		break;  	case OpCode.Conv_Ovf_I1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  		break;  	case OpCode.Conv_Ovf_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_Ovf_I2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  		break;  	case OpCode.Conv_Ovf_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_Ovf_I4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  		break;  	case OpCode.Conv_Ovf_U4:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  		break;  	case OpCode.Conv_Ovf_I8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  		break;  	case OpCode.Conv_Ovf_U8:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  		break;  	case OpCode.Refanyval:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ckfinite:  		expr = this.ParseUnaryOperation (NodeType.Ckfinite);  		break;  	case OpCode.Mkrefany:  		expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  		break;  	case OpCode.Ldtoken:  		expr = ParseLoadRuntimeMetadataToken ();  		break;  	case OpCode.Conv_U2:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  		break;  	case OpCode.Conv_U1:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  		break;  	case OpCode.Conv_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_I:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Conv_Ovf_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Add_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  		break;  	case OpCode.Add_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  		break;  	case OpCode.Mul_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  		break;  	case OpCode.Mul_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  		break;  	case OpCode.Sub_Ovf:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  		break;  	case OpCode.Sub_Ovf_Un:  		expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  		break;  	case OpCode.Endfinally:  		statement = new EndFinally ();  		transferStatement = true;  		goto done;  	case OpCode.Leave:  		statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Leave_S:  		statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  		transferStatement = true;  		goto done;  	case OpCode.Stind_I:  		statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  		goto done;  	case OpCode.Conv_U:  		expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  		break;  	case OpCode.Arglist:  		expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  		break;  	case OpCode.Ceq:  		expr = this.ParseBinaryComparison (NodeType.Ceq);  		break;  	case OpCode.Cgt:  		expr = this.ParseBinaryComparison (NodeType.Cgt);  		break;  	case OpCode.Cgt_Un:  		expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  		break;  	case OpCode.Clt:  		expr = this.ParseBinaryComparison (NodeType.Clt);  		break;  	case OpCode.Clt_Un:  		expr = this.ParseBinaryComparison (NodeType.Clt_Un);  		break;  	case OpCode.Ldftn:  		expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldvirtftn:  		expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  		break;  	case OpCode.Ldarg:  		expr = this.Parameters ((ushort)this.GetInt16 ());  		break;  	case OpCode.Ldarga:  		expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  		break;  	case OpCode.Starg:  		statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  		goto done;  	case OpCode.Ldloc:  		expr = this.locals [(ushort)this.GetInt16 ()];  		break;  	case OpCode.Ldloca:  		expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  		break;  	case OpCode.Stloc:  		statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  		goto done;  	case OpCode.Localloc:  		expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  		break;  	case OpCode.Endfilter:  		statement = new EndFilter (PopOperand ());  		transferStatement = true;  		goto done;  	case OpCode.Unaligned_:  		this.alignment = this.GetByte ();  		continue;  	case OpCode.Volatile_:  		this.isVolatile = true;  		continue;  	case OpCode.Tail_:  		this.isTailCall = true;  		continue;  	case OpCode.Initobj:  		statement = this.ParseInitObject ();  		goto done;  	case OpCode.Constrained_:  		this.constraint = this.GetMemberFromToken () as TypeNode;  		continue;  	case OpCode.Cpblk:  		expr = this.ParseTernaryOperation (NodeType.Cpblk);  		goto done;  	case OpCode.Initblk:  		expr = this.ParseTernaryOperation (NodeType.Initblk);  		goto done;  	case OpCode.Rethrow:  		statement = new Throw (null);  		statement.NodeType = NodeType.Rethrow;  		transferStatement = true;  		goto done;  	case OpCode.Sizeof:  		expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  		break;  	case OpCode.Refanytype:  		expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  		break;  	case OpCode.Readonly_:  		this.isReadOnly = true;  		continue;  	default:  		throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  	}  	if (this.blockMap [this.counter + 1] != null) {  		transferStatement = true;  		//Falls through to the next basic block' so implicitly a "transfer" statement  		goto done;  	}  	//^ assume expr != null;  	#if FxCop  	        expr.sourceContext = sourceContext;         expr.ILOffset = this.ilOffset; #endif  	this.operandStack.Push (expr);  	this.isReadOnly = false;  	this.isVolatile = false;  	this.isTailCall = false;  	this.alignment = -1;  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  	statement = new Statement (NodeType.Nop);  	goto done;  case OpCode.Break:  	statement = new Statement (NodeType.DebugBreak);  	goto done;  case OpCode.Ldarg_0:  	expr = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	expr = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	expr = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	expr = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	expr = this.locals [0];  	break;  case OpCode.Ldloc_1:  	expr = this.locals [1];  	break;  case OpCode.Ldloc_2:  	expr = this.locals [2];  	break;  case OpCode.Ldloc_3:  	expr = this.locals [3];  	break;  case OpCode.Stloc_0:  	statement = new AssignmentStatement (this.locals [0]' PopOperand ());  	goto done;  case OpCode.Stloc_1:  	statement = new AssignmentStatement (this.locals [1]' PopOperand ());  	goto done;  case OpCode.Stloc_2:  	statement = new AssignmentStatement (this.locals [2]' PopOperand ());  	goto done;  case OpCode.Stloc_3:  	statement = new AssignmentStatement (this.locals [3]' PopOperand ());  	goto done;  case OpCode.Ldarg_S:  	expr = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldarga_S:  	expr = SetType (new UnaryExpression (this.Parameters (this.GetByte ())' NodeType.AddressOf));  	break;  case OpCode.Starg_S:  	statement = new AssignmentStatement (this.Parameters (this.GetByte ())' PopOperand ());  	goto done;  case OpCode.Ldloc_S:  	expr = this.locals [this.GetByte ()];  	break;  case OpCode.Ldloca_S:  	expr = SetType (new UnaryExpression (this.locals [this.GetByte ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc_S:  	statement = new AssignmentStatement (this.locals [this.GetByte ()]' PopOperand ());  	goto done;  case OpCode.Ldnull:  	expr = new Literal (null' CoreSystemTypes.Object);  	break;  case OpCode.Ldc_I4_M1:  	expr = new Literal (-1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_0:  	expr = new Literal (0' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_1:  	expr = new Literal (1' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_2:  	expr = new Literal (2' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_3:  	expr = new Literal (3' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_4:  	expr = new Literal (4' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_5:  	expr = new Literal (5' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_6:  	expr = new Literal (6' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_7:  	expr = new Literal (7' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_8:  	expr = new Literal (8' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4_S:  	expr = new Literal ((int)this.GetSByte ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I4:  	expr = new Literal (this.GetInt32 ()' CoreSystemTypes.Int32);  	break;  case OpCode.Ldc_I8:  	expr = new Literal (this.GetInt64 ()' CoreSystemTypes.Int64);  	break;  case OpCode.Ldc_R4:  	expr = new Literal (this.GetSingle ()' CoreSystemTypes.Single);  	break;  case OpCode.Ldc_R8:  	expr = new Literal (this.GetDouble ()' CoreSystemTypes.Double);  	break;  case OpCode.Dup:  	statement = new ExpressionStatement (new Expression (NodeType.Dup));  	goto done;  case OpCode.Pop:  	statement = new ExpressionStatement (new UnaryExpression (PopOperand ()' NodeType.Pop));  	goto done;  case OpCode.Jmp:  	expr = this.ParseCall (NodeType.Jmp' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Call:  	expr = this.ParseCall (NodeType.Call' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Calli:  	expr = this.ParseCalli (out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Ret:  	Expression retVal = BodyParser.TypeIsVoid (this.method.ReturnType) ? null : PopOperand ();  	statement = new Return (retVal);  	transferStatement = true;  	goto done;  case OpCode.Br_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse_S:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue_S:  	statement = this.ParseBranch (NodeType.Nop' 1' true' false);  	transferStatement = true;  	goto done;  case OpCode.Beq_S:  	statement = this.ParseBranch (NodeType.Eq' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bge_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Ble_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Blt_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un_S:  	statement = this.ParseBranch (NodeType.Ne' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un_S:  	statement = this.ParseBranch (NodeType.Ge' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un_S:  	statement = this.ParseBranch (NodeType.Gt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un_S:  	statement = this.ParseBranch (NodeType.Le' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un_S:  	statement = this.ParseBranch (NodeType.Lt' 2' true' true);  	transferStatement = true;  	goto done;  case OpCode.Br:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brfalse:  	statement = this.ParseBranch (NodeType.LogicalNot' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Brtrue:  	statement = this.ParseBranch (NodeType.Nop' 1' false' false);  	transferStatement = true;  	goto done;  case OpCode.Beq:  	statement = this.ParseBranch (NodeType.Eq' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bge:  	statement = this.ParseBranch (NodeType.Ge' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bgt:  	statement = this.ParseBranch (NodeType.Gt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Ble:  	statement = this.ParseBranch (NodeType.Le' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Blt:  	statement = this.ParseBranch (NodeType.Lt' 2' false' false);  	transferStatement = true;  	goto done;  case OpCode.Bne_Un:  	statement = this.ParseBranch (NodeType.Ne' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bge_Un:  	statement = this.ParseBranch (NodeType.Ge' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Bgt_Un:  	statement = this.ParseBranch (NodeType.Gt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Ble_Un:  	statement = this.ParseBranch (NodeType.Le' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Blt_Un:  	statement = this.ParseBranch (NodeType.Lt' 2' false' true);  	transferStatement = true;  	goto done;  case OpCode.Switch:  	statement = this.ParseSwitchInstruction ();  	transferStatement = true;  	goto done;  case OpCode.Ldind_I1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U1:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U2:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_U4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Int64' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_I:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R4:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Single' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_R8:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Double' this.isVolatile' this.alignment);  	break;  case OpCode.Ldind_Ref:  	expr = new AddressDereference (PopOperand ()' CoreSystemTypes.Object' this.isVolatile' this.alignment);  	break;  case OpCode.Stind_Ref:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Object);  	goto done;  case OpCode.Stind_I1:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int8);  	goto done;  case OpCode.Stind_I2:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int16);  	goto done;  case OpCode.Stind_I4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int32);  	goto done;  case OpCode.Stind_I8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Int64);  	goto done;  case OpCode.Stind_R4:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Single);  	goto done;  case OpCode.Stind_R8:  	statement = this.ParseStoreIndirect (CoreSystemTypes.Double);  	goto done;  case OpCode.Add:  	expr = this.ParseBinaryOperation (NodeType.Add);  	break;  case OpCode.Sub:  	expr = this.ParseBinaryOperation (NodeType.Sub);  	break;  case OpCode.Mul:  	expr = this.ParseBinaryOperation (NodeType.Mul);  	break;  case OpCode.Div:  	expr = this.ParseBinaryOperation (NodeType.Div);  	break;  case OpCode.Div_Un:  	expr = this.ParseBinaryOperation (NodeType.Div_Un);  	break;  case OpCode.Rem:  	expr = this.ParseBinaryOperation (NodeType.Rem);  	break;  case OpCode.Rem_Un:  	expr = this.ParseBinaryOperation (NodeType.Rem_Un);  	break;  case OpCode.And:  	expr = this.ParseBinaryOperation (NodeType.And);  	break;  case OpCode.Or:  	expr = this.ParseBinaryOperation (NodeType.Or);  	break;  case OpCode.Xor:  	expr = this.ParseBinaryOperation (NodeType.Xor);  	break;  case OpCode.Shl:  	expr = this.ParseBinaryOperation (NodeType.Shl);  	break;  case OpCode.Shr:  	expr = this.ParseBinaryOperation (NodeType.Shr);  	break;  case OpCode.Shr_Un:  	expr = this.ParseBinaryOperation (NodeType.Shr_Un);  	break;  case OpCode.Neg:  	expr = this.ParseUnaryOperation (NodeType.Neg);  	break;  case OpCode.Not:  	expr = this.ParseUnaryOperation (NodeType.Not);  	break;  case OpCode.Conv_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_R4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R4' CoreSystemTypes.Single);  	break;  case OpCode.Conv_R8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R8' CoreSystemTypes.Double);  	break;  case OpCode.Conv_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Callvirt:  	expr = this.ParseCall (NodeType.Callvirt' out isStatement);  	if (isStatement)  		goto done;  	break;  case OpCode.Cpobj:  	statement = this.ParseCopyObject ();  	goto done;  case OpCode.Ldobj:  	expr = new AddressDereference (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldstr:  	expr = new Literal (this.GetStringFromToken ()' CoreSystemTypes.String);  	break;  case OpCode.Newobj:  	expr = this.ParseConstruct ();  	break;  case OpCode.Castclass:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Castclass);  	break;  case OpCode.Isinst:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Isinst);  	break;  case OpCode.Conv_R_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_R_Un' CoreSystemTypes.Double);  	break;  case OpCode.Unbox:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.Unbox);  	break;  case OpCode.Throw:  	statement = new Throw (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Ldfld:  	expr = new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldflda:  	expr = SetType (new UnaryExpression (new MemberBinding (PopOperand ()' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stfld:  	statement = this.ParseStoreField ();  	goto done;  case OpCode.Ldsfld:  	expr = new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment);  	break;  case OpCode.Ldsflda:  	expr = SetType (new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' NodeType.AddressOf));  	break;  case OpCode.Stsfld:  	statement = new AssignmentStatement (new MemberBinding (null' this.GetMemberFromToken ()' this.isVolatile' this.alignment)' PopOperand ());  	goto done;  case OpCode.Stobj:  	statement = this.ParseStoreIndirect ((TypeNode)this.GetMemberFromToken ());  	goto done;  case OpCode.Conv_Ovf_I1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_I2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_I4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_I8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U1_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_U2_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_U4_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_U8_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64);  	break;  case OpCode.Conv_Ovf_I_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U_Un:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Box:  	TypeNode t = (TypeNode)this.GetMemberFromToken ();  	TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;  	expr = new BinaryExpression (PopOperand ()' new Literal (t' CoreSystemTypes.Type)' NodeType.Box' bt);  	break;  case OpCode.Newarr:  	expr = this.ParseNewArray ();  	break;  case OpCode.Ldlen:  	expr = new UnaryExpression (PopOperand ()' NodeType.Ldlen' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Ldelema:  	expr = this.ParseArrayElementLoadAddress ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Ldelem:  	expr = this.ParseArrayElementLoad (opCode' null);  	break;  case OpCode.Stelem:  	statement = this.ParseArrayElementAssignment (opCode);  	goto done;  case OpCode.Unbox_Any:  	expr = ParseTypeCheck (PopOperand ()' (TypeNode)this.GetMemberFromToken ()' NodeType.UnboxAny);  	break;  case OpCode.Conv_Ovf_I1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8);  	break;  case OpCode.Conv_Ovf_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_Ovf_I2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16);  	break;  case OpCode.Conv_Ovf_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_Ovf_I4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32);  	break;  case OpCode.Conv_Ovf_U4:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32);  	break;  case OpCode.Conv_Ovf_I8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64);  	break;  case OpCode.Conv_Ovf_U8:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64);  	break;  case OpCode.Refanyval:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ckfinite:  	expr = this.ParseUnaryOperation (NodeType.Ckfinite);  	break;  case OpCode.Mkrefany:  	expr = new BinaryExpression (PopOperand ()' new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference);  	break;  case OpCode.Ldtoken:  	expr = ParseLoadRuntimeMetadataToken ();  	break;  case OpCode.Conv_U2:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U2' CoreSystemTypes.UInt16);  	break;  case OpCode.Conv_U1:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U1' CoreSystemTypes.UInt8);  	break;  case OpCode.Conv_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_I:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr);  	break;  case OpCode.Conv_Ovf_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Add_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf);  	break;  case OpCode.Add_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Add_Ovf_Un);  	break;  case OpCode.Mul_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf);  	break;  case OpCode.Mul_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Mul_Ovf_Un);  	break;  case OpCode.Sub_Ovf:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf);  	break;  case OpCode.Sub_Ovf_Un:  	expr = this.ParseBinaryOperation (NodeType.Sub_Ovf_Un);  	break;  case OpCode.Endfinally:  	statement = new EndFinally ();  	transferStatement = true;  	goto done;  case OpCode.Leave:  	statement = this.ParseBranch (NodeType.Nop' 0' false' false' true);  	transferStatement = true;  	goto done;  case OpCode.Leave_S:  	statement = this.ParseBranch (NodeType.Nop' 0' true' false' true);  	transferStatement = true;  	goto done;  case OpCode.Stind_I:  	statement = this.ParseStoreIndirect (CoreSystemTypes.IntPtr);  	goto done;  case OpCode.Conv_U:  	expr = new UnaryExpression (PopOperand ()' NodeType.Conv_U' CoreSystemTypes.UIntPtr);  	break;  case OpCode.Arglist:  	expr = new Expression (NodeType.Arglist' CoreSystemTypes.ArgIterator);  	break;  case OpCode.Ceq:  	expr = this.ParseBinaryComparison (NodeType.Ceq);  	break;  case OpCode.Cgt:  	expr = this.ParseBinaryComparison (NodeType.Cgt);  	break;  case OpCode.Cgt_Un:  	expr = this.ParseBinaryComparison (NodeType.Cgt_Un);  	break;  case OpCode.Clt:  	expr = this.ParseBinaryComparison (NodeType.Clt);  	break;  case OpCode.Clt_Un:  	expr = this.ParseBinaryComparison (NodeType.Clt_Un);  	break;  case OpCode.Ldftn:  	expr = new UnaryExpression (new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldvirtftn:  	expr = new BinaryExpression (PopOperand ()' new MemberBinding (null' this.GetMemberFromToken ())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr);  	break;  case OpCode.Ldarg:  	expr = this.Parameters ((ushort)this.GetInt16 ());  	break;  case OpCode.Ldarga:  	expr = SetType (new UnaryExpression (this.Parameters ((ushort)this.GetInt16 ())' NodeType.AddressOf));  	break;  case OpCode.Starg:  	statement = new AssignmentStatement (this.Parameters ((ushort)this.GetInt16 ())' PopOperand ());  	goto done;  case OpCode.Ldloc:  	expr = this.locals [(ushort)this.GetInt16 ()];  	break;  case OpCode.Ldloca:  	expr = SetType (new UnaryExpression (this.locals [(ushort)this.GetInt16 ()]' NodeType.AddressOf));  	break;  case OpCode.Stloc:  	statement = new AssignmentStatement (this.locals [(ushort)this.GetInt16 ()]' PopOperand ());  	goto done;  case OpCode.Localloc:  	expr = new UnaryExpression (PopOperand ()' NodeType.Localloc' CoreSystemTypes.Void);  	break;  case OpCode.Endfilter:  	statement = new EndFilter (PopOperand ());  	transferStatement = true;  	goto done;  case OpCode.Unaligned_:  	this.alignment = this.GetByte ();  	continue;  case OpCode.Volatile_:  	this.isVolatile = true;  	continue;  case OpCode.Tail_:  	this.isTailCall = true;  	continue;  case OpCode.Initobj:  	statement = this.ParseInitObject ();  	goto done;  case OpCode.Constrained_:  	this.constraint = this.GetMemberFromToken () as TypeNode;  	continue;  case OpCode.Cpblk:  	expr = this.ParseTernaryOperation (NodeType.Cpblk);  	goto done;  case OpCode.Initblk:  	expr = this.ParseTernaryOperation (NodeType.Initblk);  	goto done;  case OpCode.Rethrow:  	statement = new Throw (null);  	statement.NodeType = NodeType.Rethrow;  	transferStatement = true;  	goto done;  case OpCode.Sizeof:  	expr = new UnaryExpression (new Literal (this.GetMemberFromToken ()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32);  	break;  case OpCode.Refanytype:  	expr = new UnaryExpression (PopOperand ()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle);  	break;  case OpCode.Readonly_:  	this.isReadOnly = true;  	continue;  default:  	throw new InvalidMetadataException (ExceptionStrings.UnknownOpCode);  }  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = this.Parameters (2);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = this.Parameters (3);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = this.locals [2];  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = this.locals [3];  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = new AssignmentStatement (this.locals [2]' PopOperand ());  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = new AssignmentStatement (this.locals [3]' PopOperand ());  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = new Literal (2' CoreSystemTypes.Int32);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = new Literal (3' CoreSystemTypes.Int32);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = new Literal (4' CoreSystemTypes.Int32);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = new Literal (5' CoreSystemTypes.Int32);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = new Literal (6' CoreSystemTypes.Int32);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = new Literal (7' CoreSystemTypes.Int32);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: expr = new Literal (8' CoreSystemTypes.Int32);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Eq' 2' true' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Ge' 2' true' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Gt' 2' true' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Le' 2' true' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Lt' 2' true' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Ne' 2' true' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Ge' 2' true' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Gt' 2' true' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Le' 2' true' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Lt' 2' true' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Eq' 2' false' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Ge' 2' false' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Gt' 2' false' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Le' 2' false' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Lt' 2' false' false);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Ne' 2' false' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Ge' 2' false' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Gt' 2' false' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Le' 2' false' true);  
Magic Number,System.Compiler.Metadata,BodyParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: statement = this.ParseBranch (NodeType.Lt' 2' false' true);  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)  	n = dataSize / 12;  else  	n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)  	n = dataSize / 12;  else  	n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)  	n = dataSize / 12;  else  	n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: n = dataSize / 12;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: n = (dataSize + (n << 8)) / 24;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddInstruction,The following statement contains a magic number: if (instructions == null)  	this.ehMap [offset + 1] = instructions = new InstructionList (2);  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,AddInstruction,The following statement contains a magic number: this.ehMap [offset + 1] = instructions = new InstructionList (2);  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch (opCode) {  case OpCode.Nop:  case OpCode.Break:  	break;  case OpCode.Ldarg_0:  	value = this.Parameters (0);  	break;  case OpCode.Ldarg_1:  	value = this.Parameters (1);  	break;  case OpCode.Ldarg_2:  	value = this.Parameters (2);  	break;  case OpCode.Ldarg_3:  	value = this.Parameters (3);  	break;  case OpCode.Ldloc_0:  	value = this.locals [0];  	break;  case OpCode.Ldloc_1:  	value = this.locals [1];  	break;  case OpCode.Ldloc_2:  	value = this.locals [2];  	break;  case OpCode.Ldloc_3:  	value = this.locals [3];  	break;  case OpCode.Stloc_0:  	value = this.locals [0];  	break;  case OpCode.Stloc_1:  	value = this.locals [1];  	break;  case OpCode.Stloc_2:  	value = this.locals [2];  	break;  case OpCode.Stloc_3:  	value = this.locals [3];  	break;  case OpCode.Ldarg_S:  case OpCode.Ldarga_S:  case OpCode.Starg_S:  	value = this.Parameters (this.GetByte ());  	break;  case OpCode.Ldloc_S:  case OpCode.Ldloca_S:  case OpCode.Stloc_S:  	value = this.locals [this.GetByte ()];  	break;  case OpCode.Ldnull:  	break;  case OpCode.Ldc_I4_M1:  	value = (Int32)(-1);  	break;  case OpCode.Ldc_I4_0:  	value = (Int32)0;  	break;  case OpCode.Ldc_I4_1:  	value = (Int32)1;  	break;  case OpCode.Ldc_I4_2:  	value = (Int32)2;  	break;  case OpCode.Ldc_I4_3:  	value = (Int32)3;  	break;  case OpCode.Ldc_I4_4:  	value = (Int32)4;  	break;  case OpCode.Ldc_I4_5:  	value = (Int32)5;  	break;  case OpCode.Ldc_I4_6:  	value = (Int32)6;  	break;  case OpCode.Ldc_I4_7:  	value = (Int32)7;  	break;  case OpCode.Ldc_I4_8:  	value = (Int32)8;  	break;  case OpCode.Ldc_I4_S:  	value = (Int32)this.GetSByte ();  	break;  case OpCode.Ldc_I4:  	value = this.GetInt32 ();  	break;  case OpCode.Ldc_I8:  	value = this.GetInt64 ();  	break;  case OpCode.Ldc_R4:  	value = this.GetSingle ();  	break;  case OpCode.Ldc_R8:  	value = this.GetDouble ();  	break;  case OpCode.Dup:  case OpCode.Pop:  	break;  case OpCode.Jmp:  case OpCode.Call:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Calli:  	value = (FunctionPointer)this.reader.GetCalliSignature (this.GetInt32 ());  	break;  case OpCode.Ret:  	break;  case OpCode.Br_S:  case OpCode.Brfalse_S:  case OpCode.Brtrue_S:  case OpCode.Beq_S:  case OpCode.Bge_S:  case OpCode.Bgt_S:  case OpCode.Ble_S:  case OpCode.Blt_S:  case OpCode.Bne_Un_S:  case OpCode.Bge_Un_S:  case OpCode.Bgt_Un_S:  case OpCode.Ble_Un_S:  case OpCode.Blt_Un_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_Un:  case OpCode.Bge_Un:  case OpCode.Bgt_Un:  case OpCode.Ble_Un:  case OpCode.Blt_Un:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Switch:  	value = this.ParseSwitchInstruction ();  	break;  case OpCode.Ldind_I1:  case OpCode.Ldind_U1:  case OpCode.Ldind_I2:  case OpCode.Ldind_U2:  case OpCode.Ldind_I4:  case OpCode.Ldind_U4:  case OpCode.Ldind_I8:  case OpCode.Ldind_I:  case OpCode.Ldind_R4:  case OpCode.Ldind_R8:  case OpCode.Ldind_Ref:  case OpCode.Stind_Ref:  case OpCode.Stind_I1:  case OpCode.Stind_I2:  case OpCode.Stind_I4:  case OpCode.Stind_I8:  case OpCode.Stind_R4:  case OpCode.Stind_R8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_Un:  case OpCode.Rem:  case OpCode.Rem_Un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_Un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_I1:  case OpCode.Conv_I2:  case OpCode.Conv_I4:  case OpCode.Conv_I8:  case OpCode.Conv_R4:  case OpCode.Conv_R8:  case OpCode.Conv_U4:  case OpCode.Conv_U8:  	break;  case OpCode.Callvirt:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Cpobj:  case OpCode.Ldobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldstr:  	value = this.GetStringFromToken ();  	break;  case OpCode.Newobj:  	value = (Method)this.GetMemberFromToken ();  	break;  case OpCode.Castclass:  case OpCode.Isinst:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Conv_R_Un:  	break;  case OpCode.Unbox:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Throw:  	break;  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Stobj:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1_Un:  case OpCode.Conv_Ovf_I2_Un:  case OpCode.Conv_Ovf_I4_Un:  case OpCode.Conv_Ovf_I8_Un:  case OpCode.Conv_Ovf_U1_Un:  case OpCode.Conv_Ovf_U2_Un:  case OpCode.Conv_Ovf_U4_Un:  case OpCode.Conv_Ovf_U8_Un:  case OpCode.Conv_Ovf_I_Un:  case OpCode.Conv_Ovf_U_Un:  	break;  case OpCode.Box:  case OpCode.Newarr:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldlen:  	break;  case OpCode.Ldelema:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Ldelem_I1:  case OpCode.Ldelem_U1:  case OpCode.Ldelem_I2:  case OpCode.Ldelem_U2:  case OpCode.Ldelem_I4:  case OpCode.Ldelem_U4:  case OpCode.Ldelem_I8:  case OpCode.Ldelem_I:  case OpCode.Ldelem_R4:  case OpCode.Ldelem_R8:  case OpCode.Ldelem_Ref:  case OpCode.Stelem_I:  case OpCode.Stelem_I1:  case OpCode.Stelem_I2:  case OpCode.Stelem_I4:  case OpCode.Stelem_I8:  case OpCode.Stelem_R4:  case OpCode.Stelem_R8:  case OpCode.Stelem_Ref:  	break;  case OpCode.Ldelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Stelem:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Unbox_Any:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_Ovf_I1:  case OpCode.Conv_Ovf_U1:  case OpCode.Conv_Ovf_I2:  case OpCode.Conv_Ovf_U2:  case OpCode.Conv_Ovf_I4:  case OpCode.Conv_Ovf_U4:  case OpCode.Conv_Ovf_I8:  case OpCode.Conv_Ovf_U8:  	break;  case OpCode.Refanyval:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ckfinite:  	break;  case OpCode.Mkrefany:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldtoken:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Conv_U2:  case OpCode.Conv_U1:  case OpCode.Conv_I:  case OpCode.Conv_Ovf_I:  case OpCode.Conv_Ovf_U:  case OpCode.Add_Ovf:  case OpCode.Add_Ovf_Un:  case OpCode.Mul_Ovf:  case OpCode.Mul_Ovf_Un:  case OpCode.Sub_Ovf:  case OpCode.Sub_Ovf_Un:  case OpCode.Endfinally:  	break;  case OpCode.Leave:  	value = this.counter + 4 + this.GetInt32 ();  	break;  case OpCode.Leave_S:  	value = this.counter + 1 + this.GetSByte ();  	break;  case OpCode.Stind_I:  case OpCode.Conv_U:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_Un:  case OpCode.Clt:  case OpCode.Clt_Un:  	break;  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  	value = this.Parameters (this.GetInt16 ());  	break;  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	value = this.locals [this.GetInt16 ()];  	break;  case OpCode.Localloc:  case OpCode.Endfilter:  	break;  case OpCode.Unaligned_:  	value = this.GetByte ();  	break;  case OpCode.Volatile_:  case OpCode.Tail_:  	break;  case OpCode.Initobj:  	value = (TypeNode)this.GetMemberFromToken ();  	break;  case OpCode.Constrained_:  	value = this.GetMemberFromToken () as TypeNode;  	break;  case OpCode.Cpblk:  case OpCode.Initblk:  	break;  case OpCode.Rethrow:  	break;  case OpCode.Sizeof:  	value = this.GetMemberFromToken ();  	break;  case OpCode.Refanytype:  case OpCode.Readonly_:  	break;  default:  	throw new InvalidMetadataException (String.Format (CultureInfo.CurrentCulture' ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString ("x")));  }  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = this.Parameters (2);  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = this.Parameters (3);  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = this.locals [2];  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = this.locals [3];  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = this.locals [2];  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = this.locals [3];  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = (Int32)2;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = (Int32)3;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = (Int32)4;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = (Int32)5;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = (Int32)6;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = (Int32)7;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = (Int32)8;  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = this.counter + 4 + this.GetInt32 ();  
Magic Number,System.Compiler.Metadata,InstructionParser,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: value = this.counter + 4 + this.GetInt32 ();  
Missing Default,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetLineCount,The following switch statement is missing a default case: switch (text [i]) {  case '\r':  	if (i + 1 < n && text [i + 1] == '\n')  		i++;  	count++;  	break;  case '\n':  case (char)0x2028:  case (char)0x2029:  	count++;  	break;  }  
Missing Default,System.Compiler,Document,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,ComputeLineOffsets,The following switch statement is missing a default case: switch (this.Text [i]) {  case '\r':  	if (i + 1 < n && this.Text [i + 1] == '\n')  		i++;  	this.AddOffset (i + 1);  	break;  case '\n':  case (char)0x2028:  case (char)0x2029:  	this.AddOffset (i + 1);  	break;  }  
Missing Default,System.Compiler,AssemblyNode,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following switch statement is missing a default case: switch (this.Flags & AssemblyFlags.CompatibilityMask) {  case AssemblyFlags.NonSideBySideCompatible:  	aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;  	break;  case AssemblyFlags.NonSideBySideProcess:  	aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;  	break;  case AssemblyFlags.NonSideBySideMachine:  	aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;  	break;  }  
Missing Default,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,AssemblyReference,The following switch statement is missing a default case: switch (assemblyStrongName [i]) {  case 'v':  case 'V':  	version = ParseAssignment (assemblyStrongName' "Version"' ref i);  	break;  case 'c':  case 'C':  	culture = ParseAssignment (assemblyStrongName' "Culture"' ref i);  	break;  case 'p':  case 'P':  	if (PlatformHelpers.StringCompareOrdinalIgnoreCase (assemblyStrongName' i' "PublicKeyToken"' 0' "PublicKeyToken".Length) == 0)  		token = ParseAssignment (assemblyStrongName' "PublicKeyToken"' ref i);  	else {  		token = ParseAssignment (assemblyStrongName' "PublicKey"' ref i);  		flags |= AssemblyFlags.PublicKey;  	}  	break;  case 'r':  case 'R':  	string yesOrNo = ParseAssignment (assemblyStrongName' "Retargetable"' ref i);  	if (PlatformHelpers.StringCompareOrdinalIgnoreCase (yesOrNo' "Yes") == 0)  		flags |= AssemblyFlags.Retargetable;  	break;  }  
Missing Default,System.Compiler,AssemblyReference,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetAssemblyName,The following switch statement is missing a default case: switch (this.Flags & AssemblyFlags.CompatibilityMask) {  case AssemblyFlags.NonSideBySideCompatible:  	aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;  	break;  case AssemblyFlags.NonSideBySideProcess:  	aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;  	break;  case AssemblyFlags.NonSideBySideMachine:  	aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;  	break;  }  
Missing Default,System.Compiler,Member,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Nodes.cs,GetHelpText,The following switch statement is missing a default case: switch (child.NodeType) {  case XmlNodeType.Element:  	string str = this.GetHelpText (child);  	if (str == null || str.Length == 0)  		continue;  	if (sb.Length > 0 && !Char.IsPunctuation (str [0]))  		sb.Append (' ');  	sb.Append (str);  	break;  case XmlNodeType.CDATA:  case XmlNodeType.Entity:  case XmlNodeType.Text:  	this.AppendValue (sb' child);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetBlobIndex,The following switch statement is missing a default case: switch (marshallingInformation.NativeType) {  case NativeType.SafeArray:  	signature.Write ((byte)marshallingInformation.ElementType);  	if (marshallingInformation.Class != null && marshallingInformation.Class.Length > 0)  		signature.Write (marshallingInformation.Class' false);  	break;  case NativeType.LPArray:  	signature.Write ((byte)marshallingInformation.ElementType);  	if (marshallingInformation.ParamIndex >= 0 || marshallingInformation.ElementSize > 0) {  		if (marshallingInformation.ParamIndex < 0) {  			Debug.Fail ("MarshallingInformation.ElementSize > 0 should imply that ParamIndex >= 0");  			marshallingInformation.ParamIndex = 0;  		}  		Ir2md.WriteCompressedInt (signature' marshallingInformation.ParamIndex);  	}  	if (marshallingInformation.ElementSize > 0) {  		Ir2md.WriteCompressedInt (signature' marshallingInformation.ElementSize);  		if (marshallingInformation.NumberOfElements > 0)  			Ir2md.WriteCompressedInt (signature' marshallingInformation.NumberOfElements);  	}  	break;  case NativeType.ByValArray:  	Ir2md.WriteCompressedInt (signature' marshallingInformation.Size);  	if (marshallingInformation.ElementType != NativeType.NotSpecified)  		signature.Write ((byte)marshallingInformation.ElementType);  	break;  case NativeType.ByValTStr:  	Ir2md.WriteCompressedInt (signature' marshallingInformation.Size);  	break;  case NativeType.CustomMarshaler:  	signature.Write ((short)0);  	signature.Write (marshallingInformation.Class);  	signature.Write (marshallingInformation.Cookie);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,IsStructural,The following switch statement is missing a default case: switch (type.NodeType) {  case NodeType.ArrayType:  case NodeType.Pointer:  case NodeType.Reference:  case NodeType.OptionalModifier:  case NodeType.RequiredModifier:  	return true;  case NodeType.ClassParameter:  case NodeType.TypeParameter:  	return this.UseGenerics;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,GetStaticDataIndex,The following switch statement is missing a default case: switch (targetSection) {  case PESection.SData:  	result = (int)this.sdataHeap.BaseStream.Position;  	this.sdataHeap.Write (data);  	break;  case PESection.Text:  	result = (int)this.methodBodiesHeap.BaseStream.Position;  	this.methodBodiesHeap.Write (data);  	break;  case PESection.TLS:  	result = (int)this.tlsHeap.BaseStream.Position;  	this.tlsHeap.Write (data);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateFileTable,The following switch statement is missing a default case: switch (module.Kind) {  case ModuleKindFlags.ConsoleApplication:  case ModuleKindFlags.DynamicallyLinkedLibrary:  case ModuleKindFlags.WindowsApplication:  	ftr [i].Flags = (int)FileFlags.ContainsMetaData;  	break;  case ModuleKindFlags.ManifestResourceFile:  	readContents = true;  	ftr [i].Flags = (int)FileFlags.ContainsNoMetaData;  	break;  case ModuleKindFlags.UnmanagedDynamicallyLinkedLibrary:  	ftr [i].Flags = (int)FileFlags.ContainsNoMetaData;  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,PopulateTypeDefTable,The following switch statement is missing a default case: switch (mem.NodeType) {  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	tdr [i].MethodList = this.GetMethodIndex ((Method)mem);  	goto done;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitAddressOf,The following switch statement is missing a default case: switch (operand.NodeType) {  case NodeType.Indexer:  	Indexer indexer = (Indexer)operand;  	this.Visit (indexer.Object);  	if (indexer.Operands == null || indexer.Operands.Count < 1)  		return;  	this.Visit (indexer.Operands [0]);  	if (expr.NodeType == NodeType.ReadOnlyAddressOf) {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x1e);  	}  	this.methodBodyHeap.Write ((byte)0x8f);  	this.methodBodyHeap.Write ((int)this.GetTypeToken (indexer.ElementType));  	this.stackHeight--;  	return;  case NodeType.Local:  	int li = this.GetLocalVarIndex ((Local)operand);  	if (li < 256) {  		this.methodBodyHeap.Write ((byte)0x12);  		this.methodBodyHeap.Write ((byte)li);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0d);  		this.methodBodyHeap.Write ((ushort)li);  	}  	this.IncrementStackHeight ();  	return;  case NodeType.MemberBinding:  	MemberBinding mb = (MemberBinding)operand;  	if (mb.TargetObject != null) {  		this.Visit (mb.TargetObject);  		this.methodBodyHeap.Write ((byte)0x7c);  	} else {  		this.methodBodyHeap.Write ((byte)0x7f);  		this.IncrementStackHeight ();  	}  	this.methodBodyHeap.Write ((int)this.GetFieldToken ((Field)mb.BoundMember));  	return;  case NodeType.Parameter:  	#if !MinimalReader  	ParameterBinding pb = operand as ParameterBinding;  	if (pb != null)  		operand = pb.BoundParameter;  	#endif  	int pi = ((Parameter)operand).ArgumentListIndex;  	if (pi < 256) {  		this.methodBodyHeap.Write ((byte)0x0f);  		this.methodBodyHeap.Write ((byte)pi);  	} else {  		this.methodBodyHeap.Write ((byte)0xfe);  		this.methodBodyHeap.Write ((byte)0x0a);  		this.methodBodyHeap.Write ((ushort)pi);  	}  	this.IncrementStackHeight ();  	return;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBinaryExpression,The following switch statement is missing a default case: switch (binaryExpression.NodeType) {  case NodeType.Castclass:  	opCode = 0x74;  	goto writeOpCodeAndToken;  case NodeType.Isinst:  	opCode = 0x75;  	goto writeOpCodeAndToken;  case NodeType.Unbox:  	opCode = 0x79;  	goto writeOpCodeAndToken;  case NodeType.UnboxAny:  	opCode = 0xa5;  	goto writeOpCodeAndToken;  case NodeType.Box:  	opCode = 0x8c;  	goto writeOpCodeAndToken;  case NodeType.Refanyval:  	opCode = 0xc2;  	goto writeOpCodeAndToken;  case NodeType.Mkrefany:  	opCode = 0xc6;  	goto writeOpCodeAndToken;  	writeOpCodeAndToken:  	this.methodBodyHeap.Write ((byte)opCode);  	Literal lit = binaryExpression.Operand2 as Literal;  	if (lit != null)  		this.methodBodyHeap.Write ((int)this.GetTypeToken ((TypeNode)lit.Value));  	else {  		// TODO: Normalized IR should never use a MemberBinding to represent a type  		this.methodBodyHeap.Write ((int)this.GetTypeToken ((TypeNode)((MemberBinding)binaryExpression.Operand2).BoundMember));  	}  	return;  case NodeType.Ldvirtftn:  	opCode = 0x07;  	this.methodBodyHeap.Write ((byte)0xfe);  	this.methodBodyHeap.Write ((byte)opCode);  	this.methodBodyHeap.Write ((int)this.GetMethodToken ((Method)((MemberBinding)binaryExpression.Operand2).BoundMember));  	return;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBinaryExpression,The following switch statement is missing a default case: switch (binaryExpression.NodeType) {  case NodeType.Add:  	opCode = 0x58;  	break;  case NodeType.Sub:  	opCode = 0x59;  	break;  case NodeType.Mul:  	opCode = 0x5a;  	break;  case NodeType.Div:  	opCode = 0x5b;  	break;  case NodeType.Div_Un:  	opCode = 0x5c;  	break;  case NodeType.Rem:  	opCode = 0x5d;  	break;  case NodeType.Rem_Un:  	opCode = 0x5e;  	break;  case NodeType.And:  	opCode = 0x5f;  	break;  case NodeType.Or:  	opCode = 0x60;  	break;  case NodeType.Xor:  	opCode = 0x61;  	break;  case NodeType.Shl:  	opCode = 0x62;  	break;  case NodeType.Shr:  	opCode = 0x63;  	break;  case NodeType.Shr_Un:  	opCode = 0x64;  	break;  case NodeType.Add_Ovf:  	opCode = 0xd6;  	break;  case NodeType.Add_Ovf_Un:  	opCode = 0xd7;  	break;  case NodeType.Mul_Ovf:  	opCode = 0xd8;  	break;  case NodeType.Mul_Ovf_Un:  	opCode = 0xd9;  	break;  case NodeType.Sub_Ovf:  	opCode = 0xda;  	break;  case NodeType.Sub_Ovf_Un:  	opCode = 0xdb;  	break;  case NodeType.Ceq:  	opCode = 0x01;  	this.methodBodyHeap.Write ((byte)0xfe);  	break;  case NodeType.Cgt:  	opCode = 0x02;  	this.methodBodyHeap.Write ((byte)0xfe);  	break;  case NodeType.Cgt_Un:  	opCode = 0x03;  	this.methodBodyHeap.Write ((byte)0xfe);  	break;  case NodeType.Clt:  	opCode = 0x04;  	this.methodBodyHeap.Write ((byte)0xfe);  	break;  case NodeType.Clt_Un:  	opCode = 0x05;  	this.methodBodyHeap.Write ((byte)0xfe);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBranch,The following switch statement is missing a default case: switch (typeOfCondition) {  case NodeType.Nop:  	if (branch.Condition == null) {  		if (branch.LeavesExceptionBlock)  			this.methodBodyHeap.Write ((byte)0xde);  		else  			this.methodBodyHeap.Write ((byte)0x2b);  		break;  	} else {  		this.methodBodyHeap.Write ((byte)0x2d);  		break;  	}  case NodeType.And:  case NodeType.Or:  case NodeType.Xor:  case NodeType.Isinst:  case NodeType.Castclass:  case NodeType.Undefined:  	this.methodBodyHeap.Write ((byte)0x2d);  	break;  case NodeType.LogicalNot:  	this.methodBodyHeap.Write ((byte)0x2c);  	break;  case NodeType.Eq:  	this.methodBodyHeap.Write ((byte)0x2e);  	break;  case NodeType.Ge:  	if (branch.BranchIfUnordered)  		this.methodBodyHeap.Write ((byte)0x34);  	else  		this.methodBodyHeap.Write ((byte)0x2f);  	break;  case NodeType.Gt:  	if (branch.BranchIfUnordered)  		this.methodBodyHeap.Write ((byte)0x35);  	else  		this.methodBodyHeap.Write ((byte)0x30);  	break;  case NodeType.Le:  	if (branch.BranchIfUnordered)  		this.methodBodyHeap.Write ((byte)0x36);  	else  		this.methodBodyHeap.Write ((byte)0x31);  	break;  case NodeType.Lt:  	if (branch.BranchIfUnordered)  		this.methodBodyHeap.Write ((byte)0x37);  	else  		this.methodBodyHeap.Write ((byte)0x32);  	break;  case NodeType.Ne:  	this.methodBodyHeap.Write ((byte)0x33);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitBranch,The following switch statement is missing a default case: switch (typeOfCondition) {  case NodeType.Nop:  	if (branch.Condition == null) {  		if (branch.LeavesExceptionBlock)  			this.methodBodyHeap.Write ((byte)0xdd);  		else  			this.methodBodyHeap.Write ((byte)0x38);  		break;  	} else {  		this.methodBodyHeap.Write ((byte)0x3a);  		break;  	}  case NodeType.And:  case NodeType.Or:  case NodeType.Xor:  case NodeType.Isinst:  case NodeType.Castclass:  case NodeType.Undefined:  	this.methodBodyHeap.Write ((byte)0x3a);  	break;  case NodeType.LogicalNot:  	this.methodBodyHeap.Write ((byte)0x39);  	break;  case NodeType.Eq:  	this.methodBodyHeap.Write ((byte)0x3b);  	break;  case NodeType.Ge:  	if (branch.BranchIfUnordered)  		this.methodBodyHeap.Write ((byte)0x41);  	else  		this.methodBodyHeap.Write ((byte)0x3c);  	break;  case NodeType.Gt:  	if (branch.BranchIfUnordered)  		this.methodBodyHeap.Write ((byte)0x42);  	else  		this.methodBodyHeap.Write ((byte)0x3d);  	break;  case NodeType.Le:  	if (branch.BranchIfUnordered)  		this.methodBodyHeap.Write ((byte)0x43);  	else  		this.methodBodyHeap.Write ((byte)0x3e);  	break;  case NodeType.Lt:  	if (branch.BranchIfUnordered)  		this.methodBodyHeap.Write ((byte)0x44);  	else  		this.methodBodyHeap.Write ((byte)0x3f);  	break;  case NodeType.Ne:  	this.methodBodyHeap.Write ((byte)0x40);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitExpression,The following switch statement is missing a default case: switch (expression.NodeType) {  case NodeType.Dup:  	this.methodBodyHeap.Write ((byte)0x25);  	this.IncrementStackHeight ();  	return;  case NodeType.Pop:  	UnaryExpression unex = expression as UnaryExpression;  	if (unex != null) {  		this.Visit (unex.Operand);  		this.stackHeight--;  		this.methodBodyHeap.Write ((byte)0x26);  	}  	return;  case NodeType.Arglist:  	this.IncrementStackHeight ();  	this.methodBodyHeap.Write ((byte)0xfe);  	this.methodBodyHeap.Write ((byte)0x00);  	return;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitMethodBody,The following switch statement is missing a default case: switch (eh.HandlerType) {  case NodeType.Filter:  	flags = 0x0001;  	break;  case NodeType.Finally:  	flags = 0x0002;  	break;  case NodeType.FaultHandler:  	flags = 0x0004;  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitModule,The following switch statement is missing a default case: switch (mem.NodeType) {  case NodeType.Field:  	this.GetFieldIndex ((Field)mem);  	break;  case NodeType.Method:  case NodeType.InstanceInitializer:  case NodeType.StaticInitializer:  	Method meth = (Method)mem;  	if (this.UseGenerics && meth.Template != null && meth.Template.IsGeneric)  		this.GetMethodSpecIndex (meth);  	else  		this.GetMethodIndex (meth);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitStatement,The following switch statement is missing a default case: switch (statement.NodeType) {  case NodeType.Nop:  	this.methodBodyHeap.Write ((byte)0x00);  	break;  case NodeType.DebugBreak:  	this.methodBodyHeap.Write ((byte)0x01);  	break;  case NodeType.EndFinally:  	this.methodBodyHeap.Write ((byte)0xdc);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,VisitUnaryExpression,The following switch statement is missing a default case: switch (unaryExpression.NodeType) {  case NodeType.Neg:  	opCode = 0x65;  	break;  case NodeType.Not:  	opCode = 0x66;  	break;  case NodeType.Conv_I1:  	opCode = 0x67;  	break;  case NodeType.Conv_I2:  	opCode = 0x68;  	break;  case NodeType.Conv_I4:  	opCode = 0x69;  	break;  case NodeType.Conv_I8:  	opCode = 0x6a;  	break;  case NodeType.Conv_R4:  	opCode = 0x6b;  	break;  case NodeType.Conv_R8:  	opCode = 0x6c;  	break;  case NodeType.Conv_U4:  	opCode = 0x6d;  	break;  case NodeType.Conv_U8:  	opCode = 0x6e;  	break;  case NodeType.Conv_R_Un:  	opCode = 0x76;  	break;  case NodeType.Conv_Ovf_I1_Un:  	opCode = 0x82;  	break;  case NodeType.Conv_Ovf_I2_Un:  	opCode = 0x83;  	break;  case NodeType.Conv_Ovf_I4_Un:  	opCode = 0x84;  	break;  case NodeType.Conv_Ovf_I8_Un:  	opCode = 0x85;  	break;  case NodeType.Conv_Ovf_U1_Un:  	opCode = 0x86;  	break;  case NodeType.Conv_Ovf_U2_Un:  	opCode = 0x87;  	break;  case NodeType.Conv_Ovf_U4_Un:  	opCode = 0x88;  	break;  case NodeType.Conv_Ovf_U8_Un:  	opCode = 0x89;  	break;  case NodeType.Conv_Ovf_I_Un:  	opCode = 0x8a;  	break;  case NodeType.Conv_Ovf_U_Un:  	opCode = 0x8b;  	break;  case NodeType.Ldlen:  	opCode = 0x8e;  	break;  case NodeType.Conv_Ovf_I1:  	opCode = 0xb3;  	break;  case NodeType.Conv_Ovf_U1:  	opCode = 0xb4;  	break;  case NodeType.Conv_Ovf_I2:  	opCode = 0xb5;  	break;  case NodeType.Conv_Ovf_U2:  	opCode = 0xb6;  	break;  case NodeType.Conv_Ovf_I4:  	opCode = 0xb7;  	break;  case NodeType.Conv_Ovf_U4:  	opCode = 0xb8;  	break;  case NodeType.Conv_Ovf_I8:  	opCode = 0xb9;  	break;  case NodeType.Conv_Ovf_U8:  	opCode = 0xba;  	break;  case NodeType.Ckfinite:  	opCode = 0xc3;  	break;  case NodeType.Conv_U2:  	opCode = 0xd1;  	break;  case NodeType.Conv_U1:  	opCode = 0xd2;  	break;  case NodeType.Conv_I:  	opCode = 0xd3;  	break;  case NodeType.Conv_Ovf_I:  	opCode = 0xd4;  	break;  case NodeType.Conv_Ovf_U:  	opCode = 0xd5;  	break;  case NodeType.Conv_U:  	opCode = 0xe0;  	break;  case NodeType.Localloc:  	opCode = 0x0f;  	this.methodBodyHeap.Write ((byte)0xfe);  	break;  case NodeType.Refanytype:  	opCode = 0x1d;  	this.methodBodyHeap.Write ((byte)0xfe);  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCustomModifiers,The following switch statement is missing a default case: switch (type.NodeType) {  case NodeType.RequiredModifier:  case NodeType.OptionalModifier:  	TypeModifier tm = (TypeModifier)type;  	target.Write ((byte)tm.typeCode);  	this.WriteTypeDefOrRefEncoded (target' tm.Modifier);  	return this.WriteCustomModifiers (target' tm.ModifiedType);  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCustomAttributeLiteral,The following switch statement is missing a default case: switch (typeCode) {  case ElementType.Boolean:  	writer.Write ((bool)value);  	return;  case ElementType.Char:  	writer.Write ((ushort)(char)value);  	return;  case ElementType.Double:  	writer.Write ((double)value);  	return;  case ElementType.Single:  	writer.Write ((float)value);  	return;  case ElementType.Int16:  	writer.Write ((short)value);  	return;  case ElementType.Int32:  	writer.Write ((int)value);  	return;  case ElementType.Int64:  	writer.Write ((long)value);  	return;  case ElementType.Int8:  	writer.Write ((sbyte)value);  	return;  case ElementType.UInt16:  	writer.Write ((ushort)value);  	return;  case ElementType.UInt32:  	writer.Write ((uint)value);  	return;  case ElementType.UInt64:  	writer.Write ((ulong)value);  	return;  case ElementType.UInt8:  	writer.Write ((byte)value);  	return;  case ElementType.String:  	writer.Write ((string)value' false);  	return;  case ElementType.ValueType:  	this.WriteCustomAttributeLiteral (writer' new Literal (value' ((EnumNode)literal.Type).UnderlyingType)' false);  	return;  case ElementType.Class:  	this.WriteSerializedTypeName (writer' (TypeNode)value);  	return;  case ElementType.SzArray:  	TypeNode elemType = ((ArrayType)literal.Type).ElementType;  	if (needsTag)  		writer.Write ((byte)elemType.typeCode);  	Array array = (Array)value;  	int numElems = array == null ? -1 : array.Length;  	writer.Write ((int)numElems);  	for (int i = 0; i < numElems; i++)  		this.WriteCustomAttributeLiteral (writer' new Literal (array.GetValue (i)' elemType)' false);  	return;  case ElementType.Object:  	Literal lit = (Literal)literal.Clone ();  	TypeNode t = null;  	switch (Convert.GetTypeCode (lit.Value)) {  	case TypeCode.Boolean:  		t = CoreSystemTypes.Boolean;  		break;  	case TypeCode.Byte:  		t = CoreSystemTypes.UInt8;  		break;  	case TypeCode.Char:  		t = CoreSystemTypes.Char;  		break;  	case TypeCode.Double:  		t = CoreSystemTypes.Double;  		break;  	case TypeCode.Int16:  		t = CoreSystemTypes.Int16;  		break;  	case TypeCode.Int32:  		t = CoreSystemTypes.Int32;  		break;  	case TypeCode.Int64:  		t = CoreSystemTypes.Int64;  		break;  	case TypeCode.SByte:  		t = CoreSystemTypes.Int8;  		break;  	case TypeCode.Single:  		t = CoreSystemTypes.Single;  		break;  	case TypeCode.String:  		t = CoreSystemTypes.String;  		break;  	case TypeCode.UInt16:  		t = CoreSystemTypes.UInt16;  		break;  	case TypeCode.UInt32:  		t = CoreSystemTypes.UInt32;  		break;  	case TypeCode.UInt64:  		t = CoreSystemTypes.UInt64;  		break;  	case TypeCode.Empty:  	case TypeCode.Object:  		Array arr = lit.Value as Array;  		if (arr != null) {  			#if !NoReflection  			t = TypeNode.GetTypeNode (arr.GetType ());  			#else  			                System.Type reflType = arr.GetType();                 System.Type reflElemType = reflType.GetElementType();                 AssemblyNode assem = AssemblyNode.GetAssembly(reflType.Assembly.Location);                 TypeNode cciElemType = assem.GetType(Identifier.For(reflElemType.Namespace)' Identifier.For(reflElemType.Name));                 t = cciElemType.GetArrayType(reflType.GetArrayRank()); #endif  		} else  			t = CoreSystemTypes.Type;  		break;  	}  	if (t == null)  		break;  	lit.Type = t;  	this.WriteCustomAttributeLiteral (writer' lit' true);  	return;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteCustomAttributeLiteral,The following switch statement is missing a default case: switch (Convert.GetTypeCode (lit.Value)) {  case TypeCode.Boolean:  	t = CoreSystemTypes.Boolean;  	break;  case TypeCode.Byte:  	t = CoreSystemTypes.UInt8;  	break;  case TypeCode.Char:  	t = CoreSystemTypes.Char;  	break;  case TypeCode.Double:  	t = CoreSystemTypes.Double;  	break;  case TypeCode.Int16:  	t = CoreSystemTypes.Int16;  	break;  case TypeCode.Int32:  	t = CoreSystemTypes.Int32;  	break;  case TypeCode.Int64:  	t = CoreSystemTypes.Int64;  	break;  case TypeCode.SByte:  	t = CoreSystemTypes.Int8;  	break;  case TypeCode.Single:  	t = CoreSystemTypes.Single;  	break;  case TypeCode.String:  	t = CoreSystemTypes.String;  	break;  case TypeCode.UInt16:  	t = CoreSystemTypes.UInt16;  	break;  case TypeCode.UInt32:  	t = CoreSystemTypes.UInt32;  	break;  case TypeCode.UInt64:  	t = CoreSystemTypes.UInt64;  	break;  case TypeCode.Empty:  case TypeCode.Object:  	Array arr = lit.Value as Array;  	if (arr != null) {  		#if !NoReflection  		t = TypeNode.GetTypeNode (arr.GetType ());  		#else  		                System.Type reflType = arr.GetType();                 System.Type reflElemType = reflType.GetElementType();                 AssemblyNode assem = AssemblyNode.GetAssembly(reflType.Assembly.Location);                 TypeNode cciElemType = assem.GetType(Identifier.For(reflElemType.Namespace)' Identifier.For(reflElemType.Name));                 t = cciElemType.GetArrayType(reflType.GetArrayRank()); #endif  	} else  		t = CoreSystemTypes.Type;  	break;  }  
Missing Default,System.Compiler,Ir2md,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Writer.cs,WriteTypeSignature,The following switch statement is missing a default case: switch (t.typeCode) {  case ElementType.Pointer:  	this.WriteTypeSignature (target' ((Pointer)t).ElementType);  	break;  case ElementType.Reference:  	this.WriteTypeSignature (target' ((Reference)t).ElementType);  	break;  case ElementType.ValueType:  case ElementType.Class:  	this.WriteTypeDefOrRefEncoded (target' t);  	break;  case ElementType.Array:  	this.WriteTypeSignature (target' ((ArrayType)t).ElementType);  	Ir2md.WriteArrayShape (target' (ArrayType)t);  	break;  case ElementType.FunctionPointer:  	this.WriteMethodSignature (target' (FunctionPointer)t);  	break;  case ElementType.SzArray:  	this.WriteTypeSignature (target' ((ArrayType)t).ElementType);  	break;  }  
Missing Default,System.Compiler.Metadata,MetadataReader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,GetValueFromBlob,The following switch statement is missing a default case: switch ((ElementType)type) {  case ElementType.Boolean:  	return c.ReadBoolean ();  case ElementType.Char:  	return (char)c.ReadUInt16 ();  case ElementType.Double:  	return c.ReadDouble ();  case ElementType.Single:  	return c.ReadSingle ();  case ElementType.Int16:  	return c.ReadInt16 ();  case ElementType.Int32:  	return c.ReadInt32 ();  case ElementType.Int64:  	return c.ReadInt64 ();  case ElementType.Int8:  	return c.ReadSByte ();  case ElementType.UInt16:  	return c.ReadUInt16 ();  case ElementType.UInt32:  	return c.ReadUInt32 ();  case ElementType.UInt64:  	return c.ReadUInt64 ();  case ElementType.UInt8:  	return c.ReadByte ();  case ElementType.Class:  	return null;  case ElementType.String:  	return c.ReadUTF16 (blobLength / 2);  }  
Missing Default,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,SerializeFieldRvaTable,The following switch statement is missing a default case: switch (row.TargetSection) {  case PESection.SData:  case PESection.TLS:  	Fixup fixup = new Fixup ();  	fixup.fixupLocation = writer.BaseStream.Position;  	fixup.addressOfNextInstruction = row.RVA;  	if (row.TargetSection == PESection.SData) {  		sdataFixup.nextFixUp = fixup;  		sdataFixup = fixup;  	} else {  		sdataFixup.nextFixUp = fixup;  		sdataFixup = fixup;  	}  	writer.Write ((int)0);  	break;  case PESection.Text:  	writer.Write ((int)row.RVA + mbRVAOffset);  	break;  }  
Missing Default,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following switch statement is missing a default case: switch ((TableIndices)i) {  case TableIndices.Module:  	if (this.moduleTable != null)  		j = this.moduleTable.Length;  	break;  case TableIndices.TypeRef:  	if (this.typeRefTable != null)  		j = this.typeRefTable.Length;  	break;  case TableIndices.TypeDef:  	if (this.typeDefTable != null)  		j = this.typeDefTable.Length;  	break;  case TableIndices.Field:  	if (this.fieldTable != null)  		j = this.fieldTable.Length;  	break;  case TableIndices.Method:  	if (this.methodTable != null)  		j = this.methodTable.Length;  	break;  case TableIndices.Param:  	if (this.paramTable != null)  		j = this.paramTable.Length;  	break;  case TableIndices.InterfaceImpl:  	if (this.interfaceImplTable != null)  		j = this.interfaceImplTable.Length;  	break;  case TableIndices.MemberRef:  	if (this.memberRefTable != null)  		j = this.memberRefTable.Length;  	break;  case TableIndices.Constant:  	if (this.constantTable != null)  		j = this.constantTable.Length;  	break;  case TableIndices.CustomAttribute:  	if (this.customAttributeTable != null)  		j = this.customAttributeTable.Length;  	break;  case TableIndices.FieldMarshal:  	if (this.fieldMarshalTable != null)  		j = this.fieldMarshalTable.Length;  	break;  case TableIndices.DeclSecurity:  	if (this.declSecurityTable != null)  		j = this.declSecurityTable.Length;  	break;  case TableIndices.ClassLayout:  	if (this.classLayoutTable != null)  		j = this.classLayoutTable.Length;  	break;  case TableIndices.FieldLayout:  	if (this.fieldLayoutTable != null)  		j = this.fieldLayoutTable.Length;  	break;  case TableIndices.StandAloneSig:  	if (this.standAloneSigTable != null)  		j = this.standAloneSigTable.Length;  	break;  case TableIndices.EventMap:  	if (this.eventMapTable != null)  		j = this.eventMapTable.Length;  	break;  case TableIndices.Event:  	if (this.eventTable != null)  		j = this.eventTable.Length;  	break;  case TableIndices.PropertyMap:  	if (this.propertyMapTable != null)  		j = this.propertyMapTable.Length;  	break;  case TableIndices.Property:  	if (this.propertyTable != null)  		j = this.propertyTable.Length;  	break;  case TableIndices.MethodSemantics:  	if (this.methodSemanticsTable != null)  		j = this.methodSemanticsTable.Length;  	break;  case TableIndices.MethodImpl:  	if (this.methodImplTable != null)  		j = this.methodImplTable.Length;  	break;  case TableIndices.ModuleRef:  	if (this.moduleRefTable != null)  		j = this.moduleRefTable.Length;  	break;  case TableIndices.TypeSpec:  	if (this.typeSpecTable != null)  		j = this.typeSpecTable.Length;  	break;  case TableIndices.ImplMap:  	if (this.implMapTable != null)  		j = this.implMapTable.Length;  	break;  case TableIndices.FieldRva:  	if (this.fieldRvaTable != null)  		j = this.fieldRvaTable.Length;  	break;  case TableIndices.Assembly:  	if (this.assemblyTable != null)  		j = this.assemblyTable.Length;  	break;  case TableIndices.AssemblyRef:  	if (this.assemblyRefTable != null)  		j = this.assemblyRefTable.Length;  	break;  case TableIndices.File:  	if (this.fileTable != null)  		j = this.fileTable.Length;  	break;  case TableIndices.ExportedType:  	if (this.exportedTypeTable != null)  		j = this.exportedTypeTable.Length;  	break;  case TableIndices.ManifestResource:  	if (this.manifestResourceTable != null)  		j = this.manifestResourceTable.Length;  	break;  case TableIndices.NestedClass:  	if (this.nestedClassTable != null)  		j = this.nestedClassTable.Length;  	break;  case TableIndices.GenericParam:  	if (this.genericParamTable != null)  		j = this.genericParamTable.Length;  	break;  case TableIndices.MethodSpec:  	if (this.methodSpecTable != null)  		j = this.methodSpecTable.Length;  	break;  case TableIndices.GenericParamConstraint:  	if (this.genericParamConstraintTable != null)  		j = this.genericParamConstraintTable.Length;  	break;  }  
Missing Default,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,TablesLength,The following switch statement is missing a default case: switch ((TableIndices)i) {  case TableIndices.Module:  	length += m * (2 + stringRefSize + 3 * guidRefSize);  	break;  case TableIndices.TypeRef:  	length += m * (resolutionScopeRefSize + 2 * stringRefSize);  	break;  case TableIndices.TypeDef:  	length += m * (4 + 2 * stringRefSize + typeDefOrRefOrSpecSize + tableRefSize [(int)TableIndices.Field] + tableRefSize [(int)TableIndices.Method]);  	break;  case TableIndices.Field:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.Method:  	length += m * (8 + stringRefSize + blobRefSize + tableRefSize [(int)TableIndices.Param]);  	break;  case TableIndices.Param:  	length += m * (4 + stringRefSize);  	break;  case TableIndices.InterfaceImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + typeDefOrRefOrSpecSize);  	break;  case TableIndices.MemberRef:  	length += m * (memberRefParentSize + stringRefSize + blobRefSize);  	break;  case TableIndices.Constant:  	length += m * (2 + constantParentRefSize + blobRefSize);  	break;  case TableIndices.CustomAttribute:  	length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize);  	break;  case TableIndices.FieldMarshal:  	length += m * (fieldMarshalParentRefSize + blobRefSize);  	break;  case TableIndices.DeclSecurity:  	length += m * (2 + declSecurityParentRefSize + blobRefSize);  	break;  case TableIndices.ClassLayout:  	length += m * (6 + tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.FieldLayout:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.StandAloneSig:  	length += m * (blobRefSize);  	break;  case TableIndices.EventMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Event]);  	break;  case TableIndices.Event:  	length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize);  	break;  case TableIndices.PropertyMap:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + tableRefSize [(int)TableIndices.Property]);  	break;  case TableIndices.Property:  	length += m * (2 + stringRefSize + blobRefSize);  	break;  case TableIndices.MethodSemantics:  	length += m * (2 + tableRefSize [(int)TableIndices.Method] + hasSemanticRefSize);  	break;  case TableIndices.MethodImpl:  	length += m * (tableRefSize [(int)TableIndices.TypeDef] + 2 * methodDefOrRefSize);  	break;  case TableIndices.ModuleRef:  	length += m * (stringRefSize);  	break;  case TableIndices.TypeSpec:  	length += m * (blobRefSize);  	break;  case TableIndices.ImplMap:  	length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize [(int)TableIndices.ModuleRef]);  	break;  case TableIndices.FieldRva:  	length += m * (4 + tableRefSize [(int)TableIndices.Field]);  	break;  case TableIndices.EncLog:  	throw new InvalidMetadataException (ExceptionStrings.ENCLogTableEncountered);  case TableIndices.EncMap:  	throw new InvalidMetadataException (ExceptionStrings.ENCMapTableEncountered);  case TableIndices.Assembly:  	length += m * (16 + blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.AssemblyRef:  	length += m * (12 + 2 * blobRefSize + 2 * stringRefSize);  	break;  case TableIndices.File:  	length += m * (4 + stringRefSize + blobRefSize);  	break;  case TableIndices.ExportedType:  	length += m * (8 + 2 * stringRefSize + implementationRefSize);  	break;  case TableIndices.ManifestResource:  	length += m * (8 + stringRefSize + implementationRefSize);  	break;  case TableIndices.NestedClass:  	length += m * (2 * tableRefSize [(int)TableIndices.TypeDef]);  	break;  case TableIndices.GenericParam:  	if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)  		length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);  	else  		length += m * (4 + typeDefOrMethodDefSize + stringRefSize);  	break;  case TableIndices.MethodSpec:  	length += m * (methodDefOrRefSize + blobRefSize);  	break;  case TableIndices.GenericParamConstraint:  	length += m * (tableRefSize [(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize);  	break;  }  
Missing Default,System.Compiler.Metadata,MetadataWriter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Metadata.cs,WritePE,The following switch statement is missing a default case: switch (this.moduleKind) {  case ModuleKindFlags.ConsoleApplication:  	this.ntHeader.subsystem = 3;  	break;  case ModuleKindFlags.DynamicallyLinkedLibrary:  	this.ntHeader.characteristics |= 0x2000;  	this.ntHeader.subsystem = 3;  	break;  case ModuleKindFlags.WindowsApplication:  	this.ntHeader.subsystem = 2;  	break;  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following switch statement is missing a default case: switch (codedIndex & 0x3) {  case 0x00:  	return this.TypeDefIsClass (codedIndex >> 2);  case 0x01:  	TypeNode t = this.GetTypeFromRef (codedIndex >> 2);  	return t is Class;  case 0x02:  	return this.TypeSpecIsClass (codedIndex >> 2);  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following switch statement is missing a default case: switch (codedIndex & 0x3) {  case 0x00:  	return this.TypeDefIsClassButNotValueTypeBaseClass (codedIndex >> 2);  case 0x01:  	TypeNode t = this.GetTypeFromRef (codedIndex >> 2);  	return t != CoreSystemTypes.ValueType && t != CoreSystemTypes.Enum && t is Class;  case 0x02:  	return this.TypeSpecIsClass (codedIndex >> 2);  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following switch statement is missing a default case: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2);  case 0x02:  	return this.GetTypeFromSpec (codedIndex >> 2);  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following switch statement is missing a default case: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2' expectStruct);  case 0x02:  	return this.GetTypeFromSpec (codedIndex >> 2);  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeIfNotGenericInstance,The following switch statement is missing a default case: switch (codedIndex & 0x3) {  case 0x00:  	return this.GetTypeFromDef (codedIndex >> 2);  case 0x01:  	return this.GetTypeFromRef (codedIndex >> 2' false);  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetConstructorDefOrRef,The following switch statement is missing a default case: switch (codedIndex & 0x7) {  case 0x02:  	return this.GetMethodFromDef (codedIndex >> 3);  case 0x03:  	return (Method)this.GetMemberFromRef (codedIndex >> 3' out varArgTypes);  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetResources,The following switch statement is missing a default case: switch (impl & 0x3) {  case 0x0:  	string modName = this.tables.GetString (this.tables.FileTable [(impl >> 2) - 1].Name);  	if ((this.tables.FileTable [(impl >> 2) - 1].Flags & (int)FileFlags.ContainsNoMetaData) != 0) {  		r.DefiningModule = new Module ();  		r.DefiningModule.Directory = module.Directory;  		r.DefiningModule.Location = Path.Combine (module.Directory' modName);  		r.DefiningModule.Name = modName;  		r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;  		r.DefiningModule.ContainingAssembly = module.ContainingAssembly;  		r.DefiningModule.HashValue = this.tables.GetBlob (this.tables.FileTable [(impl >> 2) - 1].HashValue);  	} else {  		string modLocation = modName;  		r.DefiningModule = GetNestedModule (module' modName' ref modLocation);  	}  	break;  case 0x1:  	r.DefiningModule = this.tables.AssemblyRefTable [(impl >> 2) - 1].AssemblyReference.Assembly;  	break;  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetCustomAttributeLiteralValue,The following switch statement is missing a default case: switch (type.typeCode) {  case ElementType.Boolean:  	return sigReader.ReadBoolean ();  case ElementType.Char:  	return sigReader.ReadChar ();  case ElementType.Double:  	return sigReader.ReadDouble ();  case ElementType.Single:  	return sigReader.ReadSingle ();  case ElementType.Int16:  	return sigReader.ReadInt16 ();  case ElementType.Int32:  	return sigReader.ReadInt32 ();  case ElementType.Int64:  	return sigReader.ReadInt64 ();  case ElementType.Int8:  	return sigReader.ReadSByte ();  case ElementType.UInt16:  	return sigReader.ReadUInt16 ();  case ElementType.UInt32:  	return sigReader.ReadUInt32 ();  case ElementType.UInt64:  	return sigReader.ReadUInt64 ();  case ElementType.UInt8:  	return sigReader.ReadByte ();  case ElementType.String:  	return ReadSerString (sigReader);  case ElementType.ValueType:  	EnumNode etype = GetCustomAttributeEnumNode (ref type);  	return this.GetCustomAttributeLiteralValue (sigReader' etype.UnderlyingType);  case ElementType.Class:  	return this.GetTypeFromSerializedName (ReadSerString (sigReader));  case ElementType.SzArray:  	int numElems = sigReader.ReadInt32 ();  	TypeNode elemType = ((ArrayType)type).ElementType;  	return this.GetCustomAttributeLiteralArray (sigReader' numElems' elemType);  case ElementType.Object: {  	type = this.ParseTypeSignature (sigReader);  	return this.GetCustomAttributeLiteralValue (sigReader' ref type);  }  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ConstructCustomAttributeLiteralArray,The following switch statement is missing a default case: switch (elemType.typeCode) {  case ElementType.Boolean:  	return new Boolean[numElems];  case ElementType.Char:  	return new Char[numElems];  case ElementType.Double:  	return new Double[numElems];  case ElementType.Single:  	return new Single[numElems];  case ElementType.Int16:  	return new Int16[numElems];  case ElementType.Int32:  	return new Int32[numElems];  case ElementType.Int64:  	return new Int64[numElems];  case ElementType.Int8:  	return new SByte[numElems];  case ElementType.UInt16:  	return new UInt16[numElems];  case ElementType.UInt32:  	return new UInt32[numElems];  case ElementType.UInt64:  	return new UInt64[numElems];  case ElementType.UInt8:  	return new Byte[numElems];  case ElementType.String:  	return new String[numElems];  // Only enum value types are legal in attribute instances as stated in section 17.1.3 of the C# 1.0 spec  case ElementType.ValueType:  	TypeNode /*!*/elType = elemType;  	EnumNode eType = GetCustomAttributeEnumNode (ref elType);  	return this.ConstructCustomAttributeLiteralArray (numElems' eType.UnderlyingType);  // This needs to be a TypeNode since GetCustomAttributeLiteralValue will return a Struct if the Type is a value type  case ElementType.Class:  	return new TypeNode[numElems];  // REVIEW: Is this the right exception? Is this the right exception string?  // Multi-dimensional arrays are not legal in attribute instances according section 17.1.3 of the C# 1.0 spec  case ElementType.SzArray:  	throw new InvalidMetadataException (ExceptionStrings.BadCustomAttributeTypeEncodedToken);  case ElementType.Object:  	return new Object[numElems];  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetLiteral,The following switch statement is missing a default case: switch (valTypeCode) {  case TypeCode.Boolean:  	type = CoreSystemTypes.Boolean;  	break;  case TypeCode.Byte:  	type = CoreSystemTypes.UInt8;  	break;  case TypeCode.Char:  	type = CoreSystemTypes.Char;  	break;  case TypeCode.Double:  	type = CoreSystemTypes.Double;  	break;  case TypeCode.Int16:  	type = CoreSystemTypes.Int16;  	break;  case TypeCode.Int32:  	type = CoreSystemTypes.Int32;  	break;  case TypeCode.Int64:  	type = CoreSystemTypes.Int64;  	break;  case TypeCode.SByte:  	type = CoreSystemTypes.Int8;  	break;  case TypeCode.Single:  	type = CoreSystemTypes.Single;  	break;  case TypeCode.String:  	type = CoreSystemTypes.String;  	break;  case TypeCode.UInt16:  	type = CoreSystemTypes.UInt16;  	break;  case TypeCode.UInt32:  	type = CoreSystemTypes.UInt32;  	break;  case TypeCode.UInt64:  	type = CoreSystemTypes.UInt64;  	break;  case TypeCode.Empty:  case TypeCode.Object:  	type = CoreSystemTypes.Type;  	break;  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodDefOrRef,The following switch statement is missing a default case: switch (codedIndex & 0x1) {  case 0x00:  	return this.GetMethodFromDef (codedIndex >> 1);  case 0x01:  	TypeNodeList varArgTypes;  	return (Method)this.GetMemberFromRef (codedIndex >> 1' out varArgTypes);  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMethodDefOrRef,The following switch statement is missing a default case: switch (codedIndex & 0x1) {  case 0x00:  	return this.GetMethodFromDef (codedIndex >> 1);  case 0x01:  	TypeNodeList varArgTypes;  	return (Method)this.GetMemberFromRef (codedIndex >> 1' out varArgTypes' numberOfGenericArguments);  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetMemberFromRef,The following switch statement is missing a default case: switch (header & 7) {  case 1:  	callingConvention |= CallingConventionFlags.C;  	break;  case 2:  	callingConvention |= CallingConventionFlags.StandardCall;  	break;  case 3:  	callingConvention |= CallingConventionFlags.ThisCall;  	break;  case 4:  	callingConvention |= CallingConventionFlags.FastCall;  	break;  case 5:  	callingConvention |= CallingConventionFlags.VarArg;  	break;  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,GetTypeList,The following switch statement is missing a default case: switch (etr.Implementation & 0x3) {  case 0:  	string modName = this.tables.GetString (this.tables.FileTable [(etr.Implementation >> 2) - 1].Name);  	string modLocation = modName;  	Module mod = GetNestedModule (assem' modName' ref modLocation);  	if (mod == null) {  		Debug.Assert (false);  		break;  	}  	exportedType = mod.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace + "." + typeName' modLocation));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = mod;  	}  	break;  case 1:  	AssemblyReference aref = this.tables.AssemblyRefTable [(etr.Implementation >> 2) - 1].AssemblyReference;  	if (aref == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);  		aref = new AssemblyReference ("dummy assembly for bad reference");  	}  	AssemblyNode a = aref.Assembly;  	if (a == null) {  		Debug.Assert (false);  		continue;  	}  	exportedType = a.GetType (nameSpace' typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace + "." + typeName' a.StrongName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Namespace = nameSpace;  		exportedType.Flags = TypeFlags.Class | TypeFlags.Public;  		exportedType.DeclaringModule = a;  	}  	break;  case 2:  	TypeNode parentType = types [(etr.Implementation >> 2) - 1];  	if (parentType == null) {  		HandleError (assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);  		parentType = new Class ();  		parentType.DeclaringModule = this.module;  		parentType.Name = Identifier.For ("Missing parent type");  	}  	exportedType = parentType.GetNestedType (typeName);  	if (exportedType == null) {  		HandleError (assem' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));  		exportedType = new Class ();  		exportedType.Name = typeName;  		exportedType.Flags = TypeFlags.Class | TypeFlags.NestedPublic;  		exportedType.DeclaringType = parentType;  		exportedType.DeclaringModule = parentType.DeclaringModule;  	}  	break;  }  
Missing Default,System.Compiler.Metadata,Reader,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\CCI\Reader.cs,ParseTypeSignature,The following switch statement is missing a default case: switch (tok) {  case ElementType.Boolean:  	return CoreSystemTypes.Boolean;  case ElementType.Char:  	return CoreSystemTypes.Char;  case ElementType.Double:  	return CoreSystemTypes.Double;  case ElementType.Int16:  	return CoreSystemTypes.Int16;  case ElementType.Int32:  	return CoreSystemTypes.Int32;  case ElementType.Int64:  	return CoreSystemTypes.Int64;  case ElementType.Int8:  	return CoreSystemTypes.Int8;  case ElementType.IntPtr:  	return CoreSystemTypes.IntPtr;  case ElementType.BoxedEnum:  case ElementType.Object:  	return CoreSystemTypes.Object;  case ElementType.Single:  	return CoreSystemTypes.Single;  case ElementType.String:  	return CoreSystemTypes.String;  case ElementType.DynamicallyTypedReference:  	return CoreSystemTypes.DynamicallyTypedReference;  case ElementType.UInt16:  	return CoreSystemTypes.UInt16;  case ElementType.UInt32:  	return CoreSystemTypes.UInt32;  case ElementType.UInt64:  	return CoreSystemTypes.UInt64;  case ElementType.UInt8:  	return CoreSystemTypes.UInt8;  case ElementType.UIntPtr:  	return CoreSystemTypes.UIntPtr;  case ElementType.Void:  	return CoreSystemTypes.Void;  case ElementType.Pointer:  	elementType = this.ParseTypeSignature (sigReader' ref pinned);  	if (elementType == null)  		elementType = CoreSystemTypes.Object;  	if (elementType == null)  		return null;  	return elementType.GetPointerType ();  case ElementType.Reference:  	elementType = this.ParseTypeSignature (sigReader' ref pinned);  	if (elementType == null)  		elementType = CoreSystemTypes.Object;  	return elementType.GetReferenceType ();  case ElementType.FunctionPointer:  	return this.ParseFunctionPointer (sigReader);  case ElementType.OptionalModifier:  case ElementType.RequiredModifier:  	TypeNode modifier = this.DecodeAndGetTypeDefOrRefOrSpec (sigReader.ReadCompressedInt ());  	if (modifier == null)  		modifier = CoreSystemTypes.Object;  	TypeNode modified = this.ParseTypeSignature (sigReader' ref pinned);  	if (modified == null)  		modified = CoreSystemTypes.Object;  	if (modified == null || modified == null)  		return null;  	if (tok == ElementType.RequiredModifier)  		return RequiredModifier.For (modifier' modified);  	else  		return OptionalModifier.For (modifier' modified);  case ElementType.Class:  	return this.DecodeAndGetTypeDefOrRefOrSpec (sigReader.ReadCompressedInt ());  case ElementType.ValueType:  	return this.DecodeAndGetTypeDefOrRefOrSpec (sigReader.ReadCompressedInt ()' true);  case ElementType.TypeParameter:  	TypeNode tPar = null;  	int pnum = sigReader.ReadCompressedInt ();  	if (this.currentTypeParameters != null && this.currentTypeParameters.Count > pnum)  		tPar = this.currentTypeParameters [pnum];  	if (tPar == null) {  		HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.BadTypeParameterInPositionForType' pnum' this.currentType == null ? "" : this.currentType.FullName));  		tPar = new TypeParameter ();  		tPar.Name = Identifier.For ("Bad type parameter in position " + pnum);  		tPar.DeclaringModule = this.module;  	}  	isTypeArgument = true;  	return tPar;  case ElementType.MethodParameter:  	TypeNode mTPar = null;  	pnum = sigReader.ReadCompressedInt ();  	if (this.currentMethodTypeParameters != null && this.currentMethodTypeParameters.Count > pnum)  		mTPar = this.currentMethodTypeParameters [pnum];  	if (mTPar == null) {  		HandleError (this.module' String.Format (CultureInfo.CurrentCulture' ExceptionStrings.BadMethodTypeParameterInPosition' pnum));  		mTPar = new MethodTypeParameter ();  		mTPar.Name = Identifier.For ("Bad method type parameter in position " + pnum);  	}  	isTypeArgument = true;  	return mTPar;  case ElementType.GenericTypeInstance:  	TypeNodeList savedCurrentTypeParameters = this.currentTypeParameters;  	TypeNode template = this.ParseTypeSignature (sigReader' ref pinned);  	this.currentTypeParameters = savedCurrentTypeParameters;  	if (template == null || template.ConsolidatedTemplateParameters == null)  		return template;  	//Likely a dummy type  	if (CoreSystemTypes.Initialized) {  		if (this.currentTypeParameters == null || this.currentTypeParameters.Count == 0)  			this.currentTypeParameters = template.ConsolidatedTemplateParameters;  		TypeNodeList genArgs = this.ParseTypeList (sigReader);  		if (this.module == null)  			return null;  		TypeNode genInst = template.GetGenericTemplateInstance (this.module' genArgs);  		this.currentTypeParameters = savedCurrentTypeParameters;  		return genInst;  	}  	InterfaceExpression ifaceExpr = new InterfaceExpression (null);  	ifaceExpr.Template = template;  	ifaceExpr.Namespace = template.Namespace;  	ifaceExpr.Name = template.Name;  	ifaceExpr.TemplateArguments = this.ParseTypeList (sigReader);  	this.currentTypeParameters = savedCurrentTypeParameters;  	return ifaceExpr;  case ElementType.SzArray:  	elementType = this.ParseTypeSignature (sigReader' ref pinned);  	if (elementType == null)  		elementType = CoreSystemTypes.Object;  	if (elementType == null)  		return null;  	return elementType.GetArrayType (1);  case ElementType.Array:  	elementType = this.ParseTypeSignature (sigReader' ref pinned);  	if (elementType == null)  		elementType = CoreSystemTypes.Object;  	if (elementType == null)  		return null;  	int rank = sigReader.ReadCompressedInt ();  	int numSizes = sigReader.ReadCompressedInt ();  	int[] sizes = new int[numSizes];  	for (int i = 0; i < numSizes; i++)  		sizes [i] = sigReader.ReadCompressedInt ();  	int numLoBounds = sigReader.ReadCompressedInt ();  	int[] loBounds = new int[numLoBounds];  	for (int i = 0; i < numLoBounds; i++)  		loBounds [i] = sigReader.ReadCompressedInt ();  	return elementType.GetArrayType (rank' numSizes' numLoBounds' sizes' loBounds);  case ElementType.Sentinel:  	return null;  case ElementType.Type:  	return CoreSystemTypes.Type;  case ElementType.Enum:  	return this.GetTypeFromSerializedName (ReadSerString (sigReader));  }  
